(() => {
  var deferred, leafPrototypes, getProto, __webpack_modules__ = {
      "./node_modules/.pnpm/antd-dayjs-webpack-plugin@1.0.6_dayjs@1.11.6/node_modules/antd-dayjs-webpack-plugin/src/antd-plugin.js": module => {
          var localeMap = {
              en_GB: "en-gb",
              en_US: "en",
              zh_CN: "zh-cn",
              zh_TW: "zh-tw"
          };
          module.exports = function(option, dayjsClass, dayjsFactory) {
              var oldLocale = dayjsClass.prototype.locale;
              dayjsClass.prototype.locale = function(arg) {
                  var locale;
                  return "string" == typeof arg && (arg = localeMap[locale = arg] || locale.split("_")[0]), 
                  oldLocale.call(this, arg);
              };
          };
      },
      "./node_modules/.pnpm/antd-dayjs-webpack-plugin@1.0.6_dayjs@1.11.6/node_modules/antd-dayjs-webpack-plugin/src/init-dayjs-webpack-plugin-entry.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
          var dayjs = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/dayjs.min.js"), isSameOrBefore = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/isSameOrBefore.js"), isSameOrAfter = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/isSameOrAfter.js"), advancedFormat = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/advancedFormat.js"), customParseFormat = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/customParseFormat.js"), weekday = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/weekday.js"), weekYear = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/weekYear.js"), weekOfYear = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/weekOfYear.js"), isMoment = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/isMoment.js"), localeData = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/localeData.js"), localizedFormat = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/localizedFormat.js");
          dayjs.extend(isSameOrBefore), dayjs.extend(isSameOrAfter), dayjs.extend(advancedFormat), 
          dayjs.extend(customParseFormat), dayjs.extend(weekday), dayjs.extend(weekYear), 
          dayjs.extend(weekOfYear), dayjs.extend(isMoment), dayjs.extend(localeData), dayjs.extend(localizedFormat);
          var antdPlugin = __webpack_require__("./node_modules/.pnpm/antd-dayjs-webpack-plugin@1.0.6_dayjs@1.11.6/node_modules/antd-dayjs-webpack-plugin/src/antd-plugin.js");
          dayjs.extend(antdPlugin);
      },
      "./src/contents/translate/index.tsx": (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
          "use strict";
          var react = __webpack_require__("./node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"), react_namespaceObject = __webpack_require__.t(react, 2), client = __webpack_require__("./node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/client.js");
          function _arrayLikeToArray(arr, len) {
              (null == len || len > arr.length) && (len = arr.length);
              for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
              return arr2;
          }
          function _iterableToArray(iter) {
              if ("undefined" != typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) return Array.from(iter);
          }
          function _unsupportedIterableToArray(o, minLen) {
              if (o) {
                  if ("string" == typeof o) return _arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? _arrayLikeToArray(o, minLen) : void 0;
              }
          }
          function _toConsumableArray(arr) {
              return function(arr) {
                  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
              }(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || function() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }();
          }
          function _typeof(obj) {
              return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                  return typeof obj;
              } : function(obj) {
                  return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
              }, _typeof(obj);
          }
          function _toPropertyKey(arg) {
              var key = function(input, hint) {
                  if ("object" !== _typeof(input) || null === input) return input;
                  var prim = input[Symbol.toPrimitive];
                  if (void 0 !== prim) {
                      var res = prim.call(input, hint || "default");
                      if ("object" !== _typeof(res)) return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return ("string" === hint ? String : Number)(input);
              }(arg, "string");
              return "symbol" === _typeof(key) ? key : String(key);
          }
          function defineProperty_defineProperty(obj, key, value) {
              return (key = _toPropertyKey(key)) in obj ? Object.defineProperty(obj, key, {
                  value,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0
              }) : obj[key] = value, obj;
          }
          function ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function _objectSpread2(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          const hash_browser_esm = function(str) {
              for (var k, h = 0, i = 0, len = str.length; len >= 4; ++i, len -= 4) k = 1540483477 * (65535 & (k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24)) + (59797 * (k >>> 16) << 16), 
              h = 1540483477 * (65535 & (k ^= k >>> 24)) + (59797 * (k >>> 16) << 16) ^ 1540483477 * (65535 & h) + (59797 * (h >>> 16) << 16);
              switch (len) {
                case 3:
                  h ^= (255 & str.charCodeAt(i + 2)) << 16;

                case 2:
                  h ^= (255 & str.charCodeAt(i + 1)) << 8;

                case 1:
                  h = 1540483477 * (65535 & (h ^= 255 & str.charCodeAt(i))) + (59797 * (h >>> 16) << 16);
              }
              return (((h = 1540483477 * (65535 & (h ^= h >>> 13)) + (59797 * (h >>> 16) << 16)) ^ h >>> 15) >>> 0).toString(36);
          };
          function useMemo_useMemo(getValue, condition, shouldUpdate) {
              var cacheRef = react.useRef({});
              return "value" in cacheRef.current && !shouldUpdate(cacheRef.current.condition, condition) || (cacheRef.current.value = getValue(), 
              cacheRef.current.condition = condition), cacheRef.current.value;
          }
          var warned = {}, preWarningFns = [];
          function warning(valid, message) {}
          function note(valid, message) {}
          function call(method, valid, message) {
              valid || warned[message] || (method(!1, message), warned[message] = !0);
          }
          function warningOnce(valid, message) {
              call(warning, valid, message);
          }
          warningOnce.preMessage = function(fn) {
              preWarningFns.push(fn);
          }, warningOnce.resetWarned = function() {
              warned = {};
          }, warningOnce.noteOnce = function(valid, message) {
              call(note, valid, message);
          };
          const es_warning = warningOnce;
          const es_isEqual = function(obj1, obj2) {
              var shallow = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], refSet = new Set;
              return function deepEqual(a, b) {
                  var level = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, circular = refSet.has(a);
                  if (es_warning(!circular, "Warning: There may be circular references"), circular) return !1;
                  if (a === b) return !0;
                  if (shallow && level > 1) return !1;
                  refSet.add(a);
                  var newLevel = level + 1;
                  if (Array.isArray(a)) {
                      if (!Array.isArray(b) || a.length !== b.length) return !1;
                      for (var i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i], newLevel)) return !1;
                      return !0;
                  }
                  if (a && b && "object" === _typeof(a) && "object" === _typeof(b)) {
                      var keys = Object.keys(a);
                      return keys.length === Object.keys(b).length && keys.every((function(key) {
                          return deepEqual(a[key], b[key], newLevel);
                      }));
                  }
                  return !1;
              }(obj1, obj2);
          };
          function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
          }
          function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                  "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
              }
          }
          function _createClass(Constructor, protoProps, staticProps) {
              return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
              Object.defineProperty(Constructor, "prototype", {
                  writable: !1
              }), Constructor;
          }
          var Entity = function() {
              function Entity(instanceId) {
                  _classCallCheck(this, Entity), defineProperty_defineProperty(this, "instanceId", void 0), 
                  defineProperty_defineProperty(this, "cache", new Map), this.instanceId = instanceId;
              }
              return _createClass(Entity, [ {
                  key: "get",
                  value: function(keys) {
                      return this.cache.get(keys.join("%")) || null;
                  }
              }, {
                  key: "update",
                  value: function(keys, valueFn) {
                      var path = keys.join("%"), nextValue = valueFn(this.cache.get(path));
                      null === nextValue ? this.cache.delete(path) : this.cache.set(path, nextValue);
                  }
              } ]), Entity;
          }();
          const Cache = Entity;
          var StyleContext_ATTR_TOKEN = "data-token-hash", StyleContext_ATTR_MARK = "data-css-hash", CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
          function createCache() {
              var cssinjsInstanceId = Math.random().toString(12).slice(2);
              if ("undefined" != typeof document && document.head && document.body) {
                  var styles = document.body.querySelectorAll("style[".concat(StyleContext_ATTR_MARK, "]")) || [], firstChild = document.head.firstChild;
                  Array.from(styles).forEach((function(style) {
                      style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId, style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId && document.head.insertBefore(style, firstChild);
                  }));
                  var styleHash = {};
                  Array.from(document.querySelectorAll("style[".concat(StyleContext_ATTR_MARK, "]"))).forEach((function(style) {
                      var _style$parentNode, hash = style.getAttribute(StyleContext_ATTR_MARK);
                      styleHash[hash] ? style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId && (null === (_style$parentNode = style.parentNode) || void 0 === _style$parentNode || _style$parentNode.removeChild(style)) : styleHash[hash] = !0;
                  }));
              }
              return new Cache(cssinjsInstanceId);
          }
          var StyleContext = react.createContext({
              hashPriority: "low",
              cache: createCache(),
              defaultCache: !0
          });
          const es_StyleContext = StyleContext;
          function canUseDom() {
              return !("undefined" == typeof window || !window.document || !window.document.createElement);
          }
          var APPEND_ORDER = "data-rc-order", APPEND_PRIORITY = "data-rc-priority", MARK_KEY = "rc-util-key", containerCache = new Map;
          function getMark() {
              var mark = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).mark;
              return mark ? mark.startsWith("data-") ? mark : "data-".concat(mark) : MARK_KEY;
          }
          function getContainer(option) {
              return option.attachTo ? option.attachTo : document.querySelector("head") || document.body;
          }
          function findStyles(container) {
              return Array.from((containerCache.get(container) || container).children).filter((function(node) {
                  return "STYLE" === node.tagName;
              }));
          }
          function injectCSS(css) {
              var option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              if (!canUseDom()) return null;
              var csp = option.csp, prepend = option.prepend, _option$priority = option.priority, priority = void 0 === _option$priority ? 0 : _option$priority, mergedOrder = function(prepend) {
                  return "queue" === prepend ? "prependQueue" : prepend ? "prepend" : "append";
              }(prepend), isPrependQueue = "prependQueue" === mergedOrder, styleNode = document.createElement("style");
              styleNode.setAttribute(APPEND_ORDER, mergedOrder), isPrependQueue && priority && styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority)), 
              null != csp && csp.nonce && (styleNode.nonce = null == csp ? void 0 : csp.nonce), 
              styleNode.innerHTML = css;
              var container = getContainer(option), firstChild = container.firstChild;
              if (prepend) {
                  if (isPrependQueue) {
                      var existStyle = findStyles(container).filter((function(node) {
                          if (![ "prepend", "prependQueue" ].includes(node.getAttribute(APPEND_ORDER))) return !1;
                          var nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
                          return priority >= nodePriority;
                      }));
                      if (existStyle.length) return container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling), 
                      styleNode;
                  }
                  container.insertBefore(styleNode, firstChild);
              } else container.appendChild(styleNode);
              return styleNode;
          }
          function findExistNode(key) {
              var option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
              return findStyles(getContainer(option)).find((function(node) {
                  return node.getAttribute(getMark(option)) === key;
              }));
          }
          function removeCSS(key) {
              var option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, existNode = findExistNode(key, option);
              existNode && getContainer(option).removeChild(existNode);
          }
          function updateCSS(css, key) {
              var option = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              !function(container, option) {
                  var cachedRealContainer = containerCache.get(container);
                  if (!cachedRealContainer || !function(root, n) {
                      if (!root) return !1;
                      if (root.contains) return root.contains(n);
                      for (var node = n; node; ) {
                          if (node === root) return !0;
                          node = node.parentNode;
                      }
                      return !1;
                  }(document, cachedRealContainer)) {
                      var placeholderStyle = injectCSS("", option), parentNode = placeholderStyle.parentNode;
                      containerCache.set(container, parentNode), container.removeChild(placeholderStyle);
                  }
              }(getContainer(option), option);
              var existNode = findExistNode(key, option);
              if (existNode) {
                  var _option$csp, _option$csp2, _option$csp3;
                  if (null !== (_option$csp = option.csp) && void 0 !== _option$csp && _option$csp.nonce && existNode.nonce !== (null === (_option$csp2 = option.csp) || void 0 === _option$csp2 ? void 0 : _option$csp2.nonce)) existNode.nonce = null === (_option$csp3 = option.csp) || void 0 === _option$csp3 ? void 0 : _option$csp3.nonce;
                  return existNode.innerHTML !== css && (existNode.innerHTML = css), existNode;
              }
              var newNode = injectCSS(css, option);
              return newNode.setAttribute(getMark(option), key), newNode;
          }
          function _arrayWithHoles(arr) {
              if (Array.isArray(arr)) return arr;
          }
          function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          function slicedToArray_slicedToArray(arr, i) {
              return _arrayWithHoles(arr) || function(arr, i) {
                  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
                  if (null != _i) {
                      var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;
                      try {
                          if (_x = (_i = _i.call(arr)).next, 0 === i) {
                              if (Object(_i) !== _i) return;
                              _n = !1;
                          } else for (;!(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) ;
                      } catch (err) {
                          _d = !0, _e = err;
                      } finally {
                          try {
                              if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
                          } finally {
                              if (_d) throw _e;
                          }
                      }
                      return _arr;
                  }
              }(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
          }
          var ThemeCache = function() {
              function ThemeCache() {
                  _classCallCheck(this, ThemeCache), defineProperty_defineProperty(this, "cache", void 0), 
                  defineProperty_defineProperty(this, "keys", void 0), defineProperty_defineProperty(this, "cacheCallTimes", void 0), 
                  this.cache = new Map, this.keys = [], this.cacheCallTimes = 0;
              }
              return _createClass(ThemeCache, [ {
                  key: "size",
                  value: function() {
                      return this.keys.length;
                  }
              }, {
                  key: "internalGet",
                  value: function(derivativeOption) {
                      var _cache2, _cache3, updateCallTimes = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], cache = {
                          map: this.cache
                      };
                      return derivativeOption.forEach((function(derivative) {
                          var _cache, _cache$map;
                          cache ? cache = null === (_cache = cache) || void 0 === _cache || null === (_cache$map = _cache.map) || void 0 === _cache$map ? void 0 : _cache$map.get(derivative) : cache = void 0;
                      })), null !== (_cache2 = cache) && void 0 !== _cache2 && _cache2.value && updateCallTimes && (cache.value[1] = this.cacheCallTimes++), 
                      null === (_cache3 = cache) || void 0 === _cache3 ? void 0 : _cache3.value;
                  }
              }, {
                  key: "get",
                  value: function(derivativeOption) {
                      var _this$internalGet;
                      return null === (_this$internalGet = this.internalGet(derivativeOption, !0)) || void 0 === _this$internalGet ? void 0 : _this$internalGet[0];
                  }
              }, {
                  key: "has",
                  value: function(derivativeOption) {
                      return !!this.internalGet(derivativeOption);
                  }
              }, {
                  key: "set",
                  value: function(derivativeOption, value) {
                      var _this = this;
                      if (!this.has(derivativeOption)) {
                          if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
                              var _this$keys$reduce = this.keys.reduce((function(result, key) {
                                  var callTimes = slicedToArray_slicedToArray(result, 2)[1];
                                  return _this.internalGet(key)[1] < callTimes ? [ key, _this.internalGet(key)[1] ] : result;
                              }), [ this.keys[0], this.cacheCallTimes ]), targetKey = slicedToArray_slicedToArray(_this$keys$reduce, 1)[0];
                              this.delete(targetKey);
                          }
                          this.keys.push(derivativeOption);
                      }
                      var cache = this.cache;
                      derivativeOption.forEach((function(derivative, index) {
                          if (index === derivativeOption.length - 1) cache.set(derivative, {
                              value: [ value, _this.cacheCallTimes++ ]
                          }); else {
                              var cacheValue = cache.get(derivative);
                              cacheValue ? cacheValue.map || (cacheValue.map = new Map) : cache.set(derivative, {
                                  map: new Map
                              }), cache = cache.get(derivative).map;
                          }
                      }));
                  }
              }, {
                  key: "deleteByPath",
                  value: function(currentCache, derivatives) {
                      var _cache$value, cache = currentCache.get(derivatives[0]);
                      if (1 === derivatives.length) return cache.map ? currentCache.set(derivatives[0], {
                          map: cache.map
                      }) : currentCache.delete(derivatives[0]), null === (_cache$value = cache.value) || void 0 === _cache$value ? void 0 : _cache$value[0];
                      var result = this.deleteByPath(cache.map, derivatives.slice(1));
                      return cache.map && 0 !== cache.map.size || cache.value || currentCache.delete(derivatives[0]), 
                      result;
                  }
              }, {
                  key: "delete",
                  value: function(derivativeOption) {
                      if (this.has(derivativeOption)) return this.keys = this.keys.filter((function(item) {
                          return !function(left, right) {
                              if (left.length !== right.length) return !1;
                              for (var i = 0; i < left.length; i++) if (left[i] !== right[i]) return !1;
                              return !0;
                          }(item, derivativeOption);
                      })), this.deleteByPath(this.cache, derivativeOption);
                  }
              } ]), ThemeCache;
          }();
          defineProperty_defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20), defineProperty_defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);
          var uuid = 0, Theme = function() {
              function Theme(derivatives) {
                  _classCallCheck(this, Theme), defineProperty_defineProperty(this, "derivatives", void 0), 
                  defineProperty_defineProperty(this, "id", void 0), this.derivatives = Array.isArray(derivatives) ? derivatives : [ derivatives ], 
                  this.id = uuid, 0 === derivatives.length && derivatives.length, uuid += 1;
              }
              return _createClass(Theme, [ {
                  key: "getDerivativeToken",
                  value: function(token) {
                      return this.derivatives.reduce((function(result, derivative) {
                          return derivative(token, result);
                      }), void 0);
                  }
              } ]), Theme;
          }(), cacheThemes = new ThemeCache;
          function createTheme(derivatives) {
              var derivativeArr = Array.isArray(derivatives) ? derivatives : [ derivatives ];
              return cacheThemes.has(derivativeArr) || cacheThemes.set(derivativeArr, new Theme(derivativeArr)), 
              cacheThemes.get(derivativeArr);
          }
          var resultCache = new WeakMap, RESULT_VALUE = {};
          var flattenTokenCache = new WeakMap;
          function flattenToken(token) {
              var str = flattenTokenCache.get(token) || "";
              return str || (Object.keys(token).forEach((function(key) {
                  var value = token[key];
                  str += key, value instanceof Theme ? str += value.id : value && "object" === _typeof(value) ? str += flattenToken(value) : str += value;
              })), flattenTokenCache.set(token, str)), str;
          }
          var randomSelectorKey = "random-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, ""), checkContent = "_bAmBoO_";
          function supportSelector(styleStr, handleElement, supportCheck) {
              if (canUseDom()) {
                  var _getComputedStyle$con, _ele$parentNode;
                  updateCSS(styleStr, randomSelectorKey);
                  var _ele = document.createElement("div");
                  _ele.style.position = "fixed", _ele.style.left = "0", _ele.style.top = "0", null == handleElement || handleElement(_ele), 
                  document.body.appendChild(_ele);
                  var support = supportCheck ? supportCheck(_ele) : null === (_getComputedStyle$con = getComputedStyle(_ele).content) || void 0 === _getComputedStyle$con ? void 0 : _getComputedStyle$con.includes(checkContent);
                  return null === (_ele$parentNode = _ele.parentNode) || void 0 === _ele$parentNode || _ele$parentNode.removeChild(_ele), 
                  removeCSS(randomSelectorKey), support;
              }
              return !1;
          }
          var canLayer = void 0;
          var useInternalLayoutEffect = canUseDom() ? react.useLayoutEffect : react.useEffect, useLayoutEffect = function(callback, deps) {
              var firstMountRef = react.useRef(!0);
              useInternalLayoutEffect((function() {
                  return callback(firstMountRef.current);
              }), deps), useInternalLayoutEffect((function() {
                  return firstMountRef.current = !1, function() {
                      firstMountRef.current = !0;
                  };
              }), []);
          }, useLayoutUpdateEffect = function(callback, deps) {
              useLayoutEffect((function(firstMount) {
                  if (!firstMount) return callback();
              }), deps);
          };
          const hooks_useLayoutEffect = useLayoutEffect;
          var useInsertionEffect = _objectSpread2({}, react_namespaceObject).useInsertionEffect;
          const hooks_useCompatibleInsertionEffect = useInsertionEffect ? function(renderEffect, effect, deps) {
              return useInsertionEffect((function() {
                  return renderEffect(), effect();
              }), deps);
          } : function(renderEffect, effect, deps) {
              react.useMemo(renderEffect, deps), hooks_useLayoutEffect((function() {
                  return effect(!0);
              }), deps);
          };
          const hooks_useEffectCleanupRegister = void 0 !== _objectSpread2({}, react_namespaceObject).useInsertionEffect ? function(deps) {
              var effectCleanups = [], cleanupFlag = !1;
              return react.useEffect((function() {
                  return cleanupFlag = !1, function() {
                      cleanupFlag = !0, effectCleanups.length && effectCleanups.forEach((function(fn) {
                          return fn();
                      }));
                  };
              }), deps), function(fn) {
                  cleanupFlag || effectCleanups.push(fn);
              };
          } : function() {
              return function(fn) {
                  fn();
              };
          };
          const useHMR = function() {
              return !1;
          };
          function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove, onCacheEffect) {
              var globalCache = react.useContext(es_StyleContext).cache, fullPath = [ prefix ].concat(_toConsumableArray(keyPath)), deps = fullPath.join("_"), register = hooks_useEffectCleanupRegister([ deps ]), buildCache = (useHMR(), 
              function(updater) {
                  globalCache.update(fullPath, (function(prevCache) {
                      var _ref2 = slicedToArray_slicedToArray(prevCache || [], 2), _ref2$ = _ref2[0];
                      var data = [ void 0 === _ref2$ ? 0 : _ref2$, _ref2[1] || cacheFn() ];
                      return updater ? updater(data) : data;
                  }));
              });
              react.useMemo((function() {
                  buildCache();
              }), [ deps ]);
              var cacheContent = globalCache.get(fullPath)[1];
              return hooks_useCompatibleInsertionEffect((function() {
                  null == onCacheEffect || onCacheEffect(cacheContent);
              }), (function(polyfill) {
                  return buildCache((function(_ref3) {
                      var _ref4 = slicedToArray_slicedToArray(_ref3, 2), times = _ref4[0], cache = _ref4[1];
                      return polyfill && 0 === times && (null == onCacheEffect || onCacheEffect(cacheContent)), 
                      [ times + 1, cache ];
                  })), function() {
                      globalCache.update(fullPath, (function(prevCache) {
                          var _ref6 = slicedToArray_slicedToArray(prevCache || [], 2), _ref6$ = _ref6[0], times = void 0 === _ref6$ ? 0 : _ref6$, cache = _ref6[1];
                          return 0 === times - 1 ? (register((function() {
                              return null == onCacheRemove ? void 0 : onCacheRemove(cache, !1);
                          })), null) : [ times - 1, cache ];
                      }));
                  };
              }), [ deps ]), cacheContent;
          }
          var EMPTY_OVERRIDE = {}, hashPrefix = "css", tokenKeys = new Map;
          var TOKEN_THRESHOLD = 0;
          function cleanTokenStyle(tokenKey, instanceId) {
              tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
              var tokenKeyList = Array.from(tokenKeys.keys()), cleanableKeyList = tokenKeyList.filter((function(key) {
                  return (tokenKeys.get(key) || 0) <= 0;
              }));
              tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD && cleanableKeyList.forEach((function(key) {
                  !function(key, instanceId) {
                      "undefined" != typeof document && document.querySelectorAll("style[".concat(StyleContext_ATTR_TOKEN, '="').concat(key, '"]')).forEach((function(style) {
                          var _style$parentNode;
                          style[CSS_IN_JS_INSTANCE] === instanceId && (null === (_style$parentNode = style.parentNode) || void 0 === _style$parentNode || _style$parentNode.removeChild(style));
                      }));
                  }(key, instanceId), tokenKeys.delete(key);
              }));
          }
          var getComputedToken = function(originToken, overrideToken, theme, format) {
              var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, theme.getDerivativeToken(originToken)), overrideToken);
              return format && (mergedDerivativeToken = format(mergedDerivativeToken)), mergedDerivativeToken;
          };
          function useCacheToken(theme, tokens) {
              var option = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, instanceId = (0, 
              react.useContext)(es_StyleContext).cache.instanceId, _option$salt = option.salt, salt = void 0 === _option$salt ? "" : _option$salt, _option$override = option.override, override = void 0 === _option$override ? EMPTY_OVERRIDE : _option$override, formatToken = option.formatToken, compute = option.getComputedToken, mergedToken = function(callback, deps) {
                  for (var current = resultCache, i = 0; i < deps.length; i += 1) {
                      var dep = deps[i];
                      current.has(dep) || current.set(dep, new WeakMap), current = current.get(dep);
                  }
                  return current.has(RESULT_VALUE) || current.set(RESULT_VALUE, callback()), current.get(RESULT_VALUE);
              }((function() {
                  return Object.assign.apply(Object, [ {} ].concat(_toConsumableArray(tokens)));
              }), tokens), tokenStr = flattenToken(mergedToken), overrideTokenStr = flattenToken(override), cachedToken = useGlobalCache("token", [ salt, theme.id, tokenStr, overrideTokenStr ], (function() {
                  var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken(mergedToken, override, theme, formatToken), tokenKey = function(token, salt) {
                      return hash_browser_esm("".concat(salt, "_").concat(flattenToken(token)));
                  }(mergedDerivativeToken, salt);
                  mergedDerivativeToken._tokenKey = tokenKey, function(tokenKey) {
                      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
                  }(tokenKey);
                  var hashId = "".concat(hashPrefix, "-").concat(hash_browser_esm(tokenKey));
                  return mergedDerivativeToken._hashId = hashId, [ mergedDerivativeToken, hashId ];
              }), (function(cache) {
                  cleanTokenStyle(cache[0]._tokenKey, instanceId);
              }));
              return cachedToken;
          }
          function _extends() {
              return _extends = Object.assign ? Object.assign.bind() : function(target) {
                  for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                  }
                  return target;
              }, _extends.apply(this, arguments);
          }
          const unitless_browser_esm = {
              animationIterationCount: 1,
              borderImageOutset: 1,
              borderImageSlice: 1,
              borderImageWidth: 1,
              boxFlex: 1,
              boxFlexGroup: 1,
              boxOrdinalGroup: 1,
              columnCount: 1,
              columns: 1,
              flex: 1,
              flexGrow: 1,
              flexPositive: 1,
              flexShrink: 1,
              flexNegative: 1,
              flexOrder: 1,
              gridRow: 1,
              gridRowEnd: 1,
              gridRowSpan: 1,
              gridRowStart: 1,
              gridColumn: 1,
              gridColumnEnd: 1,
              gridColumnSpan: 1,
              gridColumnStart: 1,
              msGridRow: 1,
              msGridRowSpan: 1,
              msGridColumn: 1,
              msGridColumnSpan: 1,
              fontWeight: 1,
              lineHeight: 1,
              opacity: 1,
              order: 1,
              orphans: 1,
              tabSize: 1,
              widows: 1,
              zIndex: 1,
              zoom: 1,
              WebkitLineClamp: 1,
              fillOpacity: 1,
              floodOpacity: 1,
              stopOpacity: 1,
              strokeDasharray: 1,
              strokeDashoffset: 1,
              strokeMiterlimit: 1,
              strokeOpacity: 1,
              strokeWidth: 1
          };
          var COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, Utility_from = String.fromCharCode;
          Object.assign;
          function trim(value) {
              return value.trim();
          }
          function replace(value, pattern, replacement) {
              return value.replace(pattern, replacement);
          }
          function indexof(value, search) {
              return value.indexOf(search);
          }
          function charat(value, index) {
              return 0 | value.charCodeAt(index);
          }
          function substr(value, begin, end) {
              return value.slice(begin, end);
          }
          function strlen(value) {
              return value.length;
          }
          function Utility_append(value, array) {
              return array.push(value), value;
          }
          function serialize(children, callback) {
              for (var output = "", i = 0; i < children.length; i++) output += callback(children[i], i, children, callback) || "";
              return output;
          }
          function stringify(element, index, children, callback) {
              switch (element.type) {
                case LAYER:
                  if (element.children.length) break;

                case IMPORT:
                case DECLARATION:
                  return element.return = element.return || element.value;

                case COMMENT:
                  return "";

                case KEYFRAMES:
                  return element.return = element.value + "{" + serialize(element.children, callback) + "}";

                case RULESET:
                  if (!strlen(element.value = element.props.join(","))) return "";
              }
              return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
          }
          var line = 1, column = 1, Tokenizer_length = 0, position = 0, character = 0, characters = "";
          function Tokenizer_node(value, root, parent, type, props, children, length, siblings) {
              return {
                  value,
                  root,
                  parent,
                  type,
                  props,
                  children,
                  line,
                  column,
                  length,
                  return: "",
                  siblings
              };
          }
          function prev() {
              return character = position > 0 ? charat(characters, --position) : 0, column--, 
              10 === character && (column = 1, line--), character;
          }
          function next() {
              return character = position < Tokenizer_length ? charat(characters, position++) : 0, 
              column++, 10 === character && (column = 1, line++), character;
          }
          function peek() {
              return charat(characters, position);
          }
          function caret() {
              return position;
          }
          function slice(begin, end) {
              return substr(characters, begin, end);
          }
          function token(type) {
              switch (type) {
                case 0:
                case 9:
                case 10:
                case 13:
                case 32:
                  return 5;

                case 33:
                case 43:
                case 44:
                case 47:
                case 62:
                case 64:
                case 126:
                case 59:
                case 123:
                case 125:
                  return 4;

                case 58:
                  return 3;

                case 34:
                case 39:
                case 40:
                case 91:
                  return 2;

                case 41:
                case 93:
                  return 1;
              }
              return 0;
          }
          function alloc(value) {
              return line = column = 1, Tokenizer_length = strlen(characters = value), position = 0, 
              [];
          }
          function dealloc(value) {
              return characters = "", value;
          }
          function delimit(type) {
              return trim(slice(position - 1, delimiter(91 === type ? type + 2 : 40 === type ? type + 1 : type)));
          }
          function whitespace(type) {
              for (;(character = peek()) && character < 33; ) next();
              return token(type) > 2 || token(character) > 3 ? "" : " ";
          }
          function escaping(index, count) {
              for (;--count && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); ) ;
              return slice(index, caret() + (count < 6 && 32 == peek() && 32 == next()));
          }
          function delimiter(type) {
              for (;next(); ) switch (character) {
                case type:
                  return position;

                case 34:
                case 39:
                  34 !== type && 39 !== type && delimiter(character);
                  break;

                case 40:
                  41 === type && delimiter(type);
                  break;

                case 92:
                  next();
              }
              return position;
          }
          function commenter(type, index) {
              for (;next() && type + character !== 57 && (type + character !== 84 || 47 !== peek()); ) ;
              return "/*" + slice(index, position - 1) + "*" + Utility_from(47 === type ? type : next());
          }
          function identifier(index) {
              for (;!token(peek()); ) next();
              return slice(index, position);
          }
          function compile(value) {
              return dealloc(parse("", null, null, null, [ "" ], value = alloc(value), 0, [ 0 ], value));
          }
          function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
              for (var index = 0, offset = 0, length = pseudo, atrule = 0, property = 0, previous = 0, variable = 1, scanning = 1, ampersand = 1, character = 0, type = "", props = rules, children = rulesets, reference = rule, characters = type; scanning; ) switch (previous = character, 
              character = next()) {
                case 40:
                  if (108 != previous && 58 == charat(characters, length - 1)) {
                      -1 != indexof(characters += replace(delimit(character), "&", "&\f"), "&\f") && (ampersand = -1);
                      break;
                  }

                case 34:
                case 39:
                case 91:
                  characters += delimit(character);
                  break;

                case 9:
                case 10:
                case 13:
                case 32:
                  characters += whitespace(previous);
                  break;

                case 92:
                  characters += escaping(caret() - 1, 7);
                  continue;

                case 47:
                  switch (peek()) {
                    case 42:
                    case 47:
                      Utility_append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
                      break;

                    default:
                      characters += "/";
                  }
                  break;

                case 123 * variable:
                  points[index++] = strlen(characters) * ampersand;

                case 125 * variable:
                case 59:
                case 0:
                  switch (character) {
                    case 0:
                    case 125:
                      scanning = 0;

                    case 59 + offset:
                      -1 == ampersand && (characters = replace(characters, /\f/g, "")), property > 0 && strlen(characters) - length && Utility_append(property > 32 ? declaration(characters + ";", rule, parent, length - 1, declarations) : declaration(replace(characters, " ", "") + ";", rule, parent, length - 2, declarations), declarations);
                      break;

                    case 59:
                      characters += ";";

                    default:
                      if (Utility_append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets), 
                      123 === character) if (0 === offset) parse(characters, root, reference, reference, props, rulesets, length, points, children); else switch (99 === atrule && 110 === charat(characters, 3) ? 100 : atrule) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                          parse(value, reference, reference, rule && Utility_append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);
                          break;

                        default:
                          parse(characters, reference, reference, reference, [ "" ], children, 0, points, children);
                      }
                  }
                  index = offset = property = 0, variable = ampersand = 1, type = characters = "", 
                  length = pseudo;
                  break;

                case 58:
                  length = 1 + strlen(characters), property = previous;

                default:
                  if (variable < 1) if (123 == character) --variable; else if (125 == character && 0 == variable++ && 125 == prev()) continue;
                  switch (characters += Utility_from(character), character * variable) {
                    case 38:
                      ampersand = offset > 0 ? 1 : (characters += "\f", -1);
                      break;

                    case 44:
                      points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
                      break;

                    case 64:
                      45 === peek() && (characters += delimit(next())), atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), 
                      character++;
                      break;

                    case 45:
                      45 === previous && 2 == strlen(characters) && (variable = 0);
                  }
              }
              return rulesets;
          }
          function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {
              for (var post = offset - 1, rule = 0 === offset ? rules : [ "" ], size = function(value) {
                  return value.length;
              }(rule), i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x]))) && (props[k++] = z);
              return Tokenizer_node(value, root, parent, 0 === offset ? RULESET : type, props, children, length, siblings);
          }
          function comment(value, root, parent, siblings) {
              return Tokenizer_node(value, root, parent, COMMENT, Utility_from(character), substr(value, 2, -2), 0, siblings);
          }
          function declaration(value, root, parent, length, siblings) {
              return Tokenizer_node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length, siblings);
          }
          var cachePathMap, cacheMapUtil_ATTR_CACHE_MAP = "data-ant-cssinjs-cache-path", CSS_FILE_STYLE = "_FILE_STYLE__";
          var fromCSSFile = !0;
          function existPath(path) {
              return function() {
                  if (!cachePathMap && (cachePathMap = {}, canUseDom())) {
                      var div = document.createElement("div");
                      div.className = cacheMapUtil_ATTR_CACHE_MAP, div.style.position = "fixed", div.style.visibility = "hidden", 
                      div.style.top = "-9999px", document.body.appendChild(div);
                      var content = getComputedStyle(div).content || "";
                      (content = content.replace(/^"/, "").replace(/"$/, "")).split(";").forEach((function(item) {
                          var _item$split2 = slicedToArray_slicedToArray(item.split(":"), 2), path = _item$split2[0], hash = _item$split2[1];
                          cachePathMap[path] = hash;
                      }));
                      var _inlineMapStyle$paren, inlineMapStyle = document.querySelector("style[".concat(cacheMapUtil_ATTR_CACHE_MAP, "]"));
                      inlineMapStyle && (fromCSSFile = !1, null === (_inlineMapStyle$paren = inlineMapStyle.parentNode) || void 0 === _inlineMapStyle$paren || _inlineMapStyle$paren.removeChild(inlineMapStyle)), 
                      document.body.removeChild(div);
                  }
              }(), !!cachePathMap[path];
          }
          var isClientSide = canUseDom();
          function normalizeStyle(styleStr) {
              return serialize(compile(styleStr), stringify).replace(/\{%%%\:[^;];}/g, ";");
          }
          var parseStyle = function parseStyle(interpolation) {
              var config = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, _ref = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
                  root: !0,
                  parentSelectors: []
              }, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors, hashId = config.hashId, layer = config.layer, hashPriority = (config.path, 
              config.hashPriority), _config$transformers = config.transformers, transformers = void 0 === _config$transformers ? [] : _config$transformers, styleStr = (config.linters, 
              ""), effectStyle = {};
              function parseKeyframes(keyframes) {
                  var animationName = keyframes.getName(hashId);
                  if (!effectStyle[animationName]) {
                      var _parsedStr = slicedToArray_slicedToArray(parseStyle(keyframes.style, config, {
                          root: !1,
                          parentSelectors
                      }), 1)[0];
                      effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
                  }
              }
              var flattenStyleList = function flattenList(list) {
                  var fullList = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                  return list.forEach((function(item) {
                      Array.isArray(item) ? flattenList(item, fullList) : item && fullList.push(item);
                  })), fullList;
              }(Array.isArray(interpolation) ? interpolation : [ interpolation ]);
              if (flattenStyleList.forEach((function(originStyle) {
                  var style = "string" != typeof originStyle || root ? originStyle : {};
                  if ("string" == typeof style) styleStr += "".concat(style, "\n"); else if (style._keyframe) parseKeyframes(style); else {
                      var mergedStyle = transformers.reduce((function(prev, trans) {
                          var _trans$visit;
                          return (null == trans || null === (_trans$visit = trans.visit) || void 0 === _trans$visit ? void 0 : _trans$visit.call(trans, prev)) || prev;
                      }), style);
                      Object.keys(mergedStyle).forEach((function(key) {
                          var value = mergedStyle[key];
                          if ("object" !== _typeof(value) || !value || "animationName" === key && value._keyframe || function(value) {
                              return "object" === _typeof(value) && value && ("_skip_check_" in value || "_multi_value_" in value);
                          }(value)) {
                              var _value;
                              function appendStyle(cssKey, cssValue) {
                                  var styleName = cssKey.replace(/[A-Z]/g, (function(match) {
                                      return "-".concat(match.toLowerCase());
                                  })), formatValue = cssValue;
                                  unitless_browser_esm[cssKey] || "number" != typeof formatValue || 0 === formatValue || (formatValue = "".concat(formatValue, "px")), 
                                  "animationName" === cssKey && null != cssValue && cssValue._keyframe && (parseKeyframes(cssValue), 
                                  formatValue = cssValue.getName(hashId)), styleStr += "".concat(styleName, ":").concat(formatValue, ";");
                              }
                              var actualValue = null !== (_value = null == value ? void 0 : value.value) && void 0 !== _value ? _value : value;
                              "object" === _typeof(value) && null != value && value._multi_value_ && Array.isArray(actualValue) ? actualValue.forEach((function(item) {
                                  appendStyle(key, item);
                              })) : appendStyle(key, actualValue);
                          } else {
                              var subInjectHash = !1, mergedKey = key.trim(), nextRoot = !1;
                              (root || injectHash) && hashId ? mergedKey.startsWith("@") ? subInjectHash = !0 : mergedKey = function(key, hashId, hashPriority) {
                                  if (!hashId) return key;
                                  var hashClassName = ".".concat(hashId), hashSelector = "low" === hashPriority ? ":where(".concat(hashClassName, ")") : hashClassName, keys = key.split(",").map((function(k) {
                                      var _firstPath$match, fullPath = k.trim().split(/\s+/), firstPath = fullPath[0] || "", htmlElement = (null === (_firstPath$match = firstPath.match(/^\w+/)) || void 0 === _firstPath$match ? void 0 : _firstPath$match[0]) || "";
                                      return [ firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length)) ].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
                                  }));
                                  return keys.join(",");
                              }(key, hashId, hashPriority) : !root || hashId || "&" !== mergedKey && "" !== mergedKey || (mergedKey = "", 
                              nextRoot = !0);
                              var _parseStyle4 = slicedToArray_slicedToArray(parseStyle(value, config, {
                                  root: nextRoot,
                                  injectHash: subInjectHash,
                                  parentSelectors: [].concat(_toConsumableArray(parentSelectors), [ mergedKey ])
                              }), 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
                              effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle), 
                              styleStr += "".concat(mergedKey).concat(_parsedStr2);
                          }
                      }));
                  }
              })), root) {
                  if (layer && (void 0 === canLayer && (canLayer = supportSelector("@layer ".concat(randomSelectorKey, " { .").concat(randomSelectorKey, ' { content: "').concat(checkContent, '"!important; } }'), (function(ele) {
                      ele.className = randomSelectorKey;
                  }))), canLayer)) {
                      var layerCells = layer.split(","), layerName = layerCells[layerCells.length - 1].trim();
                      styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}"), layerCells.length > 1 && (styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr));
                  }
              } else styleStr = "{".concat(styleStr, "}");
              return [ styleStr, effectStyle ];
          };
          function Empty() {
              return null;
          }
          function useStyleRegister(info, styleFn) {
              var token = info.token, path = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce, clientOnly = info.clientOnly, _info$order = info.order, order = void 0 === _info$order ? 0 : _info$order, _React$useContext = react.useContext(es_StyleContext), autoClear = _React$useContext.autoClear, defaultCache = (_React$useContext.mock, 
              _React$useContext.defaultCache), hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache, tokenKey = token._tokenKey, fullPath = [ tokenKey ].concat(_toConsumableArray(path)), isMergedClientSide = isClientSide;
              var _useGlobalCache = useGlobalCache("style", fullPath, (function() {
                  var cachePath = fullPath.join("|");
                  if (existPath(cachePath)) {
                      var _getStyleAndHash = function(path) {
                          var hash = cachePathMap[path], styleStr = null;
                          if (hash && canUseDom()) if (fromCSSFile) styleStr = CSS_FILE_STYLE; else {
                              var _style = document.querySelector("style[".concat(StyleContext_ATTR_MARK, '="').concat(cachePathMap[path], '"]'));
                              _style ? styleStr = _style.innerHTML : delete cachePathMap[path];
                          }
                          return [ styleStr, hash ];
                      }(cachePath), _getStyleAndHash2 = slicedToArray_slicedToArray(_getStyleAndHash, 2), inlineCacheStyleStr = _getStyleAndHash2[0], styleHash = _getStyleAndHash2[1];
                      if (inlineCacheStyleStr) return [ inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order ];
                  }
                  var styleObj = styleFn(), _parseStyle6 = slicedToArray_slicedToArray(parseStyle(styleObj, {
                      hashId,
                      hashPriority,
                      layer,
                      path: path.join("-"),
                      transformers,
                      linters
                  }), 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1], styleStr = normalizeStyle(parsedStyle), styleId = function(path, styleStr) {
                      return hash_browser_esm("".concat(path.join("%")).concat(styleStr));
                  }(fullPath, styleStr);
                  return [ styleStr, tokenKey, styleId, effectStyle, clientOnly, order ];
              }), (function(_ref2, fromHMR) {
                  var styleId = slicedToArray_slicedToArray(_ref2, 3)[2];
                  (fromHMR || autoClear) && isClientSide && removeCSS(styleId, {
                      mark: StyleContext_ATTR_MARK
                  });
              }), (function(_ref4) {
                  var _ref5 = slicedToArray_slicedToArray(_ref4, 4), styleStr = _ref5[0], styleId = (_ref5[1], 
                  _ref5[2]), effectStyle = _ref5[3];
                  if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
                      var mergedCSSConfig = {
                          mark: StyleContext_ATTR_MARK,
                          prepend: "queue",
                          attachTo: container,
                          priority: order
                      }, nonceStr = "function" == typeof nonce ? nonce() : nonce;
                      nonceStr && (mergedCSSConfig.csp = {
                          nonce: nonceStr
                      });
                      var _style = updateCSS(styleStr, styleId, mergedCSSConfig);
                      _style[CSS_IN_JS_INSTANCE] = cache.instanceId, _style.setAttribute(StyleContext_ATTR_TOKEN, tokenKey), 
                      Object.keys(effectStyle).forEach((function(effectKey) {
                          updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
                      }));
                  }
              })), _useGlobalCache2 = slicedToArray_slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
              return function(node) {
                  var styleNode, _ref6;
                  ssrInline && !isMergedClientSide && defaultCache ? styleNode = react.createElement("style", _extends({}, (defineProperty_defineProperty(_ref6 = {}, StyleContext_ATTR_TOKEN, cachedTokenKey), 
                  defineProperty_defineProperty(_ref6, StyleContext_ATTR_MARK, cachedStyleId), _ref6), {
                      dangerouslySetInnerHTML: {
                          __html: cachedStyleStr
                      }
                  })) : styleNode = react.createElement(Empty, null);
                  return react.createElement(react.Fragment, null, styleNode, node);
              };
          }
          var Keyframe = function() {
              function Keyframe(name, style) {
                  _classCallCheck(this, Keyframe), defineProperty_defineProperty(this, "name", void 0), 
                  defineProperty_defineProperty(this, "style", void 0), defineProperty_defineProperty(this, "_keyframe", !0), 
                  this.name = name, this.style = style;
              }
              return _createClass(Keyframe, [ {
                  key: "getName",
                  value: function() {
                      var hashId = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                      return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
                  }
              } ]), Keyframe;
          }();
          const Keyframes = Keyframe;
          function noSplit(list) {
              return list.notSplit = !0, list;
          }
          noSplit([ "borderTop", "borderBottom" ]), noSplit([ "borderTop" ]), noSplit([ "borderBottom" ]), 
          noSplit([ "borderLeft", "borderRight" ]), noSplit([ "borderLeft" ]), noSplit([ "borderRight" ]);
          const Context = (0, react.createContext)({});
          function get(entity, path) {
              for (var current = entity, i = 0; i < path.length; i += 1) {
                  if (null == current) return;
                  current = current[path[i]];
              }
              return current;
          }
          function internalSet(entity, paths, value, removeIfUndefined) {
              if (!paths.length) return value;
              var arr, clone, _paths = _arrayWithHoles(arr = paths) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(), path = _paths[0], restPath = _paths.slice(1);
              return clone = entity || "number" != typeof path ? Array.isArray(entity) ? _toConsumableArray(entity) : _objectSpread2({}, entity) : [], 
              removeIfUndefined && void 0 === value && 1 === restPath.length ? delete clone[path][restPath[0]] : clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined), 
              clone;
          }
          function set(entity, paths, value) {
              var removeIfUndefined = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
              return paths.length && removeIfUndefined && void 0 === value && !get(entity, paths.slice(0, -1)) ? entity : internalSet(entity, paths, value, removeIfUndefined);
          }
          function createEmpty(source) {
              return Array.isArray(source) ? [] : {};
          }
          var keys = "undefined" == typeof Reflect ? Object.keys : Reflect.ownKeys;
          function merge() {
              for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) sources[_key] = arguments[_key];
              var clone = createEmpty(sources[0]);
              return sources.forEach((function(src) {
                  !function internalMerge(path, parentLoopSet) {
                      var obj, loopSet = new Set(parentLoopSet), value = get(src, path), isArr = Array.isArray(value);
                      if (isArr || "object" === _typeof(obj = value) && null !== obj && Object.getPrototypeOf(obj) === Object.prototype) {
                          if (!loopSet.has(value)) {
                              loopSet.add(value);
                              var originValue = get(clone, path);
                              isArr ? clone = set(clone, path, []) : originValue && "object" === _typeof(originValue) || (clone = set(clone, path, createEmpty(value))), 
                              keys(value).forEach((function(key) {
                                  internalMerge([].concat(_toConsumableArray(path), [ key ]), loopSet);
                              }));
                          }
                      } else clone = set(clone, path, value);
                  }([]);
              })), clone;
          }
          function noop() {}
          const WarningContext = react.createContext({}), warning_devUseWarning = () => {
              const noopWarning = () => {};
              return noopWarning.deprecated = noop, noopWarning;
          }, validateMessagesContext = (0, react.createContext)(void 0);
          const locale_en_US = {
              locale: "en_US",
              today: "Today",
              now: "Now",
              backToToday: "Back to today",
              ok: "OK",
              clear: "Clear",
              month: "Month",
              year: "Year",
              timeSelect: "select time",
              dateSelect: "select date",
              weekSelect: "Choose a week",
              monthSelect: "Choose a month",
              yearSelect: "Choose a year",
              decadeSelect: "Choose a decade",
              yearFormat: "YYYY",
              dateFormat: "M/D/YYYY",
              dayFormat: "D",
              dateTimeFormat: "M/D/YYYY HH:mm:ss",
              monthBeforeYear: !0,
              previousMonth: "Previous month (PageUp)",
              nextMonth: "Next month (PageDown)",
              previousYear: "Last year (Control + left)",
              nextYear: "Next year (Control + right)",
              previousDecade: "Last decade",
              nextDecade: "Next decade",
              previousCentury: "Last century",
              nextCentury: "Next century"
          }, time_picker_locale_en_US = {
              placeholder: "Select time",
              rangePlaceholder: [ "Start time", "End time" ]
          }, locale_en_US_locale = {
              lang: Object.assign({
                  placeholder: "Select date",
                  yearPlaceholder: "Select year",
                  quarterPlaceholder: "Select quarter",
                  monthPlaceholder: "Select month",
                  weekPlaceholder: "Select week",
                  rangePlaceholder: [ "Start date", "End date" ],
                  rangeYearPlaceholder: [ "Start year", "End year" ],
                  rangeQuarterPlaceholder: [ "Start quarter", "End quarter" ],
                  rangeMonthPlaceholder: [ "Start month", "End month" ],
                  rangeWeekPlaceholder: [ "Start week", "End week" ]
              }, locale_en_US),
              timePickerLocale: Object.assign({}, time_picker_locale_en_US)
          }, typeTemplate = "${label} is not a valid ${type}", es_locale_en_US = {
              locale: "en",
              Pagination: {
                  items_per_page: "/ page",
                  jump_to: "Go to",
                  jump_to_confirm: "confirm",
                  page: "Page",
                  prev_page: "Previous Page",
                  next_page: "Next Page",
                  prev_5: "Previous 5 Pages",
                  next_5: "Next 5 Pages",
                  prev_3: "Previous 3 Pages",
                  next_3: "Next 3 Pages",
                  page_size: "Page Size"
              },
              DatePicker: locale_en_US_locale,
              TimePicker: time_picker_locale_en_US,
              Calendar: locale_en_US_locale,
              global: {
                  placeholder: "Please select"
              },
              Table: {
                  filterTitle: "Filter menu",
                  filterConfirm: "OK",
                  filterReset: "Reset",
                  filterEmptyText: "No filters",
                  filterCheckall: "Select all items",
                  filterSearchPlaceholder: "Search in filters",
                  emptyText: "No data",
                  selectAll: "Select current page",
                  selectInvert: "Invert current page",
                  selectNone: "Clear all data",
                  selectionAll: "Select all data",
                  sortTitle: "Sort",
                  expand: "Expand row",
                  collapse: "Collapse row",
                  triggerDesc: "Click to sort descending",
                  triggerAsc: "Click to sort ascending",
                  cancelSort: "Click to cancel sorting"
              },
              Tour: {
                  Next: "Next",
                  Previous: "Previous",
                  Finish: "Finish"
              },
              Modal: {
                  okText: "OK",
                  cancelText: "Cancel",
                  justOkText: "OK"
              },
              Popconfirm: {
                  okText: "OK",
                  cancelText: "Cancel"
              },
              Transfer: {
                  titles: [ "", "" ],
                  searchPlaceholder: "Search here",
                  itemUnit: "item",
                  itemsUnit: "items",
                  remove: "Remove",
                  selectCurrent: "Select current page",
                  removeCurrent: "Remove current page",
                  selectAll: "Select all data",
                  removeAll: "Remove all data",
                  selectInvert: "Invert current page"
              },
              Upload: {
                  uploading: "Uploading...",
                  removeFile: "Remove file",
                  uploadError: "Upload error",
                  previewFile: "Preview file",
                  downloadFile: "Download file"
              },
              Empty: {
                  description: "No data"
              },
              Icon: {
                  icon: "icon"
              },
              Text: {
                  edit: "Edit",
                  copy: "Copy",
                  copied: "Copied",
                  expand: "Expand"
              },
              PageHeader: {
                  back: "Back"
              },
              Form: {
                  optional: "(optional)",
                  defaultValidateMessages: {
                      default: "Field validation error for ${label}",
                      required: "Please enter ${label}",
                      enum: "${label} must be one of [${enum}]",
                      whitespace: "${label} cannot be a blank character",
                      date: {
                          format: "${label} date format is invalid",
                          parse: "${label} cannot be converted to a date",
                          invalid: "${label} is an invalid date"
                      },
                      types: {
                          string: typeTemplate,
                          method: typeTemplate,
                          array: typeTemplate,
                          object: typeTemplate,
                          number: typeTemplate,
                          date: typeTemplate,
                          boolean: typeTemplate,
                          integer: typeTemplate,
                          float: typeTemplate,
                          regexp: typeTemplate,
                          email: typeTemplate,
                          url: typeTemplate,
                          hex: typeTemplate
                      },
                      string: {
                          len: "${label} must be ${len} characters",
                          min: "${label} must be at least ${min} characters",
                          max: "${label} must be up to ${max} characters",
                          range: "${label} must be between ${min}-${max} characters"
                      },
                      number: {
                          len: "${label} must be equal to ${len}",
                          min: "${label} must be minimum ${min}",
                          max: "${label} must be maximum ${max}",
                          range: "${label} must be between ${min}-${max}"
                      },
                      array: {
                          len: "Must be ${len} ${label}",
                          min: "At least ${min} ${label}",
                          max: "At most ${max} ${label}",
                          range: "The amount of ${label} must be between ${min}-${max}"
                      },
                      pattern: {
                          mismatch: "${label} does not match the pattern ${pattern}"
                      }
                  }
              },
              Image: {
                  preview: "Preview"
              },
              QRCode: {
                  expired: "QR code expired",
                  refresh: "Refresh"
              },
              ColorPicker: {
                  presetEmpty: "Empty"
              }
          };
          let runtimeLocale = Object.assign({}, es_locale_en_US.Modal), localeList = [];
          const generateLocale = () => localeList.reduce(((merged, locale) => Object.assign(Object.assign({}, merged), locale)), es_locale_en_US.Modal);
          const locale_context = (0, react.createContext)(void 0);
          const es_locale = props => {
              const {locale = {}, children, _ANT_MARK__} = props;
              react.useEffect((() => {
                  const clearLocale = function(newLocale) {
                      if (newLocale) {
                          const cloneLocale = Object.assign({}, newLocale);
                          return localeList.push(cloneLocale), runtimeLocale = generateLocale(), () => {
                              localeList = localeList.filter((locale => locale !== cloneLocale)), runtimeLocale = generateLocale();
                          };
                      }
                      runtimeLocale = Object.assign({}, es_locale_en_US.Modal);
                  }(locale && locale.Modal);
                  return clearLocale;
              }), [ locale ]);
              const getMemoizedContextValue = react.useMemo((() => Object.assign(Object.assign({}, locale), {
                  exist: !0
              })), [ locale ]);
              return react.createElement(locale_context.Provider, {
                  value: getMemoizedContextValue
              }, children);
          };
          function bound01(n, max) {
              (function(n) {
                  return "string" == typeof n && -1 !== n.indexOf(".") && 1 === parseFloat(n);
              })(n) && (n = "100%");
              var isPercent = function(n) {
                  return "string" == typeof n && -1 !== n.indexOf("%");
              }(n);
              return n = 360 === max ? n : Math.min(max, Math.max(0, parseFloat(n))), isPercent && (n = parseInt(String(n * max), 10) / 100), 
              Math.abs(n - max) < 1e-6 ? 1 : n = 360 === max ? (n < 0 ? n % max + max : n % max) / parseFloat(String(max)) : n % max / parseFloat(String(max));
          }
          function clamp01(val) {
              return Math.min(1, Math.max(0, val));
          }
          function boundAlpha(a) {
              return a = parseFloat(a), (isNaN(a) || a < 0 || a > 1) && (a = 1), a;
          }
          function convertToPercentage(n) {
              return n <= 1 ? "".concat(100 * Number(n), "%") : n;
          }
          function util_pad2(c) {
              return 1 === c.length ? "0" + c : String(c);
          }
          function rgbToHsl(r, g, b) {
              r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
              var max = Math.max(r, g, b), min = Math.min(r, g, b), h = 0, s = 0, l = (max + min) / 2;
              if (max === min) s = 0, h = 0; else {
                  var d = max - min;
                  switch (s = l > .5 ? d / (2 - max - min) : d / (max + min), max) {
                    case r:
                      h = (g - b) / d + (g < b ? 6 : 0);
                      break;

                    case g:
                      h = (b - r) / d + 2;
                      break;

                    case b:
                      h = (r - g) / d + 4;
                  }
                  h /= 6;
              }
              return {
                  h,
                  s,
                  l
              };
          }
          function hue2rgb(p, q, t) {
              return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * t * (q - p) : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
          }
          function rgbToHsv(r, g, b) {
              r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
              var max = Math.max(r, g, b), min = Math.min(r, g, b), h = 0, v = max, d = max - min, s = 0 === max ? 0 : d / max;
              if (max === min) h = 0; else {
                  switch (max) {
                    case r:
                      h = (g - b) / d + (g < b ? 6 : 0);
                      break;

                    case g:
                      h = (b - r) / d + 2;
                      break;

                    case b:
                      h = (r - g) / d + 4;
                  }
                  h /= 6;
              }
              return {
                  h,
                  s,
                  v
              };
          }
          function rgbToHex(r, g, b, allow3Char) {
              var hex = [ util_pad2(Math.round(r).toString(16)), util_pad2(Math.round(g).toString(16)), util_pad2(Math.round(b).toString(16)) ];
              return allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) : hex.join("");
          }
          function convertDecimalToHex(d) {
              return Math.round(255 * parseFloat(d)).toString(16);
          }
          function convertHexToDecimal(h) {
              return parseIntFromHex(h) / 255;
          }
          function parseIntFromHex(val) {
              return parseInt(val, 16);
          }
          var names = {
              aliceblue: "#f0f8ff",
              antiquewhite: "#faebd7",
              aqua: "#00ffff",
              aquamarine: "#7fffd4",
              azure: "#f0ffff",
              beige: "#f5f5dc",
              bisque: "#ffe4c4",
              black: "#000000",
              blanchedalmond: "#ffebcd",
              blue: "#0000ff",
              blueviolet: "#8a2be2",
              brown: "#a52a2a",
              burlywood: "#deb887",
              cadetblue: "#5f9ea0",
              chartreuse: "#7fff00",
              chocolate: "#d2691e",
              coral: "#ff7f50",
              cornflowerblue: "#6495ed",
              cornsilk: "#fff8dc",
              crimson: "#dc143c",
              cyan: "#00ffff",
              darkblue: "#00008b",
              darkcyan: "#008b8b",
              darkgoldenrod: "#b8860b",
              darkgray: "#a9a9a9",
              darkgreen: "#006400",
              darkgrey: "#a9a9a9",
              darkkhaki: "#bdb76b",
              darkmagenta: "#8b008b",
              darkolivegreen: "#556b2f",
              darkorange: "#ff8c00",
              darkorchid: "#9932cc",
              darkred: "#8b0000",
              darksalmon: "#e9967a",
              darkseagreen: "#8fbc8f",
              darkslateblue: "#483d8b",
              darkslategray: "#2f4f4f",
              darkslategrey: "#2f4f4f",
              darkturquoise: "#00ced1",
              darkviolet: "#9400d3",
              deeppink: "#ff1493",
              deepskyblue: "#00bfff",
              dimgray: "#696969",
              dimgrey: "#696969",
              dodgerblue: "#1e90ff",
              firebrick: "#b22222",
              floralwhite: "#fffaf0",
              forestgreen: "#228b22",
              fuchsia: "#ff00ff",
              gainsboro: "#dcdcdc",
              ghostwhite: "#f8f8ff",
              goldenrod: "#daa520",
              gold: "#ffd700",
              gray: "#808080",
              green: "#008000",
              greenyellow: "#adff2f",
              grey: "#808080",
              honeydew: "#f0fff0",
              hotpink: "#ff69b4",
              indianred: "#cd5c5c",
              indigo: "#4b0082",
              ivory: "#fffff0",
              khaki: "#f0e68c",
              lavenderblush: "#fff0f5",
              lavender: "#e6e6fa",
              lawngreen: "#7cfc00",
              lemonchiffon: "#fffacd",
              lightblue: "#add8e6",
              lightcoral: "#f08080",
              lightcyan: "#e0ffff",
              lightgoldenrodyellow: "#fafad2",
              lightgray: "#d3d3d3",
              lightgreen: "#90ee90",
              lightgrey: "#d3d3d3",
              lightpink: "#ffb6c1",
              lightsalmon: "#ffa07a",
              lightseagreen: "#20b2aa",
              lightskyblue: "#87cefa",
              lightslategray: "#778899",
              lightslategrey: "#778899",
              lightsteelblue: "#b0c4de",
              lightyellow: "#ffffe0",
              lime: "#00ff00",
              limegreen: "#32cd32",
              linen: "#faf0e6",
              magenta: "#ff00ff",
              maroon: "#800000",
              mediumaquamarine: "#66cdaa",
              mediumblue: "#0000cd",
              mediumorchid: "#ba55d3",
              mediumpurple: "#9370db",
              mediumseagreen: "#3cb371",
              mediumslateblue: "#7b68ee",
              mediumspringgreen: "#00fa9a",
              mediumturquoise: "#48d1cc",
              mediumvioletred: "#c71585",
              midnightblue: "#191970",
              mintcream: "#f5fffa",
              mistyrose: "#ffe4e1",
              moccasin: "#ffe4b5",
              navajowhite: "#ffdead",
              navy: "#000080",
              oldlace: "#fdf5e6",
              olive: "#808000",
              olivedrab: "#6b8e23",
              orange: "#ffa500",
              orangered: "#ff4500",
              orchid: "#da70d6",
              palegoldenrod: "#eee8aa",
              palegreen: "#98fb98",
              paleturquoise: "#afeeee",
              palevioletred: "#db7093",
              papayawhip: "#ffefd5",
              peachpuff: "#ffdab9",
              peru: "#cd853f",
              pink: "#ffc0cb",
              plum: "#dda0dd",
              powderblue: "#b0e0e6",
              purple: "#800080",
              rebeccapurple: "#663399",
              red: "#ff0000",
              rosybrown: "#bc8f8f",
              royalblue: "#4169e1",
              saddlebrown: "#8b4513",
              salmon: "#fa8072",
              sandybrown: "#f4a460",
              seagreen: "#2e8b57",
              seashell: "#fff5ee",
              sienna: "#a0522d",
              silver: "#c0c0c0",
              skyblue: "#87ceeb",
              slateblue: "#6a5acd",
              slategray: "#708090",
              slategrey: "#708090",
              snow: "#fffafa",
              springgreen: "#00ff7f",
              steelblue: "#4682b4",
              tan: "#d2b48c",
              teal: "#008080",
              thistle: "#d8bfd8",
              tomato: "#ff6347",
              turquoise: "#40e0d0",
              violet: "#ee82ee",
              wheat: "#f5deb3",
              white: "#ffffff",
              whitesmoke: "#f5f5f5",
              yellow: "#ffff00",
              yellowgreen: "#9acd32"
          };
          function inputToRGB(color) {
              var rgb = {
                  r: 0,
                  g: 0,
                  b: 0
              }, a = 1, s = null, v = null, l = null, ok = !1, format = !1;
              return "string" == typeof color && (color = function(color) {
                  if (color = color.trim().toLowerCase(), 0 === color.length) return !1;
                  var named = !1;
                  if (names[color]) color = names[color], named = !0; else if ("transparent" === color) return {
                      r: 0,
                      g: 0,
                      b: 0,
                      a: 0,
                      format: "name"
                  };
                  var match = matchers.rgb.exec(color);
                  if (match) return {
                      r: match[1],
                      g: match[2],
                      b: match[3]
                  };
                  if (match = matchers.rgba.exec(color), match) return {
                      r: match[1],
                      g: match[2],
                      b: match[3],
                      a: match[4]
                  };
                  if (match = matchers.hsl.exec(color), match) return {
                      h: match[1],
                      s: match[2],
                      l: match[3]
                  };
                  if (match = matchers.hsla.exec(color), match) return {
                      h: match[1],
                      s: match[2],
                      l: match[3],
                      a: match[4]
                  };
                  if (match = matchers.hsv.exec(color), match) return {
                      h: match[1],
                      s: match[2],
                      v: match[3]
                  };
                  if (match = matchers.hsva.exec(color), match) return {
                      h: match[1],
                      s: match[2],
                      v: match[3],
                      a: match[4]
                  };
                  if (match = matchers.hex8.exec(color), match) return {
                      r: parseIntFromHex(match[1]),
                      g: parseIntFromHex(match[2]),
                      b: parseIntFromHex(match[3]),
                      a: convertHexToDecimal(match[4]),
                      format: named ? "name" : "hex8"
                  };
                  if (match = matchers.hex6.exec(color), match) return {
                      r: parseIntFromHex(match[1]),
                      g: parseIntFromHex(match[2]),
                      b: parseIntFromHex(match[3]),
                      format: named ? "name" : "hex"
                  };
                  if (match = matchers.hex4.exec(color), match) return {
                      r: parseIntFromHex(match[1] + match[1]),
                      g: parseIntFromHex(match[2] + match[2]),
                      b: parseIntFromHex(match[3] + match[3]),
                      a: convertHexToDecimal(match[4] + match[4]),
                      format: named ? "name" : "hex8"
                  };
                  if (match = matchers.hex3.exec(color), match) return {
                      r: parseIntFromHex(match[1] + match[1]),
                      g: parseIntFromHex(match[2] + match[2]),
                      b: parseIntFromHex(match[3] + match[3]),
                      format: named ? "name" : "hex"
                  };
                  return !1;
              }(color)), "object" == typeof color && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = function(r, g, b) {
                  return {
                      r: 255 * bound01(r, 255),
                      g: 255 * bound01(g, 255),
                      b: 255 * bound01(b, 255)
                  };
              }(color.r, color.g, color.b), ok = !0, format = "%" === String(color.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s = convertToPercentage(color.s), 
              v = convertToPercentage(color.v), rgb = function(h, s, v) {
                  h = 6 * bound01(h, 360), s = bound01(s, 100), v = bound01(v, 100);
                  var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6;
                  return {
                      r: 255 * [ v, q, p, p, t, v ][mod],
                      g: 255 * [ t, v, v, q, p, p ][mod],
                      b: 255 * [ p, p, t, v, v, q ][mod]
                  };
              }(color.h, s, v), ok = !0, format = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s = convertToPercentage(color.s), 
              l = convertToPercentage(color.l), rgb = function(h, s, l) {
                  var r, g, b;
                  if (h = bound01(h, 360), s = bound01(s, 100), l = bound01(l, 100), 0 === s) g = l, 
                  b = l, r = l; else {
                      var q = l < .5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
                      r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3);
                  }
                  return {
                      r: 255 * r,
                      g: 255 * g,
                      b: 255 * b
                  };
              }(color.h, s, l), ok = !0, format = "hsl"), Object.prototype.hasOwnProperty.call(color, "a") && (a = color.a)), 
              a = boundAlpha(a), {
                  ok,
                  format: color.format || format,
                  r: Math.min(255, Math.max(rgb.r, 0)),
                  g: Math.min(255, Math.max(rgb.g, 0)),
                  b: Math.min(255, Math.max(rgb.b, 0)),
                  a
              };
          }
          var CSS_UNIT = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")"), PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?"), matchers = {
              CSS_UNIT: new RegExp(CSS_UNIT),
              rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
              rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
              hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
              hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
              hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
              hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
              hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
          };
          function isValidCSSUnit(color) {
              return Boolean(matchers.CSS_UNIT.exec(String(color)));
          }
          var hueStep = 2, saturationStep = .16, saturationStep2 = .05, brightnessStep1 = .05, brightnessStep2 = .15, lightColorCount = 5, darkColorCount = 4, darkColorMap = [ {
              index: 7,
              opacity: .15
          }, {
              index: 6,
              opacity: .25
          }, {
              index: 5,
              opacity: .3
          }, {
              index: 5,
              opacity: .45
          }, {
              index: 5,
              opacity: .65
          }, {
              index: 5,
              opacity: .85
          }, {
              index: 4,
              opacity: .9
          }, {
              index: 3,
              opacity: .95
          }, {
              index: 2,
              opacity: .97
          }, {
              index: 1,
              opacity: .98
          } ];
          function toHsv(_ref) {
              var hsv = rgbToHsv(_ref.r, _ref.g, _ref.b);
              return {
                  h: 360 * hsv.h,
                  s: hsv.s,
                  v: hsv.v
              };
          }
          function toHex(_ref2) {
              var r = _ref2.r, g = _ref2.g, b = _ref2.b;
              return "#".concat(rgbToHex(r, g, b, !1));
          }
          function getHue(hsv, i, light) {
              var hue;
              return (hue = Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240 ? light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i : light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i) < 0 ? hue += 360 : hue >= 360 && (hue -= 360), 
              hue;
          }
          function getSaturation(hsv, i, light) {
              return 0 === hsv.h && 0 === hsv.s ? hsv.s : ((saturation = light ? hsv.s - saturationStep * i : i === darkColorCount ? hsv.s + saturationStep : hsv.s + saturationStep2 * i) > 1 && (saturation = 1), 
              light && i === lightColorCount && saturation > .1 && (saturation = .1), saturation < .06 && (saturation = .06), 
              Number(saturation.toFixed(2)));
              var saturation;
          }
          function getValue(hsv, i, light) {
              var value;
              return (value = light ? hsv.v + brightnessStep1 * i : hsv.v - brightnessStep2 * i) > 1 && (value = 1), 
              Number(value.toFixed(2));
          }
          function generate(color) {
              for (var opts = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, patterns = [], pColor = inputToRGB(color), i = lightColorCount; i > 0; i -= 1) {
                  var hsv = toHsv(pColor), colorString = toHex(inputToRGB({
                      h: getHue(hsv, i, !0),
                      s: getSaturation(hsv, i, !0),
                      v: getValue(hsv, i, !0)
                  }));
                  patterns.push(colorString);
              }
              patterns.push(toHex(pColor));
              for (var _i = 1; _i <= darkColorCount; _i += 1) {
                  var _hsv = toHsv(pColor), _colorString = toHex(inputToRGB({
                      h: getHue(_hsv, _i),
                      s: getSaturation(_hsv, _i),
                      v: getValue(_hsv, _i)
                  }));
                  patterns.push(_colorString);
              }
              return "dark" === opts.theme ? darkColorMap.map((function(_ref3) {
                  var rgb1, rgb2, p, index = _ref3.index, opacity = _ref3.opacity;
                  return toHex((rgb1 = inputToRGB(opts.backgroundColor || "#141414"), rgb2 = inputToRGB(patterns[index]), 
                  p = 100 * opacity / 100, {
                      r: (rgb2.r - rgb1.r) * p + rgb1.r,
                      g: (rgb2.g - rgb1.g) * p + rgb1.g,
                      b: (rgb2.b - rgb1.b) * p + rgb1.b
                  }));
              })) : patterns;
          }
          var presetPrimaryColors = {
              red: "#F5222D",
              volcano: "#FA541C",
              orange: "#FA8C16",
              gold: "#FAAD14",
              yellow: "#FADB14",
              lime: "#A0D911",
              green: "#52C41A",
              cyan: "#13C2C2",
              blue: "#1677FF",
              geekblue: "#2F54EB",
              purple: "#722ED1",
              magenta: "#EB2F96",
              grey: "#666666"
          }, presetPalettes = {}, presetDarkPalettes = {};
          Object.keys(presetPrimaryColors).forEach((function(key) {
              presetPalettes[key] = generate(presetPrimaryColors[key]), presetPalettes[key].primary = presetPalettes[key][5], 
              presetDarkPalettes[key] = generate(presetPrimaryColors[key], {
                  theme: "dark",
                  backgroundColor: "#141414"
              }), presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
          }));
          presetPalettes.red, presetPalettes.volcano, presetPalettes.gold, presetPalettes.orange, 
          presetPalettes.yellow, presetPalettes.lime, presetPalettes.green, presetPalettes.cyan;
          var blue = presetPalettes.blue;
          presetPalettes.geekblue, presetPalettes.purple, presetPalettes.magenta, presetPalettes.grey, 
          presetPalettes.grey;
          const shared_genControlHeight = token => {
              const {controlHeight} = token;
              return {
                  controlHeightSM: .75 * controlHeight,
                  controlHeightXS: .5 * controlHeight,
                  controlHeightLG: 1.25 * controlHeight
              };
          };
          const defaultPresetColors = {
              blue: "#1677ff",
              purple: "#722ED1",
              cyan: "#13C2C2",
              green: "#52C41A",
              magenta: "#EB2F96",
              pink: "#eb2f96",
              red: "#F5222D",
              orange: "#FA8C16",
              yellow: "#FADB14",
              volcano: "#FA541C",
              geekblue: "#2F54EB",
              gold: "#FAAD14",
              lime: "#A0D911"
          }, seed = Object.assign(Object.assign({}, defaultPresetColors), {
              colorPrimary: "#1677ff",
              colorSuccess: "#52c41a",
              colorWarning: "#faad14",
              colorError: "#ff4d4f",
              colorInfo: "#1677ff",
              colorLink: "",
              colorTextBase: "",
              colorBgBase: "",
              fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,\n'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n'Noto Color Emoji'",
              fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
              fontSize: 14,
              lineWidth: 1,
              lineType: "solid",
              motionUnit: .1,
              motionBase: 0,
              motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
              motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
              motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
              motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
              motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
              motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
              motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
              motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
              borderRadius: 6,
              sizeUnit: 4,
              sizeStep: 4,
              sizePopupArrow: 16,
              controlHeight: 32,
              zIndexBase: 0,
              zIndexPopupBase: 1e3,
              opacityImage: 1,
              wireframe: !1,
              motion: !0
          });
          var TinyColor = function() {
              function TinyColor(color, opts) {
                  var _a;
                  if (void 0 === color && (color = ""), void 0 === opts && (opts = {}), color instanceof TinyColor) return color;
                  "number" == typeof color && (color = function(color) {
                      return {
                          r: color >> 16,
                          g: (65280 & color) >> 8,
                          b: 255 & color
                      };
                  }(color)), this.originalInput = color;
                  var rgb = inputToRGB(color);
                  this.originalInput = color, this.r = rgb.r, this.g = rgb.g, this.b = rgb.b, this.a = rgb.a, 
                  this.roundA = Math.round(100 * this.a) / 100, this.format = null !== (_a = opts.format) && void 0 !== _a ? _a : rgb.format, 
                  this.gradientType = opts.gradientType, this.r < 1 && (this.r = Math.round(this.r)), 
                  this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), 
                  this.isValid = rgb.ok;
              }
              return TinyColor.prototype.isDark = function() {
                  return this.getBrightness() < 128;
              }, TinyColor.prototype.isLight = function() {
                  return !this.isDark();
              }, TinyColor.prototype.getBrightness = function() {
                  var rgb = this.toRgb();
                  return (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1e3;
              }, TinyColor.prototype.getLuminance = function() {
                  var rgb = this.toRgb(), RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255;
                  return .2126 * (RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4)) + .7152 * (GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4)) + .0722 * (BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4));
              }, TinyColor.prototype.getAlpha = function() {
                  return this.a;
              }, TinyColor.prototype.setAlpha = function(alpha) {
                  return this.a = boundAlpha(alpha), this.roundA = Math.round(100 * this.a) / 100, 
                  this;
              }, TinyColor.prototype.isMonochrome = function() {
                  return 0 === this.toHsl().s;
              }, TinyColor.prototype.toHsv = function() {
                  var hsv = rgbToHsv(this.r, this.g, this.b);
                  return {
                      h: 360 * hsv.h,
                      s: hsv.s,
                      v: hsv.v,
                      a: this.a
                  };
              }, TinyColor.prototype.toHsvString = function() {
                  var hsv = rgbToHsv(this.r, this.g, this.b), h = Math.round(360 * hsv.h), s = Math.round(100 * hsv.s), v = Math.round(100 * hsv.v);
                  return 1 === this.a ? "hsv(".concat(h, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
              }, TinyColor.prototype.toHsl = function() {
                  var hsl = rgbToHsl(this.r, this.g, this.b);
                  return {
                      h: 360 * hsl.h,
                      s: hsl.s,
                      l: hsl.l,
                      a: this.a
                  };
              }, TinyColor.prototype.toHslString = function() {
                  var hsl = rgbToHsl(this.r, this.g, this.b), h = Math.round(360 * hsl.h), s = Math.round(100 * hsl.s), l = Math.round(100 * hsl.l);
                  return 1 === this.a ? "hsl(".concat(h, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
              }, TinyColor.prototype.toHex = function(allow3Char) {
                  return void 0 === allow3Char && (allow3Char = !1), rgbToHex(this.r, this.g, this.b, allow3Char);
              }, TinyColor.prototype.toHexString = function(allow3Char) {
                  return void 0 === allow3Char && (allow3Char = !1), "#" + this.toHex(allow3Char);
              }, TinyColor.prototype.toHex8 = function(allow4Char) {
                  return void 0 === allow4Char && (allow4Char = !1), function(r, g, b, a, allow4Char) {
                      var hex = [ util_pad2(Math.round(r).toString(16)), util_pad2(Math.round(g).toString(16)), util_pad2(Math.round(b).toString(16)), util_pad2(convertDecimalToHex(a)) ];
                      return allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1)) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0) : hex.join("");
                  }(this.r, this.g, this.b, this.a, allow4Char);
              }, TinyColor.prototype.toHex8String = function(allow4Char) {
                  return void 0 === allow4Char && (allow4Char = !1), "#" + this.toHex8(allow4Char);
              }, TinyColor.prototype.toHexShortString = function(allowShortChar) {
                  return void 0 === allowShortChar && (allowShortChar = !1), 1 === this.a ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
              }, TinyColor.prototype.toRgb = function() {
                  return {
                      r: Math.round(this.r),
                      g: Math.round(this.g),
                      b: Math.round(this.b),
                      a: this.a
                  };
              }, TinyColor.prototype.toRgbString = function() {
                  var r = Math.round(this.r), g = Math.round(this.g), b = Math.round(this.b);
                  return 1 === this.a ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
              }, TinyColor.prototype.toPercentageRgb = function() {
                  var fmt = function(x) {
                      return "".concat(Math.round(100 * bound01(x, 255)), "%");
                  };
                  return {
                      r: fmt(this.r),
                      g: fmt(this.g),
                      b: fmt(this.b),
                      a: this.a
                  };
              }, TinyColor.prototype.toPercentageRgbString = function() {
                  var rnd = function(x) {
                      return Math.round(100 * bound01(x, 255));
                  };
                  return 1 === this.a ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
              }, TinyColor.prototype.toName = function() {
                  if (0 === this.a) return "transparent";
                  if (this.a < 1) return !1;
                  for (var hex = "#" + rgbToHex(this.r, this.g, this.b, !1), _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
                      var _b = _a[_i], key = _b[0];
                      if (hex === _b[1]) return key;
                  }
                  return !1;
              }, TinyColor.prototype.toString = function(format) {
                  var formatSet = Boolean(format);
                  format = null != format ? format : this.format;
                  var formattedString = !1, hasAlpha = this.a < 1 && this.a >= 0;
                  return formatSet || !hasAlpha || !format.startsWith("hex") && "name" !== format ? ("rgb" === format && (formattedString = this.toRgbString()), 
                  "prgb" === format && (formattedString = this.toPercentageRgbString()), "hex" !== format && "hex6" !== format || (formattedString = this.toHexString()), 
                  "hex3" === format && (formattedString = this.toHexString(!0)), "hex4" === format && (formattedString = this.toHex8String(!0)), 
                  "hex8" === format && (formattedString = this.toHex8String()), "name" === format && (formattedString = this.toName()), 
                  "hsl" === format && (formattedString = this.toHslString()), "hsv" === format && (formattedString = this.toHsvString()), 
                  formattedString || this.toHexString()) : "name" === format && 0 === this.a ? this.toName() : this.toRgbString();
              }, TinyColor.prototype.toNumber = function() {
                  return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
              }, TinyColor.prototype.clone = function() {
                  return new TinyColor(this.toString());
              }, TinyColor.prototype.lighten = function(amount) {
                  void 0 === amount && (amount = 10);
                  var hsl = this.toHsl();
                  return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), new TinyColor(hsl);
              }, TinyColor.prototype.brighten = function(amount) {
                  void 0 === amount && (amount = 10);
                  var rgb = this.toRgb();
                  return rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(-amount / 100 * 255))), 
                  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(-amount / 100 * 255))), rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(-amount / 100 * 255))), 
                  new TinyColor(rgb);
              }, TinyColor.prototype.darken = function(amount) {
                  void 0 === amount && (amount = 10);
                  var hsl = this.toHsl();
                  return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), new TinyColor(hsl);
              }, TinyColor.prototype.tint = function(amount) {
                  return void 0 === amount && (amount = 10), this.mix("white", amount);
              }, TinyColor.prototype.shade = function(amount) {
                  return void 0 === amount && (amount = 10), this.mix("black", amount);
              }, TinyColor.prototype.desaturate = function(amount) {
                  void 0 === amount && (amount = 10);
                  var hsl = this.toHsl();
                  return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), new TinyColor(hsl);
              }, TinyColor.prototype.saturate = function(amount) {
                  void 0 === amount && (amount = 10);
                  var hsl = this.toHsl();
                  return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), new TinyColor(hsl);
              }, TinyColor.prototype.greyscale = function() {
                  return this.desaturate(100);
              }, TinyColor.prototype.spin = function(amount) {
                  var hsl = this.toHsl(), hue = (hsl.h + amount) % 360;
                  return hsl.h = hue < 0 ? 360 + hue : hue, new TinyColor(hsl);
              }, TinyColor.prototype.mix = function(color, amount) {
                  void 0 === amount && (amount = 50);
                  var rgb1 = this.toRgb(), rgb2 = new TinyColor(color).toRgb(), p = amount / 100;
                  return new TinyColor({
                      r: (rgb2.r - rgb1.r) * p + rgb1.r,
                      g: (rgb2.g - rgb1.g) * p + rgb1.g,
                      b: (rgb2.b - rgb1.b) * p + rgb1.b,
                      a: (rgb2.a - rgb1.a) * p + rgb1.a
                  });
              }, TinyColor.prototype.analogous = function(results, slices) {
                  void 0 === results && (results = 6), void 0 === slices && (slices = 30);
                  var hsl = this.toHsl(), part = 360 / slices, ret = [ this ];
                  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) hsl.h = (hsl.h + part) % 360, 
                  ret.push(new TinyColor(hsl));
                  return ret;
              }, TinyColor.prototype.complement = function() {
                  var hsl = this.toHsl();
                  return hsl.h = (hsl.h + 180) % 360, new TinyColor(hsl);
              }, TinyColor.prototype.monochromatic = function(results) {
                  void 0 === results && (results = 6);
                  for (var hsv = this.toHsv(), h = hsv.h, s = hsv.s, v = hsv.v, res = [], modification = 1 / results; results--; ) res.push(new TinyColor({
                      h,
                      s,
                      v
                  })), v = (v + modification) % 1;
                  return res;
              }, TinyColor.prototype.splitcomplement = function() {
                  var hsl = this.toHsl(), h = hsl.h;
                  return [ this, new TinyColor({
                      h: (h + 72) % 360,
                      s: hsl.s,
                      l: hsl.l
                  }), new TinyColor({
                      h: (h + 216) % 360,
                      s: hsl.s,
                      l: hsl.l
                  }) ];
              }, TinyColor.prototype.onBackground = function(background) {
                  var fg = this.toRgb(), bg = new TinyColor(background).toRgb(), alpha = fg.a + bg.a * (1 - fg.a);
                  return new TinyColor({
                      r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
                      g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
                      b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
                      a: alpha
                  });
              }, TinyColor.prototype.triad = function() {
                  return this.polyad(3);
              }, TinyColor.prototype.tetrad = function() {
                  return this.polyad(4);
              }, TinyColor.prototype.polyad = function(n) {
                  for (var hsl = this.toHsl(), h = hsl.h, result = [ this ], increment = 360 / n, i = 1; i < n; i++) result.push(new TinyColor({
                      h: (h + i * increment) % 360,
                      s: hsl.s,
                      l: hsl.l
                  }));
                  return result;
              }, TinyColor.prototype.equals = function(color) {
                  return this.toRgbString() === new TinyColor(color).toRgbString();
              }, TinyColor;
          }();
          const shared_genRadius = radiusBase => {
              let radiusLG = radiusBase, radiusSM = radiusBase, radiusXS = radiusBase, radiusOuter = radiusBase;
              return radiusBase < 6 && radiusBase >= 5 ? radiusLG = radiusBase + 1 : radiusBase < 16 && radiusBase >= 6 ? radiusLG = radiusBase + 2 : radiusBase >= 16 && (radiusLG = 16), 
              radiusBase < 7 && radiusBase >= 5 ? radiusSM = 4 : radiusBase < 8 && radiusBase >= 7 ? radiusSM = 5 : radiusBase < 14 && radiusBase >= 8 ? radiusSM = 6 : radiusBase < 16 && radiusBase >= 14 ? radiusSM = 7 : radiusBase >= 16 && (radiusSM = 8), 
              radiusBase < 6 && radiusBase >= 2 ? radiusXS = 1 : radiusBase >= 6 && (radiusXS = 2), 
              radiusBase > 4 && radiusBase < 8 ? radiusOuter = 4 : radiusBase >= 8 && (radiusOuter = 6), 
              {
                  borderRadius: radiusBase,
                  borderRadiusXS: radiusXS,
                  borderRadiusSM: radiusSM,
                  borderRadiusLG: radiusLG,
                  borderRadiusOuter: radiusOuter
              };
          };
          const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString(), getSolidColor = (baseColor, brightness) => new TinyColor(baseColor).darken(brightness).toHexString(), generateColorPalettes = baseColor => {
              const colors = generate(baseColor);
              return {
                  1: colors[0],
                  2: colors[1],
                  3: colors[2],
                  4: colors[3],
                  5: colors[4],
                  6: colors[5],
                  7: colors[6],
                  8: colors[4],
                  9: colors[5],
                  10: colors[6]
              };
          }, generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
              const colorBgBase = bgBaseColor || "#fff", colorTextBase = textBaseColor || "#000";
              return {
                  colorBgBase,
                  colorTextBase,
                  colorText: getAlphaColor(colorTextBase, .88),
                  colorTextSecondary: getAlphaColor(colorTextBase, .65),
                  colorTextTertiary: getAlphaColor(colorTextBase, .45),
                  colorTextQuaternary: getAlphaColor(colorTextBase, .25),
                  colorFill: getAlphaColor(colorTextBase, .15),
                  colorFillSecondary: getAlphaColor(colorTextBase, .06),
                  colorFillTertiary: getAlphaColor(colorTextBase, .04),
                  colorFillQuaternary: getAlphaColor(colorTextBase, .02),
                  colorBgLayout: getSolidColor(colorBgBase, 4),
                  colorBgContainer: getSolidColor(colorBgBase, 0),
                  colorBgElevated: getSolidColor(colorBgBase, 0),
                  colorBgSpotlight: getAlphaColor(colorTextBase, .85),
                  colorBgBlur: "transparent",
                  colorBorder: getSolidColor(colorBgBase, 15),
                  colorBorderSecondary: getSolidColor(colorBgBase, 6)
              };
          };
          const shared_genFontMapToken = fontSize => {
              const fontSizePairs = function(base) {
                  const fontSizes = new Array(10).fill(null).map(((_, index) => {
                      const i = index - 1, baseSize = base * Math.pow(2.71828, i / 5), intSize = index > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
                      return 2 * Math.floor(intSize / 2);
                  }));
                  return fontSizes[1] = base, fontSizes.map((size => ({
                      size,
                      lineHeight: (size + 8) / size
                  })));
              }(fontSize), fontSizes = fontSizePairs.map((pair => pair.size)), lineHeights = fontSizePairs.map((pair => pair.lineHeight));
              return {
                  fontSizeSM: fontSizes[0],
                  fontSize: fontSizes[1],
                  fontSizeLG: fontSizes[2],
                  fontSizeXL: fontSizes[3],
                  fontSizeHeading1: fontSizes[6],
                  fontSizeHeading2: fontSizes[5],
                  fontSizeHeading3: fontSizes[4],
                  fontSizeHeading4: fontSizes[3],
                  fontSizeHeading5: fontSizes[2],
                  lineHeight: lineHeights[1],
                  lineHeightLG: lineHeights[2],
                  lineHeightSM: lineHeights[0],
                  lineHeightHeading1: lineHeights[6],
                  lineHeightHeading2: lineHeights[5],
                  lineHeightHeading3: lineHeights[4],
                  lineHeightHeading4: lineHeights[3],
                  lineHeightHeading5: lineHeights[2]
              };
          };
          const defaultTheme = createTheme((function(token) {
              const colorPalettes = Object.keys(defaultPresetColors).map((colorKey => {
                  const colors = generate(token[colorKey]);
                  return new Array(10).fill(1).reduce(((prev, _, i) => (prev[`${colorKey}-${i + 1}`] = colors[i], 
                  prev[`${colorKey}${i + 1}`] = colors[i], prev)), {});
              })).reduce(((prev, cur) => prev = Object.assign(Object.assign({}, prev), cur)), {});
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token), colorPalettes), function(seed, _ref) {
                  let {generateColorPalettes, generateNeutralColorPalettes} = _ref;
                  const {colorSuccess: colorSuccessBase, colorWarning: colorWarningBase, colorError: colorErrorBase, colorInfo: colorInfoBase, colorPrimary: colorPrimaryBase, colorBgBase, colorTextBase} = seed, primaryColors = generateColorPalettes(colorPrimaryBase), successColors = generateColorPalettes(colorSuccessBase), warningColors = generateColorPalettes(colorWarningBase), errorColors = generateColorPalettes(colorErrorBase), infoColors = generateColorPalettes(colorInfoBase), neutralColors = generateNeutralColorPalettes(colorBgBase, colorTextBase), linkColors = generateColorPalettes(seed.colorLink || seed.colorInfo);
                  return Object.assign(Object.assign({}, neutralColors), {
                      colorPrimaryBg: primaryColors[1],
                      colorPrimaryBgHover: primaryColors[2],
                      colorPrimaryBorder: primaryColors[3],
                      colorPrimaryBorderHover: primaryColors[4],
                      colorPrimaryHover: primaryColors[5],
                      colorPrimary: primaryColors[6],
                      colorPrimaryActive: primaryColors[7],
                      colorPrimaryTextHover: primaryColors[8],
                      colorPrimaryText: primaryColors[9],
                      colorPrimaryTextActive: primaryColors[10],
                      colorSuccessBg: successColors[1],
                      colorSuccessBgHover: successColors[2],
                      colorSuccessBorder: successColors[3],
                      colorSuccessBorderHover: successColors[4],
                      colorSuccessHover: successColors[4],
                      colorSuccess: successColors[6],
                      colorSuccessActive: successColors[7],
                      colorSuccessTextHover: successColors[8],
                      colorSuccessText: successColors[9],
                      colorSuccessTextActive: successColors[10],
                      colorErrorBg: errorColors[1],
                      colorErrorBgHover: errorColors[2],
                      colorErrorBorder: errorColors[3],
                      colorErrorBorderHover: errorColors[4],
                      colorErrorHover: errorColors[5],
                      colorError: errorColors[6],
                      colorErrorActive: errorColors[7],
                      colorErrorTextHover: errorColors[8],
                      colorErrorText: errorColors[9],
                      colorErrorTextActive: errorColors[10],
                      colorWarningBg: warningColors[1],
                      colorWarningBgHover: warningColors[2],
                      colorWarningBorder: warningColors[3],
                      colorWarningBorderHover: warningColors[4],
                      colorWarningHover: warningColors[4],
                      colorWarning: warningColors[6],
                      colorWarningActive: warningColors[7],
                      colorWarningTextHover: warningColors[8],
                      colorWarningText: warningColors[9],
                      colorWarningTextActive: warningColors[10],
                      colorInfoBg: infoColors[1],
                      colorInfoBgHover: infoColors[2],
                      colorInfoBorder: infoColors[3],
                      colorInfoBorderHover: infoColors[4],
                      colorInfoHover: infoColors[4],
                      colorInfo: infoColors[6],
                      colorInfoActive: infoColors[7],
                      colorInfoTextHover: infoColors[8],
                      colorInfoText: infoColors[9],
                      colorInfoTextActive: infoColors[10],
                      colorLinkHover: linkColors[4],
                      colorLink: linkColors[6],
                      colorLinkActive: linkColors[7],
                      colorBgMask: new TinyColor("#000").setAlpha(.45).toRgbString(),
                      colorWhite: "#fff"
                  });
              }(token, {
                  generateColorPalettes,
                  generateNeutralColorPalettes
              })), shared_genFontMapToken(token.fontSize)), function(token) {
                  const {sizeUnit, sizeStep} = token;
                  return {
                      sizeXXL: sizeUnit * (sizeStep + 8),
                      sizeXL: sizeUnit * (sizeStep + 4),
                      sizeLG: sizeUnit * (sizeStep + 2),
                      sizeMD: sizeUnit * (sizeStep + 1),
                      sizeMS: sizeUnit * sizeStep,
                      size: sizeUnit * sizeStep,
                      sizeSM: sizeUnit * (sizeStep - 1),
                      sizeXS: sizeUnit * (sizeStep - 2),
                      sizeXXS: sizeUnit * (sizeStep - 3)
                  };
              }(token)), shared_genControlHeight(token)), function(token) {
                  const {motionUnit, motionBase, borderRadius, lineWidth} = token;
                  return Object.assign({
                      motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
                      motionDurationMid: `${(motionBase + 2 * motionUnit).toFixed(1)}s`,
                      motionDurationSlow: `${(motionBase + 3 * motionUnit).toFixed(1)}s`,
                      lineWidthBold: lineWidth + 1
                  }, shared_genRadius(borderRadius));
              }(token));
          })), defaultConfig = {
              token: seed,
              hashed: !0
          }, DesignTokenContext = react.createContext(defaultConfig), context_ConfigContext = react.createContext({
              getPrefixCls: (suffixCls, customizePrefixCls) => customizePrefixCls || (suffixCls ? `ant-${suffixCls}` : "ant"),
              iconPrefixCls: "anticon"
          }), {Consumer: ConfigConsumer} = context_ConfigContext, dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
          function registerTheme(globalPrefixCls, theme) {
              const style = function(globalPrefixCls, theme) {
                  const variables = {}, formatColor = (color, updater) => {
                      let clone = color.clone();
                      return clone = (null == updater ? void 0 : updater(clone)) || clone, clone.toRgbString();
                  }, fillColor = (colorVal, type) => {
                      const baseColor = new TinyColor(colorVal), colorPalettes = generate(baseColor.toRgbString());
                      variables[`${type}-color`] = formatColor(baseColor), variables[`${type}-color-disabled`] = colorPalettes[1], 
                      variables[`${type}-color-hover`] = colorPalettes[4], variables[`${type}-color-active`] = colorPalettes[6], 
                      variables[`${type}-color-outline`] = baseColor.clone().setAlpha(.2).toRgbString(), 
                      variables[`${type}-color-deprecated-bg`] = colorPalettes[0], variables[`${type}-color-deprecated-border`] = colorPalettes[2];
                  };
                  if (theme.primaryColor) {
                      fillColor(theme.primaryColor, "primary");
                      const primaryColor = new TinyColor(theme.primaryColor), primaryColors = generate(primaryColor.toRgbString());
                      primaryColors.forEach(((color, index) => {
                          variables[`primary-${index + 1}`] = color;
                      })), variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c => c.lighten(35))), 
                      variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c => c.lighten(20))), 
                      variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c => c.tint(20))), 
                      variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c => c.tint(50))), 
                      variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c => c.setAlpha(.12 * c.getAlpha())));
                      const primaryActiveColor = new TinyColor(primaryColors[0]);
                      variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c => c.setAlpha(.3 * c.getAlpha()))), 
                      variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c => c.darken(2)));
                  }
                  return theme.successColor && fillColor(theme.successColor, "success"), theme.warningColor && fillColor(theme.warningColor, "warning"), 
                  theme.errorColor && fillColor(theme.errorColor, "error"), theme.infoColor && fillColor(theme.infoColor, "info"), 
                  `\n  :root {\n    ${Object.keys(variables).map((key => `--${globalPrefixCls}-${key}: ${variables[key]};`)).join("\n")}\n  }\n  `.trim();
              }(globalPrefixCls, theme);
              canUseDom() && updateCSS(style, `${dynamicStyleMark}-dynamic-theme`);
          }
          const DisabledContext = react.createContext(!1), DisabledContextProvider = _ref => {
              let {children, disabled} = _ref;
              const originDisabled = react.useContext(DisabledContext);
              return react.createElement(DisabledContext.Provider, {
                  value: null != disabled ? disabled : originDisabled
              }, children);
          }, config_provider_DisabledContext = DisabledContext, SizeContext = react.createContext(void 0), SizeContextProvider = _ref => {
              let {children, size} = _ref;
              const originSize = react.useContext(SizeContext);
              return react.createElement(SizeContext.Provider, {
                  value: size || originSize
              }, children);
          }, config_provider_SizeContext = SizeContext;
          const hooks_useConfig = function() {
              return {
                  componentDisabled: (0, react.useContext)(config_provider_DisabledContext),
                  componentSize: (0, react.useContext)(config_provider_SizeContext)
              };
          };
          var classnames = __webpack_require__("./node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js"), classnames_default = __webpack_require__.n(classnames), react_dom = __webpack_require__("./node_modules/.pnpm/react-dom@18.2.0_react@18.2.0/node_modules/react-dom/index.js"), react_dom_namespaceObject = __webpack_require__.t(react_dom, 2);
          function isDOM(node) {
              return node instanceof HTMLElement || node instanceof SVGElement;
          }
          function findDOMNode(node) {
              return isDOM(node) ? node : node instanceof react.Component ? react_dom.findDOMNode(node) : null;
          }
          var react_is = __webpack_require__("./node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/index.js");
          function fillRef(ref, node) {
              "function" == typeof ref ? ref(node) : "object" === _typeof(ref) && ref && "current" in ref && (ref.current = node);
          }
          function composeRef() {
              for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) refs[_key] = arguments[_key];
              var refList = refs.filter((function(ref) {
                  return ref;
              }));
              return refList.length <= 1 ? refList[0] : function(node) {
                  refs.forEach((function(ref) {
                      fillRef(ref, node);
                  }));
              };
          }
          function useComposeRef() {
              for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) refs[_key2] = arguments[_key2];
              return useMemo_useMemo((function() {
                  return composeRef.apply(void 0, refs);
              }), refs, (function(prev, next) {
                  return prev.length !== next.length || prev.every((function(ref, i) {
                      return ref !== next[i];
                  }));
              }));
          }
          function supportRef(nodeOrComponent) {
              var _type$prototype, _nodeOrComponent$prot, type = (0, react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
              return !!("function" != typeof type || null !== (_type$prototype = type.prototype) && void 0 !== _type$prototype && _type$prototype.render) && !!("function" != typeof nodeOrComponent || null !== (_nodeOrComponent$prot = nodeOrComponent.prototype) && void 0 !== _nodeOrComponent$prot && _nodeOrComponent$prot.render);
          }
          function objectWithoutProperties_objectWithoutProperties(source, excluded) {
              if (null == source) return {};
              var key, i, target = function(source, excluded) {
                  if (null == source) return {};
                  var key, i, target = {}, sourceKeys = Object.keys(source);
                  for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
                  return target;
              }(source, excluded);
              if (Object.getOwnPropertySymbols) {
                  var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                  for (i = 0; i < sourceSymbolKeys.length; i++) key = sourceSymbolKeys[i], excluded.indexOf(key) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
              }
              return target;
          }
          var context_excluded = [ "children" ], context_Context = react.createContext({});
          function MotionProvider(_ref) {
              var children = _ref.children, props = objectWithoutProperties_objectWithoutProperties(_ref, context_excluded);
              return react.createElement(context_Context.Provider, {
                  value: props
              }, children);
          }
          function _setPrototypeOf(o, p) {
              return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, p) {
                  return o.__proto__ = p, o;
              }, _setPrototypeOf(o, p);
          }
          function _inherits(subClass, superClass) {
              if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
              subClass.prototype = Object.create(superClass && superClass.prototype, {
                  constructor: {
                      value: subClass,
                      writable: !0,
                      configurable: !0
                  }
              }), Object.defineProperty(subClass, "prototype", {
                  writable: !1
              }), superClass && _setPrototypeOf(subClass, superClass);
          }
          function _getPrototypeOf(o) {
              return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
              }, _getPrototypeOf(o);
          }
          function _assertThisInitialized(self) {
              if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return self;
          }
          function _possibleConstructorReturn(self, call) {
              if (call && ("object" === _typeof(call) || "function" == typeof call)) return call;
              if (void 0 !== call) throw new TypeError("Derived constructors may only return object or undefined");
              return _assertThisInitialized(self);
          }
          function _createSuper(Derived) {
              var hasNativeReflectConstruct = function() {
                  if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                  if (Reflect.construct.sham) return !1;
                  if ("function" == typeof Proxy) return !0;
                  try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                      !0;
                  } catch (e) {
                      return !1;
                  }
              }();
              return function() {
                  var result, Super = _getPrototypeOf(Derived);
                  if (hasNativeReflectConstruct) {
                      var NewTarget = _getPrototypeOf(this).constructor;
                      result = Reflect.construct(Super, arguments, NewTarget);
                  } else result = Super.apply(this, arguments);
                  return _possibleConstructorReturn(this, result);
              };
          }
          const es_DomWrapper = function(_React$Component) {
              _inherits(DomWrapper, _React$Component);
              var _super = _createSuper(DomWrapper);
              function DomWrapper() {
                  return _classCallCheck(this, DomWrapper), _super.apply(this, arguments);
              }
              return _createClass(DomWrapper, [ {
                  key: "render",
                  value: function() {
                      return this.props.children;
                  }
              } ]), DomWrapper;
          }(react.Component);
          function useSafeState(defaultValue) {
              var destroyRef = react.useRef(!1), _React$useState2 = slicedToArray_slicedToArray(react.useState(defaultValue), 2), value = _React$useState2[0], setValue = _React$useState2[1];
              return react.useEffect((function() {
                  return destroyRef.current = !1, function() {
                      destroyRef.current = !0;
                  };
              }), []), [ value, function(updater, ignoreDestroy) {
                  ignoreDestroy && destroyRef.current || setValue(updater);
              } ];
          }
          var STATUS_NONE = "none", STATUS_APPEAR = "appear", STATUS_ENTER = "enter", STATUS_LEAVE = "leave", STEP_PREPARE = "prepare", STEP_START = "start", STEP_ACTIVE = "active", STEP_ACTIVATED = "end", STEP_PREPARED = "prepared";
          function makePrefixMap(styleProp, eventName) {
              var prefixes = {};
              return prefixes[styleProp.toLowerCase()] = eventName.toLowerCase(), prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName), 
              prefixes["Moz".concat(styleProp)] = "moz".concat(eventName), prefixes["ms".concat(styleProp)] = "MS".concat(eventName), 
              prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase()), prefixes;
          }
          var vendorPrefixes = function(domSupport, win) {
              var prefixes = {
                  animationend: makePrefixMap("Animation", "AnimationEnd"),
                  transitionend: makePrefixMap("Transition", "TransitionEnd")
              };
              return domSupport && ("AnimationEvent" in win || delete prefixes.animationend.animation, 
              "TransitionEvent" in win || delete prefixes.transitionend.transition), prefixes;
          }(canUseDom(), "undefined" != typeof window ? window : {}), style = {};
          if (canUseDom()) {
              var _document$createEleme = document.createElement("div");
              style = _document$createEleme.style;
          }
          var prefixedEventNames = {};
          function getVendorPrefixedEventName(eventName) {
              if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
              var prefixMap = vendorPrefixes[eventName];
              if (prefixMap) for (var stylePropList = Object.keys(prefixMap), len = stylePropList.length, i = 0; i < len; i += 1) {
                  var styleProp = stylePropList[i];
                  if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp], 
                  prefixedEventNames[eventName];
              }
              return "";
          }
          var internalAnimationEndName = getVendorPrefixedEventName("animationend"), internalTransitionEndName = getVendorPrefixedEventName("transitionend"), supportTransition = !(!internalAnimationEndName || !internalTransitionEndName), animationEndName = internalAnimationEndName || "animationend", transitionEndName = internalTransitionEndName || "transitionend";
          function getTransitionName(transitionName, transitionType) {
              if (!transitionName) return null;
              if ("object" === _typeof(transitionName)) {
                  var type = transitionType.replace(/-\w/g, (function(match) {
                      return match[1].toUpperCase();
                  }));
                  return transitionName[type];
              }
              return "".concat(transitionName, "-").concat(transitionType);
          }
          const useDomMotionEvents = function(callback) {
              var cacheElementRef = (0, react.useRef)(), callbackRef = (0, react.useRef)(callback);
              callbackRef.current = callback;
              var onInternalMotionEnd = react.useCallback((function(event) {
                  callbackRef.current(event);
              }), []);
              function removeMotionEvents(element) {
                  element && (element.removeEventListener(transitionEndName, onInternalMotionEnd), 
                  element.removeEventListener(animationEndName, onInternalMotionEnd));
              }
              return react.useEffect((function() {
                  return function() {
                      removeMotionEvents(cacheElementRef.current);
                  };
              }), []), [ function(element) {
                  cacheElementRef.current && cacheElementRef.current !== element && removeMotionEvents(cacheElementRef.current), 
                  element && element !== cacheElementRef.current && (element.addEventListener(transitionEndName, onInternalMotionEnd), 
                  element.addEventListener(animationEndName, onInternalMotionEnd), cacheElementRef.current = element);
              }, removeMotionEvents ];
          };
          const hooks_useIsomorphicLayoutEffect = canUseDom() ? react.useLayoutEffect : react.useEffect;
          var raf = function(callback) {
              return +setTimeout(callback, 16);
          }, caf = function(num) {
              return clearTimeout(num);
          };
          "undefined" != typeof window && "requestAnimationFrame" in window && (raf = function(callback) {
              return window.requestAnimationFrame(callback);
          }, caf = function(handle) {
              return window.cancelAnimationFrame(handle);
          });
          var rafUUID = 0, rafIds = new Map;
          function cleanup(id) {
              rafIds.delete(id);
          }
          var wrapperRaf = function(callback) {
              var id = rafUUID += 1;
              return function callRef(leftTimes) {
                  if (0 === leftTimes) cleanup(id), callback(); else {
                      var realId = raf((function() {
                          callRef(leftTimes - 1);
                      }));
                      rafIds.set(id, realId);
                  }
              }(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1), id;
          };
          wrapperRaf.cancel = function(id) {
              var realId = rafIds.get(id);
              return cleanup(realId), caf(realId);
          };
          const es_raf = wrapperRaf;
          var FULL_STEP_QUEUE = [ STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED ], SIMPLE_STEP_QUEUE = [ STEP_PREPARE, STEP_PREPARED ], SkipStep = !1, DoStep = !0;
          function isActive(step) {
              return step === STEP_ACTIVE || step === STEP_ACTIVATED;
          }
          const useStepQueue = function(status, prepareOnly, callback) {
              var _useState2 = slicedToArray_slicedToArray(useSafeState("none"), 2), step = _useState2[0], setStep = _useState2[1], _useNextFrame = function() {
                  var nextFrameRef = react.useRef(null);
                  function cancelNextFrame() {
                      es_raf.cancel(nextFrameRef.current);
                  }
                  return react.useEffect((function() {
                      return function() {
                          cancelNextFrame();
                      };
                  }), []), [ function nextFrame(callback) {
                      var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                      cancelNextFrame();
                      var nextFrameId = es_raf((function() {
                          delay <= 1 ? callback({
                              isCanceled: function() {
                                  return nextFrameId !== nextFrameRef.current;
                              }
                          }) : nextFrame(callback, delay - 1);
                      }));
                      nextFrameRef.current = nextFrameId;
                  }, cancelNextFrame ];
              }(), _useNextFrame2 = slicedToArray_slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
              var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
              return hooks_useIsomorphicLayoutEffect((function() {
                  if ("none" !== step && step !== STEP_ACTIVATED) {
                      var index = STEP_QUEUE.indexOf(step), nextStep = STEP_QUEUE[index + 1], result = callback(step);
                      result === SkipStep ? setStep(nextStep, !0) : nextStep && nextFrame((function(info) {
                          function doNext() {
                              info.isCanceled() || setStep(nextStep, !0);
                          }
                          !0 === result ? doNext() : Promise.resolve(result).then(doNext);
                      }));
                  }
              }), [ status, step ]), react.useEffect((function() {
                  return function() {
                      cancelNextFrame();
                  };
              }), []), [ function() {
                  setStep(STEP_PREPARE, !0);
              }, step ];
          };
          const es_CSSMotion = function(config) {
              var transitionSupport = config;
              "object" === _typeof(config) && (transitionSupport = config.transitionSupport);
              var CSSMotion = react.forwardRef((function(props, ref) {
                  var _props$visible = props.visible, visible = void 0 === _props$visible || _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = void 0 === _props$removeOnLeave || _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps, supportMotion = function(props, contextMotion) {
                      return !(!props.motionName || !transitionSupport || !1 === contextMotion);
                  }(props, react.useContext(context_Context).motion), nodeRef = (0, react.useRef)(), wrapperNodeRef = (0, 
                  react.useRef)();
                  var _useStatus = function(supportMotion, visible, getElement, _ref) {
                      var _ref$motionEnter = _ref.motionEnter, motionEnter = void 0 === _ref$motionEnter || _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = void 0 === _ref$motionAppear || _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = void 0 === _ref$motionLeave || _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged, _useState2 = slicedToArray_slicedToArray(useSafeState(), 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1], _useState4 = slicedToArray_slicedToArray(useSafeState(STATUS_NONE), 2), status = _useState4[0], setStatus = _useState4[1], _useState6 = slicedToArray_slicedToArray(useSafeState(null), 2), style = _useState6[0], setStyle = _useState6[1], mountedRef = (0, 
                      react.useRef)(!1), deadlineRef = (0, react.useRef)(null);
                      function getDomElement() {
                          return getElement();
                      }
                      var activeRef = (0, react.useRef)(!1);
                      function updateMotionEndStatus() {
                          setStatus(STATUS_NONE, !0), setStyle(null, !0);
                      }
                      function onInternalMotionEnd(event) {
                          var element = getDomElement();
                          if (!event || event.deadline || event.target === element) {
                              var canEnd, currentActive = activeRef.current;
                              status === STATUS_APPEAR && currentActive ? canEnd = null == onAppearEnd ? void 0 : onAppearEnd(element, event) : status === STATUS_ENTER && currentActive ? canEnd = null == onEnterEnd ? void 0 : onEnterEnd(element, event) : status === STATUS_LEAVE && currentActive && (canEnd = null == onLeaveEnd ? void 0 : onLeaveEnd(element, event)), 
                              status !== STATUS_NONE && currentActive && !1 !== canEnd && updateMotionEndStatus();
                          }
                      }
                      var patchMotionEvents = slicedToArray_slicedToArray(useDomMotionEvents(onInternalMotionEnd), 1)[0], getEventHandlers = function(targetStatus) {
                          var _ref2, _ref3, _ref4;
                          switch (targetStatus) {
                            case STATUS_APPEAR:
                              return defineProperty_defineProperty(_ref2 = {}, STEP_PREPARE, onAppearPrepare), 
                              defineProperty_defineProperty(_ref2, STEP_START, onAppearStart), defineProperty_defineProperty(_ref2, STEP_ACTIVE, onAppearActive), 
                              _ref2;

                            case STATUS_ENTER:
                              return defineProperty_defineProperty(_ref3 = {}, STEP_PREPARE, onEnterPrepare), 
                              defineProperty_defineProperty(_ref3, STEP_START, onEnterStart), defineProperty_defineProperty(_ref3, STEP_ACTIVE, onEnterActive), 
                              _ref3;

                            case STATUS_LEAVE:
                              return defineProperty_defineProperty(_ref4 = {}, STEP_PREPARE, onLeavePrepare), 
                              defineProperty_defineProperty(_ref4, STEP_START, onLeaveStart), defineProperty_defineProperty(_ref4, STEP_ACTIVE, onLeaveActive), 
                              _ref4;

                            default:
                              return {};
                          }
                      }, eventHandlers = react.useMemo((function() {
                          return getEventHandlers(status);
                      }), [ status ]), _useStepQueue2 = slicedToArray_slicedToArray(useStepQueue(status, !supportMotion, (function(newStep) {
                          if (newStep === STEP_PREPARE) {
                              var onPrepare = eventHandlers[STEP_PREPARE];
                              return onPrepare ? onPrepare(getDomElement()) : SkipStep;
                          }
                          var _eventHandlers$step;
                          return step in eventHandlers && setStyle((null === (_eventHandlers$step = eventHandlers[step]) || void 0 === _eventHandlers$step ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null), 
                          step === STEP_ACTIVE && (patchMotionEvents(getDomElement()), motionDeadline > 0 && (clearTimeout(deadlineRef.current), 
                          deadlineRef.current = setTimeout((function() {
                              onInternalMotionEnd({
                                  deadline: !0
                              });
                          }), motionDeadline))), step === STEP_PREPARED && updateMotionEndStatus(), DoStep;
                      })), 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1], active = isActive(step);
                      activeRef.current = active, hooks_useIsomorphicLayoutEffect((function() {
                          setAsyncVisible(visible);
                          var nextStatus, isMounted = mountedRef.current;
                          mountedRef.current = !0, !isMounted && visible && motionAppear && (nextStatus = STATUS_APPEAR), 
                          isMounted && visible && motionEnter && (nextStatus = STATUS_ENTER), (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) && (nextStatus = STATUS_LEAVE);
                          var nextEventHandlers = getEventHandlers(nextStatus);
                          nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE]) ? (setStatus(nextStatus), 
                          startStep()) : setStatus(STATUS_NONE);
                      }), [ visible ]), (0, react.useEffect)((function() {
                          (status === STATUS_APPEAR && !motionAppear || status === STATUS_ENTER && !motionEnter || status === STATUS_LEAVE && !motionLeave) && setStatus(STATUS_NONE);
                      }), [ motionAppear, motionEnter, motionLeave ]), (0, react.useEffect)((function() {
                          return function() {
                              mountedRef.current = !1, clearTimeout(deadlineRef.current);
                          };
                      }), []);
                      var firstMountChangeRef = react.useRef(!1);
                      (0, react.useEffect)((function() {
                          asyncVisible && (firstMountChangeRef.current = !0), void 0 !== asyncVisible && status === STATUS_NONE && ((firstMountChangeRef.current || asyncVisible) && (null == onVisibleChanged || onVisibleChanged(asyncVisible)), 
                          firstMountChangeRef.current = !0);
                      }), [ asyncVisible, status ]);
                      var mergedStyle = style;
                      return eventHandlers[STEP_PREPARE] && step === STEP_START && (mergedStyle = _objectSpread2({
                          transition: "none"
                      }, mergedStyle)), [ status, step, mergedStyle, null != asyncVisible ? asyncVisible : visible ];
                  }(supportMotion, visible, (function() {
                      try {
                          return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
                      } catch (e) {
                          return null;
                      }
                  }), props), _useStatus2 = slicedToArray_slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3], renderedRef = react.useRef(mergedVisible);
                  mergedVisible && (renderedRef.current = !0);
                  var motionChildren, setNodeRef = react.useCallback((function(node) {
                      nodeRef.current = node, fillRef(ref, node);
                  }), [ ref ]), mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
                      visible
                  });
                  if (children) if (status === STATUS_NONE) motionChildren = mergedVisible ? children(_objectSpread2({}, mergedProps), setNodeRef) : !removeOnLeave && renderedRef.current && leavedClassName ? children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
                      className: leavedClassName
                  }), setNodeRef) : forceRender || !removeOnLeave && !leavedClassName ? children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
                      style: {
                          display: "none"
                      }
                  }), setNodeRef) : null; else {
                      var _classNames, statusSuffix;
                      statusStep === STEP_PREPARE ? statusSuffix = "prepare" : isActive(statusStep) ? statusSuffix = "active" : statusStep === STEP_START && (statusSuffix = "start");
                      var motionCls = getTransitionName(motionName, "".concat(status, "-").concat(statusSuffix));
                      motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
                          className: classnames_default()(getTransitionName(motionName, status), (_classNames = {}, 
                          defineProperty_defineProperty(_classNames, motionCls, motionCls && statusSuffix), 
                          defineProperty_defineProperty(_classNames, motionName, "string" == typeof motionName), 
                          _classNames)),
                          style: statusStyle
                      }), setNodeRef);
                  } else motionChildren = null;
                  react.isValidElement(motionChildren) && supportRef(motionChildren) && (motionChildren.ref || (motionChildren = react.cloneElement(motionChildren, {
                      ref: setNodeRef
                  })));
                  return react.createElement(es_DomWrapper, {
                      ref: wrapperNodeRef
                  }, motionChildren);
              }));
              return CSSMotion.displayName = "CSSMotion", CSSMotion;
          }(supportTransition);
          var STATUS_ADD = "add", STATUS_KEEP = "keep", STATUS_REMOVE = "remove";
          function wrapKeyToObject(key) {
              var keyObj;
              return _objectSpread2(_objectSpread2({}, keyObj = key && "object" === _typeof(key) && "key" in key ? key : {
                  key
              }), {}, {
                  key: String(keyObj.key)
              });
          }
          function parseKeys() {
              return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).map(wrapKeyToObject);
          }
          var CSSMotionList_excluded = [ "component", "children", "onVisibleChanged", "onAllRemoved" ], _excluded2 = [ "status" ], MOTION_PROP_NAMES = [ "eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd" ];
          !function(transitionSupport) {
              var CSSMotion = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : es_CSSMotion, CSSMotionList = function(_React$Component) {
                  _inherits(CSSMotionList, _React$Component);
                  var _super = _createSuper(CSSMotionList);
                  function CSSMotionList() {
                      var _this;
                      _classCallCheck(this, CSSMotionList);
                      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                      return defineProperty_defineProperty(_assertThisInitialized(_this = _super.call.apply(_super, [ this ].concat(args))), "state", {
                          keyEntities: []
                      }), defineProperty_defineProperty(_assertThisInitialized(_this), "removeKey", (function(removeKey) {
                          var nextKeyEntities = _this.state.keyEntities.map((function(entity) {
                              return entity.key !== removeKey ? entity : _objectSpread2(_objectSpread2({}, entity), {}, {
                                  status: "removed"
                              });
                          }));
                          return _this.setState({
                              keyEntities: nextKeyEntities
                          }), nextKeyEntities.filter((function(_ref) {
                              return "removed" !== _ref.status;
                          })).length;
                      })), _this;
                  }
                  return _createClass(CSSMotionList, [ {
                      key: "render",
                      value: function() {
                          var _this2 = this, keyEntities = this.state.keyEntities, _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = objectWithoutProperties_objectWithoutProperties(_this$props, CSSMotionList_excluded), Component = component || react.Fragment, motionProps = {};
                          return MOTION_PROP_NAMES.forEach((function(prop) {
                              motionProps[prop] = restProps[prop], delete restProps[prop];
                          })), delete restProps.keys, react.createElement(Component, restProps, keyEntities.map((function(_ref2, index) {
                              var status = _ref2.status, eventProps = objectWithoutProperties_objectWithoutProperties(_ref2, _excluded2), visible = status === STATUS_ADD || status === STATUS_KEEP;
                              return react.createElement(CSSMotion, _extends({}, motionProps, {
                                  key: eventProps.key,
                                  visible,
                                  eventProps,
                                  onVisibleChanged: function(changedVisible) {
                                      (null == _onVisibleChanged || _onVisibleChanged(changedVisible, {
                                          key: eventProps.key
                                      }), changedVisible) || 0 === _this2.removeKey(eventProps.key) && onAllRemoved && onAllRemoved();
                                  }
                              }), (function(props, ref) {
                                  return children(_objectSpread2(_objectSpread2({}, props), {}, {
                                      index
                                  }), ref);
                              }));
                          })));
                      }
                  } ], [ {
                      key: "getDerivedStateFromProps",
                      value: function(_ref3, _ref4) {
                          var keys = _ref3.keys, keyEntities = _ref4.keyEntities, parsedKeyObjects = parseKeys(keys), mixedKeyEntities = function() {
                              var prevKeys = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], currentKeys = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], list = [], currentIndex = 0, currentLen = currentKeys.length, prevKeyObjects = parseKeys(prevKeys), currentKeyObjects = parseKeys(currentKeys);
                              prevKeyObjects.forEach((function(keyObj) {
                                  for (var hit = !1, i = currentIndex; i < currentLen; i += 1) {
                                      var currentKeyObj = currentKeyObjects[i];
                                      if (currentKeyObj.key === keyObj.key) {
                                          currentIndex < i && (list = list.concat(currentKeyObjects.slice(currentIndex, i).map((function(obj) {
                                              return _objectSpread2(_objectSpread2({}, obj), {}, {
                                                  status: STATUS_ADD
                                              });
                                          }))), currentIndex = i), list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
                                              status: STATUS_KEEP
                                          })), currentIndex += 1, hit = !0;
                                          break;
                                      }
                                  }
                                  hit || list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
                                      status: STATUS_REMOVE
                                  }));
                              })), currentIndex < currentLen && (list = list.concat(currentKeyObjects.slice(currentIndex).map((function(obj) {
                                  return _objectSpread2(_objectSpread2({}, obj), {}, {
                                      status: STATUS_ADD
                                  });
                              }))));
                              var keys = {};
                              return list.forEach((function(_ref) {
                                  var key = _ref.key;
                                  keys[key] = (keys[key] || 0) + 1;
                              })), Object.keys(keys).filter((function(key) {
                                  return keys[key] > 1;
                              })).forEach((function(matchKey) {
                                  (list = list.filter((function(_ref2) {
                                      var key = _ref2.key, status = _ref2.status;
                                      return key !== matchKey || status !== STATUS_REMOVE;
                                  }))).forEach((function(node) {
                                      node.key === matchKey && (node.status = STATUS_KEEP);
                                  }));
                              })), list;
                          }(keyEntities, parsedKeyObjects);
                          return {
                              keyEntities: mixedKeyEntities.filter((function(entity) {
                                  var prevEntity = keyEntities.find((function(_ref5) {
                                      var key = _ref5.key;
                                      return entity.key === key;
                                  }));
                                  return !prevEntity || "removed" !== prevEntity.status || entity.status !== STATUS_REMOVE;
                              }))
                          };
                      }
                  } ]), CSSMotionList;
              }(react.Component);
              defineProperty_defineProperty(CSSMotionList, "defaultProps", {
                  component: "div"
              });
          }(supportTransition);
          const es = es_CSSMotion, es_version = "5.10.0";
          function isStableColor(color) {
              return color >= 0 && color <= 255;
          }
          const util_getAlphaColor = function(frontColor, backgroundColor) {
              const {r: fR, g: fG, b: fB, a: originAlpha} = new TinyColor(frontColor).toRgb();
              if (originAlpha < 1) return frontColor;
              const {r: bR, g: bG, b: bB} = new TinyColor(backgroundColor).toRgb();
              for (let fA = .01; fA <= 1; fA += .01) {
                  const r = Math.round((fR - bR * (1 - fA)) / fA), g = Math.round((fG - bG * (1 - fA)) / fA), b = Math.round((fB - bB * (1 - fA)) / fA);
                  if (isStableColor(r) && isStableColor(g) && isStableColor(b)) return new TinyColor({
                      r,
                      g,
                      b,
                      a: Math.round(100 * fA) / 100
                  }).toRgbString();
              }
              return new TinyColor({
                  r: fR,
                  g: fG,
                  b: fB,
                  a: 1
              }).toRgbString();
          };
          var __rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          function formatToken(derivativeToken) {
              const {override} = derivativeToken, restToken = __rest(derivativeToken, [ "override" ]), overrideTokens = Object.assign({}, override);
              Object.keys(seed).forEach((token => {
                  delete overrideTokens[token];
              }));
              const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
              if (!1 === mergedToken.motion) {
                  const fastDuration = "0s";
                  mergedToken.motionDurationFast = fastDuration, mergedToken.motionDurationMid = fastDuration, 
                  mergedToken.motionDurationSlow = fastDuration;
              }
              return Object.assign(Object.assign(Object.assign({}, mergedToken), {
                  colorFillContent: mergedToken.colorFillSecondary,
                  colorFillContentHover: mergedToken.colorFill,
                  colorFillAlter: mergedToken.colorFillQuaternary,
                  colorBgContainerDisabled: mergedToken.colorFillTertiary,
                  colorBorderBg: mergedToken.colorBgContainer,
                  colorSplit: util_getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
                  colorTextPlaceholder: mergedToken.colorTextQuaternary,
                  colorTextDisabled: mergedToken.colorTextQuaternary,
                  colorTextHeading: mergedToken.colorText,
                  colorTextLabel: mergedToken.colorTextSecondary,
                  colorTextDescription: mergedToken.colorTextTertiary,
                  colorTextLightSolid: mergedToken.colorWhite,
                  colorHighlight: mergedToken.colorError,
                  colorBgTextHover: mergedToken.colorFillSecondary,
                  colorBgTextActive: mergedToken.colorFill,
                  colorIcon: mergedToken.colorTextTertiary,
                  colorIconHover: mergedToken.colorText,
                  colorErrorOutline: util_getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
                  colorWarningOutline: util_getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
                  fontSizeIcon: mergedToken.fontSizeSM,
                  lineWidthFocus: 4 * mergedToken.lineWidth,
                  lineWidth: mergedToken.lineWidth,
                  controlOutlineWidth: 2 * mergedToken.lineWidth,
                  controlInteractiveSize: mergedToken.controlHeight / 2,
                  controlItemBgHover: mergedToken.colorFillTertiary,
                  controlItemBgActive: mergedToken.colorPrimaryBg,
                  controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
                  controlItemBgActiveDisabled: mergedToken.colorFill,
                  controlTmpOutline: mergedToken.colorFillQuaternary,
                  controlOutline: util_getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
                  lineType: mergedToken.lineType,
                  borderRadius: mergedToken.borderRadius,
                  borderRadiusXS: mergedToken.borderRadiusXS,
                  borderRadiusSM: mergedToken.borderRadiusSM,
                  borderRadiusLG: mergedToken.borderRadiusLG,
                  fontWeightStrong: 600,
                  opacityLoading: .65,
                  linkDecoration: "none",
                  linkHoverDecoration: "none",
                  linkFocusDecoration: "none",
                  controlPaddingHorizontal: 12,
                  controlPaddingHorizontalSM: 8,
                  paddingXXS: mergedToken.sizeXXS,
                  paddingXS: mergedToken.sizeXS,
                  paddingSM: mergedToken.sizeSM,
                  padding: mergedToken.size,
                  paddingMD: mergedToken.sizeMD,
                  paddingLG: mergedToken.sizeLG,
                  paddingXL: mergedToken.sizeXL,
                  paddingContentHorizontalLG: mergedToken.sizeLG,
                  paddingContentVerticalLG: mergedToken.sizeMS,
                  paddingContentHorizontal: mergedToken.sizeMS,
                  paddingContentVertical: mergedToken.sizeSM,
                  paddingContentHorizontalSM: mergedToken.size,
                  paddingContentVerticalSM: mergedToken.sizeXS,
                  marginXXS: mergedToken.sizeXXS,
                  marginXS: mergedToken.sizeXS,
                  marginSM: mergedToken.sizeSM,
                  margin: mergedToken.size,
                  marginMD: mergedToken.sizeMD,
                  marginLG: mergedToken.sizeLG,
                  marginXL: mergedToken.sizeXL,
                  marginXXL: mergedToken.sizeXXL,
                  boxShadow: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                  boxShadowSecondary: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                  boxShadowTertiary: "\n      0 1px 2px 0 rgba(0, 0, 0, 0.03),\n      0 1px 6px -1px rgba(0, 0, 0, 0.02),\n      0 2px 4px 0 rgba(0, 0, 0, 0.02)\n    ",
                  screenXS: 480,
                  screenXSMin: 480,
                  screenXSMax: 575,
                  screenSM: 576,
                  screenSMMin: 576,
                  screenSMMax: 767,
                  screenMD: 768,
                  screenMDMin: 768,
                  screenMDMax: 991,
                  screenLG: 992,
                  screenLGMin: 992,
                  screenLGMax: 1199,
                  screenXL: 1200,
                  screenXLMin: 1200,
                  screenXLMax: 1599,
                  screenXXL: 1600,
                  screenXXLMin: 1600,
                  boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
                  boxShadowCard: `\n      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},\n      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},\n      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}\n    `,
                  boxShadowDrawerRight: "\n      -6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      -3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      -9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                  boxShadowDrawerLeft: "\n      6px 0 16px 0 rgba(0, 0, 0, 0.08),\n      3px 0 6px -4px rgba(0, 0, 0, 0.12),\n      9px 0 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                  boxShadowDrawerUp: "\n      0 6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                  boxShadowDrawerDown: "\n      0 -6px 16px 0 rgba(0, 0, 0, 0.08),\n      0 -3px 6px -4px rgba(0, 0, 0, 0.12),\n      0 -9px 28px 8px rgba(0, 0, 0, 0.05)\n    ",
                  boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
                  boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
                  boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
                  boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
              }), overrideTokens);
          }
          var useToken_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const useToken_getComputedToken = (originToken, overrideToken, theme) => {
              const derivativeToken = theme.getDerivativeToken(originToken), {override} = overrideToken, components = useToken_rest(overrideToken, [ "override" ]);
              let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
                  override
              });
              return mergedDerivativeToken = formatToken(mergedDerivativeToken), components && Object.entries(components).forEach((_ref => {
                  let [key, value] = _ref;
                  const {theme: componentTheme} = value, componentTokens = useToken_rest(value, [ "theme" ]);
                  let mergedComponentToken = componentTokens;
                  componentTheme && (mergedComponentToken = useToken_getComputedToken(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
                      override: componentTokens
                  }, componentTheme)), mergedDerivativeToken[key] = mergedComponentToken;
              })), mergedDerivativeToken;
          };
          function useToken() {
              const {token: rootDesignToken, hashed, theme, components} = react.useContext(DesignTokenContext), salt = `${es_version}-${hashed || ""}`, mergedTheme = theme || defaultTheme, [token, hashId] = useCacheToken(mergedTheme, [ seed, rootDesignToken ], {
                  salt,
                  override: Object.assign({
                      override: rootDesignToken
                  }, components),
                  getComputedToken: useToken_getComputedToken,
                  formatToken
              });
              return [ mergedTheme, token, hashed ? hashId : "" ];
          }
          function MotionWrapper(props) {
              const {children} = props, [, token] = useToken(), {motion} = token, needWrapMotionProviderRef = react.useRef(!1);
              return needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || !1 === motion, 
              needWrapMotionProviderRef.current ? react.createElement(MotionProvider, {
                  motion
              }, children) : children;
          }
          const config_provider_PropWarning = () => null, resetComponent = function(token) {
              let needInheritFontFamily = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
              return {
                  boxSizing: "border-box",
                  margin: 0,
                  padding: 0,
                  color: token.colorText,
                  fontSize: token.fontSize,
                  lineHeight: token.lineHeight,
                  listStyle: "none",
                  fontFamily: needInheritFontFamily ? "inherit" : token.fontFamily
              };
          }, genLinkStyle = token => ({
              a: {
                  color: token.colorLink,
                  textDecoration: token.linkDecoration,
                  backgroundColor: "transparent",
                  outline: "none",
                  cursor: "pointer",
                  transition: `color ${token.motionDurationSlow}`,
                  "-webkit-text-decoration-skip": "objects",
                  "&:hover": {
                      color: token.colorLinkHover
                  },
                  "&:active": {
                      color: token.colorLinkActive
                  },
                  "&:active,\n  &:hover": {
                      textDecoration: token.linkHoverDecoration,
                      outline: 0
                  },
                  "&:focus": {
                      textDecoration: token.linkFocusDecoration,
                      outline: 0
                  },
                  "&[disabled]": {
                      color: token.colorTextDisabled,
                      cursor: "not-allowed"
                  }
              }
          }), genCommonStyle = (token, componentPrefixCls) => {
              const {fontFamily, fontSize} = token, rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
              return {
                  [rootPrefixSelector]: {
                      fontFamily,
                      fontSize,
                      boxSizing: "border-box",
                      "&::before, &::after": {
                          boxSizing: "border-box"
                      },
                      [rootPrefixSelector]: {
                          boxSizing: "border-box",
                          "&::before, &::after": {
                              boxSizing: "border-box"
                          }
                      }
                  }
              };
          }, genFocusOutline = token => ({
              outline: `${token.lineWidthFocus}px solid ${token.colorPrimaryBorder}`,
              outlineOffset: 1,
              transition: "outline-offset 0s, outline 0s"
          }), genFocusStyle = token => ({
              "&:focus-visible": Object.assign({}, genFocusOutline(token))
          }), util_useResetIconStyle = (iconPrefixCls, csp) => {
              const [theme, token] = useToken();
              return useStyleRegister({
                  theme,
                  token,
                  hashId: "",
                  path: [ "ant-design-icons", iconPrefixCls ],
                  nonce: () => null == csp ? void 0 : csp.nonce
              }, (() => [ {
                  [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, {
                      display: "inline-flex",
                      alignItems: "center",
                      color: "inherit",
                      fontStyle: "normal",
                      lineHeight: 0,
                      textAlign: "center",
                      textTransform: "none",
                      verticalAlign: "-0.125em",
                      textRendering: "optimizeLegibility",
                      "-webkit-font-smoothing": "antialiased",
                      "-moz-osx-font-smoothing": "grayscale",
                      "> *": {
                          lineHeight: 1
                      },
                      svg: {
                          display: "inline-block"
                      }
                  }), {
                      [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
                          display: "block"
                      }
                  })
              } ]));
          };
          var config_provider_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const PASSED_PROPS = [ "getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select", "button" ];
          let globalPrefixCls, globalIconPrefixCls, globalTheme;
          function getGlobalPrefixCls() {
              return globalPrefixCls || "ant";
          }
          const ProviderChildren = props => {
              const {children, csp: customCsp, autoInsertSpaceInButton, alert, anchor, form, locale, componentSize, direction, space, virtual, dropdownMatchSelectWidth, popupMatchSelectWidth, popupOverflow, legacyLocale, parentContext, iconPrefixCls: customIconPrefixCls, theme, componentDisabled, segmented, statistic, spin, calendar, carousel, cascader, collapse, typography, checkbox, descriptions, divider, drawer, skeleton, steps, image, layout, list, mentions, modal, progress, result, slider, breadcrumb, menu, pagination, input, empty, badge, radio, rate, switch: SWITCH, transfer, avatar, message, tag, table, card, tabs, timeline, timePicker, upload, notification, tree, colorPicker, datePicker, flex, wave, warning: warningConfig} = props, getPrefixCls = react.useCallback(((suffixCls, customizePrefixCls) => {
                  const {prefixCls} = props;
                  if (customizePrefixCls) return customizePrefixCls;
                  const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
                  return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
              }), [ parentContext.getPrefixCls, props.prefixCls ]), iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || "anticon", csp = customCsp || parentContext.csp;
              util_useResetIconStyle(iconPrefixCls, csp);
              const mergedTheme = function(theme, parentTheme) {
                  const themeConfig = theme || {}, parentThemeConfig = !1 !== themeConfig.inherit && parentTheme ? parentTheme : defaultConfig;
                  return useMemo_useMemo((() => {
                      if (!theme) return parentTheme;
                      const mergedComponents = Object.assign({}, parentThemeConfig.components);
                      return Object.keys(theme.components || {}).forEach((componentName => {
                          mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
                      })), Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
                          token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
                          components: mergedComponents
                      });
                  }), [ themeConfig, parentThemeConfig ], ((prev, next) => prev.some(((prevTheme, index) => {
                      const nextTheme = next[index];
                      return !es_isEqual(prevTheme, nextTheme, !0);
                  }))));
              }(theme, parentContext.theme);
              const baseConfig = {
                  csp,
                  autoInsertSpaceInButton,
                  alert,
                  anchor,
                  locale: locale || legacyLocale,
                  direction,
                  space,
                  virtual,
                  popupMatchSelectWidth: null != popupMatchSelectWidth ? popupMatchSelectWidth : dropdownMatchSelectWidth,
                  popupOverflow,
                  getPrefixCls,
                  iconPrefixCls,
                  theme: mergedTheme,
                  segmented,
                  statistic,
                  spin,
                  calendar,
                  carousel,
                  cascader,
                  collapse,
                  typography,
                  checkbox,
                  descriptions,
                  divider,
                  drawer,
                  skeleton,
                  steps,
                  image,
                  input,
                  layout,
                  list,
                  mentions,
                  modal,
                  progress,
                  result,
                  slider,
                  breadcrumb,
                  menu,
                  pagination,
                  empty,
                  badge,
                  radio,
                  rate,
                  switch: SWITCH,
                  transfer,
                  avatar,
                  message,
                  tag,
                  table,
                  card,
                  tabs,
                  timeline,
                  timePicker,
                  upload,
                  notification,
                  tree,
                  colorPicker,
                  datePicker,
                  flex,
                  wave,
                  warning: warningConfig
              }, config = Object.assign({}, parentContext);
              Object.keys(baseConfig).forEach((key => {
                  void 0 !== baseConfig[key] && (config[key] = baseConfig[key]);
              })), PASSED_PROPS.forEach((propName => {
                  const propValue = props[propName];
                  propValue && (config[propName] = propValue);
              }));
              const memoedConfig = useMemo_useMemo((() => config), config, ((prevConfig, currentConfig) => {
                  const prevKeys = Object.keys(prevConfig), currentKeys = Object.keys(currentConfig);
                  return prevKeys.length !== currentKeys.length || prevKeys.some((key => prevConfig[key] !== currentConfig[key]));
              })), memoIconContextValue = react.useMemo((() => ({
                  prefixCls: iconPrefixCls,
                  csp
              })), [ iconPrefixCls, csp ]);
              let childNode = react.createElement(react.Fragment, null, react.createElement(config_provider_PropWarning, {
                  dropdownMatchSelectWidth
              }), children);
              const validateMessages = react.useMemo((() => {
                  var _a, _b, _c, _d;
                  return merge((null === (_a = es_locale_en_US.Form) || void 0 === _a ? void 0 : _a.defaultValidateMessages) || {}, (null === (_c = null === (_b = memoedConfig.locale) || void 0 === _b ? void 0 : _b.Form) || void 0 === _c ? void 0 : _c.defaultValidateMessages) || {}, (null === (_d = memoedConfig.form) || void 0 === _d ? void 0 : _d.validateMessages) || {}, (null == form ? void 0 : form.validateMessages) || {});
              }), [ memoedConfig, null == form ? void 0 : form.validateMessages ]);
              Object.keys(validateMessages).length > 0 && (childNode = react.createElement(validateMessagesContext.Provider, {
                  value: validateMessages
              }, childNode)), locale && (childNode = react.createElement(es_locale, {
                  locale,
                  _ANT_MARK__: "internalMark"
              }, childNode)), (iconPrefixCls || csp) && (childNode = react.createElement(Context.Provider, {
                  value: memoIconContextValue
              }, childNode)), componentSize && (childNode = react.createElement(SizeContextProvider, {
                  size: componentSize
              }, childNode)), childNode = react.createElement(MotionWrapper, null, childNode);
              const memoTheme = react.useMemo((() => {
                  const _a = mergedTheme || {}, {algorithm, token, components} = _a, rest = config_provider_rest(_a, [ "algorithm", "token", "components" ]), themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme, parsedComponents = {};
                  return Object.entries(components || {}).forEach((_ref2 => {
                      let [componentName, componentToken] = _ref2;
                      const parsedToken = Object.assign({}, componentToken);
                      "algorithm" in parsedToken && (!0 === parsedToken.algorithm ? parsedToken.theme = themeObj : (Array.isArray(parsedToken.algorithm) || "function" == typeof parsedToken.algorithm) && (parsedToken.theme = createTheme(parsedToken.algorithm)), 
                      delete parsedToken.algorithm), parsedComponents[componentName] = parsedToken;
                  })), Object.assign(Object.assign({}, rest), {
                      theme: themeObj,
                      token: Object.assign(Object.assign({}, seed), token),
                      components: parsedComponents
                  });
              }), [ mergedTheme ]);
              return theme && (childNode = react.createElement(DesignTokenContext.Provider, {
                  value: memoTheme
              }, childNode)), memoedConfig.warning && (childNode = react.createElement(WarningContext.Provider, {
                  value: memoedConfig.warning
              }, childNode)), void 0 !== componentDisabled && (childNode = react.createElement(DisabledContextProvider, {
                  disabled: componentDisabled
              }, childNode)), react.createElement(context_ConfigContext.Provider, {
                  value: memoedConfig
              }, childNode);
          }, ConfigProvider = props => {
              const context = react.useContext(context_ConfigContext), antLocale = react.useContext(locale_context);
              return react.createElement(ProviderChildren, Object.assign({
                  parentContext: context,
                  legacyLocale: antLocale
              }, props));
          };
          ConfigProvider.ConfigContext = context_ConfigContext, ConfigProvider.SizeContext = config_provider_SizeContext, 
          ConfigProvider.config = _ref => {
              let {prefixCls, iconPrefixCls, theme} = _ref;
              void 0 !== prefixCls && (globalPrefixCls = prefixCls), void 0 !== iconPrefixCls && (globalIconPrefixCls = iconPrefixCls), 
              theme && (!function(theme) {
                  return Object.keys(theme).some((key => key.endsWith("Color")));
              }(theme) ? globalTheme = theme : registerTheme(getGlobalPrefixCls(), theme));
          }, ConfigProvider.useConfig = hooks_useConfig, Object.defineProperty(ConfigProvider, "SizeContext", {
              get: () => config_provider_SizeContext
          });
          const config_provider = ConfigProvider;
          var jsx_runtime = __webpack_require__("./node_modules/.pnpm/react@18.2.0/node_modules/react/jsx-runtime.js");
          const theme = {
              token: {
                  colorPrimary: "#7155ff",
                  colorPrimaryBorder: "#7155ff",
                  colorPrimaryBorderHover: "#7155ff"
              },
              components: {
                  Tooltip: {
                      colorBgSpotlight: "#7155ff",
                      zIndexPopupBase: 40002
                  },
                  Slider: {
                      dotActiveBorderColor: "rgb(250, 255, 255)",
                      trackBg: "#7155ff",
                      trackHoverBg: "#7155ff",
                      handleColor: "rgb(251, 255, 255)",
                      handleActiveColor: "rgb(252, 255, 255)"
                  },
                  Popover: {
                      zIndexPopupBase: 1e5
                  },
                  Radio: {
                      colorBgContainer: "transparent"
                  },
                  Spin: {
                      colorPrimary: "#fff"
                  }
              }
          };
          const antdConfigProvider = function({children}) {
              return (0, jsx_runtime.jsx)(config_provider, {
                  prefixCls: "fant",
                  theme,
                  children
              });
          };
          __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/es.typed-array.find-last.js"), 
          __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/es.typed-array.find-last-index.js"), 
          __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/esnext.typed-array.to-reversed.js"), 
          __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/esnext.typed-array.to-sorted.js"), 
          __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/esnext.typed-array.with.js");
          var promise, ua_parser = __webpack_require__("./node_modules/.pnpm/ua-parser-js@1.0.36/node_modules/ua-parser-js/src/ua-parser.js"), ua_parser_default = __webpack_require__.n(ua_parser), tiny_uid = __webpack_require__("./node_modules/.pnpm/tiny-uid@1.1.2/node_modules/tiny-uid/index.js"), isValidConnectionArgs = (args, requiredKeys = [ "endpointName", "fingerprint" ]) => "object" == typeof args && null !== args && requiredKeys.every((k => k in args)), encodeConnectionArgs = args => {
              if (!isValidConnectionArgs(args)) throw new TypeError("Invalid connection args");
              return JSON.stringify(args);
          }, PortMessage = class {
              static toBackground(port, message) {
                  return port.postMessage(message);
              }
              static toExtensionContext(port, message) {
                  return port.postMessage(message);
              }
          }, browser_polyfill = __webpack_require__("./node_modules/.pnpm/webextension-polyfill@0.9.0/node_modules/webextension-polyfill/dist/browser-polyfill.js");
          var __defProp = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value
          }) : obj[key] = value, __spreadValues = (a, b) => {
              for (var prop in b || (b = {})) __hasOwnProp.call(b, prop) && __defNormalProp(a, prop, b[prop]);
              if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) __propIsEnum.call(b, prop) && __defNormalProp(a, prop, b[prop]);
              return a;
          }, __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b)), ENDPOINT_RE = /^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/, parseEndpoint = endpoint => {
              const [, context, tabId, frameId] = endpoint.match(ENDPOINT_RE) || [];
              return {
                  context,
                  tabId: +tabId,
                  frameId: frameId ? +frameId : void 0
              };
          };
          Error;
          const commonProperties = [ {
              property: "name",
              enumerable: !1
          }, {
              property: "message",
              enumerable: !1
          }, {
              property: "stack",
              enumerable: !1
          }, {
              property: "code",
              enumerable: !0
          } ], toJsonWasCalled = Symbol(".toJSON was called"), destroyCircular = ({from, seen, to_, forceEnumerable, maxDepth, depth}) => {
              const to = to_ || (Array.isArray(from) ? [] : {});
              if (seen.push(from), depth >= maxDepth) return to;
              if ("function" == typeof from.toJSON && !0 !== from[toJsonWasCalled]) return (from => {
                  from[toJsonWasCalled] = !0;
                  const json = from.toJSON();
                  return delete from[toJsonWasCalled], json;
              })(from);
              for (const [key, value] of Object.entries(from)) "function" == typeof Buffer && Buffer.isBuffer(value) ? to[key] = "[object Buffer]" : null === value || "object" != typeof value || "function" != typeof value.pipe ? "function" != typeof value && (value && "object" == typeof value ? seen.includes(from[key]) ? to[key] = "[Circular]" : (depth++, 
              to[key] = destroyCircular({
                  from: from[key],
                  seen: [ ...seen ],
                  forceEnumerable,
                  maxDepth,
                  depth
              })) : to[key] = value) : to[key] = "[object Stream]";
              for (const {property, enumerable} of commonProperties) "string" == typeof from[property] && Object.defineProperty(to, property, {
                  value: from[property],
                  enumerable: !!forceEnumerable || enumerable,
                  configurable: !0,
                  writable: !0
              });
              return to;
          };
          let createNanoEvents = () => ({
              events: {},
              emit(event, ...args) {
                  (this.events[event] || []).forEach((i => i(...args)));
              },
              on(event, cb) {
                  return (this.events[event] = this.events[event] || []).push(cb), () => this.events[event] = (this.events[event] || []).filter((i => i !== cb));
              }
          });
          var _Stream = class {
              constructor(endpointRuntime, streamInfo) {
                  this.endpointRuntime = endpointRuntime, this.streamInfo = streamInfo, this.emitter = createNanoEvents(), 
                  this.isClosed = !1, this.handleStreamClose = () => {
                      this.isClosed || (this.isClosed = !0, this.emitter.emit("closed", !0), this.emitter.events = {});
                  }, _Stream.initDone || (endpointRuntime.onMessage("__crx_bridge_stream_transfer__", (msg => {
                      const {streamId, streamTransfer, action} = msg.data, stream = _Stream.openStreams.get(streamId);
                      stream && !stream.isClosed && ("transfer" === action && stream.emitter.emit("message", streamTransfer), 
                      "close" === action && (_Stream.openStreams.delete(streamId), stream.handleStreamClose()));
                  })), _Stream.initDone = !0), _Stream.openStreams.set(this.streamInfo.streamId, this);
              }
              get info() {
                  return this.streamInfo;
              }
              send(msg) {
                  if (this.isClosed) throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");
                  this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__", {
                      streamId: this.streamInfo.streamId,
                      streamTransfer: msg,
                      action: "transfer"
                  }, this.streamInfo.endpoint);
              }
              close(msg) {
                  msg && this.send(msg), this.handleStreamClose(), this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__", {
                      streamId: this.streamInfo.streamId,
                      streamTransfer: null,
                      action: "close"
                  }, this.streamInfo.endpoint);
              }
              onMessage(callback) {
                  return this.getDisposable("message", callback);
              }
              onClose(callback) {
                  return this.getDisposable("closed", callback);
              }
              getDisposable(event, callback) {
                  const off = this.emitter.on(event, callback);
                  return Object.assign(off, {
                      dispose: off,
                      close: off
                  });
              }
          }, Stream = _Stream;
          Stream.initDone = !1, Stream.openStreams = new Map;
          var content_script_win = (thisContext => {
              let allocatedNamespace, onMessageCallback, portP, messagingEnabled = !1;
              return {
                  enable: () => messagingEnabled = !0,
                  onMessage: cb => onMessageCallback = cb,
                  postMessage: async msg => {
                      if ("content-script" !== thisContext && "window" !== thisContext) throw new Error("Endpoint does not use postMessage");
                      if (!messagingEnabled) throw new Error("Communication with window has not been allowed");
                      return function(namespace) {
                          if ("string" != typeof namespace || 0 === namespace.trim().length) throw new Error("webext-bridge uses window.postMessage to talk with other \"window\"(s) for message routingwhich is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used`");
                      }(allocatedNamespace), (await portP).postMessage(msg);
                  },
                  setNamespace: nsps => {
                      if (allocatedNamespace) throw new Error("Namespace once set cannot be changed");
                      allocatedNamespace = nsps, portP = ((thisContext, namespace, onMessage) => null != promise ? promise : promise = new Promise((resolve => {
                          const acceptMessagingPort = event => {
                              const {data: {cmd, scope, context}, ports} = event;
                              if ("webext-port-offer" === cmd && scope === namespace && context !== thisContext) return window.removeEventListener("message", acceptMessagingPort), 
                              ports[0].onmessage = onMessage, ports[0].postMessage("port-accepted"), resolve(ports[0]);
                          }, offerMessagingPort = () => {
                              const channel = new MessageChannel;
                              channel.port1.onmessage = event => {
                                  if ("port-accepted" === event.data) return window.removeEventListener("message", acceptMessagingPort), 
                                  resolve(channel.port1);
                                  null == onMessage || onMessage(event);
                              }, window.postMessage({
                                  cmd: "webext-port-offer",
                                  scope: namespace,
                                  context: thisContext
                              }, "*", [ channel.port2 ]);
                          };
                          window.addEventListener("message", acceptMessagingPort), "window" === thisContext ? setTimeout(offerMessagingPort, 0) : offerMessagingPort();
                      })))(thisContext, nsps, (({data}) => null == onMessageCallback ? void 0 : onMessageCallback(data)));
                  }
              };
          })("content-script"), port = ((name = "") => {
              const fingerprint = `uid::${tiny_uid(7)}`;
              let port, undeliveredQueue = [];
              const pendingResponses = (() => {
                  let logs = [];
                  return {
                      add: (...receipts) => {
                          logs = [ ...logs, ...receipts ];
                      },
                      remove: message => {
                          logs = "string" == typeof message ? logs.filter((receipt => receipt.message.transactionId !== message)) : logs.filter((receipt => !message.includes(receipt)));
                      },
                      entries: () => logs
                  };
              })(), onMessageListeners = new Set, onFailureListeners = new Set, handleMessage = (msg, port2) => {
                  switch (msg.status) {
                    case "undeliverable":
                      return void (undeliveredQueue.some((m => m.message.messageID === msg.message.messageID)) || (undeliveredQueue = [ ...undeliveredQueue, {
                          message: msg.message,
                          resolvedDestination: msg.resolvedDestination
                      } ]));

                    case "deliverable":
                      return void (undeliveredQueue = undeliveredQueue.reduce(((acc, queuedMsg) => queuedMsg.resolvedDestination === msg.deliverableTo ? (PortMessage.toBackground(port2, {
                          type: "deliver",
                          message: queuedMsg.message
                      }), acc) : [ ...acc, queuedMsg ]), []));

                    case "delivered":
                      return void ("message" === msg.receipt.message.messageType && pendingResponses.add(msg.receipt));

                    case "incoming":
                      return "reply" === msg.message.messageType && pendingResponses.remove(msg.message.messageID), 
                      void onMessageListeners.forEach((cb => cb(msg.message, port2)));

                    case "terminated":
                      {
                          const rogueMsgs = pendingResponses.entries().filter((receipt => msg.fingerprint === receipt.to));
                          pendingResponses.remove(rogueMsgs), rogueMsgs.forEach((({message}) => onFailureListeners.forEach((cb => cb(message)))));
                      }
                  }
              }, connect = () => {
                  port = browser_polyfill.runtime.connect({
                      name: encodeConnectionArgs({
                          endpointName: name,
                          fingerprint
                      })
                  }), port.onMessage.addListener(handleMessage), port.onDisconnect.addListener(connect), 
                  PortMessage.toBackground(port, {
                      type: "sync",
                      pendingResponses: pendingResponses.entries(),
                      pendingDeliveries: [ ...new Set(undeliveredQueue.map((({resolvedDestination}) => resolvedDestination))) ]
                  });
              };
              return connect(), {
                  onFailure(cb) {
                      onFailureListeners.add(cb);
                  },
                  onMessage(cb) {
                      onMessageListeners.add(cb);
                  },
                  postMessage(message) {
                      PortMessage.toBackground(port, {
                          type: "deliver",
                          message
                      });
                  }
              };
          })(), endpointRuntime = ((thisContext, routeMessage, localMessage) => {
              const runtimeId = tiny_uid(), openTransactions = new Map, onMessageListeners = new Map, handleMessage = message => {
                  if (message.destination.context === thisContext && !message.destination.frameId && !message.destination.tabId) {
                      null == localMessage || localMessage(message);
                      const {transactionId, messageID, messageType} = message, handleReply = () => {
                          const transactionP = openTransactions.get(transactionId);
                          if (transactionP) {
                              const {err, data} = message;
                              if (err) {
                                  const dehydratedErr = err, errCtr = self[dehydratedErr.name], hydratedErr = new ("function" == typeof errCtr ? errCtr : Error)(dehydratedErr.message);
                                  for (const prop in dehydratedErr) hydratedErr[prop] = dehydratedErr[prop];
                                  transactionP.reject(hydratedErr);
                              } else transactionP.resolve(data);
                              openTransactions.delete(transactionId);
                          }
                      }, handleNewMessage = async () => {
                          let reply, err, noHandlerFoundError = !1;
                          try {
                              const cb = onMessageListeners.get(messageID);
                              if ("function" != typeof cb) throw noHandlerFoundError = !0, new Error(`[webext-bridge] No handler registered in '${thisContext}' to accept messages with id '${messageID}'`);
                              reply = await cb({
                                  sender: message.origin,
                                  id: messageID,
                                  data: message.data,
                                  timestamp: message.timestamp
                              });
                          } catch (error) {
                              err = error;
                          } finally {
                              if (err && (message.err = function(value, options = {}) {
                                  const {maxDepth = Number.POSITIVE_INFINITY} = options;
                                  return "object" == typeof value && null !== value ? destroyCircular({
                                      from: value,
                                      seen: [],
                                      forceEnumerable: !0,
                                      maxDepth,
                                      depth: 0
                                  }) : "function" == typeof value ? `[Function: ${value.name || "anonymous"}]` : value;
                              }(err)), handleMessage(__spreadProps(__spreadValues({}, message), {
                                  messageType: "reply",
                                  data: reply,
                                  origin: {
                                      context: thisContext,
                                      tabId: null
                                  },
                                  destination: message.origin,
                                  hops: []
                              })), err && !noHandlerFoundError) throw reply;
                          }
                      };
                      switch (messageType) {
                        case "reply":
                          return handleReply();

                        case "message":
                          return handleNewMessage();
                      }
                  }
                  return message.hops.push(`${thisContext}::${runtimeId}`), routeMessage(message);
              };
              return {
                  handleMessage,
                  endTransaction: transactionID => {
                      const transactionP = openTransactions.get(transactionID);
                      null == transactionP || transactionP.reject("Transaction was ended before it could complete"), 
                      openTransactions.delete(transactionID);
                  },
                  sendMessage: (messageID, data, destination = "background") => {
                      const endpoint = "string" == typeof destination ? parseEndpoint(destination) : destination;
                      if (!endpoint.context) throw new TypeError("Bridge#sendMessage -> Destination must be any one of known destinations");
                      return new Promise(((resolve, reject) => {
                          const payload = {
                              messageID,
                              data,
                              destination: endpoint,
                              messageType: "message",
                              transactionId: tiny_uid(),
                              origin: {
                                  context: thisContext,
                                  tabId: null
                              },
                              hops: [],
                              timestamp: Date.now()
                          };
                          openTransactions.set(payload.transactionId, {
                              resolve,
                              reject
                          });
                          try {
                              handleMessage(payload);
                          } catch (error) {
                              openTransactions.delete(payload.transactionId), reject(error);
                          }
                      }));
                  },
                  onMessage: (messageID, callback) => (onMessageListeners.set(messageID, callback), 
                  () => onMessageListeners.delete(messageID))
              };
          })("content-script", (message => {
              "window" === message.destination.context ? content_script_win.postMessage(message) : port.postMessage(message);
          }));
          content_script_win.onMessage((message => {
              message.origin = {
                  context: "window",
                  tabId: null
              }, endpointRuntime.handleMessage(message);
          })), port.onMessage(endpointRuntime.handleMessage), port.onFailure((message => {
              "window" !== message.origin.context ? endpointRuntime.endTransaction(message.transactionId) : content_script_win.postMessage({
                  type: "error",
                  transactionID: message.transactionId
              });
          }));
          var {sendMessage: content_script_sendMessage, onMessage} = endpointRuntime, {openStream, onOpenStreamChannel} = (endpointRuntime => {
              const openStreams = new Map, onOpenStreamCallbacks = new Map, streamyEmitter = createNanoEvents();
              return endpointRuntime.onMessage("__crx_bridge_stream_open__", (message => new Promise((resolve => {
                  const {sender, data} = message, {channel} = data;
                  let watching = !1, off = () => {};
                  const readyup = () => {
                      const callback = onOpenStreamCallbacks.get(channel);
                      "function" == typeof callback ? (callback(new Stream(endpointRuntime, __spreadProps(__spreadValues({}, data), {
                          endpoint: sender
                      }))), watching && off(), resolve(!0)) : watching || (watching = !0, off = streamyEmitter.on("did-change-stream-callbacks", readyup));
                  };
                  readyup();
              })))), {
                  openStream: async function(channel, destination) {
                      if (openStreams.has(channel)) throw new Error("webext-bridge: A Stream is already open at this channel");
                      const endpoint = "string" == typeof destination ? parseEndpoint(destination) : destination, streamInfo = {
                          streamId: tiny_uid(),
                          channel,
                          endpoint
                      }, stream = new Stream(endpointRuntime, streamInfo);
                      return stream.onClose((() => openStreams.delete(channel))), await endpointRuntime.sendMessage("__crx_bridge_stream_open__", streamInfo, endpoint), 
                      openStreams.set(channel, stream), stream;
                  },
                  onOpenStreamChannel: function(channel, callback) {
                      if (onOpenStreamCallbacks.has(channel)) throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");
                      onOpenStreamCallbacks.set(channel, callback), streamyEmitter.emit("did-change-stream-callbacks");
                  }
              };
          })(endpointRuntime);
          const createStoreImpl = createState => {
              let state;
              const listeners = new Set, setState = (partial, replace) => {
                  const nextState = "function" == typeof partial ? partial(state) : partial;
                  if (!Object.is(nextState, state)) {
                      const previousState = state;
                      state = (null != replace ? replace : "object" != typeof nextState) ? nextState : Object.assign({}, state, nextState), 
                      listeners.forEach((listener => listener(state, previousState)));
                  }
              }, getState = () => state, api = {
                  setState,
                  getState,
                  subscribe: listener => (listeners.add(listener), () => listeners.delete(listener)),
                  destroy: () => {
                      console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), 
                      listeners.clear();
                  }
              };
              return state = createState(setState, getState, api), api;
          }, createStore = createState => createState ? createStoreImpl(createState) : createStoreImpl;
          var with_selector = __webpack_require__("./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js");
          const {useSyncExternalStoreWithSelector} = with_selector;
          let didWarnAboutEqualityFn = !1;
          const createImpl = createState => {
              "function" != typeof createState && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
              const api = "function" == typeof createState ? createStore(createState) : createState, useBoundStore = (selector, equalityFn) => function(api, selector = api.getState, equalityFn) {
                  equalityFn && !didWarnAboutEqualityFn && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), 
                  didWarnAboutEqualityFn = !0);
                  const slice = useSyncExternalStoreWithSelector(api.subscribe, api.getState, api.getServerState || api.getState, selector, equalityFn);
                  return (0, react.useDebugValue)(slice), slice;
              }(api, selector, equalityFn);
              return Object.assign(useBoundStore, api), useBoundStore;
          }, create = createState => createState ? createImpl(createState) : createImpl;
          const debug_build_DEBUG_BUILD = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
          function isGlobalObj(obj) {
              return obj && obj.Math == Math ? obj : void 0;
          }
          const worldwide_GLOBAL_OBJ = "object" == typeof globalThis && isGlobalObj(globalThis) || "object" == typeof window && isGlobalObj(window) || "object" == typeof self && isGlobalObj(self) || "object" == typeof __webpack_require__.g && isGlobalObj(__webpack_require__.g) || function() {
              return this;
          }() || {};
          function getGlobalObject() {
              return worldwide_GLOBAL_OBJ;
          }
          function getGlobalSingleton(name, creator, obj) {
              const gbl = obj || worldwide_GLOBAL_OBJ, __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
              return __SENTRY__[name] || (__SENTRY__[name] = creator());
          }
          const CONSOLE_LEVELS = [ "debug", "info", "warn", "error", "log", "assert", "trace" ], originalConsoleMethods = {};
          function consoleSandbox(callback) {
              if (!("console" in worldwide_GLOBAL_OBJ)) return callback();
              const console = worldwide_GLOBAL_OBJ.console, wrappedFuncs = {}, wrappedLevels = Object.keys(originalConsoleMethods);
              wrappedLevels.forEach((level => {
                  const originalConsoleMethod = originalConsoleMethods[level];
                  wrappedFuncs[level] = console[level], console[level] = originalConsoleMethod;
              }));
              try {
                  return callback();
              } finally {
                  wrappedLevels.forEach((level => {
                      console[level] = wrappedFuncs[level];
                  }));
              }
          }
          const logger_logger = function() {
              let enabled = !1;
              const logger = {
                  enable: () => {
                      enabled = !0;
                  },
                  disable: () => {
                      enabled = !1;
                  },
                  isEnabled: () => enabled
              };
              return debug_build_DEBUG_BUILD ? CONSOLE_LEVELS.forEach((name => {
                  logger[name] = (...args) => {
                      enabled && consoleSandbox((() => {
                          worldwide_GLOBAL_OBJ.console[name](`Sentry Logger [${name}]:`, ...args);
                      }));
                  };
              })) : CONSOLE_LEVELS.forEach((name => {
                  logger[name] = () => {};
              })), logger;
          }(), objectToString = Object.prototype.toString;
          function isError(wat) {
              switch (objectToString.call(wat)) {
                case "[object Error]":
                case "[object Exception]":
                case "[object DOMException]":
                  return !0;

                default:
                  return isInstanceOf(wat, Error);
              }
          }
          function isBuiltin(wat, className) {
              return objectToString.call(wat) === `[object ${className}]`;
          }
          function isErrorEvent(wat) {
              return isBuiltin(wat, "ErrorEvent");
          }
          function isDOMError(wat) {
              return isBuiltin(wat, "DOMError");
          }
          function isString(wat) {
              return isBuiltin(wat, "String");
          }
          function isParameterizedString(wat) {
              return "object" == typeof wat && null !== wat && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
          }
          function is_isPrimitive(wat) {
              return null === wat || isParameterizedString(wat) || "object" != typeof wat && "function" != typeof wat;
          }
          function isPlainObject(wat) {
              return isBuiltin(wat, "Object");
          }
          function isEvent(wat) {
              return "undefined" != typeof Event && isInstanceOf(wat, Event);
          }
          function is_isThenable(wat) {
              return Boolean(wat && wat.then && "function" == typeof wat.then);
          }
          function isInstanceOf(wat, base) {
              try {
                  return wat instanceof base;
              } catch (_e) {
                  return !1;
              }
          }
          function isVueViewModel(wat) {
              return !("object" != typeof wat || null === wat || !wat.__isVue && !wat._isVue);
          }
          const browser_WINDOW = getGlobalObject(), DEFAULT_MAX_STRING_LENGTH = 80;
          function htmlTreeAsString(elem, options = {}) {
              if (!elem) return "<unknown>";
              try {
                  let currentElem = elem;
                  const MAX_TRAVERSE_HEIGHT = 5, out = [];
                  let height = 0, len = 0;
                  const separator = " > ", sepLength = separator.length;
                  let nextStr;
                  const keyAttrs = Array.isArray(options) ? options : options.keyAttrs, maxStringLength = !Array.isArray(options) && options.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
                  for (;currentElem && height++ < MAX_TRAVERSE_HEIGHT && (nextStr = _htmlElementAsString(currentElem, keyAttrs), 
                  !("html" === nextStr || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength)); ) out.push(nextStr), 
                  len += nextStr.length, currentElem = currentElem.parentNode;
                  return out.reverse().join(separator);
              } catch (_oO) {
                  return "<unknown>";
              }
          }
          function _htmlElementAsString(el, keyAttrs) {
              const elem = el, out = [];
              let className, classes, key, attr, i;
              if (!elem || !elem.tagName) return "";
              if (browser_WINDOW.HTMLElement && elem instanceof HTMLElement && elem.dataset && elem.dataset.sentryComponent) return elem.dataset.sentryComponent;
              out.push(elem.tagName.toLowerCase());
              const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr => elem.getAttribute(keyAttr))).map((keyAttr => [ keyAttr, elem.getAttribute(keyAttr) ])) : null;
              if (keyAttrPairs && keyAttrPairs.length) keyAttrPairs.forEach((keyAttrPair => {
                  out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
              })); else if (elem.id && out.push(`#${elem.id}`), className = elem.className, className && isString(className)) for (classes = className.split(/\s+/), 
              i = 0; i < classes.length; i++) out.push(`.${classes[i]}`);
              const allowedAttrs = [ "aria-label", "type", "name", "title", "alt" ];
              for (i = 0; i < allowedAttrs.length; i++) key = allowedAttrs[i], attr = elem.getAttribute(key), 
              attr && out.push(`[${key}="${attr}"]`);
              return out.join("");
          }
          function truncate(str, max = 0) {
              return "string" != typeof str || 0 === max || str.length <= max ? str : `${str.slice(0, max)}...`;
          }
          function safeJoin(input, delimiter) {
              if (!Array.isArray(input)) return "";
              const output = [];
              for (let i = 0; i < input.length; i++) {
                  const value = input[i];
                  try {
                      isVueViewModel(value) ? output.push("[VueViewModel]") : output.push(String(value));
                  } catch (e) {
                      output.push("[value cannot be serialized]");
                  }
              }
              return output.join(delimiter);
          }
          function isMatchingPattern(value, pattern, requireExactStringMatch = !1) {
              return !!isString(value) && (isBuiltin(pattern, "RegExp") ? pattern.test(value) : !!isString(pattern) && (requireExactStringMatch ? value === pattern : value.includes(pattern)));
          }
          function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = !1) {
              return patterns.some((pattern => isMatchingPattern(testString, pattern, requireExactStringMatch)));
          }
          function fill(source, name, replacementFactory) {
              if (!(name in source)) return;
              const original = source[name], wrapped = replacementFactory(original);
              "function" == typeof wrapped && markFunctionWrapped(wrapped, original), source[name] = wrapped;
          }
          function addNonEnumerableProperty(obj, name, value) {
              try {
                  Object.defineProperty(obj, name, {
                      value,
                      writable: !0,
                      configurable: !0
                  });
              } catch (o_O) {
                  debug_build_DEBUG_BUILD && logger_logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
              }
          }
          function markFunctionWrapped(wrapped, original) {
              try {
                  const proto = original.prototype || {};
                  wrapped.prototype = original.prototype = proto, addNonEnumerableProperty(wrapped, "__sentry_original__", original);
              } catch (o_O) {}
          }
          function getOriginalFunction(func) {
              return func.__sentry_original__;
          }
          function convertToPlainObject(value) {
              if (isError(value)) return {
                  message: value.message,
                  name: value.name,
                  stack: value.stack,
                  ...getOwnProperties(value)
              };
              if (isEvent(value)) {
                  const newObj = {
                      type: value.type,
                      target: serializeEventTarget(value.target),
                      currentTarget: serializeEventTarget(value.currentTarget),
                      ...getOwnProperties(value)
                  };
                  return "undefined" != typeof CustomEvent && isInstanceOf(value, CustomEvent) && (newObj.detail = value.detail), 
                  newObj;
              }
              return value;
          }
          function serializeEventTarget(target) {
              try {
                  return wat = target, "undefined" != typeof Element && isInstanceOf(wat, Element) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
              } catch (_oO) {
                  return "<unknown>";
              }
              var wat;
          }
          function getOwnProperties(obj) {
              if ("object" == typeof obj && null !== obj) {
                  const extractedProps = {};
                  for (const property in obj) Object.prototype.hasOwnProperty.call(obj, property) && (extractedProps[property] = obj[property]);
                  return extractedProps;
              }
              return {};
          }
          function object_dropUndefinedKeys(inputValue) {
              return _dropUndefinedKeys(inputValue, new Map);
          }
          function _dropUndefinedKeys(inputValue, memoizationMap) {
              if (function(input) {
                  if (!isPlainObject(input)) return !1;
                  try {
                      const name = Object.getPrototypeOf(input).constructor.name;
                      return !name || "Object" === name;
                  } catch (e) {
                      return !0;
                  }
              }(inputValue)) {
                  const memoVal = memoizationMap.get(inputValue);
                  if (void 0 !== memoVal) return memoVal;
                  const returnValue = {};
                  memoizationMap.set(inputValue, returnValue);
                  for (const key of Object.keys(inputValue)) void 0 !== inputValue[key] && (returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap));
                  return returnValue;
              }
              if (Array.isArray(inputValue)) {
                  const memoVal = memoizationMap.get(inputValue);
                  if (void 0 !== memoVal) return memoVal;
                  const returnValue = [];
                  return memoizationMap.set(inputValue, returnValue), inputValue.forEach((item => {
                      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
                  })), returnValue;
              }
              return inputValue;
          }
          function misc_uuid4() {
              const gbl = worldwide_GLOBAL_OBJ, crypto = gbl.crypto || gbl.msCrypto;
              let getRandomByte = () => 16 * Math.random();
              try {
                  if (crypto && crypto.randomUUID) return crypto.randomUUID().replace(/-/g, "");
                  crypto && crypto.getRandomValues && (getRandomByte = () => {
                      const typedArray = new Uint8Array(1);
                      return crypto.getRandomValues(typedArray), typedArray[0];
                  });
              } catch (_) {}
              return ([ 1e7 ] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (c => (c ^ (15 & getRandomByte()) >> c / 4).toString(16)));
          }
          function getFirstException(event) {
              return event.exception && event.exception.values ? event.exception.values[0] : void 0;
          }
          function getEventDescription(event) {
              const {message, event_id: eventId} = event;
              if (message) return message;
              const firstException = getFirstException(event);
              return firstException ? firstException.type && firstException.value ? `${firstException.type}: ${firstException.value}` : firstException.type || firstException.value || eventId || "<unknown>" : eventId || "<unknown>";
          }
          function addExceptionTypeValue(event, value, type) {
              const exception = event.exception = event.exception || {}, values = exception.values = exception.values || [], firstException = values[0] = values[0] || {};
              firstException.value || (firstException.value = value || ""), firstException.type || (firstException.type = type || "Error");
          }
          function addExceptionMechanism(event, newMechanism) {
              const firstException = getFirstException(event);
              if (!firstException) return;
              const currentMechanism = firstException.mechanism;
              if (firstException.mechanism = {
                  type: "generic",
                  handled: !0,
                  ...currentMechanism,
                  ...newMechanism
              }, newMechanism && "data" in newMechanism) {
                  const mergedData = {
                      ...currentMechanism && currentMechanism.data,
                      ...newMechanism.data
                  };
                  firstException.mechanism.data = mergedData;
              }
          }
          function checkOrSetAlreadyCaught(exception) {
              if (exception && exception.__sentry_captured__) return !0;
              try {
                  addNonEnumerableProperty(exception, "__sentry_captured__", !0);
              } catch (err) {}
              return !1;
          }
          const esm_debug_build_DEBUG_BUILD = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
          var States;
          function resolvedSyncPromise(value) {
              return new SyncPromise((resolve => {
                  resolve(value);
              }));
          }
          function rejectedSyncPromise(reason) {
              return new SyncPromise(((_, reject) => {
                  reject(reason);
              }));
          }
          !function(States) {
              States[States.PENDING = 0] = "PENDING";
              States[States.RESOLVED = 1] = "RESOLVED";
              States[States.REJECTED = 2] = "REJECTED";
          }(States || (States = {}));
          class SyncPromise {
              constructor(executor) {
                  SyncPromise.prototype.__init.call(this), SyncPromise.prototype.__init2.call(this), 
                  SyncPromise.prototype.__init3.call(this), SyncPromise.prototype.__init4.call(this), 
                  this._state = States.PENDING, this._handlers = [];
                  try {
                      executor(this._resolve, this._reject);
                  } catch (e) {
                      this._reject(e);
                  }
              }
              then(onfulfilled, onrejected) {
                  return new SyncPromise(((resolve, reject) => {
                      this._handlers.push([ !1, result => {
                          if (onfulfilled) try {
                              resolve(onfulfilled(result));
                          } catch (e) {
                              reject(e);
                          } else resolve(result);
                      }, reason => {
                          if (onrejected) try {
                              resolve(onrejected(reason));
                          } catch (e) {
                              reject(e);
                          } else reject(reason);
                      } ]), this._executeHandlers();
                  }));
              }
              catch(onrejected) {
                  return this.then((val => val), onrejected);
              }
              finally(onfinally) {
                  return new SyncPromise(((resolve, reject) => {
                      let val, isRejected;
                      return this.then((value => {
                          isRejected = !1, val = value, onfinally && onfinally();
                      }), (reason => {
                          isRejected = !0, val = reason, onfinally && onfinally();
                      })).then((() => {
                          isRejected ? reject(val) : resolve(val);
                      }));
                  }));
              }
              __init() {
                  this._resolve = value => {
                      this._setResult(States.RESOLVED, value);
                  };
              }
              __init2() {
                  this._reject = reason => {
                      this._setResult(States.REJECTED, reason);
                  };
              }
              __init3() {
                  this._setResult = (state, value) => {
                      this._state === States.PENDING && (is_isThenable(value) ? value.then(this._resolve, this._reject) : (this._state = state, 
                      this._value = value, this._executeHandlers()));
                  };
              }
              __init4() {
                  this._executeHandlers = () => {
                      if (this._state === States.PENDING) return;
                      const cachedHandlers = this._handlers.slice();
                      this._handlers = [], cachedHandlers.forEach((handler => {
                          handler[0] || (this._state === States.RESOLVED && handler[1](this._value), this._state === States.REJECTED && handler[2](this._value), 
                          handler[0] = !0);
                      }));
                  };
              }
          }
          function getGlobalEventProcessors() {
              return getGlobalSingleton("globalEventProcessors", (() => []));
          }
          function addGlobalEventProcessor(callback) {
              getGlobalEventProcessors().push(callback);
          }
          function notifyEventProcessors(processors, event, hint, index = 0) {
              return new SyncPromise(((resolve, reject) => {
                  const processor = processors[index];
                  if (null === event || "function" != typeof processor) resolve(event); else {
                      const result = processor({
                          ...event
                      }, hint);
                      esm_debug_build_DEBUG_BUILD && processor.id && null === result && logger_logger.log(`Event processor "${processor.id}" dropped event`), 
                      is_isThenable(result) ? result.then((final => notifyEventProcessors(processors, final, hint, index + 1).then(resolve))).then(null, reject) : notifyEventProcessors(processors, result, hint, index + 1).then(resolve).then(null, reject);
                  }
              }));
          }
          const ONE_SECOND_IN_MS = 1e3;
          function dateTimestampInSeconds() {
              return Date.now() / ONE_SECOND_IN_MS;
          }
          const time_timestampInSeconds = function() {
              const {performance} = worldwide_GLOBAL_OBJ;
              if (!performance || !performance.now) return dateTimestampInSeconds;
              const approxStartingTimeOrigin = Date.now() - performance.now(), timeOrigin = null == performance.timeOrigin ? approxStartingTimeOrigin : performance.timeOrigin;
              return () => (timeOrigin + performance.now()) / ONE_SECOND_IN_MS;
          }();
          let _browserPerformanceTimeOriginMode;
          (() => {
              const {performance} = worldwide_GLOBAL_OBJ;
              if (!performance || !performance.now) return void (_browserPerformanceTimeOriginMode = "none");
              const performanceNow = performance.now(), dateNow = Date.now(), timeOriginDelta = performance.timeOrigin ? Math.abs(performance.timeOrigin + performanceNow - dateNow) : 36e5, timeOriginIsReliable = timeOriginDelta < 36e5, navigationStart = performance.timing && performance.timing.navigationStart, navigationStartDelta = "number" == typeof navigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : 36e5;
              timeOriginIsReliable || navigationStartDelta < 36e5 ? timeOriginDelta <= navigationStartDelta ? (_browserPerformanceTimeOriginMode = "timeOrigin", 
              performance.timeOrigin) : _browserPerformanceTimeOriginMode = "navigationStart" : _browserPerformanceTimeOriginMode = "dateNow";
          })();
          const constants_DEFAULT_ENVIRONMENT = "production";
          function session_makeSession(context) {
              const startingTime = time_timestampInSeconds(), session = {
                  sid: misc_uuid4(),
                  init: !0,
                  timestamp: startingTime,
                  started: startingTime,
                  duration: 0,
                  status: "ok",
                  errors: 0,
                  ignoreDuration: !1,
                  toJSON: () => function(session) {
                      return object_dropUndefinedKeys({
                          sid: `${session.sid}`,
                          init: session.init,
                          started: new Date(1e3 * session.started).toISOString(),
                          timestamp: new Date(1e3 * session.timestamp).toISOString(),
                          status: session.status,
                          errors: session.errors,
                          did: "number" == typeof session.did || "string" == typeof session.did ? `${session.did}` : void 0,
                          duration: session.duration,
                          abnormal_mechanism: session.abnormal_mechanism,
                          attrs: {
                              release: session.release,
                              environment: session.environment,
                              ip_address: session.ipAddress,
                              user_agent: session.userAgent
                          }
                      });
                  }(session)
              };
              return context && session_updateSession(session, context), session;
          }
          function session_updateSession(session, context = {}) {
              if (context.user && (!session.ipAddress && context.user.ip_address && (session.ipAddress = context.user.ip_address), 
              session.did || context.did || (session.did = context.user.id || context.user.email || context.user.username)), 
              session.timestamp = context.timestamp || time_timestampInSeconds(), context.abnormal_mechanism && (session.abnormal_mechanism = context.abnormal_mechanism), 
              context.ignoreDuration && (session.ignoreDuration = context.ignoreDuration), context.sid && (session.sid = 32 === context.sid.length ? context.sid : misc_uuid4()), 
              void 0 !== context.init && (session.init = context.init), !session.did && context.did && (session.did = `${context.did}`), 
              "number" == typeof context.started && (session.started = context.started), session.ignoreDuration) session.duration = void 0; else if ("number" == typeof context.duration) session.duration = context.duration; else {
                  const duration = session.timestamp - session.started;
                  session.duration = duration >= 0 ? duration : 0;
              }
              context.release && (session.release = context.release), context.environment && (session.environment = context.environment), 
              !session.ipAddress && context.ipAddress && (session.ipAddress = context.ipAddress), 
              !session.userAgent && context.userAgent && (session.userAgent = context.userAgent), 
              "number" == typeof context.errors && (session.errors = context.errors), context.status && (session.status = context.status);
          }
          const STACKTRACE_FRAME_LIMIT = 50, WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/, STRIP_FRAME_REGEXP = /captureMessage|captureException/;
          function createStackParser(...parsers) {
              const sortedParsers = parsers.sort(((a, b) => a[0] - b[0])).map((p => p[1]));
              return (stack, skipFirst = 0) => {
                  const frames = [], lines = stack.split("\n");
                  for (let i = skipFirst; i < lines.length; i++) {
                      const line = lines[i];
                      if (line.length > 1024) continue;
                      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
                      if (!cleanedLine.match(/\S*Error: /)) {
                          for (const parser of sortedParsers) {
                              const frame = parser(cleanedLine);
                              if (frame) {
                                  frames.push(frame);
                                  break;
                              }
                          }
                          if (frames.length >= STACKTRACE_FRAME_LIMIT) break;
                      }
                  }
                  return function(stack) {
                      if (!stack.length) return [];
                      const localStack = Array.from(stack);
                      /sentryWrapped/.test(localStack[localStack.length - 1].function || "") && localStack.pop();
                      localStack.reverse(), STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "") && (localStack.pop(), 
                      STRIP_FRAME_REGEXP.test(localStack[localStack.length - 1].function || "") && localStack.pop());
                      return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame => ({
                          ...frame,
                          filename: frame.filename || localStack[localStack.length - 1].filename,
                          function: frame.function || "?"
                      })));
                  }(frames);
              };
          }
          const defaultFunctionName = "<anonymous>";
          function getFunctionName(fn) {
              try {
                  return fn && "function" == typeof fn && fn.name || defaultFunctionName;
              } catch (e) {
                  return defaultFunctionName;
              }
          }
          function normalize(input, depth = 100, maxProperties = 1 / 0) {
              try {
                  return visit("", input, depth, maxProperties);
              } catch (err) {
                  return {
                      ERROR: `**non-serializable** (${err})`
                  };
              }
          }
          function normalizeToSize(object, depth = 3, maxSize = 102400) {
              const normalized = normalize(object, depth);
              return value = normalized, function(value) {
                  return ~-encodeURI(value).split(/%..|./).length;
              }(JSON.stringify(value)) > maxSize ? normalizeToSize(object, depth - 1, maxSize) : normalized;
              var value;
          }
          function visit(key, value, depth = 1 / 0, maxProperties = 1 / 0, memo = function() {
              const hasWeakSet = "function" == typeof WeakSet, inner = hasWeakSet ? new WeakSet : [];
              return [ function(obj) {
                  if (hasWeakSet) return !!inner.has(obj) || (inner.add(obj), !1);
                  for (let i = 0; i < inner.length; i++) if (inner[i] === obj) return !0;
                  return inner.push(obj), !1;
              }, function(obj) {
                  if (hasWeakSet) inner.delete(obj); else for (let i = 0; i < inner.length; i++) if (inner[i] === obj) {
                      inner.splice(i, 1);
                      break;
                  }
              } ];
          }()) {
              const [memoize, unmemoize] = memo;
              if (null == value || [ "number", "boolean", "string" ].includes(typeof value) && ("number" != typeof (wat = value) || wat == wat)) return value;
              var wat;
              const stringified = function(key, value) {
                  try {
                      if ("domain" === key && value && "object" == typeof value && value._events) return "[Domain]";
                      if ("domainEmitter" === key) return "[DomainEmitter]";
                      if (void 0 !== __webpack_require__.g && value === __webpack_require__.g) return "[Global]";
                      if ("undefined" != typeof window && value === window) return "[Window]";
                      if ("undefined" != typeof document && value === document) return "[Document]";
                      if (isVueViewModel(value)) return "[VueViewModel]";
                      if (function(wat) {
                          return isPlainObject(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
                      }(value)) return "[SyntheticEvent]";
                      if ("number" == typeof value && value != value) return "[NaN]";
                      if ("function" == typeof value) return `[Function: ${getFunctionName(value)}]`;
                      if ("symbol" == typeof value) return `[${String(value)}]`;
                      if ("bigint" == typeof value) return `[BigInt: ${String(value)}]`;
                      const objName = function(value) {
                          const prototype = Object.getPrototypeOf(value);
                          return prototype ? prototype.constructor.name : "null prototype";
                      }(value);
                      return /^HTML(\w*)Element$/.test(objName) ? `[HTMLElement: ${objName}]` : `[object ${objName}]`;
                  } catch (err) {
                      return `**non-serializable** (${err})`;
                  }
              }(key, value);
              if (!stringified.startsWith("[object ")) return stringified;
              if (value.__sentry_skip_normalization__) return value;
              const remainingDepth = "number" == typeof value.__sentry_override_normalization_depth__ ? value.__sentry_override_normalization_depth__ : depth;
              if (0 === remainingDepth) return stringified.replace("object ", "");
              if (memoize(value)) return "[Circular ~]";
              const valueWithToJSON = value;
              if (valueWithToJSON && "function" == typeof valueWithToJSON.toJSON) try {
                  return visit("", valueWithToJSON.toJSON(), remainingDepth - 1, maxProperties, memo);
              } catch (err) {}
              const normalized = Array.isArray(value) ? [] : {};
              let numAdded = 0;
              const visitable = convertToPlainObject(value);
              for (const visitKey in visitable) {
                  if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) continue;
                  if (numAdded >= maxProperties) {
                      normalized[visitKey] = "[MaxProperties ~]";
                      break;
                  }
                  const visitValue = visitable[visitKey];
                  normalized[visitKey] = visit(visitKey, visitValue, remainingDepth - 1, maxProperties, memo), 
                  numAdded++;
              }
              return unmemoize(value), normalized;
          }
          const TRACE_FLAG_SAMPLED = 1;
          function spanToTraceContext(span) {
              const {spanId: span_id, traceId: trace_id} = span.spanContext(), {data, op, parent_span_id, status, tags, origin} = spanToJSON(span);
              return object_dropUndefinedKeys({
                  data,
                  op,
                  parent_span_id,
                  span_id,
                  status,
                  tags,
                  trace_id,
                  origin
              });
          }
          function spanToJSON(span) {
              return function(span) {
                  return "function" == typeof span.getSpanJSON;
              }(span) ? span.getSpanJSON() : "function" == typeof span.toJSON ? span.toJSON() : {};
          }
          function spanIsSampled(span) {
              const {traceFlags} = span.spanContext();
              return Boolean(traceFlags & TRACE_FLAG_SAMPLED);
          }
          function prepareEvent(options, event, hint, scope, client, isolationScope) {
              const {normalizeDepth = 3, normalizeMaxBreadth = 1e3} = options, prepared = {
                  ...event,
                  event_id: event.event_id || hint.event_id || misc_uuid4(),
                  timestamp: event.timestamp || dateTimestampInSeconds()
              }, integrations = hint.integrations || options.integrations.map((i => i.name));
              !function(event, options) {
                  const {environment, release, dist, maxValueLength = 250} = options;
                  "environment" in event || (event.environment = "environment" in options ? environment : constants_DEFAULT_ENVIRONMENT);
                  void 0 === event.release && void 0 !== release && (event.release = release);
                  void 0 === event.dist && void 0 !== dist && (event.dist = dist);
                  event.message && (event.message = truncate(event.message, maxValueLength));
                  const exception = event.exception && event.exception.values && event.exception.values[0];
                  exception && exception.value && (exception.value = truncate(exception.value, maxValueLength));
                  const request = event.request;
                  request && request.url && (request.url = truncate(request.url, maxValueLength));
              }(prepared, options), function(event, integrationNames) {
                  integrationNames.length > 0 && (event.sdk = event.sdk || {}, event.sdk.integrations = [ ...event.sdk.integrations || [], ...integrationNames ]);
              }(prepared, integrations), void 0 === event.type && function(event, stackParser) {
                  const debugIdMap = worldwide_GLOBAL_OBJ._sentryDebugIds;
                  if (!debugIdMap) return;
                  let debugIdStackFramesCache;
                  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(stackParser);
                  cachedDebugIdStackFrameCache ? debugIdStackFramesCache = cachedDebugIdStackFrameCache : (debugIdStackFramesCache = new Map, 
                  debugIdStackParserCache.set(stackParser, debugIdStackFramesCache));
                  const filenameDebugIdMap = Object.keys(debugIdMap).reduce(((acc, debugIdStackTrace) => {
                      let parsedStack;
                      const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);
                      cachedParsedStack ? parsedStack = cachedParsedStack : (parsedStack = stackParser(debugIdStackTrace), 
                      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack));
                      for (let i = parsedStack.length - 1; i >= 0; i--) {
                          const stackFrame = parsedStack[i];
                          if (stackFrame.filename) {
                              acc[stackFrame.filename] = debugIdMap[debugIdStackTrace];
                              break;
                          }
                      }
                      return acc;
                  }), {});
                  try {
                      event.exception.values.forEach((exception => {
                          exception.stacktrace.frames.forEach((frame => {
                              frame.filename && (frame.debug_id = filenameDebugIdMap[frame.filename]);
                          }));
                      }));
                  } catch (e) {}
              }(prepared, options.stackParser);
              const finalScope = function(scope, captureContext) {
                  if (!captureContext) return scope;
                  const finalScope = scope ? scope.clone() : new Scope;
                  return finalScope.update(captureContext), finalScope;
              }(scope, hint.captureContext);
              hint.mechanism && addExceptionMechanism(prepared, hint.mechanism);
              const clientEventProcessors = client && client.getEventProcessors ? client.getEventProcessors() : [], data = function() {
                  globalScope || (globalScope = new Scope);
                  return globalScope;
              }().getScopeData();
              if (isolationScope) {
                  mergeScopeData(data, isolationScope.getScopeData());
              }
              if (finalScope) {
                  mergeScopeData(data, finalScope.getScopeData());
              }
              const attachments = [ ...hint.attachments || [], ...data.attachments ];
              attachments.length && (hint.attachments = attachments), applyScopeDataToEvent(prepared, data);
              return notifyEventProcessors([ ...clientEventProcessors, ...getGlobalEventProcessors(), ...data.eventProcessors ], prepared, hint).then((evt => (evt && function(event) {
                  const filenameDebugIdMap = {};
                  try {
                      event.exception.values.forEach((exception => {
                          exception.stacktrace.frames.forEach((frame => {
                              frame.debug_id && (frame.abs_path ? filenameDebugIdMap[frame.abs_path] = frame.debug_id : frame.filename && (filenameDebugIdMap[frame.filename] = frame.debug_id), 
                              delete frame.debug_id);
                          }));
                      }));
                  } catch (e) {}
                  if (0 === Object.keys(filenameDebugIdMap).length) return;
                  event.debug_meta = event.debug_meta || {}, event.debug_meta.images = event.debug_meta.images || [];
                  const images = event.debug_meta.images;
                  Object.keys(filenameDebugIdMap).forEach((filename => {
                      images.push({
                          type: "sourcemap",
                          code_file: filename,
                          debug_id: filenameDebugIdMap[filename]
                      });
                  }));
              }(evt), "number" == typeof normalizeDepth && normalizeDepth > 0 ? function(event, depth, maxBreadth) {
                  if (!event) return null;
                  const normalized = {
                      ...event,
                      ...event.breadcrumbs && {
                          breadcrumbs: event.breadcrumbs.map((b => ({
                              ...b,
                              ...b.data && {
                                  data: normalize(b.data, depth, maxBreadth)
                              }
                          })))
                      },
                      ...event.user && {
                          user: normalize(event.user, depth, maxBreadth)
                      },
                      ...event.contexts && {
                          contexts: normalize(event.contexts, depth, maxBreadth)
                      },
                      ...event.extra && {
                          extra: normalize(event.extra, depth, maxBreadth)
                      }
                  };
                  event.contexts && event.contexts.trace && normalized.contexts && (normalized.contexts.trace = event.contexts.trace, 
                  event.contexts.trace.data && (normalized.contexts.trace.data = normalize(event.contexts.trace.data, depth, maxBreadth)));
                  event.spans && (normalized.spans = event.spans.map((span => {
                      const data = spanToJSON(span).data;
                      return data && (span.data = normalize(data, depth, maxBreadth)), span;
                  })));
                  return normalized;
              }(evt, normalizeDepth, normalizeMaxBreadth) : evt)));
          }
          const debugIdStackParserCache = new WeakMap;
          function parseEventHintOrCaptureContext(hint) {
              if (hint) return function(hint) {
                  return hint instanceof Scope || "function" == typeof hint;
              }(hint) || function(hint) {
                  return Object.keys(hint).some((key => captureContextKeys.includes(key)));
              }(hint) ? {
                  captureContext: hint
              } : hint;
          }
          const captureContextKeys = [ "user", "level", "extra", "contexts", "tags", "fingerprint", "requestSession", "propagationContext" ];
          function captureEvent(event, hint) {
              return hub_getCurrentHub().captureEvent(event, hint);
          }
          function addBreadcrumb(breadcrumb, hint) {
              hub_getCurrentHub().addBreadcrumb(breadcrumb, hint);
          }
          function withScope(...rest) {
              const hub = hub_getCurrentHub();
              if (2 === rest.length) {
                  const [scope, callback] = rest;
                  return scope ? hub.withScope((() => (hub.getStackTop().scope = scope, callback(scope)))) : hub.withScope(callback);
              }
              return hub.withScope(rest[0]);
          }
          function exports_getClient() {
              return hub_getCurrentHub().getClient();
          }
          function getCurrentScope() {
              return hub_getCurrentHub().getScope();
          }
          function getRootSpan(span) {
              return span.transaction;
          }
          function getDynamicSamplingContextFromClient(trace_id, client, scope) {
              const options = client.getOptions(), {publicKey: public_key} = client.getDsn() || {}, {segment: user_segment} = scope && scope.getUser() || {}, dsc = object_dropUndefinedKeys({
                  environment: options.environment || constants_DEFAULT_ENVIRONMENT,
                  release: options.release,
                  user_segment,
                  public_key,
                  trace_id
              });
              return client.emit && client.emit("createDsc", dsc), dsc;
          }
          function getDynamicSamplingContextFromSpan(span) {
              const client = exports_getClient();
              if (!client) return {};
              const dsc = getDynamicSamplingContextFromClient(spanToJSON(span).trace_id || "", client, getCurrentScope()), txn = getRootSpan(span);
              if (!txn) return dsc;
              const v7FrozenDsc = txn && txn._frozenDynamicSamplingContext;
              if (v7FrozenDsc) return v7FrozenDsc;
              const {sampleRate: maybeSampleRate, source} = txn.metadata;
              null != maybeSampleRate && (dsc.sample_rate = `${maybeSampleRate}`);
              const jsonSpan = spanToJSON(txn);
              return source && "url" !== source && (dsc.transaction = jsonSpan.description), dsc.sampled = String(spanIsSampled(txn)), 
              client.emit && client.emit("createDsc", dsc), dsc;
          }
          function applyScopeDataToEvent(event, data) {
              const {fingerprint, span, breadcrumbs, sdkProcessingMetadata} = data;
              !function(event, data) {
                  const {extra, tags, user, contexts, level, transactionName} = data, cleanedExtra = object_dropUndefinedKeys(extra);
                  cleanedExtra && Object.keys(cleanedExtra).length && (event.extra = {
                      ...cleanedExtra,
                      ...event.extra
                  });
                  const cleanedTags = object_dropUndefinedKeys(tags);
                  cleanedTags && Object.keys(cleanedTags).length && (event.tags = {
                      ...cleanedTags,
                      ...event.tags
                  });
                  const cleanedUser = object_dropUndefinedKeys(user);
                  cleanedUser && Object.keys(cleanedUser).length && (event.user = {
                      ...cleanedUser,
                      ...event.user
                  });
                  const cleanedContexts = object_dropUndefinedKeys(contexts);
                  cleanedContexts && Object.keys(cleanedContexts).length && (event.contexts = {
                      ...cleanedContexts,
                      ...event.contexts
                  });
                  level && (event.level = level);
                  transactionName && (event.transaction = transactionName);
              }(event, data), span && function(event, span) {
                  event.contexts = {
                      trace: spanToTraceContext(span),
                      ...event.contexts
                  };
                  const rootSpan = getRootSpan(span);
                  if (rootSpan) {
                      event.sdkProcessingMetadata = {
                          dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
                          ...event.sdkProcessingMetadata
                      };
                      const transactionName = spanToJSON(rootSpan).description;
                      transactionName && (event.tags = {
                          transaction: transactionName,
                          ...event.tags
                      });
                  }
              }(event, span), function(event, fingerprint) {
                  event.fingerprint = event.fingerprint ? function(maybeArray) {
                      return Array.isArray(maybeArray) ? maybeArray : [ maybeArray ];
                  }(event.fingerprint) : [], fingerprint && (event.fingerprint = event.fingerprint.concat(fingerprint));
                  event.fingerprint && !event.fingerprint.length && delete event.fingerprint;
              }(event, fingerprint), function(event, breadcrumbs) {
                  const mergedBreadcrumbs = [ ...event.breadcrumbs || [], ...breadcrumbs ];
                  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
              }(event, breadcrumbs), function(event, sdkProcessingMetadata) {
                  event.sdkProcessingMetadata = {
                      ...event.sdkProcessingMetadata,
                      ...sdkProcessingMetadata
                  };
              }(event, sdkProcessingMetadata);
          }
          function mergeScopeData(data, mergeData) {
              const {extra, tags, user, contexts, level, sdkProcessingMetadata, breadcrumbs, fingerprint, eventProcessors, attachments, propagationContext, transactionName, span} = mergeData;
              mergeAndOverwriteScopeData(data, "extra", extra), mergeAndOverwriteScopeData(data, "tags", tags), 
              mergeAndOverwriteScopeData(data, "user", user), mergeAndOverwriteScopeData(data, "contexts", contexts), 
              mergeAndOverwriteScopeData(data, "sdkProcessingMetadata", sdkProcessingMetadata), 
              level && (data.level = level), transactionName && (data.transactionName = transactionName), 
              span && (data.span = span), breadcrumbs.length && (data.breadcrumbs = [ ...data.breadcrumbs, ...breadcrumbs ]), 
              fingerprint.length && (data.fingerprint = [ ...data.fingerprint, ...fingerprint ]), 
              eventProcessors.length && (data.eventProcessors = [ ...data.eventProcessors, ...eventProcessors ]), 
              attachments.length && (data.attachments = [ ...data.attachments, ...attachments ]), 
              data.propagationContext = {
                  ...data.propagationContext,
                  ...propagationContext
              };
          }
          function mergeAndOverwriteScopeData(data, prop, mergeVal) {
              if (mergeVal && Object.keys(mergeVal).length) {
                  data[prop] = {
                      ...data[prop]
                  };
                  for (const key in mergeVal) Object.prototype.hasOwnProperty.call(mergeVal, key) && (data[prop][key] = mergeVal[key]);
              }
          }
          let globalScope;
          class Scope {
              constructor() {
                  this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], 
                  this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, 
                  this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = generatePropagationContext();
              }
              static clone(scope) {
                  return scope ? scope.clone() : new Scope;
              }
              clone() {
                  const newScope = new Scope;
                  return newScope._breadcrumbs = [ ...this._breadcrumbs ], newScope._tags = {
                      ...this._tags
                  }, newScope._extra = {
                      ...this._extra
                  }, newScope._contexts = {
                      ...this._contexts
                  }, newScope._user = this._user, newScope._level = this._level, newScope._span = this._span, 
                  newScope._session = this._session, newScope._transactionName = this._transactionName, 
                  newScope._fingerprint = this._fingerprint, newScope._eventProcessors = [ ...this._eventProcessors ], 
                  newScope._requestSession = this._requestSession, newScope._attachments = [ ...this._attachments ], 
                  newScope._sdkProcessingMetadata = {
                      ...this._sdkProcessingMetadata
                  }, newScope._propagationContext = {
                      ...this._propagationContext
                  }, newScope._client = this._client, newScope;
              }
              setClient(client) {
                  this._client = client;
              }
              getClient() {
                  return this._client;
              }
              addScopeListener(callback) {
                  this._scopeListeners.push(callback);
              }
              addEventProcessor(callback) {
                  return this._eventProcessors.push(callback), this;
              }
              setUser(user) {
                  return this._user = user || {
                      email: void 0,
                      id: void 0,
                      ip_address: void 0,
                      segment: void 0,
                      username: void 0
                  }, this._session && session_updateSession(this._session, {
                      user
                  }), this._notifyScopeListeners(), this;
              }
              getUser() {
                  return this._user;
              }
              getRequestSession() {
                  return this._requestSession;
              }
              setRequestSession(requestSession) {
                  return this._requestSession = requestSession, this;
              }
              setTags(tags) {
                  return this._tags = {
                      ...this._tags,
                      ...tags
                  }, this._notifyScopeListeners(), this;
              }
              setTag(key, value) {
                  return this._tags = {
                      ...this._tags,
                      [key]: value
                  }, this._notifyScopeListeners(), this;
              }
              setExtras(extras) {
                  return this._extra = {
                      ...this._extra,
                      ...extras
                  }, this._notifyScopeListeners(), this;
              }
              setExtra(key, extra) {
                  return this._extra = {
                      ...this._extra,
                      [key]: extra
                  }, this._notifyScopeListeners(), this;
              }
              setFingerprint(fingerprint) {
                  return this._fingerprint = fingerprint, this._notifyScopeListeners(), this;
              }
              setLevel(level) {
                  return this._level = level, this._notifyScopeListeners(), this;
              }
              setTransactionName(name) {
                  return this._transactionName = name, this._notifyScopeListeners(), this;
              }
              setContext(key, context) {
                  return null === context ? delete this._contexts[key] : this._contexts[key] = context, 
                  this._notifyScopeListeners(), this;
              }
              setSpan(span) {
                  return this._span = span, this._notifyScopeListeners(), this;
              }
              getSpan() {
                  return this._span;
              }
              getTransaction() {
                  const span = this._span;
                  return span && span.transaction;
              }
              setSession(session) {
                  return session ? this._session = session : delete this._session, this._notifyScopeListeners(), 
                  this;
              }
              getSession() {
                  return this._session;
              }
              update(captureContext) {
                  if (!captureContext) return this;
                  const scopeToMerge = "function" == typeof captureContext ? captureContext(this) : captureContext;
                  if (scopeToMerge instanceof Scope) {
                      const scopeData = scopeToMerge.getScopeData();
                      this._tags = {
                          ...this._tags,
                          ...scopeData.tags
                      }, this._extra = {
                          ...this._extra,
                          ...scopeData.extra
                      }, this._contexts = {
                          ...this._contexts,
                          ...scopeData.contexts
                      }, scopeData.user && Object.keys(scopeData.user).length && (this._user = scopeData.user), 
                      scopeData.level && (this._level = scopeData.level), scopeData.fingerprint.length && (this._fingerprint = scopeData.fingerprint), 
                      scopeToMerge.getRequestSession() && (this._requestSession = scopeToMerge.getRequestSession()), 
                      scopeData.propagationContext && (this._propagationContext = scopeData.propagationContext);
                  } else if (isPlainObject(scopeToMerge)) {
                      const scopeContext = captureContext;
                      this._tags = {
                          ...this._tags,
                          ...scopeContext.tags
                      }, this._extra = {
                          ...this._extra,
                          ...scopeContext.extra
                      }, this._contexts = {
                          ...this._contexts,
                          ...scopeContext.contexts
                      }, scopeContext.user && (this._user = scopeContext.user), scopeContext.level && (this._level = scopeContext.level), 
                      scopeContext.fingerprint && (this._fingerprint = scopeContext.fingerprint), scopeContext.requestSession && (this._requestSession = scopeContext.requestSession), 
                      scopeContext.propagationContext && (this._propagationContext = scopeContext.propagationContext);
                  }
                  return this;
              }
              clear() {
                  return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, 
                  this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, 
                  this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), 
                  this._attachments = [], this._propagationContext = generatePropagationContext(), 
                  this;
              }
              addBreadcrumb(breadcrumb, maxBreadcrumbs) {
                  const maxCrumbs = "number" == typeof maxBreadcrumbs ? maxBreadcrumbs : 100;
                  if (maxCrumbs <= 0) return this;
                  const mergedBreadcrumb = {
                      timestamp: dateTimestampInSeconds(),
                      ...breadcrumb
                  }, breadcrumbs = this._breadcrumbs;
                  return breadcrumbs.push(mergedBreadcrumb), this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs, 
                  this._notifyScopeListeners(), this;
              }
              getLastBreadcrumb() {
                  return this._breadcrumbs[this._breadcrumbs.length - 1];
              }
              clearBreadcrumbs() {
                  return this._breadcrumbs = [], this._notifyScopeListeners(), this;
              }
              addAttachment(attachment) {
                  return this._attachments.push(attachment), this;
              }
              getAttachments() {
                  return this.getScopeData().attachments;
              }
              clearAttachments() {
                  return this._attachments = [], this;
              }
              getScopeData() {
                  const {_breadcrumbs, _attachments, _contexts, _tags, _extra, _user, _level, _fingerprint, _eventProcessors, _propagationContext, _sdkProcessingMetadata, _transactionName, _span} = this;
                  return {
                      breadcrumbs: _breadcrumbs,
                      attachments: _attachments,
                      contexts: _contexts,
                      tags: _tags,
                      extra: _extra,
                      user: _user,
                      level: _level,
                      fingerprint: _fingerprint || [],
                      eventProcessors: _eventProcessors,
                      propagationContext: _propagationContext,
                      sdkProcessingMetadata: _sdkProcessingMetadata,
                      transactionName: _transactionName,
                      span: _span
                  };
              }
              applyToEvent(event, hint = {}, additionalEventProcessors = []) {
                  applyScopeDataToEvent(event, this.getScopeData());
                  return notifyEventProcessors([ ...additionalEventProcessors, ...getGlobalEventProcessors(), ...this._eventProcessors ], event, hint);
              }
              setSDKProcessingMetadata(newData) {
                  return this._sdkProcessingMetadata = {
                      ...this._sdkProcessingMetadata,
                      ...newData
                  }, this;
              }
              setPropagationContext(context) {
                  return this._propagationContext = context, this;
              }
              getPropagationContext() {
                  return this._propagationContext;
              }
              captureException(exception, hint) {
                  const eventId = hint && hint.event_id ? hint.event_id : misc_uuid4();
                  if (!this._client) return logger_logger.warn("No client configured on scope - will not capture exception!"), 
                  eventId;
                  const syntheticException = new Error("Sentry syntheticException");
                  return this._client.captureException(exception, {
                      originalException: exception,
                      syntheticException,
                      ...hint,
                      event_id: eventId
                  }, this), eventId;
              }
              captureMessage(message, level, hint) {
                  const eventId = hint && hint.event_id ? hint.event_id : misc_uuid4();
                  if (!this._client) return logger_logger.warn("No client configured on scope - will not capture message!"), 
                  eventId;
                  const syntheticException = new Error(message);
                  return this._client.captureMessage(message, level, {
                      originalException: message,
                      syntheticException,
                      ...hint,
                      event_id: eventId
                  }, this), eventId;
              }
              captureEvent(event, hint) {
                  const eventId = hint && hint.event_id ? hint.event_id : misc_uuid4();
                  return this._client ? (this._client.captureEvent(event, {
                      ...hint,
                      event_id: eventId
                  }, this), eventId) : (logger_logger.warn("No client configured on scope - will not capture event!"), 
                  eventId);
              }
              _notifyScopeListeners() {
                  this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((callback => {
                      callback(this);
                  })), this._notifyingListeners = !1);
              }
          }
          function generatePropagationContext() {
              return {
                  traceId: misc_uuid4(),
                  spanId: misc_uuid4().substring(16)
              };
          }
          const API_VERSION = parseFloat("7.112.2"), DEFAULT_BREADCRUMBS = 100;
          class Hub {
              constructor(client, scope, isolationScope, _version = API_VERSION) {
                  let assignedScope, assignedIsolationScope;
                  this._version = _version, scope ? assignedScope = scope : (assignedScope = new Scope, 
                  assignedScope.setClient(client)), isolationScope ? assignedIsolationScope = isolationScope : (assignedIsolationScope = new Scope, 
                  assignedIsolationScope.setClient(client)), this._stack = [ {
                      scope: assignedScope
                  } ], client && this.bindClient(client), this._isolationScope = assignedIsolationScope;
              }
              isOlderThan(version) {
                  return this._version < version;
              }
              bindClient(client) {
                  const top = this.getStackTop();
                  top.client = client, top.scope.setClient(client), client && client.setupIntegrations && client.setupIntegrations();
              }
              pushScope() {
                  const scope = this.getScope().clone();
                  return this.getStack().push({
                      client: this.getClient(),
                      scope
                  }), scope;
              }
              popScope() {
                  return !(this.getStack().length <= 1) && !!this.getStack().pop();
              }
              withScope(callback) {
                  const scope = this.pushScope();
                  let maybePromiseResult;
                  try {
                      maybePromiseResult = callback(scope);
                  } catch (e) {
                      throw this.popScope(), e;
                  }
                  return is_isThenable(maybePromiseResult) ? maybePromiseResult.then((res => (this.popScope(), 
                  res)), (e => {
                      throw this.popScope(), e;
                  })) : (this.popScope(), maybePromiseResult);
              }
              getClient() {
                  return this.getStackTop().client;
              }
              getScope() {
                  return this.getStackTop().scope;
              }
              getIsolationScope() {
                  return this._isolationScope;
              }
              getStack() {
                  return this._stack;
              }
              getStackTop() {
                  return this._stack[this._stack.length - 1];
              }
              captureException(exception, hint) {
                  const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : misc_uuid4(), syntheticException = new Error("Sentry syntheticException");
                  return this.getScope().captureException(exception, {
                      originalException: exception,
                      syntheticException,
                      ...hint,
                      event_id: eventId
                  }), eventId;
              }
              captureMessage(message, level, hint) {
                  const eventId = this._lastEventId = hint && hint.event_id ? hint.event_id : misc_uuid4(), syntheticException = new Error(message);
                  return this.getScope().captureMessage(message, level, {
                      originalException: message,
                      syntheticException,
                      ...hint,
                      event_id: eventId
                  }), eventId;
              }
              captureEvent(event, hint) {
                  const eventId = hint && hint.event_id ? hint.event_id : misc_uuid4();
                  return event.type || (this._lastEventId = eventId), this.getScope().captureEvent(event, {
                      ...hint,
                      event_id: eventId
                  }), eventId;
              }
              lastEventId() {
                  return this._lastEventId;
              }
              addBreadcrumb(breadcrumb, hint) {
                  const {scope, client} = this.getStackTop();
                  if (!client) return;
                  const {beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS} = client.getOptions && client.getOptions() || {};
                  if (maxBreadcrumbs <= 0) return;
                  const mergedBreadcrumb = {
                      timestamp: dateTimestampInSeconds(),
                      ...breadcrumb
                  }, finalBreadcrumb = beforeBreadcrumb ? consoleSandbox((() => beforeBreadcrumb(mergedBreadcrumb, hint))) : mergedBreadcrumb;
                  null !== finalBreadcrumb && (client.emit && client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint), 
                  scope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs));
              }
              setUser(user) {
                  this.getScope().setUser(user), this.getIsolationScope().setUser(user);
              }
              setTags(tags) {
                  this.getScope().setTags(tags), this.getIsolationScope().setTags(tags);
              }
              setExtras(extras) {
                  this.getScope().setExtras(extras), this.getIsolationScope().setExtras(extras);
              }
              setTag(key, value) {
                  this.getScope().setTag(key, value), this.getIsolationScope().setTag(key, value);
              }
              setExtra(key, extra) {
                  this.getScope().setExtra(key, extra), this.getIsolationScope().setExtra(key, extra);
              }
              setContext(name, context) {
                  this.getScope().setContext(name, context), this.getIsolationScope().setContext(name, context);
              }
              configureScope(callback) {
                  const {scope, client} = this.getStackTop();
                  client && callback(scope);
              }
              run(callback) {
                  const oldHub = makeMain(this);
                  try {
                      callback(this);
                  } finally {
                      makeMain(oldHub);
                  }
              }
              getIntegration(integration) {
                  const client = this.getClient();
                  if (!client) return null;
                  try {
                      return client.getIntegration(integration);
                  } catch (_oO) {
                      return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Cannot retrieve integration ${integration.id} from the current Hub`), 
                      null;
                  }
              }
              startTransaction(context, customSamplingContext) {
                  const result = this._callExtensionMethod("startTransaction", context, customSamplingContext);
                  if (esm_debug_build_DEBUG_BUILD && !result) {
                      this.getClient() ? logger_logger.warn("Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n") : logger_logger.warn("Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'");
                  }
                  return result;
              }
              traceHeaders() {
                  return this._callExtensionMethod("traceHeaders");
              }
              captureSession(endSession = !1) {
                  if (endSession) return this.endSession();
                  this._sendSessionUpdate();
              }
              endSession() {
                  const scope = this.getStackTop().scope, session = scope.getSession();
                  session && function(session, status) {
                      let context = {};
                      status ? context = {
                          status
                      } : "ok" === session.status && (context = {
                          status: "exited"
                      }), session_updateSession(session, context);
                  }(session), this._sendSessionUpdate(), scope.setSession();
              }
              startSession(context) {
                  const {scope, client} = this.getStackTop(), {release, environment = constants_DEFAULT_ENVIRONMENT} = client && client.getOptions() || {}, {userAgent} = worldwide_GLOBAL_OBJ.navigator || {}, session = session_makeSession({
                      release,
                      environment,
                      user: scope.getUser(),
                      ...userAgent && {
                          userAgent
                      },
                      ...context
                  }), currentSession = scope.getSession && scope.getSession();
                  return currentSession && "ok" === currentSession.status && session_updateSession(currentSession, {
                      status: "exited"
                  }), this.endSession(), scope.setSession(session), session;
              }
              shouldSendDefaultPii() {
                  const client = this.getClient(), options = client && client.getOptions();
                  return Boolean(options && options.sendDefaultPii);
              }
              _sendSessionUpdate() {
                  const {scope, client} = this.getStackTop(), session = scope.getSession();
                  session && client && client.captureSession && client.captureSession(session);
              }
              _callExtensionMethod(method, ...args) {
                  const sentry = getMainCarrier().__SENTRY__;
                  if (sentry && sentry.extensions && "function" == typeof sentry.extensions[method]) return sentry.extensions[method].apply(this, args);
                  esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Extension method ${method} couldn't be found, doing nothing.`);
              }
          }
          function getMainCarrier() {
              return worldwide_GLOBAL_OBJ.__SENTRY__ = worldwide_GLOBAL_OBJ.__SENTRY__ || {
                  extensions: {},
                  hub: void 0
              }, worldwide_GLOBAL_OBJ;
          }
          function makeMain(hub) {
              const registry = getMainCarrier(), oldHub = getHubFromCarrier(registry);
              return setHubOnCarrier(registry, hub), oldHub;
          }
          function hub_getCurrentHub() {
              const registry = getMainCarrier();
              if (registry.__SENTRY__ && registry.__SENTRY__.acs) {
                  const hub = registry.__SENTRY__.acs.getCurrentHub();
                  if (hub) return hub;
              }
              return getGlobalHub(registry);
          }
          function getGlobalHub(registry = getMainCarrier()) {
              return hasHubOnCarrier(registry) && !getHubFromCarrier(registry).isOlderThan(API_VERSION) || setHubOnCarrier(registry, new Hub), 
              getHubFromCarrier(registry);
          }
          function hasHubOnCarrier(carrier) {
              return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
          }
          function getHubFromCarrier(carrier) {
              return getGlobalSingleton("hub", (() => new Hub), carrier);
          }
          function setHubOnCarrier(carrier, hub) {
              if (!carrier) return !1;
              return (carrier.__SENTRY__ = carrier.__SENTRY__ || {}).hub = hub, !0;
          }
          const installedIntegrations = [];
          function afterSetupIntegrations(client, integrations) {
              for (const integration of integrations) integration && integration.afterAllSetup && integration.afterAllSetup(client);
          }
          function setupIntegration(client, integration, integrationIndex) {
              if (integrationIndex[integration.name]) esm_debug_build_DEBUG_BUILD && logger_logger.log(`Integration skipped because it was already installed: ${integration.name}`); else {
                  if (integrationIndex[integration.name] = integration, -1 === installedIntegrations.indexOf(integration.name) && (integration.setupOnce(addGlobalEventProcessor, hub_getCurrentHub), 
                  installedIntegrations.push(integration.name)), integration.setup && "function" == typeof integration.setup && integration.setup(client), 
                  client.on && "function" == typeof integration.preprocessEvent) {
                      const callback = integration.preprocessEvent.bind(integration);
                      client.on("preprocessEvent", ((event, hint) => callback(event, hint, client)));
                  }
                  if (client.addEventProcessor && "function" == typeof integration.processEvent) {
                      const callback = integration.processEvent.bind(integration), processor = Object.assign(((event, hint) => callback(event, hint, client)), {
                          id: integration.name
                      });
                      client.addEventProcessor(processor);
                  }
                  esm_debug_build_DEBUG_BUILD && logger_logger.log(`Integration installed: ${integration.name}`);
              }
          }
          function convertIntegrationFnToClass(name, fn) {
              return Object.assign((function(...args) {
                  return fn(...args);
              }), {
                  id: name
              });
          }
          const DEFAULT_IGNORE_ERRORS = [ /^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/ ], DEFAULT_IGNORE_TRANSACTIONS = [ /^.*\/healthcheck$/, /^.*\/healthy$/, /^.*\/live$/, /^.*\/ready$/, /^.*\/heartbeat$/, /^.*\/health$/, /^.*\/healthz$/ ], inboundFiltersIntegration = (options = {}) => ({
              name: "InboundFilters",
              setupOnce() {},
              processEvent(event, _hint, client) {
                  const clientOptions = client.getOptions(), mergedOptions = function(internalOptions = {}, clientOptions = {}) {
                      return {
                          allowUrls: [ ...internalOptions.allowUrls || [], ...clientOptions.allowUrls || [] ],
                          denyUrls: [ ...internalOptions.denyUrls || [], ...clientOptions.denyUrls || [] ],
                          ignoreErrors: [ ...internalOptions.ignoreErrors || [], ...clientOptions.ignoreErrors || [], ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS ],
                          ignoreTransactions: [ ...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || [], ...internalOptions.disableTransactionDefaults ? [] : DEFAULT_IGNORE_TRANSACTIONS ],
                          ignoreInternal: void 0 === internalOptions.ignoreInternal || internalOptions.ignoreInternal
                      };
                  }(options, clientOptions);
                  return function(event, options) {
                      if (options.ignoreInternal && function(event) {
                          try {
                              return "SentryError" === event.exception.values[0].type;
                          } catch (e) {}
                          return !1;
                      }(event)) return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Event dropped due to being internal Sentry Error.\nEvent: ${getEventDescription(event)}`), 
                      !0;
                      if (function(event, ignoreErrors) {
                          if (event.type || !ignoreErrors || !ignoreErrors.length) return !1;
                          return function(event) {
                              const possibleMessages = [];
                              event.message && possibleMessages.push(event.message);
                              let lastException;
                              try {
                                  lastException = event.exception.values[event.exception.values.length - 1];
                              } catch (e) {}
                              lastException && lastException.value && (possibleMessages.push(lastException.value), 
                              lastException.type && possibleMessages.push(`${lastException.type}: ${lastException.value}`));
                              esm_debug_build_DEBUG_BUILD && 0 === possibleMessages.length && logger_logger.error(`Could not extract message for event ${getEventDescription(event)}`);
                              return possibleMessages;
                          }(event).some((message => stringMatchesSomePattern(message, ignoreErrors)));
                      }(event, options.ignoreErrors)) return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${getEventDescription(event)}`), 
                      !0;
                      if (function(event, ignoreTransactions) {
                          if ("transaction" !== event.type || !ignoreTransactions || !ignoreTransactions.length) return !1;
                          const name = event.transaction;
                          return !!name && stringMatchesSomePattern(name, ignoreTransactions);
                      }(event, options.ignoreTransactions)) return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${getEventDescription(event)}`), 
                      !0;
                      if (function(event, denyUrls) {
                          if (!denyUrls || !denyUrls.length) return !1;
                          const url = _getEventFilterUrl(event);
                          return !!url && stringMatchesSomePattern(url, denyUrls);
                      }(event, options.denyUrls)) return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${getEventDescription(event)}.\nUrl: ${_getEventFilterUrl(event)}`), 
                      !0;
                      if (!function(event, allowUrls) {
                          if (!allowUrls || !allowUrls.length) return !0;
                          const url = _getEventFilterUrl(event);
                          return !url || stringMatchesSomePattern(url, allowUrls);
                      }(event, options.allowUrls)) return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${getEventDescription(event)}.\nUrl: ${_getEventFilterUrl(event)}`), 
                      !0;
                      return !1;
                  }(event, mergedOptions) ? null : event;
              }
          });
          convertIntegrationFnToClass("InboundFilters", inboundFiltersIntegration);
          function _getEventFilterUrl(event) {
              try {
                  let frames;
                  try {
                      frames = event.exception.values[0].stacktrace.frames;
                  } catch (e) {}
                  return frames ? function(frames = []) {
                      for (let i = frames.length - 1; i >= 0; i--) {
                          const frame = frames[i];
                          if (frame && "<anonymous>" !== frame.filename && "[native code]" !== frame.filename) return frame.filename || null;
                      }
                      return null;
                  }(frames) : null;
              } catch (oO) {
                  return esm_debug_build_DEBUG_BUILD && logger_logger.error(`Cannot extract url for event ${getEventDescription(event)}`), 
                  null;
              }
          }
          let originalFunctionToString;
          const SETUP_CLIENTS = new WeakMap, functionToStringIntegration = () => ({
              name: "FunctionToString",
              setupOnce() {
                  originalFunctionToString = Function.prototype.toString;
                  try {
                      Function.prototype.toString = function(...args) {
                          const originalFunction = getOriginalFunction(this), context = SETUP_CLIENTS.has(exports_getClient()) && void 0 !== originalFunction ? originalFunction : this;
                          return originalFunctionToString.apply(context, args);
                      };
                  } catch (e) {}
              },
              setup(client) {
                  SETUP_CLIENTS.set(client, !0);
              }
          }), handlers = (convertIntegrationFnToClass("FunctionToString", functionToStringIntegration), 
          {}), instrumented = {};
          function addHandler(type, handler) {
              handlers[type] = handlers[type] || [], handlers[type].push(handler);
          }
          function maybeInstrument(type, instrumentFn) {
              instrumented[type] || (instrumentFn(), instrumented[type] = !0);
          }
          function triggerHandlers(type, data) {
              const typeHandlers = type && handlers[type];
              if (typeHandlers) for (const handler of typeHandlers) try {
                  handler(data);
              } catch (e) {
                  debug_build_DEBUG_BUILD && logger_logger.error(`Error while triggering instrumentation handler.\nType: ${type}\nName: ${getFunctionName(handler)}\nError:`, e);
              }
          }
          function instrumentConsole() {
              "console" in worldwide_GLOBAL_OBJ && CONSOLE_LEVELS.forEach((function(level) {
                  level in worldwide_GLOBAL_OBJ.console && fill(worldwide_GLOBAL_OBJ.console, level, (function(originalConsoleMethod) {
                      return originalConsoleMethods[level] = originalConsoleMethod, function(...args) {
                          triggerHandlers("console", {
                              args,
                              level
                          });
                          const log = originalConsoleMethods[level];
                          log && log.apply(worldwide_GLOBAL_OBJ.console, args);
                      };
                  }));
              }));
          }
          const dom_WINDOW = worldwide_GLOBAL_OBJ, DEBOUNCE_DURATION = 1e3;
          let debounceTimerID, lastCapturedEventType, lastCapturedEventTargetId;
          function instrumentDOM() {
              if (!dom_WINDOW.document) return;
              const triggerDOMHandler = triggerHandlers.bind(null, "dom"), globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, !0);
              dom_WINDOW.document.addEventListener("click", globalDOMEventHandler, !1), dom_WINDOW.document.addEventListener("keypress", globalDOMEventHandler, !1), 
              [ "EventTarget", "Node" ].forEach((target => {
                  const proto = dom_WINDOW[target] && dom_WINDOW[target].prototype;
                  proto && proto.hasOwnProperty && proto.hasOwnProperty("addEventListener") && (fill(proto, "addEventListener", (function(originalAddEventListener) {
                      return function(type, listener, options) {
                          if ("click" === type || "keypress" == type) try {
                              const el = this, handlers = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {}, handlerForType = handlers[type] = handlers[type] || {
                                  refCount: 0
                              };
                              if (!handlerForType.handler) {
                                  const handler = makeDOMEventHandler(triggerDOMHandler);
                                  handlerForType.handler = handler, originalAddEventListener.call(this, type, handler, options);
                              }
                              handlerForType.refCount++;
                          } catch (e) {}
                          return originalAddEventListener.call(this, type, listener, options);
                      };
                  })), fill(proto, "removeEventListener", (function(originalRemoveEventListener) {
                      return function(type, listener, options) {
                          if ("click" === type || "keypress" == type) try {
                              const el = this, handlers = el.__sentry_instrumentation_handlers__ || {}, handlerForType = handlers[type];
                              handlerForType && (handlerForType.refCount--, handlerForType.refCount <= 0 && (originalRemoveEventListener.call(this, type, handlerForType.handler, options), 
                              handlerForType.handler = void 0, delete handlers[type]), 0 === Object.keys(handlers).length && delete el.__sentry_instrumentation_handlers__);
                          } catch (e) {}
                          return originalRemoveEventListener.call(this, type, listener, options);
                      };
                  })));
              }));
          }
          function makeDOMEventHandler(handler, globalListener = !1) {
              return event => {
                  if (!event || event._sentryCaptured) return;
                  const target = function(event) {
                      try {
                          return event.target;
                      } catch (e) {
                          return null;
                      }
                  }(event);
                  if (function(eventType, target) {
                      return "keypress" === eventType && (!target || !target.tagName || "INPUT" !== target.tagName && "TEXTAREA" !== target.tagName && !target.isContentEditable);
                  }(event.type, target)) return;
                  addNonEnumerableProperty(event, "_sentryCaptured", !0), target && !target._sentryId && addNonEnumerableProperty(target, "_sentryId", misc_uuid4());
                  const name = "keypress" === event.type ? "input" : event.type;
                  if (!function(event) {
                      if (event.type !== lastCapturedEventType) return !1;
                      try {
                          if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) return !1;
                      } catch (e) {}
                      return !0;
                  }(event)) {
                      handler({
                          event,
                          name,
                          global: globalListener
                      }), lastCapturedEventType = event.type, lastCapturedEventTargetId = target ? target._sentryId : void 0;
                  }
                  clearTimeout(debounceTimerID), debounceTimerID = dom_WINDOW.setTimeout((() => {
                      lastCapturedEventTargetId = void 0, lastCapturedEventType = void 0;
                  }), DEBOUNCE_DURATION);
              };
          }
          const xhr_WINDOW = worldwide_GLOBAL_OBJ, SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
          function instrumentXHR() {
              if (!xhr_WINDOW.XMLHttpRequest) return;
              const xhrproto = XMLHttpRequest.prototype;
              fill(xhrproto, "open", (function(originalOpen) {
                  return function(...args) {
                      const startTimestamp = Date.now(), method = isString(args[0]) ? args[0].toUpperCase() : void 0, url = function(url) {
                          if (isString(url)) return url;
                          try {
                              return url.toString();
                          } catch (e2) {}
                          return;
                      }(args[1]);
                      if (!method || !url) return originalOpen.apply(this, args);
                      this[SENTRY_XHR_DATA_KEY] = {
                          method,
                          url,
                          request_headers: {}
                      }, "POST" === method && url.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
                      const onreadystatechangeHandler = () => {
                          const xhrInfo = this[SENTRY_XHR_DATA_KEY];
                          if (xhrInfo && 4 === this.readyState) {
                              try {
                                  xhrInfo.status_code = this.status;
                              } catch (e) {}
                              triggerHandlers("xhr", {
                                  args: [ method, url ],
                                  endTimestamp: Date.now(),
                                  startTimestamp,
                                  xhr: this
                              });
                          }
                      };
                      return "onreadystatechange" in this && "function" == typeof this.onreadystatechange ? fill(this, "onreadystatechange", (function(original) {
                          return function(...readyStateArgs) {
                              return onreadystatechangeHandler(), original.apply(this, readyStateArgs);
                          };
                      })) : this.addEventListener("readystatechange", onreadystatechangeHandler), fill(this, "setRequestHeader", (function(original) {
                          return function(...setRequestHeaderArgs) {
                              const [header, value] = setRequestHeaderArgs, xhrInfo = this[SENTRY_XHR_DATA_KEY];
                              return xhrInfo && isString(header) && isString(value) && (xhrInfo.request_headers[header.toLowerCase()] = value), 
                              original.apply(this, setRequestHeaderArgs);
                          };
                      })), originalOpen.apply(this, args);
                  };
              })), fill(xhrproto, "send", (function(originalSend) {
                  return function(...args) {
                      const sentryXhrData = this[SENTRY_XHR_DATA_KEY];
                      if (!sentryXhrData) return originalSend.apply(this, args);
                      void 0 !== args[0] && (sentryXhrData.body = args[0]);
                      return triggerHandlers("xhr", {
                          args: [ sentryXhrData.method, sentryXhrData.url ],
                          startTimestamp: Date.now(),
                          xhr: this
                      }), originalSend.apply(this, args);
                  };
              }));
          }
          const supports_WINDOW = getGlobalObject();
          function supports_supportsFetch() {
              if (!("fetch" in supports_WINDOW)) return !1;
              try {
                  return new Headers, new Request("http://www.example.com"), new Response, !0;
              } catch (e) {
                  return !1;
              }
          }
          function isNativeFetch(func) {
              return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
          }
          function instrumentFetch() {
              (function() {
                  if ("string" == typeof EdgeRuntime) return !0;
                  if (!supports_supportsFetch()) return !1;
                  if (isNativeFetch(supports_WINDOW.fetch)) return !0;
                  let result = !1;
                  const doc = supports_WINDOW.document;
                  if (doc && "function" == typeof doc.createElement) try {
                      const sandbox = doc.createElement("iframe");
                      sandbox.hidden = !0, doc.head.appendChild(sandbox), sandbox.contentWindow && sandbox.contentWindow.fetch && (result = isNativeFetch(sandbox.contentWindow.fetch)), 
                      doc.head.removeChild(sandbox);
                  } catch (err) {
                      debug_build_DEBUG_BUILD && logger_logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
                  }
                  return result;
              })() && fill(worldwide_GLOBAL_OBJ, "fetch", (function(originalFetch) {
                  return function(...args) {
                      const {method, url} = function(fetchArgs) {
                          if (0 === fetchArgs.length) return {
                              method: "GET",
                              url: ""
                          };
                          if (2 === fetchArgs.length) {
                              const [url, options] = fetchArgs;
                              return {
                                  url: getUrlFromResource(url),
                                  method: hasProp(options, "method") ? String(options.method).toUpperCase() : "GET"
                              };
                          }
                          const arg = fetchArgs[0];
                          return {
                              url: getUrlFromResource(arg),
                              method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
                          };
                      }(args), handlerData = {
                          args,
                          fetchData: {
                              method,
                              url
                          },
                          startTimestamp: Date.now()
                      };
                      return triggerHandlers("fetch", {
                          ...handlerData
                      }), originalFetch.apply(worldwide_GLOBAL_OBJ, args).then((response => (triggerHandlers("fetch", {
                          ...handlerData,
                          endTimestamp: Date.now(),
                          response
                      }), response)), (error => {
                          throw triggerHandlers("fetch", {
                              ...handlerData,
                              endTimestamp: Date.now(),
                              error
                          }), error;
                      }));
                  };
              }));
          }
          function hasProp(obj, prop) {
              return !!obj && "object" == typeof obj && !!obj[prop];
          }
          function getUrlFromResource(resource) {
              return "string" == typeof resource ? resource : resource ? hasProp(resource, "url") ? resource.url : resource.toString ? resource.toString() : "" : "";
          }
          const supportsHistory_WINDOW = getGlobalObject();
          const history_WINDOW = worldwide_GLOBAL_OBJ;
          let lastHref;
          function instrumentHistory() {
              if (!function() {
                  const chromeVar = supportsHistory_WINDOW.chrome, isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime, hasHistoryApi = "history" in supportsHistory_WINDOW && !!supportsHistory_WINDOW.history.pushState && !!supportsHistory_WINDOW.history.replaceState;
                  return !isChromePackagedApp && hasHistoryApi;
              }()) return;
              const oldOnPopState = history_WINDOW.onpopstate;
              function historyReplacementFunction(originalHistoryFunction) {
                  return function(...args) {
                      const url = args.length > 2 ? args[2] : void 0;
                      if (url) {
                          const from = lastHref, to = String(url);
                          lastHref = to;
                          triggerHandlers("history", {
                              from,
                              to
                          });
                      }
                      return originalHistoryFunction.apply(this, args);
                  };
              }
              history_WINDOW.onpopstate = function(...args) {
                  const to = history_WINDOW.location.href, from = lastHref;
                  lastHref = to;
                  if (triggerHandlers("history", {
                      from,
                      to
                  }), oldOnPopState) try {
                      return oldOnPopState.apply(this, args);
                  } catch (_oO) {}
              }, fill(history_WINDOW.history, "pushState", historyReplacementFunction), fill(history_WINDOW.history, "replaceState", historyReplacementFunction);
          }
          const validSeverityLevels = [ "fatal", "error", "warning", "log", "info", "debug" ];
          function severityLevelFromString(level) {
              return "warn" === level ? "warning" : validSeverityLevels.includes(level) ? level : "log";
          }
          function url_parseUrl(url) {
              if (!url) return {};
              const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
              if (!match) return {};
              const query = match[6] || "", fragment = match[8] || "";
              return {
                  host: match[4],
                  path: match[5],
                  protocol: match[2],
                  search: query,
                  hash: fragment,
                  relative: match[5] + query + fragment
              };
          }
          const browser_esm_debug_build_DEBUG_BUILD = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__, helpers_WINDOW = worldwide_GLOBAL_OBJ;
          let ignoreOnError = 0;
          function shouldIgnoreOnError() {
              return ignoreOnError > 0;
          }
          function wrap(fn, options = {}, before) {
              if ("function" != typeof fn) return fn;
              try {
                  const wrapper = fn.__sentry_wrapped__;
                  if (wrapper) return wrapper;
                  if (getOriginalFunction(fn)) return fn;
              } catch (e) {
                  return fn;
              }
              const sentryWrapped = function() {
                  const args = Array.prototype.slice.call(arguments);
                  try {
                      before && "function" == typeof before && before.apply(this, arguments);
                      const wrappedArguments = args.map((arg => wrap(arg, options)));
                      return fn.apply(this, wrappedArguments);
                  } catch (ex) {
                      throw ignoreOnError++, setTimeout((() => {
                          ignoreOnError--;
                      })), withScope((scope => {
                          var exception, hint;
                          scope.addEventProcessor((event => (options.mechanism && (addExceptionTypeValue(event, void 0, void 0), 
                          addExceptionMechanism(event, options.mechanism)), event.extra = {
                              ...event.extra,
                              arguments: args
                          }, event))), exception = ex, hub_getCurrentHub().captureException(exception, parseEventHintOrCaptureContext(hint));
                      })), ex;
                  }
              };
              try {
                  for (const property in fn) Object.prototype.hasOwnProperty.call(fn, property) && (sentryWrapped[property] = fn[property]);
              } catch (_oO) {}
              markFunctionWrapped(sentryWrapped, fn), addNonEnumerableProperty(fn, "__sentry_wrapped__", sentryWrapped);
              try {
                  Object.getOwnPropertyDescriptor(sentryWrapped, "name").configurable && Object.defineProperty(sentryWrapped, "name", {
                      get: () => fn.name
                  });
              } catch (_oO) {}
              return sentryWrapped;
          }
          const breadcrumbsIntegration = (options = {}) => {
              const _options = {
                  console: !0,
                  dom: !0,
                  fetch: !0,
                  history: !0,
                  sentry: !0,
                  xhr: !0,
                  ...options
              };
              return {
                  name: "Breadcrumbs",
                  setupOnce() {},
                  setup(client) {
                      _options.console && function(handler) {
                          addHandler("console", handler), maybeInstrument("console", instrumentConsole);
                      }(function(client) {
                          return function(handlerData) {
                              if (exports_getClient() !== client) return;
                              const breadcrumb = {
                                  category: "console",
                                  data: {
                                      arguments: handlerData.args,
                                      logger: "console"
                                  },
                                  level: severityLevelFromString(handlerData.level),
                                  message: safeJoin(handlerData.args, " ")
                              };
                              if ("assert" === handlerData.level) {
                                  if (!1 !== handlerData.args[0]) return;
                                  breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`, 
                                  breadcrumb.data.arguments = handlerData.args.slice(1);
                              }
                              addBreadcrumb(breadcrumb, {
                                  input: handlerData.args,
                                  level: handlerData.level
                              });
                          };
                      }(client)), _options.dom && function(handler) {
                          addHandler("dom", handler), maybeInstrument("dom", instrumentDOM);
                      }(function(client, dom) {
                          return function(handlerData) {
                              if (exports_getClient() !== client) return;
                              let target, componentName, keyAttrs = "object" == typeof dom ? dom.serializeAttribute : void 0, maxStringLength = "object" == typeof dom && "number" == typeof dom.maxStringLength ? dom.maxStringLength : void 0;
                              maxStringLength && maxStringLength > 1024 && (browser_esm_debug_build_DEBUG_BUILD && logger_logger.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${maxStringLength} was configured. Sentry will use 1024 instead.`), 
                              maxStringLength = 1024), "string" == typeof keyAttrs && (keyAttrs = [ keyAttrs ]);
                              try {
                                  const event = handlerData.event, element = function(event) {
                                      return !!event && !!event.target;
                                  }(event) ? event.target : event;
                                  target = htmlTreeAsString(element, {
                                      keyAttrs,
                                      maxStringLength
                                  }), componentName = function(elem) {
                                      if (!browser_WINDOW.HTMLElement) return null;
                                      let currentElem = elem;
                                      for (let i = 0; i < 5; i++) {
                                          if (!currentElem) return null;
                                          if (currentElem instanceof HTMLElement && currentElem.dataset.sentryComponent) return currentElem.dataset.sentryComponent;
                                          currentElem = currentElem.parentNode;
                                      }
                                      return null;
                                  }(element);
                              } catch (e) {
                                  target = "<unknown>";
                              }
                              if (0 === target.length) return;
                              const breadcrumb = {
                                  category: `ui.${handlerData.name}`,
                                  message: target
                              };
                              componentName && (breadcrumb.data = {
                                  "ui.component_name": componentName
                              }), addBreadcrumb(breadcrumb, {
                                  event: handlerData.event,
                                  name: handlerData.name,
                                  global: handlerData.global
                              });
                          };
                      }(client, _options.dom)), _options.xhr && function(handler) {
                          addHandler("xhr", handler), maybeInstrument("xhr", instrumentXHR);
                      }(function(client) {
                          return function(handlerData) {
                              if (exports_getClient() !== client) return;
                              const {startTimestamp, endTimestamp} = handlerData, sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
                              if (!startTimestamp || !endTimestamp || !sentryXhrData) return;
                              const {method, url, status_code, body} = sentryXhrData;
                              addBreadcrumb({
                                  category: "xhr",
                                  data: {
                                      method,
                                      url,
                                      status_code
                                  },
                                  type: "http"
                              }, {
                                  xhr: handlerData.xhr,
                                  input: body,
                                  startTimestamp,
                                  endTimestamp
                              });
                          };
                      }(client)), _options.fetch && function(handler) {
                          addHandler("fetch", handler), maybeInstrument("fetch", instrumentFetch);
                      }(function(client) {
                          return function(handlerData) {
                              if (exports_getClient() !== client) return;
                              const {startTimestamp, endTimestamp} = handlerData;
                              if (endTimestamp && (!handlerData.fetchData.url.match(/sentry_key/) || "POST" !== handlerData.fetchData.method)) if (handlerData.error) {
                                  addBreadcrumb({
                                      category: "fetch",
                                      data: handlerData.fetchData,
                                      level: "error",
                                      type: "http"
                                  }, {
                                      data: handlerData.error,
                                      input: handlerData.args,
                                      startTimestamp,
                                      endTimestamp
                                  });
                              } else {
                                  const response = handlerData.response;
                                  addBreadcrumb({
                                      category: "fetch",
                                      data: {
                                          ...handlerData.fetchData,
                                          status_code: response && response.status
                                      },
                                      type: "http"
                                  }, {
                                      input: handlerData.args,
                                      response,
                                      startTimestamp,
                                      endTimestamp
                                  });
                              }
                          };
                      }(client)), _options.history && function(handler) {
                          addHandler("history", handler), maybeInstrument("history", instrumentHistory);
                      }(function(client) {
                          return function(handlerData) {
                              if (exports_getClient() !== client) return;
                              let from = handlerData.from, to = handlerData.to;
                              const parsedLoc = url_parseUrl(helpers_WINDOW.location.href);
                              let parsedFrom = from ? url_parseUrl(from) : void 0;
                              const parsedTo = url_parseUrl(to);
                              parsedFrom && parsedFrom.path || (parsedFrom = parsedLoc), parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host && (to = parsedTo.relative), 
                              parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host && (from = parsedFrom.relative), 
                              addBreadcrumb({
                                  category: "navigation",
                                  data: {
                                      from,
                                      to
                                  }
                              });
                          };
                      }(client)), _options.sentry && client.on && client.on("beforeSendEvent", function(client) {
                          return function(event) {
                              exports_getClient() === client && addBreadcrumb({
                                  category: "sentry." + ("transaction" === event.type ? "transaction" : "event"),
                                  event_id: event.event_id,
                                  level: event.level,
                                  message: getEventDescription(event)
                              }, {
                                  event
                              });
                          };
                      }(client));
                  }
              };
          };
          convertIntegrationFnToClass("Breadcrumbs", breadcrumbsIntegration);
          const dedupeIntegration = () => {
              let previousEvent;
              return {
                  name: "Dedupe",
                  setupOnce() {},
                  processEvent(currentEvent) {
                      if (currentEvent.type) return currentEvent;
                      try {
                          if (function(currentEvent, previousEvent) {
                              if (!previousEvent) return !1;
                              if (function(currentEvent, previousEvent) {
                                  const currentMessage = currentEvent.message, previousMessage = previousEvent.message;
                                  if (!currentMessage && !previousMessage) return !1;
                                  if (currentMessage && !previousMessage || !currentMessage && previousMessage) return !1;
                                  if (currentMessage !== previousMessage) return !1;
                                  if (!_isSameFingerprint(currentEvent, previousEvent)) return !1;
                                  if (!_isSameStacktrace(currentEvent, previousEvent)) return !1;
                                  return !0;
                              }(currentEvent, previousEvent)) return !0;
                              if (function(currentEvent, previousEvent) {
                                  const previousException = _getExceptionFromEvent(previousEvent), currentException = _getExceptionFromEvent(currentEvent);
                                  if (!previousException || !currentException) return !1;
                                  if (previousException.type !== currentException.type || previousException.value !== currentException.value) return !1;
                                  if (!_isSameFingerprint(currentEvent, previousEvent)) return !1;
                                  if (!_isSameStacktrace(currentEvent, previousEvent)) return !1;
                                  return !0;
                              }(currentEvent, previousEvent)) return !0;
                              return !1;
                          }(currentEvent, previousEvent)) return browser_esm_debug_build_DEBUG_BUILD && logger_logger.warn("Event dropped due to being a duplicate of previously captured event."), 
                          null;
                      } catch (_oO) {}
                      return previousEvent = currentEvent;
                  }
              };
          };
          convertIntegrationFnToClass("Dedupe", dedupeIntegration);
          function _isSameStacktrace(currentEvent, previousEvent) {
              let currentFrames = _getFramesFromEvent(currentEvent), previousFrames = _getFramesFromEvent(previousEvent);
              if (!currentFrames && !previousFrames) return !0;
              if (currentFrames && !previousFrames || !currentFrames && previousFrames) return !1;
              if (previousFrames.length !== currentFrames.length) return !1;
              for (let i = 0; i < previousFrames.length; i++) {
                  const frameA = previousFrames[i], frameB = currentFrames[i];
                  if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) return !1;
              }
              return !0;
          }
          function _isSameFingerprint(currentEvent, previousEvent) {
              let currentFingerprint = currentEvent.fingerprint, previousFingerprint = previousEvent.fingerprint;
              if (!currentFingerprint && !previousFingerprint) return !0;
              if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) return !1;
              try {
                  return !(currentFingerprint.join("") !== previousFingerprint.join(""));
              } catch (_oO) {
                  return !1;
              }
          }
          function _getExceptionFromEvent(event) {
              return event.exception && event.exception.values && event.exception.values[0];
          }
          function _getFramesFromEvent(event) {
              const exception = event.exception;
              if (exception) try {
                  return exception.values[0].stacktrace.frames;
              } catch (_oO) {
                  return;
              }
          }
          let _oldOnErrorHandler = null;
          function instrumentError() {
              _oldOnErrorHandler = worldwide_GLOBAL_OBJ.onerror, worldwide_GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
                  return triggerHandlers("error", {
                      column,
                      error,
                      line,
                      msg,
                      url
                  }), !(!_oldOnErrorHandler || _oldOnErrorHandler.__SENTRY_LOADER__) && _oldOnErrorHandler.apply(this, arguments);
              }, worldwide_GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0;
          }
          let _oldOnUnhandledRejectionHandler = null;
          function instrumentUnhandledRejection() {
              _oldOnUnhandledRejectionHandler = worldwide_GLOBAL_OBJ.onunhandledrejection, worldwide_GLOBAL_OBJ.onunhandledrejection = function(e) {
                  return triggerHandlers("unhandledrejection", e), !(_oldOnUnhandledRejectionHandler && !_oldOnUnhandledRejectionHandler.__SENTRY_LOADER__) || _oldOnUnhandledRejectionHandler.apply(this, arguments);
              }, worldwide_GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
          }
          function exceptionFromError(stackParser, ex) {
              const frames = parseStackFrames(stackParser, ex), exception = {
                  type: ex && ex.name,
                  value: extractMessage(ex)
              };
              return frames.length && (exception.stacktrace = {
                  frames
              }), void 0 === exception.type && "" === exception.value && (exception.value = "Unrecoverable error caught"), 
              exception;
          }
          function eventFromError(stackParser, ex) {
              return {
                  exception: {
                      values: [ exceptionFromError(stackParser, ex) ]
                  }
              };
          }
          function parseStackFrames(stackParser, ex) {
              const stacktrace = ex.stacktrace || ex.stack || "", popSize = function(ex) {
                  if (ex) {
                      if ("number" == typeof ex.framesToPop) return ex.framesToPop;
                      if (reactMinifiedRegexp.test(ex.message)) return 1;
                  }
                  return 0;
              }(ex);
              try {
                  return stackParser(stacktrace, popSize);
              } catch (e) {}
              return [];
          }
          const reactMinifiedRegexp = /Minified React error #\d+;/i;
          function extractMessage(ex) {
              const message = ex && ex.message;
              return message ? message.error && "string" == typeof message.error.message ? message.error.message : message : "No error message";
          }
          function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
              let event;
              if (isErrorEvent(exception) && exception.error) {
                  return eventFromError(stackParser, exception.error);
              }
              if (isDOMError(exception) || isBuiltin(exception, "DOMException")) {
                  const domException = exception;
                  if ("stack" in exception) event = eventFromError(stackParser, exception); else {
                      const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException"), message = domException.message ? `${name}: ${domException.message}` : name;
                      event = eventFromString(stackParser, message, syntheticException, attachStacktrace), 
                      addExceptionTypeValue(event, message);
                  }
                  return "code" in domException && (event.tags = {
                      ...event.tags,
                      "DOMException.code": `${domException.code}`
                  }), event;
              }
              if (isError(exception)) return eventFromError(stackParser, exception);
              if (isPlainObject(exception) || isEvent(exception)) {
                  return event = function(stackParser, exception, syntheticException, isUnhandledRejection) {
                      const client = exports_getClient(), normalizeDepth = client && client.getOptions().normalizeDepth, event = {
                          exception: {
                              values: [ {
                                  type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
                                  value: getNonErrorObjectExceptionValue(exception, {
                                      isUnhandledRejection
                                  })
                              } ]
                          },
                          extra: {
                              __serialized__: normalizeToSize(exception, normalizeDepth)
                          }
                      };
                      if (syntheticException) {
                          const frames = parseStackFrames(stackParser, syntheticException);
                          frames.length && (event.exception.values[0].stacktrace = {
                              frames
                          });
                      }
                      return event;
                  }(stackParser, exception, syntheticException, isUnhandledRejection), addExceptionMechanism(event, {
                      synthetic: !0
                  }), event;
              }
              return event = eventFromString(stackParser, exception, syntheticException, attachStacktrace), 
              addExceptionTypeValue(event, `${exception}`, void 0), addExceptionMechanism(event, {
                  synthetic: !0
              }), event;
          }
          function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
              const event = {};
              if (attachStacktrace && syntheticException) {
                  const frames = parseStackFrames(stackParser, syntheticException);
                  frames.length && (event.exception = {
                      values: [ {
                          value: message,
                          stacktrace: {
                              frames
                          }
                      } ]
                  });
              }
              if (isParameterizedString(message)) {
                  const {__sentry_template_string__, __sentry_template_values__} = message;
                  return event.logentry = {
                      message: __sentry_template_string__,
                      params: __sentry_template_values__
                  }, event;
              }
              return event.message = message, event;
          }
          function getNonErrorObjectExceptionValue(exception, {isUnhandledRejection}) {
              const keys = function(exception, maxLength = 40) {
                  const keys = Object.keys(convertToPlainObject(exception));
                  if (keys.sort(), !keys.length) return "[object has no keys]";
                  if (keys[0].length >= maxLength) return truncate(keys[0], maxLength);
                  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
                      const serialized = keys.slice(0, includedKeys).join(", ");
                      if (!(serialized.length > maxLength)) return includedKeys === keys.length ? serialized : truncate(serialized, maxLength);
                  }
                  return "";
              }(exception), captureType = isUnhandledRejection ? "promise rejection" : "exception";
              if (isErrorEvent(exception)) return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
              if (isEvent(exception)) {
                  return `Event \`${function(obj) {
                      try {
                          const prototype = Object.getPrototypeOf(obj);
                          return prototype ? prototype.constructor.name : void 0;
                      } catch (e) {}
                  }(exception)}\` (type=${exception.type}) captured as ${captureType}`;
              }
              return `Object captured as ${captureType} with keys: ${keys}`;
          }
          const globalHandlersIntegration = (options = {}) => {
              const _options = {
                  onerror: !0,
                  onunhandledrejection: !0,
                  ...options
              };
              return {
                  name: "GlobalHandlers",
                  setupOnce() {
                      Error.stackTraceLimit = 50;
                  },
                  setup(client) {
                      _options.onerror && (!function(client) {
                          !function(handler) {
                              addHandler("error", handler), maybeInstrument("error", instrumentError);
                          }((data => {
                              const {stackParser, attachStacktrace} = getOptions();
                              if (exports_getClient() !== client || shouldIgnoreOnError()) return;
                              const {msg, url, line, column, error} = data, event = void 0 === error && isString(msg) ? function(msg, url, line, column) {
                                  const ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
                                  let message = isErrorEvent(msg) ? msg.message : msg, name = "Error";
                                  const groups = message.match(ERROR_TYPES_RE);
                                  groups && (name = groups[1], message = groups[2]);
                                  const event = {
                                      exception: {
                                          values: [ {
                                              type: name,
                                              value: message
                                          } ]
                                      }
                                  };
                                  return _enhanceEventWithInitialFrame(event, url, line, column);
                              }(msg, url, line, column) : _enhanceEventWithInitialFrame(eventFromUnknownInput(stackParser, error || msg, void 0, attachStacktrace, !1), url, line, column);
                              event.level = "error", captureEvent(event, {
                                  originalException: error,
                                  mechanism: {
                                      handled: !1,
                                      type: "onerror"
                                  }
                              });
                          }));
                      }(client), globalHandlerLog("onerror")), _options.onunhandledrejection && (!function(client) {
                          !function(handler) {
                              const type = "unhandledrejection";
                              addHandler(type, handler), maybeInstrument(type, instrumentUnhandledRejection);
                          }((e => {
                              const {stackParser, attachStacktrace} = getOptions();
                              if (exports_getClient() !== client || shouldIgnoreOnError()) return;
                              const error = function(error) {
                                  if (is_isPrimitive(error)) return error;
                                  const e = error;
                                  try {
                                      if ("reason" in e) return e.reason;
                                      if ("detail" in e && "reason" in e.detail) return e.detail.reason;
                                  } catch (e2) {}
                                  return error;
                              }(e), event = is_isPrimitive(error) ? {
                                  exception: {
                                      values: [ {
                                          type: "UnhandledRejection",
                                          value: `Non-Error promise rejection captured with value: ${String(error)}`
                                      } ]
                                  }
                              } : eventFromUnknownInput(stackParser, error, void 0, attachStacktrace, !0);
                              event.level = "error", captureEvent(event, {
                                  originalException: error,
                                  mechanism: {
                                      handled: !1,
                                      type: "onunhandledrejection"
                                  }
                              });
                          }));
                      }(client), globalHandlerLog("onunhandledrejection"));
                  }
              };
          };
          convertIntegrationFnToClass("GlobalHandlers", globalHandlersIntegration);
          function _enhanceEventWithInitialFrame(event, url, line, column) {
              const e = event.exception = event.exception || {}, ev = e.values = e.values || [], ev0 = ev[0] = ev[0] || {}, ev0s = ev0.stacktrace = ev0.stacktrace || {}, ev0sf = ev0s.frames = ev0s.frames || [], colno = isNaN(parseInt(column, 10)) ? void 0 : column, lineno = isNaN(parseInt(line, 10)) ? void 0 : line, filename = isString(url) && url.length > 0 ? url : function() {
                  try {
                      return browser_WINDOW.document.location.href;
                  } catch (oO) {
                      return "";
                  }
              }();
              return 0 === ev0sf.length && ev0sf.push({
                  colno,
                  filename,
                  function: "?",
                  in_app: !0,
                  lineno
              }), event;
          }
          function globalHandlerLog(type) {
              browser_esm_debug_build_DEBUG_BUILD && logger_logger.log(`Global Handler attached: ${type}`);
          }
          function getOptions() {
              const client = exports_getClient();
              return client && client.getOptions() || {
                  stackParser: () => [],
                  attachStacktrace: !1
              };
          }
          const httpContextIntegration = () => ({
              name: "HttpContext",
              setupOnce() {},
              preprocessEvent(event) {
                  if (!helpers_WINDOW.navigator && !helpers_WINDOW.location && !helpers_WINDOW.document) return;
                  const url = event.request && event.request.url || helpers_WINDOW.location && helpers_WINDOW.location.href, {referrer} = helpers_WINDOW.document || {}, {userAgent} = helpers_WINDOW.navigator || {}, headers = {
                      ...event.request && event.request.headers,
                      ...referrer && {
                          Referer: referrer
                      },
                      ...userAgent && {
                          "User-Agent": userAgent
                      }
                  }, request = {
                      ...event.request,
                      ...url && {
                          url
                      },
                      headers
                  };
                  event.request = request;
              }
          });
          convertIntegrationFnToClass("HttpContext", httpContextIntegration);
          function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser, maxValueLimit = 250, key, limit, event, hint) {
              if (!(event.exception && event.exception.values && hint && isInstanceOf(hint.originalException, Error))) return;
              const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
              var exceptions, maxValueLength;
              originalException && (event.exception.values = (exceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, hint.originalException, key, event.exception.values, originalException, 0), 
              maxValueLength = maxValueLimit, exceptions.map((exception => (exception.value && (exception.value = truncate(exception.value, maxValueLength)), 
              exception)))));
          }
          function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error, key, prevExceptions, exception, exceptionId) {
              if (prevExceptions.length >= limit + 1) return prevExceptions;
              let newExceptions = [ ...prevExceptions ];
              if (isInstanceOf(error[key], Error)) {
                  applyExceptionGroupFieldsForParentException(exception, exceptionId);
                  const newException = exceptionFromErrorImplementation(parser, error[key]), newExceptionId = newExceptions.length;
                  applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId), 
                  newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, error[key], key, [ newException, ...newExceptions ], newException, newExceptionId);
              }
              return Array.isArray(error.errors) && error.errors.forEach(((childError, i) => {
                  if (isInstanceOf(childError, Error)) {
                      applyExceptionGroupFieldsForParentException(exception, exceptionId);
                      const newException = exceptionFromErrorImplementation(parser, childError), newExceptionId = newExceptions.length;
                      applyExceptionGroupFieldsForChildException(newException, `errors[${i}]`, newExceptionId, exceptionId), 
                      newExceptions = aggregateExceptionsFromError(exceptionFromErrorImplementation, parser, limit, childError, key, [ newException, ...newExceptions ], newException, newExceptionId);
                  }
              })), newExceptions;
          }
          function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
              exception.mechanism = exception.mechanism || {
                  type: "generic",
                  handled: !0
              }, exception.mechanism = {
                  ...exception.mechanism,
                  ..."AggregateError" === exception.type && {
                      is_exception_group: !0
                  },
                  exception_id: exceptionId
              };
          }
          function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
              exception.mechanism = exception.mechanism || {
                  type: "generic",
                  handled: !0
              }, exception.mechanism = {
                  ...exception.mechanism,
                  type: "chained",
                  source,
                  exception_id: exceptionId,
                  parent_id: parentId
              };
          }
          const linkedErrorsIntegration = (options = {}) => {
              const limit = options.limit || 5, key = options.key || "cause";
              return {
                  name: "LinkedErrors",
                  setupOnce() {},
                  preprocessEvent(event, hint, client) {
                      const options = client.getOptions();
                      applyAggregateErrorsToEvent(exceptionFromError, options.stackParser, options.maxValueLength, key, limit, event, hint);
                  }
              };
          }, DEFAULT_EVENT_TARGET = (convertIntegrationFnToClass("LinkedErrors", linkedErrorsIntegration), 
          [ "EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload" ]), browserApiErrorsIntegration = (options = {}) => {
              const _options = {
                  XMLHttpRequest: !0,
                  eventTarget: !0,
                  requestAnimationFrame: !0,
                  setInterval: !0,
                  setTimeout: !0,
                  ...options
              };
              return {
                  name: "TryCatch",
                  setupOnce() {
                      _options.setTimeout && fill(helpers_WINDOW, "setTimeout", _wrapTimeFunction), _options.setInterval && fill(helpers_WINDOW, "setInterval", _wrapTimeFunction), 
                      _options.requestAnimationFrame && fill(helpers_WINDOW, "requestAnimationFrame", _wrapRAF), 
                      _options.XMLHttpRequest && "XMLHttpRequest" in helpers_WINDOW && fill(XMLHttpRequest.prototype, "send", _wrapXHR);
                      const eventTargetOption = _options.eventTarget;
                      if (eventTargetOption) {
                          (Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET).forEach(_wrapEventTarget);
                      }
                  }
              };
          };
          convertIntegrationFnToClass("TryCatch", browserApiErrorsIntegration);
          function _wrapTimeFunction(original) {
              return function(...args) {
                  const originalCallback = args[0];
                  return args[0] = wrap(originalCallback, {
                      mechanism: {
                          data: {
                              function: getFunctionName(original)
                          },
                          handled: !1,
                          type: "instrument"
                      }
                  }), original.apply(this, args);
              };
          }
          function _wrapRAF(original) {
              return function(callback) {
                  return original.apply(this, [ wrap(callback, {
                      mechanism: {
                          data: {
                              function: "requestAnimationFrame",
                              handler: getFunctionName(original)
                          },
                          handled: !1,
                          type: "instrument"
                      }
                  }) ]);
              };
          }
          function _wrapXHR(originalSend) {
              return function(...args) {
                  const xhr = this;
                  return [ "onload", "onerror", "onprogress", "onreadystatechange" ].forEach((prop => {
                      prop in xhr && "function" == typeof xhr[prop] && fill(xhr, prop, (function(original) {
                          const wrapOptions = {
                              mechanism: {
                                  data: {
                                      function: prop,
                                      handler: getFunctionName(original)
                                  },
                                  handled: !1,
                                  type: "instrument"
                              }
                          }, originalFunction = getOriginalFunction(original);
                          return originalFunction && (wrapOptions.mechanism.data.handler = getFunctionName(originalFunction)), 
                          wrap(original, wrapOptions);
                      }));
                  })), originalSend.apply(this, args);
              };
          }
          function _wrapEventTarget(target) {
              const globalObject = helpers_WINDOW, proto = globalObject[target] && globalObject[target].prototype;
              proto && proto.hasOwnProperty && proto.hasOwnProperty("addEventListener") && (fill(proto, "addEventListener", (function(original) {
                  return function(eventName, fn, options) {
                      try {
                          "function" == typeof fn.handleEvent && (fn.handleEvent = wrap(fn.handleEvent, {
                              mechanism: {
                                  data: {
                                      function: "handleEvent",
                                      handler: getFunctionName(fn),
                                      target
                                  },
                                  handled: !1,
                                  type: "instrument"
                              }
                          }));
                      } catch (err) {}
                      return original.apply(this, [ eventName, wrap(fn, {
                          mechanism: {
                              data: {
                                  function: "addEventListener",
                                  handler: getFunctionName(fn),
                                  target
                              },
                              handled: !1,
                              type: "instrument"
                          }
                      }), options ]);
                  };
              })), fill(proto, "removeEventListener", (function(originalRemoveEventListener) {
                  return function(eventName, fn, options) {
                      const wrappedEventHandler = fn;
                      try {
                          const originalEventHandler = wrappedEventHandler && wrappedEventHandler.__sentry_wrapped__;
                          originalEventHandler && originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
                      } catch (e) {}
                      return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
                  };
              })));
          }
          const defaultIntegrations = [ inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration() ];
          function getDefaultIntegrations(_options) {
              return [ ...defaultIntegrations ];
          }
          const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
          function dsn_dsnToString(dsn, withPassword = !1) {
              const {host, path, pass, port, projectId, protocol, publicKey} = dsn;
              return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
          }
          function dsnFromComponents(components) {
              return {
                  protocol: components.protocol,
                  publicKey: components.publicKey || "",
                  pass: components.pass || "",
                  host: components.host,
                  port: components.port || "",
                  path: components.path || "",
                  projectId: components.projectId
              };
          }
          function dsn_makeDsn(from) {
              const components = "string" == typeof from ? function(str) {
                  const match = DSN_REGEX.exec(str);
                  if (!match) return void consoleSandbox((() => {
                      console.error(`Invalid Sentry Dsn: ${str}`);
                  }));
                  const [protocol, publicKey, pass = "", host, port = "", lastPath] = match.slice(1);
                  let path = "", projectId = lastPath;
                  const split = projectId.split("/");
                  if (split.length > 1 && (path = split.slice(0, -1).join("/"), projectId = split.pop()), 
                  projectId) {
                      const projectMatch = projectId.match(/^\d+/);
                      projectMatch && (projectId = projectMatch[0]);
                  }
                  return dsnFromComponents({
                      host,
                      pass,
                      path,
                      projectId,
                      port,
                      protocol,
                      publicKey
                  });
              }(from) : dsnFromComponents(from);
              if (components && function(dsn) {
                  if (!debug_build_DEBUG_BUILD) return !0;
                  const {port, projectId, protocol} = dsn;
                  return !([ "protocol", "publicKey", "host", "projectId" ].find((component => !dsn[component] && (logger_logger.error(`Invalid Sentry Dsn: ${component} missing`), 
                  !0))) || (projectId.match(/^\d+$/) ? function(protocol) {
                      return "http" === protocol || "https" === protocol;
                  }(protocol) ? port && isNaN(parseInt(port, 10)) && (logger_logger.error(`Invalid Sentry Dsn: Invalid port ${port}`), 
                  1) : (logger_logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`), 1) : (logger_logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`), 
                  1)));
              }(components)) return components;
          }
          function createEnvelope(headers, items = []) {
              return [ headers, items ];
          }
          function addItemToEnvelope(envelope, newItem) {
              const [headers, items] = envelope;
              return [ headers, [ ...items, newItem ] ];
          }
          function forEachEnvelopeItem(envelope, callback) {
              const envelopeItems = envelope[1];
              for (const envelopeItem of envelopeItems) {
                  if (callback(envelopeItem, envelopeItem[0].type)) return !0;
              }
              return !1;
          }
          function encodeUTF8(input, textEncoder) {
              return (textEncoder || new TextEncoder).encode(input);
          }
          function serializeEnvelope(envelope, textEncoder) {
              const [envHeaders, items] = envelope;
              let parts = JSON.stringify(envHeaders);
              function append(next) {
                  "string" == typeof parts ? parts = "string" == typeof next ? parts + next : [ encodeUTF8(parts, textEncoder), next ] : parts.push("string" == typeof next ? encodeUTF8(next, textEncoder) : next);
              }
              for (const item of items) {
                  const [itemHeaders, payload] = item;
                  if (append(`\n${JSON.stringify(itemHeaders)}\n`), "string" == typeof payload || payload instanceof Uint8Array) append(payload); else {
                      let stringifiedPayload;
                      try {
                          stringifiedPayload = JSON.stringify(payload);
                      } catch (e) {
                          stringifiedPayload = JSON.stringify(normalize(payload));
                      }
                      append(stringifiedPayload);
                  }
              }
              return "string" == typeof parts ? parts : function(buffers) {
                  const totalLength = buffers.reduce(((acc, buf) => acc + buf.length), 0), merged = new Uint8Array(totalLength);
                  let offset = 0;
                  for (const buffer of buffers) merged.set(buffer, offset), offset += buffer.length;
                  return merged;
              }(parts);
          }
          function createAttachmentEnvelopeItem(attachment, textEncoder) {
              const buffer = "string" == typeof attachment.data ? encodeUTF8(attachment.data, textEncoder) : attachment.data;
              return [ object_dropUndefinedKeys({
                  type: "attachment",
                  length: buffer.length,
                  filename: attachment.filename,
                  content_type: attachment.contentType,
                  attachment_type: attachment.attachmentType
              }), buffer ];
          }
          const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
              session: "session",
              sessions: "session",
              attachment: "attachment",
              transaction: "transaction",
              event: "error",
              client_report: "internal",
              user_report: "default",
              profile: "profile",
              replay_event: "replay",
              replay_recording: "replay",
              check_in: "monitor",
              feedback: "feedback",
              span: "span",
              statsd: "metric_bucket"
          };
          function envelopeItemTypeToDataCategory(type) {
              return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
          }
          function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
              if (!metadataOrEvent || !metadataOrEvent.sdk) return;
              const {name, version} = metadataOrEvent.sdk;
              return {
                  name,
                  version
              };
          }
          class SentryError extends Error {
              constructor(message, logLevel = "warn") {
                  super(message), this.message = message, this.name = new.target.prototype.constructor.name, 
                  Object.setPrototypeOf(this, new.target.prototype), this.logLevel = logLevel;
              }
          }
          const SENTRY_API_VERSION = "7";
          function getBaseApiEndpoint(dsn) {
              const protocol = dsn.protocol ? `${dsn.protocol}:` : "", port = dsn.port ? `:${dsn.port}` : "";
              return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
          }
          function _encodedAuth(dsn, sdkInfo) {
              return function(object) {
                  return Object.keys(object).map((key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)).join("&");
              }({
                  sentry_key: dsn.publicKey,
                  sentry_version: SENTRY_API_VERSION,
                  ...sdkInfo && {
                      sentry_client: `${sdkInfo.name}/${sdkInfo.version}`
                  }
              });
          }
          function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnelOrOptions = {}) {
              const tunnel = "string" == typeof tunnelOrOptions ? tunnelOrOptions : tunnelOrOptions.tunnel, sdkInfo = "string" != typeof tunnelOrOptions && tunnelOrOptions._metadata ? tunnelOrOptions._metadata.sdk : void 0;
              return tunnel || `${function(dsn) {
                  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
              }(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
          }
          function createEventEnvelope(event, dsn, metadata, tunnel) {
              const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata), eventType = event.type && "replay_event" !== event.type ? event.type : "event";
              !function(event, sdkInfo) {
                  sdkInfo && (event.sdk = event.sdk || {}, event.sdk.name = event.sdk.name || sdkInfo.name, 
                  event.sdk.version = event.sdk.version || sdkInfo.version, event.sdk.integrations = [ ...event.sdk.integrations || [], ...sdkInfo.integrations || [] ], 
                  event.sdk.packages = [ ...event.sdk.packages || [], ...sdkInfo.packages || [] ]);
              }(event, metadata && metadata.sdk);
              const envelopeHeaders = function(event, sdkInfo, tunnel, dsn) {
                  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
                  return {
                      event_id: event.event_id,
                      sent_at: (new Date).toISOString(),
                      ...sdkInfo && {
                          sdk: sdkInfo
                      },
                      ...!!tunnel && dsn && {
                          dsn: dsn_dsnToString(dsn)
                      },
                      ...dynamicSamplingContext && {
                          trace: object_dropUndefinedKeys({
                              ...dynamicSamplingContext
                          })
                      }
                  };
              }(event, sdkInfo, tunnel, dsn);
              delete event.sdkProcessingMetadata;
              return createEnvelope(envelopeHeaders, [ [ {
                  type: eventType
              }, event ] ]);
          }
          function createMetricEnvelope(metricBucketItems, dsn, metadata, tunnel) {
              const headers = {
                  sent_at: (new Date).toISOString()
              };
              metadata && metadata.sdk && (headers.sdk = {
                  name: metadata.sdk.name,
                  version: metadata.sdk.version
              }), tunnel && dsn && (headers.dsn = dsn_dsnToString(dsn));
              const item = function(metricBucketItems) {
                  const payload = function(metricBucketItems) {
                      let out = "";
                      for (const item of metricBucketItems) {
                          const tagEntries = Object.entries(item.tags), maybeTags = tagEntries.length > 0 ? `|#${tagEntries.map((([key, value]) => `${key}:${value}`)).join(",")}` : "";
                          out += `${item.name}@${item.unit}:${item.metric}|${item.metricType}${maybeTags}|T${item.timestamp}\n`;
                      }
                      return out;
                  }(metricBucketItems);
                  return [ {
                      type: "statsd",
                      length: payload.length
                  }, payload ];
              }(metricBucketItems);
              return createEnvelope(headers, [ item ]);
          }
          const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
          class BaseClient {
              constructor(options) {
                  if (this._options = options, this._integrations = {}, this._integrationsInitialized = !1, 
                  this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], 
                  options.dsn ? this._dsn = dsn_makeDsn(options.dsn) : esm_debug_build_DEBUG_BUILD && logger_logger.warn("No DSN provided, client will not send events."), 
                  this._dsn) {
                      const url = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, options);
                      this._transport = options.transport({
                          recordDroppedEvent: this.recordDroppedEvent.bind(this),
                          ...options.transportOptions,
                          url
                      });
                  }
              }
              captureException(exception, hint, scope) {
                  if (checkOrSetAlreadyCaught(exception)) return void (esm_debug_build_DEBUG_BUILD && logger_logger.log(ALREADY_SEEN_ERROR));
                  let eventId = hint && hint.event_id;
                  return this._process(this.eventFromException(exception, hint).then((event => this._captureEvent(event, hint, scope))).then((result => {
                      eventId = result;
                  }))), eventId;
              }
              captureMessage(message, level, hint, scope) {
                  let eventId = hint && hint.event_id;
                  const eventMessage = isParameterizedString(message) ? message : String(message), promisedEvent = is_isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hint) : this.eventFromException(message, hint);
                  return this._process(promisedEvent.then((event => this._captureEvent(event, hint, scope))).then((result => {
                      eventId = result;
                  }))), eventId;
              }
              captureEvent(event, hint, scope) {
                  if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) return void (esm_debug_build_DEBUG_BUILD && logger_logger.log(ALREADY_SEEN_ERROR));
                  let eventId = hint && hint.event_id;
                  const capturedSpanScope = (event.sdkProcessingMetadata || {}).capturedSpanScope;
                  return this._process(this._captureEvent(event, hint, capturedSpanScope || scope).then((result => {
                      eventId = result;
                  }))), eventId;
              }
              captureSession(session) {
                  "string" != typeof session.release ? esm_debug_build_DEBUG_BUILD && logger_logger.warn("Discarded session because of missing or non-string release") : (this.sendSession(session), 
                  session_updateSession(session, {
                      init: !1
                  }));
              }
              getDsn() {
                  return this._dsn;
              }
              getOptions() {
                  return this._options;
              }
              getSdkMetadata() {
                  return this._options._metadata;
              }
              getTransport() {
                  return this._transport;
              }
              flush(timeout) {
                  const transport = this._transport;
                  return transport ? (this.metricsAggregator && this.metricsAggregator.flush(), this._isClientDoneProcessing(timeout).then((clientFinished => transport.flush(timeout).then((transportFlushed => clientFinished && transportFlushed))))) : resolvedSyncPromise(!0);
              }
              close(timeout) {
                  return this.flush(timeout).then((result => (this.getOptions().enabled = !1, this.metricsAggregator && this.metricsAggregator.close(), 
                  result)));
              }
              getEventProcessors() {
                  return this._eventProcessors;
              }
              addEventProcessor(eventProcessor) {
                  this._eventProcessors.push(eventProcessor);
              }
              setupIntegrations(forceInitialize) {
                  (forceInitialize && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && this._setupIntegrations();
              }
              init() {
                  this._isEnabled() && this._setupIntegrations();
              }
              getIntegrationById(integrationId) {
                  return this.getIntegrationByName(integrationId);
              }
              getIntegrationByName(integrationName) {
                  return this._integrations[integrationName];
              }
              getIntegration(integration) {
                  try {
                      return this._integrations[integration.id] || null;
                  } catch (_oO) {
                      return esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`), 
                      null;
                  }
              }
              addIntegration(integration) {
                  const isAlreadyInstalled = this._integrations[integration.name];
                  setupIntegration(this, integration, this._integrations), isAlreadyInstalled || afterSetupIntegrations(this, [ integration ]);
              }
              sendEvent(event, hint = {}) {
                  this.emit("beforeSendEvent", event, hint);
                  let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
                  for (const attachment of hint.attachments || []) env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment, this._options.transportOptions && this._options.transportOptions.textEncoder));
                  const promise = this._sendEnvelope(env);
                  promise && promise.then((sendResponse => this.emit("afterSendEvent", event, sendResponse)), null);
              }
              sendSession(session) {
                  const env = function(session, dsn, metadata, tunnel) {
                      const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
                      return createEnvelope({
                          sent_at: (new Date).toISOString(),
                          ...sdkInfo && {
                              sdk: sdkInfo
                          },
                          ...!!tunnel && dsn && {
                              dsn: dsn_dsnToString(dsn)
                          }
                      }, [ "aggregates" in session ? [ {
                          type: "sessions"
                      }, session ] : [ {
                          type: "session"
                      }, session.toJSON() ] ]);
                  }(session, this._dsn, this._options._metadata, this._options.tunnel);
                  this._sendEnvelope(env);
              }
              recordDroppedEvent(reason, category, _event) {
                  if (this._options.sendClientReports) {
                      const key = `${reason}:${category}`;
                      esm_debug_build_DEBUG_BUILD && logger_logger.log(`Adding outcome: "${key}"`), this._outcomes[key] = this._outcomes[key] + 1 || 1;
                  }
              }
              captureAggregateMetrics(metricBucketItems) {
                  esm_debug_build_DEBUG_BUILD && logger_logger.log(`Flushing aggregated metrics, number of metrics: ${metricBucketItems.length}`);
                  const metricsEnvelope = createMetricEnvelope(metricBucketItems, this._dsn, this._options._metadata, this._options.tunnel);
                  this._sendEnvelope(metricsEnvelope);
              }
              on(hook, callback) {
                  this._hooks[hook] || (this._hooks[hook] = []), this._hooks[hook].push(callback);
              }
              emit(hook, ...rest) {
                  this._hooks[hook] && this._hooks[hook].forEach((callback => callback(...rest)));
              }
              _setupIntegrations() {
                  const {integrations} = this._options;
                  this._integrations = function(client, integrations) {
                      const integrationIndex = {};
                      return integrations.forEach((integration => {
                          integration && setupIntegration(client, integration, integrationIndex);
                      })), integrationIndex;
                  }(this, integrations), afterSetupIntegrations(this, integrations), this._integrationsInitialized = !0;
              }
              _updateSessionFromEvent(session, event) {
                  let crashed = !1, errored = !1;
                  const exceptions = event.exception && event.exception.values;
                  if (exceptions) {
                      errored = !0;
                      for (const ex of exceptions) {
                          const mechanism = ex.mechanism;
                          if (mechanism && !1 === mechanism.handled) {
                              crashed = !0;
                              break;
                          }
                      }
                  }
                  const sessionNonTerminal = "ok" === session.status;
                  (sessionNonTerminal && 0 === session.errors || sessionNonTerminal && crashed) && (session_updateSession(session, {
                      ...crashed && {
                          status: "crashed"
                      },
                      errors: session.errors || Number(errored || crashed)
                  }), this.captureSession(session));
              }
              _isClientDoneProcessing(timeout) {
                  return new SyncPromise((resolve => {
                      let ticked = 0;
                      const interval = setInterval((() => {
                          0 == this._numProcessing ? (clearInterval(interval), resolve(!0)) : (ticked += 1, 
                          timeout && ticked >= timeout && (clearInterval(interval), resolve(!1)));
                      }), 1);
                  }));
              }
              _isEnabled() {
                  return !1 !== this.getOptions().enabled && void 0 !== this._transport;
              }
              _prepareEvent(event, hint, scope, isolationScope = function() {
                  return hub_getCurrentHub().getIsolationScope();
              }()) {
                  const options = this.getOptions(), integrations = Object.keys(this._integrations);
                  return !hint.integrations && integrations.length > 0 && (hint.integrations = integrations), 
                  this.emit("preprocessEvent", event, hint), prepareEvent(options, event, hint, scope, this, isolationScope).then((evt => {
                      if (null === evt) return evt;
                      const propagationContext = {
                          ...isolationScope.getPropagationContext(),
                          ...scope ? scope.getPropagationContext() : void 0
                      };
                      if (!(evt.contexts && evt.contexts.trace) && propagationContext) {
                          const {traceId: trace_id, spanId, parentSpanId, dsc} = propagationContext;
                          evt.contexts = {
                              trace: {
                                  trace_id,
                                  span_id: spanId,
                                  parent_span_id: parentSpanId
                              },
                              ...evt.contexts
                          };
                          const dynamicSamplingContext = dsc || getDynamicSamplingContextFromClient(trace_id, this, scope);
                          evt.sdkProcessingMetadata = {
                              dynamicSamplingContext,
                              ...evt.sdkProcessingMetadata
                          };
                      }
                      return evt;
                  }));
              }
              _captureEvent(event, hint = {}, scope) {
                  return this._processEvent(event, hint, scope).then((finalEvent => finalEvent.event_id), (reason => {
                      if (esm_debug_build_DEBUG_BUILD) {
                          const sentryError = reason;
                          "log" === sentryError.logLevel ? logger_logger.log(sentryError.message) : logger_logger.warn(sentryError);
                      }
                  }));
              }
              _processEvent(event, hint, scope) {
                  const options = this.getOptions(), {sampleRate} = options, isTransaction = isTransactionEvent(event), isError = baseclient_isErrorEvent(event), eventType = event.type || "error", beforeSendLabel = `before send for type \`${eventType}\``;
                  if (isError && "number" == typeof sampleRate && Math.random() > sampleRate) return this.recordDroppedEvent("sample_rate", "error", event), 
                  rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`, "log"));
                  const dataCategory = "replay_event" === eventType ? "replay" : eventType, capturedSpanIsolationScope = (event.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
                  return this._prepareEvent(event, hint, scope, capturedSpanIsolationScope).then((prepared => {
                      if (null === prepared) throw this.recordDroppedEvent("event_processor", dataCategory, event), 
                      new SentryError("An event processor returned `null`, will not send event.", "log");
                      if (hint.data && !0 === hint.data.__sentry__) return prepared;
                      const result = function(options, event, hint) {
                          const {beforeSend, beforeSendTransaction} = options;
                          if (baseclient_isErrorEvent(event) && beforeSend) return beforeSend(event, hint);
                          if (isTransactionEvent(event) && beforeSendTransaction) return beforeSendTransaction(event, hint);
                          return event;
                      }(options, prepared, hint);
                      return function(beforeSendResult, beforeSendLabel) {
                          const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
                          if (is_isThenable(beforeSendResult)) return beforeSendResult.then((event => {
                              if (!isPlainObject(event) && null !== event) throw new SentryError(invalidValueError);
                              return event;
                          }), (e => {
                              throw new SentryError(`${beforeSendLabel} rejected with ${e}`);
                          }));
                          if (!isPlainObject(beforeSendResult) && null !== beforeSendResult) throw new SentryError(invalidValueError);
                          return beforeSendResult;
                      }(result, beforeSendLabel);
                  })).then((processedEvent => {
                      if (null === processedEvent) throw this.recordDroppedEvent("before_send", dataCategory, event), 
                      new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
                      const session = scope && scope.getSession();
                      !isTransaction && session && this._updateSessionFromEvent(session, processedEvent);
                      const transactionInfo = processedEvent.transaction_info;
                      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
                          const source = "custom";
                          processedEvent.transaction_info = {
                              ...transactionInfo,
                              source
                          };
                      }
                      return this.sendEvent(processedEvent, hint), processedEvent;
                  })).then(null, (reason => {
                      if (reason instanceof SentryError) throw reason;
                      throw this.captureException(reason, {
                          data: {
                              __sentry__: !0
                          },
                          originalException: reason
                      }), new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${reason}`);
                  }));
              }
              _process(promise) {
                  this._numProcessing++, promise.then((value => (this._numProcessing--, value)), (reason => (this._numProcessing--, 
                  reason)));
              }
              _sendEnvelope(envelope) {
                  if (this.emit("beforeEnvelope", envelope), this._isEnabled() && this._transport) return this._transport.send(envelope).then(null, (reason => {
                      esm_debug_build_DEBUG_BUILD && logger_logger.error("Error while sending event:", reason);
                  }));
                  esm_debug_build_DEBUG_BUILD && logger_logger.error("Transport disabled");
              }
              _clearOutcomes() {
                  const outcomes = this._outcomes;
                  return this._outcomes = {}, Object.keys(outcomes).map((key => {
                      const [reason, category] = key.split(":");
                      return {
                          reason,
                          category,
                          quantity: outcomes[key]
                      };
                  }));
              }
          }
          function baseclient_isErrorEvent(event) {
              return void 0 === event.type;
          }
          function isTransactionEvent(event) {
              return "transaction" === event.type;
          }
          function makePromiseBuffer(limit) {
              const buffer = [];
              function remove(task) {
                  return buffer.splice(buffer.indexOf(task), 1)[0];
              }
              return {
                  $: buffer,
                  add: function(taskProducer) {
                      if (!(void 0 === limit || buffer.length < limit)) return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
                      const task = taskProducer();
                      return -1 === buffer.indexOf(task) && buffer.push(task), task.then((() => remove(task))).then(null, (() => remove(task).then(null, (() => {})))), 
                      task;
                  },
                  drain: function(timeout) {
                      return new SyncPromise(((resolve, reject) => {
                          let counter = buffer.length;
                          if (!counter) return resolve(!0);
                          const capturedSetTimeout = setTimeout((() => {
                              timeout && timeout > 0 && resolve(!1);
                          }), timeout);
                          buffer.forEach((item => {
                              resolvedSyncPromise(item).then((() => {
                                  --counter || (clearTimeout(capturedSetTimeout), resolve(!0));
                              }), reject);
                          }));
                      }));
                  }
              };
          }
          const DEFAULT_RETRY_AFTER = 6e4;
          function updateRateLimits(limits, {statusCode, headers}, now = Date.now()) {
              const updatedRateLimits = {
                  ...limits
              }, rateLimitHeader = headers && headers["x-sentry-rate-limits"], retryAfterHeader = headers && headers["retry-after"];
              if (rateLimitHeader) for (const limit of rateLimitHeader.trim().split(",")) {
                  const [retryAfter, categories, , , namespaces] = limit.split(":", 5), headerDelay = parseInt(retryAfter, 10), delay = 1e3 * (isNaN(headerDelay) ? 60 : headerDelay);
                  if (categories) for (const category of categories.split(";")) "metric_bucket" === category && namespaces && !namespaces.split(";").includes("custom") || (updatedRateLimits[category] = now + delay); else updatedRateLimits.all = now + delay;
              } else retryAfterHeader ? updatedRateLimits.all = now + function(header, now = Date.now()) {
                  const headerDelay = parseInt(`${header}`, 10);
                  if (!isNaN(headerDelay)) return 1e3 * headerDelay;
                  const headerDate = Date.parse(`${header}`);
                  return isNaN(headerDate) ? DEFAULT_RETRY_AFTER : headerDate - now;
              }(retryAfterHeader, now) : 429 === statusCode && (updatedRateLimits.all = now + 6e4);
              return updatedRateLimits;
          }
          const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;
          function createTransport(options, makeRequest, buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {
              let rateLimits = {};
              function send(envelope) {
                  const filteredEnvelopeItems = [];
                  if (forEachEnvelopeItem(envelope, ((item, type) => {
                      const dataCategory = envelopeItemTypeToDataCategory(type);
                      if (function(limits, dataCategory, now = Date.now()) {
                          return function(limits, dataCategory) {
                              return limits[dataCategory] || limits.all || 0;
                          }(limits, dataCategory) > now;
                      }(rateLimits, dataCategory)) {
                          const event = getEventForEnvelopeItem(item, type);
                          options.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
                      } else filteredEnvelopeItems.push(item);
                  })), 0 === filteredEnvelopeItems.length) return resolvedSyncPromise();
                  const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems), recordEnvelopeLoss = reason => {
                      forEachEnvelopeItem(filteredEnvelope, ((item, type) => {
                          const event = getEventForEnvelopeItem(item, type);
                          options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
                      }));
                  };
                  return buffer.add((() => makeRequest({
                      body: serializeEnvelope(filteredEnvelope, options.textEncoder)
                  }).then((response => (void 0 !== response.statusCode && (response.statusCode < 200 || response.statusCode >= 300) && esm_debug_build_DEBUG_BUILD && logger_logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`), 
                  rateLimits = updateRateLimits(rateLimits, response), response)), (error => {
                      throw recordEnvelopeLoss("network_error"), error;
                  })))).then((result => result), (error => {
                      if (error instanceof SentryError) return esm_debug_build_DEBUG_BUILD && logger_logger.error("Skipped sending event because buffer is full."), 
                      recordEnvelopeLoss("queue_overflow"), resolvedSyncPromise();
                      throw error;
                  }));
              }
              return send.__sentry__baseTransport__ = !0, {
                  send,
                  flush: timeout => buffer.drain(timeout)
              };
          }
          function getEventForEnvelopeItem(item, type) {
              if ("event" === type || "transaction" === type) return Array.isArray(item) ? item[1] : void 0;
          }
          let cachedFetchImpl;
          function createFrame(filename, func, lineno, colno) {
              const frame = {
                  filename,
                  function: func,
                  in_app: !0
              };
              return void 0 !== lineno && (frame.lineno = lineno), void 0 !== colno && (frame.colno = colno), 
              frame;
          }
          const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/, chromeStackLineParser = [ 30, line => {
              const parts = chromeRegex.exec(line);
              if (parts) {
                  if (parts[2] && 0 === parts[2].indexOf("eval")) {
                      const subMatch = chromeEvalRegex.exec(parts[2]);
                      subMatch && (parts[2] = subMatch[1], parts[3] = subMatch[2], parts[4] = subMatch[3]);
                  }
                  const [func, filename] = extractSafariExtensionDetails(parts[1] || "?", parts[2]);
                  return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
              }
          } ], geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, geckoStackLineParser = [ 50, line => {
              const parts = geckoREgex.exec(line);
              if (parts) {
                  if (parts[3] && parts[3].indexOf(" > eval") > -1) {
                      const subMatch = geckoEvalRegex.exec(parts[3]);
                      subMatch && (parts[1] = parts[1] || "eval", parts[3] = subMatch[1], parts[4] = subMatch[2], 
                      parts[5] = "");
                  }
                  let filename = parts[3], func = parts[1] || "?";
                  return [func, filename] = extractSafariExtensionDetails(func, filename), createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
              }
          } ], winjsRegex = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i, winjsStackLineParser = [ 40, line => {
              const parts = winjsRegex.exec(line);
              return parts ? createFrame(parts[2], parts[1] || "?", +parts[3], parts[4] ? +parts[4] : void 0) : void 0;
          } ], stack_parsers_defaultStackParser = createStackParser(...[ chromeStackLineParser, geckoStackLineParser, winjsStackLineParser ]), extractSafariExtensionDetails = (func, filename) => {
              const isSafariExtension = -1 !== func.indexOf("safari-extension"), isSafariWebExtension = -1 !== func.indexOf("safari-web-extension");
              return isSafariExtension || isSafariWebExtension ? [ -1 !== func.indexOf("@") ? func.split("@")[0] : "?", isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}` ] : [ func, filename ];
          }, integrations = getDefaultIntegrations().filter((defaultIntegration => ![ "BrowserApiErrors", "TryCatch", "Breadcrumbs", "GlobalHandlers" ].includes(defaultIntegration.name))), sentry_client = new class extends BaseClient {
              constructor(options) {
                  !function(options, name, names = [ name ], source = "npm") {
                      const metadata = options._metadata || {};
                      metadata.sdk || (metadata.sdk = {
                          name: `sentry.javascript.${name}`,
                          packages: names.map((name => ({
                              name: `${source}:@sentry/${name}`,
                              version: "7.112.2"
                          }))),
                          version: "7.112.2"
                      }), options._metadata = metadata;
                  }(options, "browser", [ "browser" ], helpers_WINDOW.SENTRY_SDK_SOURCE || "npm"), 
                  super(options), options.sendClientReports && helpers_WINDOW.document && helpers_WINDOW.document.addEventListener("visibilitychange", (() => {
                      "hidden" === helpers_WINDOW.document.visibilityState && this._flushOutcomes();
                  }));
              }
              eventFromException(exception, hint) {
                  return function(stackParser, exception, hint, attachStacktrace) {
                      const event = eventFromUnknownInput(stackParser, exception, hint && hint.syntheticException || void 0, attachStacktrace);
                      return addExceptionMechanism(event), event.level = "error", hint && hint.event_id && (event.event_id = hint.event_id), 
                      resolvedSyncPromise(event);
                  }(this._options.stackParser, exception, hint, this._options.attachStacktrace);
              }
              eventFromMessage(message, level = "info", hint) {
                  return function(stackParser, message, level = "info", hint, attachStacktrace) {
                      const event = eventFromString(stackParser, message, hint && hint.syntheticException || void 0, attachStacktrace);
                      return event.level = level, hint && hint.event_id && (event.event_id = hint.event_id), 
                      resolvedSyncPromise(event);
                  }(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
              }
              captureUserFeedback(feedback) {
                  if (!this._isEnabled()) return void (browser_esm_debug_build_DEBUG_BUILD && logger_logger.warn("SDK not enabled, will not capture user feedback."));
                  const envelope = function(feedback, {metadata, tunnel, dsn}) {
                      const headers = {
                          event_id: feedback.event_id,
                          sent_at: (new Date).toISOString(),
                          ...metadata && metadata.sdk && {
                              sdk: {
                                  name: metadata.sdk.name,
                                  version: metadata.sdk.version
                              }
                          },
                          ...!!tunnel && !!dsn && {
                              dsn: dsn_dsnToString(dsn)
                          }
                      }, item = function(feedback) {
                          return [ {
                              type: "user_report"
                          }, feedback ];
                      }(feedback);
                      return createEnvelope(headers, [ item ]);
                  }(feedback, {
                      metadata: this.getSdkMetadata(),
                      dsn: this.getDsn(),
                      tunnel: this.getOptions().tunnel
                  });
                  this._sendEnvelope(envelope);
              }
              _prepareEvent(event, hint, scope) {
                  return event.platform = event.platform || "javascript", super._prepareEvent(event, hint, scope);
              }
              _flushOutcomes() {
                  const outcomes = this._clearOutcomes();
                  if (0 === outcomes.length) return void (browser_esm_debug_build_DEBUG_BUILD && logger_logger.log("No outcomes to send"));
                  if (!this._dsn) return void (browser_esm_debug_build_DEBUG_BUILD && logger_logger.log("No dsn provided, will not send outcomes"));
                  browser_esm_debug_build_DEBUG_BUILD && logger_logger.log("Sending outcomes:", outcomes);
                  const envelope = (discarded_events = outcomes, createEnvelope((dsn = this._options.tunnel && dsn_dsnToString(this._dsn)) ? {
                      dsn
                  } : {}, [ [ {
                      type: "client_report"
                  }, {
                      timestamp: timestamp || dateTimestampInSeconds(),
                      discarded_events
                  } ] ]));
                  var discarded_events, dsn, timestamp;
                  this._sendEnvelope(envelope);
              }
          }({
              dsn: "https://4fb13a4e7ff5d42ce6d33e319470835a@o1175436.ingest.us.sentry.io/4506862752497664",
              transport: function(options, nativeFetch = function() {
                  if (cachedFetchImpl) return cachedFetchImpl;
                  if (isNativeFetch(helpers_WINDOW.fetch)) return cachedFetchImpl = helpers_WINDOW.fetch.bind(helpers_WINDOW);
                  const document = helpers_WINDOW.document;
                  let fetchImpl = helpers_WINDOW.fetch;
                  if (document && "function" == typeof document.createElement) try {
                      const sandbox = document.createElement("iframe");
                      sandbox.hidden = !0, document.head.appendChild(sandbox);
                      const contentWindow = sandbox.contentWindow;
                      contentWindow && contentWindow.fetch && (fetchImpl = contentWindow.fetch), document.head.removeChild(sandbox);
                  } catch (e) {
                      browser_esm_debug_build_DEBUG_BUILD && logger_logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e);
                  }
                  return cachedFetchImpl = fetchImpl.bind(helpers_WINDOW);
              }()) {
                  let pendingBodySize = 0, pendingCount = 0;
                  return createTransport(options, (function(request) {
                      const requestSize = request.body.length;
                      pendingBodySize += requestSize, pendingCount++;
                      const requestOptions = {
                          body: request.body,
                          method: "POST",
                          referrerPolicy: "origin",
                          headers: options.headers,
                          keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
                          ...options.fetchOptions
                      };
                      try {
                          return nativeFetch(options.url, requestOptions).then((response => (pendingBodySize -= requestSize, 
                          pendingCount--, {
                              statusCode: response.status,
                              headers: {
                                  "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
                                  "retry-after": response.headers.get("Retry-After")
                              }
                          })));
                      } catch (e) {
                          return cachedFetchImpl = void 0, pendingBodySize -= requestSize, pendingCount--, 
                          rejectedSyncPromise(e);
                      }
                  }));
              },
              stackParser: stack_parsers_defaultStackParser,
              integrations,
              tracesSampleRate: 1,
              tracePropagationTargets: [ "localhost", /^(chrome-extension|extension):\/\//, /^https:\/\/(log-dev|log)\.felo\.ai\/api/ ],
              ignoreErrors: [ "/Extension context invalidated/", "Error: Extension context invalidated.", "ResizeObserver loop limit exceeded", "ResizeObserver loop completed with undelivered notifications.", "Attempting to use a disconnected port object", "The message port closed before a response was received", "The user aborted a request.", /Extension context invalidated/g ]
          }), scope = new Scope;
          scope.setClient(sentry_client), sentry_client.init();
          const sentry = scope, initialValues = {
              info: void 0,
              logined: void 0
          }, useUserStore = create(((set, get) => (content_script_sendMessage("login:init", {
              type: "init"
          }, "background").then((isAuth => {
              console.log("login:init isAuth", isAuth), set(null == isAuth ? {
                  logined: void 0
              } : {
                  logined: isAuth
              });
          })), setInterval((async () => {
              const {logined, info} = get(), res = await content_script_sendMessage("login:status:change", {}, "background");
              null == res ? set({
                  logined: void 0
              }) : res !== logined && (window.postMessage({
                  type: "subtitle:user-changed",
                  value: res
              }), set({
                  logined: res
              }));
              const resUser = await content_script_sendMessage("user:status:change", {}, "background");
              resUser.uid !== info?.uid && (Object.keys(resUser).length > 0 ? (set({
                  info: resUser
              }), sentry.setTag("uid", resUser.uid), sentry.setTag("email", resUser.email)) : set({
                  info: void 0
              }));
          }), 1500), {
              ...initialValues,
              setInfo: info => set({
                  info
              })
          }))), useLogined = () => useUserStore((({logined}) => logined)), user = useUserStore, useAppConfigStore = create(((set, get) => {
              chrome.storage.local.get("inviteClicked", (items => {
                  "inviteClicked" in items && set({
                      inviteClicked: items.inviteClicked
                  });
              })), content_script_sendMessage("get-register-benefit", {}, "background").then((loginEarnTime => {
                  set({
                      loginEarnTime
                  });
              }));
              return {
                  inviteClicked: !1,
                  loginEarnTime: 0,
                  checkCapture: !1,
                  canTranscribe: !1,
                  microphoneEnabled: !1,
                  hasExistSubtitles: !1,
                  shortcutHighLightedSites: void 0,
                  shortcutIgnoreSites: void 0,
                  setInviteClicked: inviteClicked => {
                      chrome.storage.local.set({
                          inviteClicked
                      }), set({
                          inviteClicked
                      });
                  },
                  getShortcutConfigs: () => new Promise((resolve => {
                      const {shortcutHighLightedSites, shortcutIgnoreSites} = get();
                      shortcutHighLightedSites && shortcutIgnoreSites && resolve({
                          shortcutHighLightedSites,
                          shortcutIgnoreSites
                      }), content_script_sendMessage("get-shortcut-config", {}, "background").then((_config => {
                          const config = _config, res = {
                              shortcutHighLightedSites: config.SHOW_SHORTCUT,
                              shortcutIgnoreSites: config.HIDE_SHORTCUT
                          };
                          set(res), resolve(res);
                      }));
                  })),
                  setCheckCapture: checkCapture => set({
                      checkCapture
                  }),
                  setCanTranscribe: canTranscribe => set({
                      canTranscribe
                  }),
                  setMicrophoneEnabled: microphoneEnabled => set({
                      microphoneEnabled
                  }),
                  setHasExistSubtitles: hasExistSubtitles => set({
                      hasExistSubtitles
                  })
              };
          })), appConfig = useAppConfigStore;
          class GoogleTrans {
              constructor() {
                  defineProperty_defineProperty(this, "url", "https://translate.googleapis.com/translate_a/t"), 
                  defineProperty_defineProperty(this, "TKK", "448487.932609646"), defineProperty_defineProperty(this, "data", {
                      anno: "3",
                      client: "te",
                      v: "1.0",
                      format: "html",
                      sl: "auto",
                      tl: "",
                      tk: ""
                  });
              }
              construct_url() {
                  let base = this.url + "?";
                  for (const [key, value] of Object.entries(this.data)) base = Array.isArray(value) ? base + "dt=" + value.join("&dt=") + "&" : base + key + "=" + value + "&";
                  return base.slice(0, -1), base;
              }
              uo(a, b) {
                  for (let c = 0; c < b.length - 2; c += 3) {
                      let d = b.charAt(c + 2);
                      d = "a" <= d ? d.charCodeAt(0) - 87 : Number(d), d = "+" == b.charAt(c + 1) ? a >>> d : a << d, 
                      a = "+" == b.charAt(c) ? a + d & 4294967295 : a ^ d;
                  }
                  return a;
              }
              wo(a, tkk) {
                  const d = tkk.split("."), b = Number(d[0]), e = [];
                  for (let f = 0, g = 0; g < a.length; g++) {
                      let h = a.charCodeAt(g);
                      128 > h ? e[f++] = h : (2048 > h ? e[f++] = h >> 6 | 192 : (55296 == (64512 & h) && g + 1 < a.length && 56320 == (64512 & a.charCodeAt(g + 1)) ? (h = 65536 + ((1023 & h) << 10) + (1023 & a.charCodeAt(++g)), 
                      e[f++] = h >> 18 | 240, e[f++] = h >> 12 & 63 | 128) : e[f++] = h >> 12 | 224, e[f++] = h >> 6 & 63 | 128), 
                      e[f++] = 63 & h | 128);
                  }
                  let c = b;
                  for (let f = 0; f < e.length; f++) c += e[f], c = this.uo(c, "+-a^+6");
                  return c = this.uo(c, "+-3^+b+-f"), c ^= Number(d[1]) || 0, 0 > c && (c = 2147483648 + (2147483647 & c)), 
                  c %= 1e6, c.toString() + "." + (c ^ b);
              }
              async query(q, tl, sl) {
                  const controller = new AbortController, timer = setTimeout((() => controller.abort()), 500);
                  this.data.tk = this.wo(q, this.TKK), this.data.tl = tl, this.data.sl = sl || this.data.sl;
                  const url = this.construct_url(), response = await fetch(url, {
                      method: "POST",
                      headers: {
                          "Content-Type": "application/x-www-form-urlencoded"
                      },
                      body: `q=${encodeURIComponent(q)}`,
                      signal: controller.signal
                  });
                  if (clearTimeout(timer), 200 === response.status) {
                      const data = await response.json();
                      return (Array.isArray(data[0]) ? data[0][0] : data[0]).replaceAll(/<i>(.|\s)*?<\/i>/g, "").replaceAll(/<\/?b>/g, "").replaceAll(/&#39;/gi, "'");
                  }
                  {
                      const {status, statusText} = response;
                      throw new Error(JSON.stringify({
                          status,
                          statusText
                      }));
                  }
              }
          }
          function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
              return _classCheckPrivateStaticAccess(receiver, classConstructor), _classCheckPrivateStaticFieldDescriptor(descriptor, "set"), 
              function(receiver, descriptor, value) {
                  if (descriptor.set) descriptor.set.call(receiver, value); else {
                      if (!descriptor.writable) throw new TypeError("attempted to set read only private field");
                      descriptor.value = value;
                  }
              }(receiver, descriptor, value), value;
          }
          function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
              return _classCheckPrivateStaticAccess(receiver, classConstructor), _classCheckPrivateStaticFieldDescriptor(descriptor, "get"), 
              function(receiver, descriptor) {
                  if (descriptor.get) return descriptor.get.call(receiver);
                  return descriptor.value;
              }(receiver, descriptor);
          }
          function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
              if (void 0 === descriptor) throw new TypeError("attempted to " + action + " private static field before its declaration");
          }
          function _classCheckPrivateStaticAccess(receiver, classConstructor) {
              if (receiver !== classConstructor) throw new TypeError("Private static access of wrong provenance");
          }
          class BingTrans {
              constructor() {
                  defineProperty_defineProperty(this, "url", "https://api-edge.cognitive.microsofttranslator.com/translate?api-version=3.0&includeSentenceLength=true"), 
                  defineProperty_defineProperty(this, "data", {
                      from: "",
                      to: ""
                  });
              }
              construct_url() {
                  let base = this.url + "&";
                  for (const [key, value] of Object.entries(this.data)) base = base + key + "=" + value + "&";
                  return base.slice(0, -1), base;
              }
              async query(q, tl, sl) {
                  if (await BingHelper.findAuth(), !BingHelper.translateAuth) throw new Error(JSON.stringify({
                      status: 403,
                      statusText: "Unauthorized"
                  }));
                  sl && (this.data.from = sl), this.data.to = tl, "zh_hans" === tl && (this.data.to = "zh-Hans"), 
                  "zh_hant" === tl && (this.data.to = "zh-Hant"), this.url = this.construct_url();
                  const response = await fetch(this.url, {
                      method: "POST",
                      headers: {
                          "Content-Type": "application/json",
                          Authorization: "Bearer " + BingHelper.translateAuth
                      },
                      body: JSON.stringify([ {
                          Text: q
                      } ])
                  });
                  if (200 === response.status) {
                      return (await response.json())[0].translations[0].text;
                  }
                  {
                      const {status, statusText} = response;
                      throw new Error(JSON.stringify({
                          status,
                          statusText
                      }));
                  }
              }
          }
          class BingHelper {
              static get translateAuth() {
                  return _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _translateAuth);
              }
              static async findAuth() {
                  if (_classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _authPromise)) return await _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _authPromise);
                  _classStaticPrivateFieldSpecSet(BingHelper, BingHelper, _authPromise, new Promise((resolve => {
                      let updateBingAuth = !1;
                      if (_classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _lastRequestAuthTime)) {
                          const date = new Date;
                          _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _translateAuth) ? date.setMinutes(date.getMinutes() - 30) : _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _AuthNotFound) ? date.setMinutes(date.getMinutes() - 5) : date.setMinutes(date.getMinutes() - 2), 
                          date.getTime() > _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _lastRequestAuthTime) && (updateBingAuth = !0);
                      } else updateBingAuth = !0;
                      updateBingAuth ? (_classStaticPrivateFieldSpecSet(BingHelper, BingHelper, _lastRequestAuthTime, Date.now()), 
                      fetch("https://edge.microsoft.com/translate/auth").then((r => r.text())).then((token => {
                          _classStaticPrivateFieldSpecSet(BingHelper, BingHelper, _translateAuth, token), 
                          _classStaticPrivateFieldSpecSet(BingHelper, BingHelper, _AuthNotFound, !1);
                      })).catch((() => _classStaticPrivateFieldSpecSet(BingHelper, BingHelper, _AuthNotFound, !0))).finally(resolve)) : resolve();
                  }))), _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _authPromise).finally((() => {
                      _classStaticPrivateFieldSpecSet(BingHelper, BingHelper, _authPromise, null);
                  })), await _classStaticPrivateFieldSpecGet(BingHelper, BingHelper, _authPromise);
              }
          }
          var _lastRequestAuthTime = {
              writable: !0,
              value: null
          }, _translateAuth = {
              writable: !0,
              value: null
          }, _AuthNotFound = {
              writable: !0,
              value: !1
          }, _authPromise = {
              writable: !0,
              value: null
          };
          const config_version = "2.1.0", appId = "202211041038134050490941440", subtitleUrl = "https://subtitles.felo.me", logUrl = "https://log.felo.ai", FeloIDUrl = "https://account.felo.ai", userUrl = "https://user.felo.me";
          "prod" === "prod;" && (console.log = () => {});
          const _cbs = {};
          onMessage("callback-token", (async ({data}) => {
              console.log("get token :", data);
              const cbKey = data.cbKey;
              cbKey && _cbs[cbKey] && (_cbs[cbKey](data), delete _cbs[cbKey]);
          }));
          let subtitleToken_bizId = "";
          const getMQTTInfo = async (bizId, roomId) => {
              const subtitleInfo = await async function(roomId) {
                  return content_script_sendMessage("get-subtitle-token", {
                      roomId
                  }, "background");
              }(roomId);
              return console.log(subtitleInfo), subtitleInfo ? (subtitleInfo.bizId = bizId, subtitleInfo.appId = appId, 
              subtitleInfo.success = !0, subtitleInfo) : null;
          }, langFormator = {
              "zh-CN": "zh_hans",
              "en-US": "en",
              "ja-JP": "ja",
              "es-ES": "es",
              "de-DE": "de",
              "fr-FR": "fr",
              "it-IT": "it",
              "ru-RU": "ru",
              "ko-KR": "ko",
              "th-TH": "th",
              "nl-NL": "nl",
              "id-ID": "id",
              "pt-PT": "pt",
              "tr-TR": "tr",
              "uk-UA": "uk",
              "vi-VN": "vi",
              "hi-IN": "hi",
              zh: "zh_hans",
              en: "en",
              ja: "ja",
              es: "es",
              de: "de",
              fr: "fr",
              it: "it",
              ru: "ru",
              ko: "ko",
              th: "th",
              nl: "nl",
              id: "id",
              pt: "pt",
              tr: "tr",
              uk: "uk",
              vi: "vi",
              hi: "hi"
          }, getLimitTime = async () => {
              const rst = await content_script_sendMessage("get-limit-time", {}, "background");
              return console.log("@@getlimittime:", rst), rst;
          };
          const localLang = {
              zh: "zh_hans",
              "zh-CN": "zh_hans",
              "en-US": "en",
              "ja-JP": "ja",
              "es-ES": "es",
              "de-DE": "de",
              "fr-FR": "fr",
              "it-IT": "it",
              "ru-RU": "ru",
              "ko-KR": "ko",
              "th-TH": "th",
              "nl-NL": "nl",
              "id-ID": "id",
              "pt-PT": "pt",
              "tr-TR": "tr",
              "uk-UA": "uk",
              "vi-VN": "vi",
              "hi-IN": "hi",
              en: "en",
              ja: "ja",
              es: "es",
              de: "de",
              fr: "fr",
              it: "it",
              ru: "ru",
              ko: "ko",
              th: "th",
              nl: "nl",
              id: "id",
              pt: "pt",
              tr: "tr",
              uk: "uk",
              vi: "vi",
              hi: "hi"
          }[navigator.language] || "en";
          console.log("local lang", localLang);
          const getLocalData = key => new Promise((resolve => {
              chrome.storage.local.get([ key ], (rst => {
                  console.log("## useLocalInfo", rst, key), rst.length <= 0 ? resolve(!1) : key in rst ? (console.log("## 2useLocalInfo", rst), 
                  resolve(rst[key])) : (console.log("## 2useLocalInfo", rst), resolve(!1));
              }));
          })), saveLocalData = (key, newVal) => {
              const json = {};
              json[key] = newVal, chrome.storage.local.set(json, (() => {
                  console.log("## useLocalData save data succ", json);
              }));
          };
          const noSpaceSuffixLangs = [ "zh-Hans", "zh-Hant", "zh-CN", "zh-TW", "zh-HK", "zh", "zh-SG", "yue", "nan", "yue-HK", "nan-TW", "hak-TW", "hak", "ja", "ko", "th", "km", "lo", "my" ];
          async function getConverTranscript({transcriptLangOptionsWithLink}) {
              const rawTranscript = transcriptLangOptionsWithLink ? await async function(link) {
                  if (!link) return [];
                  const transcriptPageResponse = await fetch(link), transcriptPageXml = await transcriptPageResponse.text(), textNodes = function(htmlString) {
                      const template = document.createElement("template");
                      return template.innerHTML = htmlString.trim(), template.content.childNodes;
                  }(transcriptPageXml)[1].childNodes, texts = Array.from(textNodes).map((i => {
                      const element = i;
                      return {
                          start: Number(element.getAttribute("start")),
                          duration: Number(element.getAttribute("dur")),
                          text: element.textContent || ""
                      };
                  }));
                  return texts;
              }(transcriptLangOptionsWithLink[0]?.link) : [], cSubtitles = function(jsonResult, spaceSuffix) {
                  return jsonResult.reduce(((prevResult, nextItem, currentIndex) => {
                      0 === currentIndex && (prevResult = prevResult.concat(nextItem));
                      const prevItem = prevResult[prevResult.length - 1];
                      return nextItem.start < prevItem.start + prevItem.duration ? (prevItem.text += spaceSuffix + nextItem.text, 
                      prevResult) : prevResult.concat(nextItem);
                  }), []);
              }(rawTranscript, noSpaceSuffixLangs.includes(transcriptLangOptionsWithLink[0]?.language || "no-lang") ? "" : " ");
              return {
                  rawTranscript: cSubtitles,
                  lang: transcriptLangOptionsWithLink[0]?.languageCode
              };
          }
          const updateTranslateMessage = async ({targetLang, subtitleId, roomId, text}) => {
              if (!subtitleId) return !1;
              return await content_script_sendMessage("update-translate-message", {
                  lang: targetLang,
                  subtitle_id: subtitleId,
                  room_id: roomId,
                  text
              }, "background");
          };
          let transMethod = "Google";
          let isCheckEscape = !1;
          let translateStatus = {
              Google: {
                  available: !0,
                  errMsg: null
              },
              Bing: {
                  available: !0,
                  errMsg: null
              }
          };
          !async function() {
              const [googleStatus, googleErr] = await (new GoogleTrans).query("It's OK!", "en").then((() => [ !0, null ]), (error => [ !1, error ])), [bingStatus, bingErr] = await (new BingTrans).query("It's OK!", "en").then((() => [ !0, null ]), (error => [ !1, error ]));
              translateStatus = {
                  Google: {
                      available: googleStatus,
                      errMsg: googleErr
                  },
                  Bing: {
                      available: bingStatus,
                      errMsg: bingErr
                  }
              }, trackEvent({
                  event_type: "CheckEscape",
                  trigger_type: "Automatic",
                  trigger_control: "CheckGoogleAndBingAvailable",
                  Data: {
                      translateStatus
                  }
              });
          }();
          const createTranslate = method => "Google" === method && translateStatus.Google.available ? GoogleTrans : ("Bing" === method && translateStatus.Bing.available || trackEvent({
              event_type: "CheckEscape",
              trigger_type: "Automatic",
              trigger_control: "ServerMethodUnavailable",
              Data: {
                  translateStatus,
                  serverMethod: method
              }
          }), BingTrans), getSource = () => {
              const url = window.location.href;
              return url.includes("meet.google.com") ? [ "GOOGLE_MEET", !0, !1 ] : url.includes("teams.live.com") || url.includes("teams.microsoft.com") ? [ "TEAMS", !0, !1 ] : url.includes("zoom.us") ? [ "ZOOM", !0, !0 ] : url.includes("youtube.com") ? [ "YOUTUBE", !1, !1 ] : [ "OTHERS", !1, !0 ];
          }, useInfoStore = create(((set, get) => {
              const getTranslateConf = () => async function() {
                  const rst = await content_script_sendMessage("get-translate-config", {}, "background");
                  return {
                      translateAdapter: rst.translate_method,
                      checkEscape: rst.check_escape,
                      escapeMethod: rst.escape_method
                  };
              }().then((({translateAdapter, checkEscape, escapeMethod}) => (console.log(">>> get", translateAdapter, checkEscape, escapeMethod), 
              translateAdapter && set({
                  translateAdapter
              }), escapeMethod && (method => {
                  "MS" !== method && (transMethod = method);
              })(escapeMethod), set({
                  checkEscape
              }), isCheckEscape = checkEscape, {
                  translateAdapter,
                  checkEscape
              }))), [source, isMeet] = getSource();
              return {
                  title: document.title,
                  url: location.href,
                  source,
                  isMeet,
                  bizId: "",
                  roomId: "",
                  translateAdapter: "Google",
                  checkEscape: !1,
                  setBizId: bizId => set({
                      bizId
                  }),
                  getRoomId: () => {
                      getTranslateConf().then((res => {
                          console.log(">>>> get", res);
                      }));
                      const {bizId, title, source} = get();
                      return async function(data) {
                          return content_script_sendMessage("get-room", data, "background");
                      }({
                          biz_id: bizId,
                          room_name: title,
                          source,
                          source_url: window.location.href
                      }).then((res => (res.room_id && set({
                          roomId: res.room_id
                      }), res.room_id)));
                  },
                  getPageInfo: () => {
                      const [source, isMeet, needCapture] = getSource();
                      set({
                          title: document.title,
                          url: location.href,
                          source,
                          isMeet
                      }), needCapture && appConfig.getState().setCheckCapture(!0);
                  },
                  resetRoomId: () => set({
                      roomId: ""
                  }),
                  resetIds: () => set({
                      bizId: "",
                      roomId: ""
                  })
              };
          })), stores_info = useInfoStore, ua = ua_parser_default()();
          let localFpId = null;
          async function trackEvent(event) {
              const fpId = localFpId ?? await async function() {
                  const res = await getLocalData("uuid");
                  if (!res) {
                      const fp = self.crypto.randomUUID();
                      return saveLocalData("uuid", fp), localFpId = fp, fp;
                  }
                  return localFpId = res, res;
              }(), browserLanguage = navigator.language, {timeZone} = Intl.DateTimeFormat().resolvedOptions(), {url: current_url, source} = stores_info.getState(), data = {
                  browser_language: browserLanguage,
                  browser_type: ua.browser.name,
                  browser_version: ua.browser.major,
                  device_id: fpId,
                  event_time: Date.now(),
                  ext: JSON.stringify({
                      current_url,
                      source,
                      ...event
                  }),
                  os_type: ua.os.name,
                  report_application: "subtitle",
                  report_application_branch: "plugin",
                  report_application_version: config_version,
                  timezone: timeZone,
                  user_id: user.getState().info?.uid
              };
              try {
                  const response = await fetch(`${logUrl}/api/data/report`, {
                      method: "POST",
                      body: JSON.stringify(data)
                  });
                  response.ok || console.log("mark error", await response.text());
              } catch (error) {
                  console.log("mark error", error);
              }
          }
          const formatSeconds = seconds => {
              const totalSeconds = Math.round(seconds), hours = Math.floor(totalSeconds / 3600), minutes = Math.floor(totalSeconds % 3600 / 60), remainingSeconds = totalSeconds % 60;
              return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${remainingSeconds.toString().padStart(2, "0")}`;
          }, userConfig_initialValues = {
              translateLang: localLang,
              bothSubtitles: !1,
              autoSave: !1,
              showFloatingSwitch: !0
          }, useUserConfigStore = create(((set, get) => {
              const getConfig = () => new Promise((resolve => {
                  chrome.storage.local.get("userConfig", (items => {
                      console.log("Getted userconfig from local", items);
                      const nextConfig = {
                          ...get().config,
                          ...items.userConfig
                      };
                      set({
                          config: nextConfig
                      }), resolve(nextConfig);
                  }));
              })), setConfig = values => {
                  const nextConfig = {
                      ...get().config,
                      ...values
                  };
                  set({
                      config: nextConfig
                  }), chrome.storage.local.set({
                      userConfig: nextConfig
                  });
              };
              return onMessage("sync-config", (() => {
                  getConfig();
              })), getConfig(), {
                  config: {
                      ...userConfig_initialValues
                  },
                  shortcutIgnoreSites: [],
                  getConfig,
                  setTranslateLang: translateLang => setConfig({
                      translateLang
                  }),
                  setBothSubtitles: bothSubtitles => setConfig({
                      bothSubtitles
                  }),
                  setAutoSave: autoSave => setConfig({
                      autoSave
                  }),
                  setShowFloatingSwitch: showFloatingSwitch => setConfig({
                      showFloatingSwitch
                  }),
                  getShortcutIgnoreSites: () => new Promise((resolve => {
                      chrome.storage.local.get("userShortcutIgnoreSites", (items => {
                          items.userShortcutIgnoreSites ? (set({
                              shortcutIgnoreSites: items.userShortcutIgnoreSites
                          }), resolve(items.userShortcutIgnoreSites)) : resolve([]);
                      }));
                  })),
                  addShortcutIgnoreSite: value => {
                      const shortcutIgnoreSites = [ ...new Set([ ...get().shortcutIgnoreSites, value ]) ];
                      set({
                          shortcutIgnoreSites
                      }), chrome.storage.local.set({
                          userShortcutIgnoreSites: shortcutIgnoreSites
                      });
                  }
              };
          })), useBothSubtitles = () => useUserConfigStore((({config: {bothSubtitles}}) => bothSubtitles)), userConfig = useUserConfigStore, storeKeys = [ "bothSubtitles", "color", "fontSize", "opacity", "textShadow" ], initialStyleValues = {
              color: "default",
              fontSize: 20,
              opacity: 80,
              textShadow: "none"
          }, useUIConfigStore = create(((set, get) => {
              chrome.storage.local.get(storeKeys, (items => {
                  set(items);
              }));
              const getFloatingSwitchVisible = async () => {
                  if (sessionStorage.getItem("hideFloatingSwitch")) return;
                  const {getShortcutConfigs} = appConfig.getState(), {getConfig, getShortcutIgnoreSites} = userConfig.getState(), currentSiteConfig = (await getShortcutConfigs()).shortcutIgnoreSites.find((item => item.base_url === window.location.origin));
                  if (currentSiteConfig?.path_regex) {
                      if (new RegExp(currentSiteConfig.path_regex).test(window.location.pathname)) return;
                  } else if (currentSiteConfig) return;
                  if ((await getShortcutIgnoreSites()).includes(window.location.host)) return;
                  const {showFloatingSwitch} = await getConfig();
                  showFloatingSwitch && set({
                      floatingSwitchVisible: showFloatingSwitch
                  });
              }, getFloatingSwitchHighlight = async () => {
                  if (await chrome.runtime.sendMessage({
                      type: "is-shortcut-highlighted",
                      data: window.location.origin
                  })) return;
                  const {getShortcutConfigs} = appConfig.getState(), currentSiteConfig = (await getShortcutConfigs()).shortcutHighLightedSites.find((item => item.base_url === window.location.origin));
                  if (currentSiteConfig?.path_regex) {
                      new RegExp(currentSiteConfig.path_regex).test(window.location.pathname) && (set({
                          floatingSwitchHighlight: !0
                      }), chrome.runtime.sendMessage({
                          type: "set-shortcut-highlighted",
                          data: window.location.origin
                      }));
                  } else currentSiteConfig && (set({
                      floatingSwitchHighlight: !0
                  }), chrome.runtime.sendMessage({
                      type: "set-shortcut-highlighted",
                      data: window.location.origin
                  }));
              };
              getFloatingSwitchVisible(), getFloatingSwitchHighlight();
              const setWithStorage = (values, setStorage = !0) => {
                  set(values), setStorage && chrome.storage.local.set(values);
              };
              return {
                  floatingSwitchVisible: !1,
                  floatingSwitchHighlight: !1,
                  historyPopupVisible: !1,
                  visible: !1,
                  position: void 0,
                  size: void 0,
                  menuVisible: !1,
                  menuPosition: "bottom",
                  paused: !0,
                  limitVisible: !1,
                  mutedVisible: !1,
                  noCapture: !1,
                  connectBlocked: !1,
                  bothSubtitles: !1,
                  color: "default",
                  fontSize: 20,
                  opacity: 80,
                  textShadow: "none",
                  ...initialStyleValues,
                  getFloatingSwitchVisible,
                  getFloatingSwitchHighlight,
                  setFloatingSwitchVisible: floatingSwitchVisible => set({
                      floatingSwitchVisible
                  }),
                  setFloatingSwitchHighlight: floatingSwitchHighlight => set({
                      floatingSwitchHighlight
                  }),
                  setHistoryPopupVisible: historyPopupVisible => set({
                      historyPopupVisible
                  }),
                  setVisible: visible => set({
                      visible
                  }),
                  getPositionAndSize: prefix => {
                      const positionKey = `${prefix}Position`, sizeKey = `${prefix}Size`;
                      chrome.storage.local.get([ positionKey, sizeKey ]).then((values => {
                          const nextConfig = {};
                          positionKey in values && (nextConfig.position = values[positionKey]), sizeKey in values && (nextConfig.size = values[sizeKey]), 
                          set(nextConfig);
                      }));
                  },
                  setPosition: (prefix, position) => {
                      set({
                          position
                      }), chrome.storage.local.set({
                          [`${prefix}Position`]: position
                      });
                  },
                  setSize: (prefix, size) => {
                      set({
                          size
                      }), chrome.storage.local.set({
                          [`${prefix}Size`]: size
                      });
                  },
                  toggleMenuVisible: menuPosition => set({
                      menuVisible: !get().menuVisible,
                      menuPosition
                  }),
                  setPaused: paused => set({
                      paused
                  }),
                  setBothSubtitles: bothSubtitles => setWithStorage({
                      bothSubtitles
                  }),
                  setColor: color => setWithStorage({
                      color
                  }),
                  setFontSize: (fontSize, setStorage = !1) => setWithStorage({
                      fontSize
                  }, setStorage),
                  setOpacity: (opacity, setStorage = !1) => setWithStorage({
                      opacity
                  }, setStorage),
                  setTextShadow: textShadow => setWithStorage({
                      textShadow
                  }),
                  resetStyles: () => {
                      set(initialStyleValues), chrome.storage.local.remove(storeKeys);
                  }
              };
          })), useHistoryPopupVisible = () => useUIConfigStore((({historyPopupVisible}) => historyPopupVisible)), useVisible = () => useUIConfigStore((({visible}) => visible)), useMenuVisible = () => useUIConfigStore((({menuVisible}) => menuVisible)), usePaused = () => useUIConfigStore((({paused}) => paused)), useColor = () => useUIConfigStore((({color, setColor}) => ({
              color,
              setColor
          }))), useFontSize = () => useUIConfigStore((({fontSize, setFontSize}) => ({
              fontSize,
              setFontSize
          }))), useOpacity = () => useUIConfigStore((({opacity}) => opacity)), useTextShadow = () => useUIConfigStore((({textShadow, setTextShadow}) => ({
              textShadow,
              setTextShadow
          }))), uiConfig = useUIConfigStore, useLimitStore = create(((set, get) => {
              const decreaseTimer = {
                  timer: 0,
                  fn: () => {
                      const prevCount = get().count;
                      prevCount && (prevCount < 600 && uiConfig.setState({
                          limitVisible: !0
                      }), 1 === prevCount && (set({
                          limited: !0
                      }), window.postMessage({
                          type: "subtitle:pause"
                      })), set({
                          count: prevCount - 1
                      }));
                  },
                  start: () => {
                      console.log("paul start timer"), decreaseTimer.timer = window.setInterval(decreaseTimer.fn, 1e3);
                  },
                  stop: () => {
                      console.log("paul end timer"), window.clearInterval(decreaseTimer.timer), decreaseTimer.timer = 0;
                  }
              }, setError = () => {
                  void 0 === get().count && set({
                      errorMsg: "BALANCE_EMPTY"
                  });
              };
              return {
                  count: void 0,
                  countRef: void 0,
                  limited: void 0,
                  errorMsg: "",
                  getData: () => getLimitTime().then((count => {
                      if (!1 === count) throw setError(), new Error("BALANCE_EMPTY");
                      return set({
                          count,
                          countRef: count,
                          limited: 0 === count,
                          errorMsg: ""
                      }), uiConfig.setState({
                          limitVisible: count < 600
                      }), count;
                  })),
                  updateData: () => getLimitTime().then((nextCount => {
                      if (!1 === nextCount) throw setError(), new Error("BALANCE_EMPTY");
                      const {count, countRef} = get();
                      return void 0 !== count && void 0 !== countRef && (set({
                          count: nextCount - (countRef - count),
                          countRef: nextCount,
                          limited: 0 === nextCount,
                          errorMsg: ""
                      }), uiConfig.setState({
                          limitVisible: count < 600
                      })), count;
                  })),
                  checkData: () => getLimitTime().then((nextCount => {
                      if (!1 === nextCount) throw setError(), new Error("BALANCE_EMPTY");
                      0 === nextCount && (set({
                          count: 0,
                          limited: !0,
                          errorMsg: ""
                      }), window.postMessage({
                          type: "subtitle:pause"
                      }), uiConfig.setState({
                          limitVisible: !0
                      }));
                  })),
                  startTimer: decreaseTimer.start,
                  stopTimer: decreaseTimer.stop,
                  reset: () => {
                      set({
                          count: void 0,
                          countRef: void 0,
                          limited: void 0
                      });
                  }
              };
          })), useLimited = () => useLimitStore((({limited}) => limited)), limit = useLimitStore;
          var B, dayjs_min = __webpack_require__("./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/dayjs.min.js"), dayjs_min_default = __webpack_require__.n(dayjs_min), ps = Object.defineProperty, Kg = Object.getOwnPropertyDescriptor, Gg = Object.getOwnPropertyNames, Qg = Object.prototype.hasOwnProperty, we = (t, e) => () => (t && (e = t(t = 0)), 
          e), M = (t, e) => () => (e || t((e = {
              exports: {}
          }).exports, e), e.exports), Qt = (t, e) => {
              for (var r in e) ps(t, r, {
                  get: e[r],
                  enumerable: !0
              });
          }, X = t => ((t, e, r, i) => {
              if (e && "object" == typeof e || "function" == typeof e) for (let n of Gg(e)) !Qg.call(t, n) && n !== r && ps(t, n, {
                  get: () => e[n],
                  enumerable: !(i = Kg(e, n)) || i.enumerable
              });
              return t;
          })(ps({}, "__esModule", {
              value: !0
          }), t), _ = we((() => {
              B = {
                  deviceMemory: 8,
                  hardwareConcurrency: 8,
                  language: "en-US"
              };
          })), P = {};
          function bs(t) {
              throw new Error("Node.js process " + t + " is not supported by JSPM core outside of Node.js");
          }
          function Jg() {
              !xr || !Yt || (xr = !1, Yt.length ? bt = Yt.concat(bt) : Di = -1, bt.length && Bl());
          }
          function Bl() {
              if (!xr) {
                  var t = setTimeout(Jg, 0);
                  xr = !0;
                  for (var e = bt.length; e; ) {
                      for (Yt = bt, bt = []; ++Di < e; ) Yt && Yt[Di].run();
                      Di = -1, e = bt.length;
                  }
                  Yt = null, xr = !1, clearTimeout(t);
              }
          }
          function Pl(t) {
              var e = new Array(arguments.length - 1);
              if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
              bt.push(new Ol(t, e)), 1 === bt.length && !xr && setTimeout(Bl, 0);
          }
          function Ol(t, e) {
              this.fun = t, this.array = e;
          }
          function ve() {}
          function Gl(t) {
              bs("_linkedBinding");
          }
          function Xl(t) {
              bs("dlopen");
          }
          function Zl() {
              return [];
          }
          function eu() {
              return [];
          }
          function uu(t, e) {
              if (!t) throw new Error(e || "assertion error");
          }
          function du() {
              return !1;
          }
          function Pu() {
              return Lt.now() / 1e3;
          }
          function ji(t) {
              var e = Math.floor(.001 * (Date.now() - Lt.now())), r = .001 * Lt.now(), i = Math.floor(r) + e, n = Math.floor(r % 1 * 1e9);
              return t && (i -= t[0], (n -= t[1]) < 0 && (i--, n += ys)), [ i, n ];
          }
          function wt() {
              return $u;
          }
          function Wu(t) {
              return [];
          }
          Qt(P, {
              _debugEnd: () => yu,
              _debugProcess: () => gu,
              _events: () => ku,
              _eventsCount: () => xu,
              _exiting: () => Yl,
              _fatalExceptions: () => cu,
              _getActiveHandles: () => eu,
              _getActiveRequests: () => Zl,
              _kill: () => ru,
              _linkedBinding: () => Gl,
              _maxListeners: () => Ou,
              _preload_modules: () => Cu,
              _rawDebug: () => zl,
              _startProfilerIdleNotifier: () => bu,
              _stopProfilerIdleNotifier: () => wu,
              _tickCallback: () => pu,
              abort: () => Eu,
              addListener: () => Mu,
              allowedNodeEnvironmentFlags: () => lu,
              arch: () => xl,
              argv: () => Ul,
              argv0: () => Ru,
              assert: () => uu,
              binding: () => Fl,
              chdir: () => Hl,
              config: () => Jl,
              cpuUsage: () => Fi,
              cwd: () => $l,
              debugPort: () => Tu,
              default: () => $u,
              dlopen: () => Xl,
              domain: () => Ql,
              emit: () => Du,
              emitWarning: () => jl,
              env: () => Ll,
              execArgv: () => Nl,
              execPath: () => Iu,
              exit: () => ou,
              features: () => fu,
              hasUncaughtExceptionCaptureCallback: () => du,
              hrtime: () => ji,
              kill: () => su,
              listeners: () => Wu,
              memoryUsage: () => nu,
              moduleLoadList: () => Kl,
              nextTick: () => Pl,
              off: () => Uu,
              on: () => wt,
              once: () => Lu,
              openStdin: () => au,
              pid: () => Su,
              platform: () => Ml,
              ppid: () => Au,
              prependListener: () => ju,
              prependOnceListener: () => Fu,
              reallyExit: () => tu,
              release: () => Vl,
              removeAllListeners: () => qu,
              removeListener: () => Nu,
              resourceUsage: () => iu,
              setSourceMapsEnabled: () => Bu,
              setUncaughtExceptionCaptureCallback: () => hu,
              stderr: () => mu,
              stdin: () => vu,
              stdout: () => _u,
              title: () => kl,
              umask: () => Wl,
              uptime: () => Pu,
              version: () => ql,
              versions: () => Dl
          });
          var bt, xr, Yt, Di, kl, xl, Ml, Ll, Ul, Nl, ql, Dl, jl, Fl, Wl, $l, Hl, Vl, zl, Kl, Ql, Yl, Jl, tu, ru, Fi, iu, nu, su, ou, au, lu, fu, cu, hu, pu, gu, yu, bu, wu, _u, mu, vu, Eu, Su, Au, Iu, Tu, Ru, Cu, Bu, Lt, gs, ys, Ou, ku, xu, Mu, Lu, Uu, Nu, qu, Du, ju, Fu, $u, Hu = we((() => {
              v(), m(), _(), bt = [], xr = !1, Di = -1, Ol.prototype.run = function() {
                  this.fun.apply(null, this.array);
              }, kl = "browser", xl = "x64", Ml = "browser", Ll = {
                  PATH: "/usr/bin",
                  LANG: B.language + ".UTF-8",
                  PWD: "/",
                  HOME: "/home",
                  TMP: "/tmp"
              }, Ul = [ "/usr/bin/node" ], Nl = [], ql = "v16.8.0", Dl = {}, jl = function(t, e) {
                  console.warn((e ? e + ": " : "") + t);
              }, Fl = function(t) {
                  bs("binding");
              }, Wl = function(t) {
                  return 0;
              }, $l = function() {
                  return "/";
              }, Hl = function(t) {}, Vl = {
                  name: "node",
                  sourceUrl: "",
                  headersUrl: "",
                  libUrl: ""
              }, zl = ve, Kl = [], Ql = {}, Yl = !1, Jl = {}, tu = ve, ru = ve, iu = Fi = function() {
                  return {};
              }, nu = Fi, su = ve, ou = ve, au = ve, lu = {}, fu = {
                  inspector: !1,
                  debug: !1,
                  uv: !1,
                  ipv6: !1,
                  tls_alpn: !1,
                  tls_sni: !1,
                  tls_ocsp: !1,
                  tls: !1,
                  cached_builtins: !0
              }, cu = ve, hu = ve, pu = ve, gu = ve, yu = ve, bu = ve, wu = ve, _u = void 0, mu = void 0, 
              vu = void 0, Eu = ve, Su = 2, Au = 1, Iu = "/bin/usr/node", Tu = 9229, Ru = "node", 
              Cu = [], Bu = ve, void 0 === (Lt = {
                  now: typeof performance < "u" ? performance.now.bind(performance) : void 0,
                  timing: typeof performance < "u" ? performance.timing : void 0
              }).now && (gs = Date.now(), Lt.timing && Lt.timing.navigationStart && (gs = Lt.timing.navigationStart), 
              Lt.now = () => Date.now() - gs), ys = 1e9, ji.bigint = function(t) {
                  var e = ji(t);
                  return typeof BigInt > "u" ? e[0] * ys + e[1] : BigInt(e[0] * ys) + BigInt(e[1]);
              }, $u = {
                  version: ql,
                  versions: Dl,
                  arch: xl,
                  platform: Ml,
                  release: Vl,
                  _rawDebug: zl,
                  moduleLoadList: Kl,
                  binding: Fl,
                  _linkedBinding: Gl,
                  _events: ku = {},
                  _eventsCount: xu = 0,
                  _maxListeners: Ou = 10,
                  on: wt,
                  addListener: Mu = wt,
                  once: Lu = wt,
                  off: Uu = wt,
                  removeListener: Nu = wt,
                  removeAllListeners: qu = wt,
                  emit: Du = ve,
                  prependListener: ju = wt,
                  prependOnceListener: Fu = wt,
                  listeners: Wu,
                  domain: Ql,
                  _exiting: Yl,
                  config: Jl,
                  dlopen: Xl,
                  uptime: Pu,
                  _getActiveRequests: Zl,
                  _getActiveHandles: eu,
                  reallyExit: tu,
                  _kill: ru,
                  cpuUsage: Fi,
                  resourceUsage: iu,
                  memoryUsage: nu,
                  kill: su,
                  exit: ou,
                  openStdin: au,
                  allowedNodeEnvironmentFlags: lu,
                  assert: uu,
                  features: fu,
                  _fatalExceptions: cu,
                  setUncaughtExceptionCaptureCallback: hu,
                  hasUncaughtExceptionCaptureCallback: du,
                  emitWarning: jl,
                  nextTick: Pl,
                  _tickCallback: pu,
                  _debugProcess: gu,
                  _debugEnd: yu,
                  _startProfilerIdleNotifier: bu,
                  _stopProfilerIdleNotifier: wu,
                  stdout: _u,
                  stdin: vu,
                  stderr: mu,
                  abort: Eu,
                  umask: Wl,
                  chdir: Hl,
                  cwd: $l,
                  env: Ll,
                  title: kl,
                  argv: Ul,
                  execArgv: Nl,
                  pid: Su,
                  ppid: Au,
                  execPath: Iu,
                  debugPort: Tu,
                  hrtime: ji,
                  argv0: Ru,
                  _preload_modules: Cu,
                  setSourceMapsEnabled: Bu
              };
          })), m = we((() => {
              Hu();
          })), _e = {};
          function ey() {
              if (Ku) return Jt;
              Ku = !0;
              let t = function() {
                  if (Vu) return ui;
                  Vu = !0, ui.byteLength = function(y) {
                      var w = s(y), E = w[0], S = w[1];
                      return 3 * (E + S) / 4 - S;
                  }, ui.toByteArray = function(y) {
                      var w, N, E = s(y), S = E[0], I = E[1], C = new r(function(y, w, E) {
                          return 3 * (w + E) / 4 - E;
                      }(0, S, I)), R = 0, U = I > 0 ? S - 4 : S;
                      for (N = 0; N < U; N += 4) w = e[y.charCodeAt(N)] << 18 | e[y.charCodeAt(N + 1)] << 12 | e[y.charCodeAt(N + 2)] << 6 | e[y.charCodeAt(N + 3)], 
                      C[R++] = w >> 16 & 255, C[R++] = w >> 8 & 255, C[R++] = 255 & w;
                      return 2 === I && (w = e[y.charCodeAt(N)] << 2 | e[y.charCodeAt(N + 1)] >> 4, C[R++] = 255 & w), 
                      1 === I && (w = e[y.charCodeAt(N)] << 10 | e[y.charCodeAt(N + 1)] << 4 | e[y.charCodeAt(N + 2)] >> 2, 
                      C[R++] = w >> 8 & 255, C[R++] = 255 & w), C;
                  }, ui.fromByteArray = function(y) {
                      for (var w, E = y.length, S = E % 3, I = [], C = 16383, R = 0, U = E - S; R < U; R += C) I.push(d(y, R, R + C > U ? U : R + C));
                      return 1 === S ? (w = y[E - 1], I.push(t[w >> 2] + t[w << 4 & 63] + "==")) : 2 === S && (w = (y[E - 2] << 8) + y[E - 1], 
                      I.push(t[w >> 10] + t[w >> 4 & 63] + t[w << 2 & 63] + "=")), I.join("");
                  };
                  for (var t = [], e = [], r = typeof Uint8Array < "u" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0; n < 64; ++n) t[n] = i[n], 
                  e[i.charCodeAt(n)] = n;
                  function s(y) {
                      var w = y.length;
                      if (w % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                      var E = y.indexOf("=");
                      return -1 === E && (E = w), [ E, E === w ? 0 : 4 - E % 4 ];
                  }
                  function h(y) {
                      return t[y >> 18 & 63] + t[y >> 12 & 63] + t[y >> 6 & 63] + t[63 & y];
                  }
                  function d(y, w, E) {
                      for (var S, I = [], C = w; C < E; C += 3) S = (y[C] << 16 & 16711680) + (y[C + 1] << 8 & 65280) + (255 & y[C + 2]), 
                      I.push(h(S));
                      return I.join("");
                  }
                  return e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63, ui;
              }(), e = (zu || (zu = !0, Wi.read = function(t, e, r, i, n) {
                  var o, s, a = 8 * n - i - 1, u = (1 << a) - 1, c = u >> 1, h = -7, d = r ? n - 1 : 0, g = r ? -1 : 1, y = t[e + d];
                  for (d += g, o = y & (1 << -h) - 1, y >>= -h, h += a; h > 0; o = 256 * o + t[e + d], 
                  d += g, h -= 8) ;
                  for (s = o & (1 << -h) - 1, o >>= -h, h += i; h > 0; s = 256 * s + t[e + d], d += g, 
                  h -= 8) ;
                  if (0 === o) o = 1 - c; else {
                      if (o === u) return s ? NaN : 1 / 0 * (y ? -1 : 1);
                      s += Math.pow(2, i), o -= c;
                  }
                  return (y ? -1 : 1) * s * Math.pow(2, o - i);
              }, Wi.write = function(t, e, r, i, n, o) {
                  var s, a, u, c = 8 * o - n - 1, h = (1 << c) - 1, d = h >> 1, g = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = i ? 0 : o - 1, w = i ? 1 : -1, E = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e) / Math.LN2), 
                  e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (e += s + d >= 1 ? g / u : g * Math.pow(2, 1 - d)) * u >= 2 && (s++, 
                  u /= 2), s + d >= h ? (a = 0, s = h) : s + d >= 1 ? (a = (e * u - 1) * Math.pow(2, n), 
                  s += d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, n), s = 0)); n >= 8; t[r + y] = 255 & a, 
                  y += w, a /= 256, n -= 8) ;
                  for (s = s << n | a, c += n; c > 0; t[r + y] = 255 & s, y += w, s /= 256, c -= 8) ;
                  t[r + y - w] |= 128 * E;
              }), Wi), r = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
              Jt.Buffer = s, Jt.SlowBuffer = function(p) {
                  return +p != p && (p = 0), s.alloc(+p);
              }, Jt.INSPECT_MAX_BYTES = 50;
              let i = 2147483647;
              function o(p) {
                  if (p > i) throw new RangeError('The value "' + p + '" is invalid for option "size"');
                  let l = new Uint8Array(p);
                  return Object.setPrototypeOf(l, s.prototype), l;
              }
              function s(p, l, f) {
                  if ("number" == typeof p) {
                      if ("string" == typeof l) throw new TypeError('The "string" argument must be of type string. Received type number');
                      return h(p);
                  }
                  return a(p, l, f);
              }
              function a(p, l, f) {
                  if ("string" == typeof p) return function(p, l) {
                      if (("string" != typeof l || "" === l) && (l = "utf8"), !s.isEncoding(l)) throw new TypeError("Unknown encoding: " + l);
                      let f = 0 | C(p, l), b = o(f), A = b.write(p, l);
                      return A !== f && (b = b.slice(0, A)), b;
                  }(p, l);
                  if (ArrayBuffer.isView(p)) return function(p) {
                      if (Ye(p, Uint8Array)) {
                          let l = new Uint8Array(p);
                          return w(l.buffer, l.byteOffset, l.byteLength);
                      }
                      return g(p);
                  }(p);
                  if (null == p) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p);
                  if (Ye(p, ArrayBuffer) || p && Ye(p.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ye(p, SharedArrayBuffer) || p && Ye(p.buffer, SharedArrayBuffer))) return w(p, l, f);
                  if ("number" == typeof p) throw new TypeError('The "value" argument must not be of type number. Received type number');
                  let b = p.valueOf && p.valueOf();
                  if (null != b && b !== p) return s.from(b, l, f);
                  let A = function(p) {
                      if (s.isBuffer(p)) {
                          let l = 0 | S(p.length), f = o(l);
                          return 0 === f.length || p.copy(f, 0, 0, l), f;
                      }
                      if (void 0 !== p.length) return "number" != typeof p.length || ds(p.length) ? o(0) : g(p);
                      if ("Buffer" === p.type && Array.isArray(p.data)) return g(p.data);
                  }(p);
                  if (A) return A;
                  if (typeof Symbol < "u" && null != Symbol.toPrimitive && "function" == typeof p[Symbol.toPrimitive]) return s.from(p[Symbol.toPrimitive]("string"), l, f);
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p);
              }
              function u(p) {
                  if ("number" != typeof p) throw new TypeError('"size" argument must be of type number');
                  if (p < 0) throw new RangeError('The value "' + p + '" is invalid for option "size"');
              }
              function h(p) {
                  return u(p), o(p < 0 ? 0 : 0 | S(p));
              }
              function g(p) {
                  let l = p.length < 0 ? 0 : 0 | S(p.length), f = o(l);
                  for (let b = 0; b < l; b += 1) f[b] = 255 & p[b];
                  return f;
              }
              function w(p, l, f) {
                  if (l < 0 || p.byteLength < l) throw new RangeError('"offset" is outside of buffer bounds');
                  if (p.byteLength < l + (f || 0)) throw new RangeError('"length" is outside of buffer bounds');
                  let b;
                  return b = void 0 === l && void 0 === f ? new Uint8Array(p) : void 0 === f ? new Uint8Array(p, l) : new Uint8Array(p, l, f), 
                  Object.setPrototypeOf(b, s.prototype), b;
              }
              function S(p) {
                  if (p >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
                  return 0 | p;
              }
              function C(p, l) {
                  if (s.isBuffer(p)) return p.length;
                  if (ArrayBuffer.isView(p) || Ye(p, ArrayBuffer)) return p.byteLength;
                  if ("string" != typeof p) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof p);
                  let f = p.length, b = arguments.length > 2 && !0 === arguments[2];
                  if (!b && 0 === f) return 0;
                  let A = !1;
                  for (;;) switch (l) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return f;

                    case "utf8":
                    case "utf-8":
                      return hs(p).length;

                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return 2 * f;

                    case "hex":
                      return f >>> 1;

                    case "base64":
                      return Cl(p).length;

                    default:
                      if (A) return b ? -1 : hs(p).length;
                      l = ("" + l).toLowerCase(), A = !0;
                  }
              }
              function R(p, l, f) {
                  let b = !1;
                  if ((void 0 === l || l < 0) && (l = 0), l > this.length || ((void 0 === f || f > this.length) && (f = this.length), 
                  f <= 0) || (f >>>= 0) <= (l >>>= 0)) return "";
                  for (p || (p = "utf8"); ;) switch (p) {
                    case "hex":
                      return qg(this, l, f);

                    case "utf8":
                    case "utf-8":
                      return Cr(this, l, f);

                    case "ascii":
                      return fs(this, l, f);

                    case "latin1":
                    case "binary":
                      return Ng(this, l, f);

                    case "base64":
                      return pe(this, l, f);

                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return Dg(this, l, f);

                    default:
                      if (b) throw new TypeError("Unknown encoding: " + p);
                      p = (p + "").toLowerCase(), b = !0;
                  }
              }
              function U(p, l, f) {
                  let b = p[l];
                  p[l] = p[f], p[f] = b;
              }
              function N(p, l, f, b, A) {
                  if (0 === p.length) return -1;
                  if ("string" == typeof f ? (b = f, f = 0) : f > 2147483647 ? f = 2147483647 : f < -2147483648 && (f = -2147483648), 
                  ds(f = +f) && (f = A ? 0 : p.length - 1), f < 0 && (f = p.length + f), f >= p.length) {
                      if (A) return -1;
                      f = p.length - 1;
                  } else if (f < 0) {
                      if (!A) return -1;
                      f = 0;
                  }
                  if ("string" == typeof l && (l = s.from(l, b)), s.isBuffer(l)) return 0 === l.length ? -1 : W(p, l, f, b, A);
                  if ("number" == typeof l) return l &= 255, "function" == typeof Uint8Array.prototype.indexOf ? A ? Uint8Array.prototype.indexOf.call(p, l, f) : Uint8Array.prototype.lastIndexOf.call(p, l, f) : W(p, [ l ], f, b, A);
                  throw new TypeError("val must be string, number or Buffer");
              }
              function W(p, l, f, b, A) {
                  let te, T = 1, O = p.length, $ = l.length;
                  if (void 0 !== b && ("ucs2" === (b = String(b).toLowerCase()) || "ucs-2" === b || "utf16le" === b || "utf-16le" === b)) {
                      if (p.length < 2 || l.length < 2) return -1;
                      T = 2, O /= 2, $ /= 2, f /= 2;
                  }
                  function se(oe, J) {
                      return 1 === T ? oe[J] : oe.readUInt16BE(J * T);
                  }
                  if (A) {
                      let oe = -1;
                      for (te = f; te < O; te++) if (se(p, te) === se(l, -1 === oe ? 0 : te - oe)) {
                          if (-1 === oe && (oe = te), te - oe + 1 === $) return oe * T;
                      } else -1 !== oe && (te -= te - oe), oe = -1;
                  } else for (f + $ > O && (f = O - $), te = f; te >= 0; te--) {
                      let oe = !0;
                      for (let J = 0; J < $; J++) if (se(p, te + J) !== se(l, J)) {
                          oe = !1;
                          break;
                      }
                      if (oe) return te;
                  }
                  return -1;
              }
              function K(p, l, f, b) {
                  f = Number(f) || 0;
                  let A = p.length - f;
                  b ? (b = Number(b)) > A && (b = A) : b = A;
                  let O, T = l.length;
                  for (b > T / 2 && (b = T / 2), O = 0; O < b; ++O) {
                      let $ = parseInt(l.substr(2 * O, 2), 16);
                      if (ds($)) return O;
                      p[f + O] = $;
                  }
                  return O;
              }
              function z(p, l, f, b) {
                  return qi(hs(l, p.length - f), p, f, b);
              }
              function Q(p, l, f, b) {
                  return qi(function(p) {
                      let l = [];
                      for (let f = 0; f < p.length; ++f) l.push(255 & p.charCodeAt(f));
                      return l;
                  }(l), p, f, b);
              }
              function de(p, l, f, b) {
                  return qi(Cl(l), p, f, b);
              }
              function Gt(p, l, f, b) {
                  return qi(function(p, l) {
                      let f, b, A, T = [];
                      for (let O = 0; O < p.length && !((l -= 2) < 0); ++O) f = p.charCodeAt(O), b = f >> 8, 
                      A = f % 256, T.push(A), T.push(b);
                      return T;
                  }(l, p.length - f), p, f, b);
              }
              function pe(p, l, f) {
                  return 0 === l && f === p.length ? t.fromByteArray(p) : t.fromByteArray(p.slice(l, f));
              }
              function Cr(p, l, f) {
                  f = Math.min(p.length, f);
                  let b = [], A = l;
                  for (;A < f; ) {
                      let T = p[A], O = null, $ = T > 239 ? 4 : T > 223 ? 3 : T > 191 ? 2 : 1;
                      if (A + $ <= f) {
                          let se, te, oe, J;
                          switch ($) {
                            case 1:
                              T < 128 && (O = T);
                              break;

                            case 2:
                              se = p[A + 1], 128 == (192 & se) && (J = (31 & T) << 6 | 63 & se, J > 127 && (O = J));
                              break;

                            case 3:
                              se = p[A + 1], te = p[A + 2], 128 == (192 & se) && 128 == (192 & te) && (J = (15 & T) << 12 | (63 & se) << 6 | 63 & te, 
                              J > 2047 && (J < 55296 || J > 57343) && (O = J));
                              break;

                            case 4:
                              se = p[A + 1], te = p[A + 2], oe = p[A + 3], 128 == (192 & se) && 128 == (192 & te) && 128 == (192 & oe) && (J = (15 & T) << 18 | (63 & se) << 12 | (63 & te) << 6 | 63 & oe, 
                              J > 65535 && J < 1114112 && (O = J));
                          }
                      }
                      null === O ? (O = 65533, $ = 1) : O > 65535 && (O -= 65536, b.push(O >>> 10 & 1023 | 55296), 
                      O = 56320 | 1023 & O), b.push(O), A += $;
                  }
                  return function(p) {
                      let l = p.length;
                      if (l <= Br) return String.fromCharCode.apply(String, p);
                      let f = "", b = 0;
                      for (;b < l; ) f += String.fromCharCode.apply(String, p.slice(b, b += Br));
                      return f;
                  }(b);
              }
              Jt.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = function() {
                  try {
                      let p = new Uint8Array(1), l = {
                          foo: function() {
                              return 42;
                          }
                      };
                      return Object.setPrototypeOf(l, Uint8Array.prototype), Object.setPrototypeOf(p, l), 
                      42 === p.foo();
                  } catch {
                      return !1;
                  }
              }(), !s.TYPED_ARRAY_SUPPORT && typeof console < "u" && "function" == typeof console.error && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), 
              Object.defineProperty(s.prototype, "parent", {
                  enumerable: !0,
                  get: function() {
                      if (s.isBuffer(this)) return this.buffer;
                  }
              }), Object.defineProperty(s.prototype, "offset", {
                  enumerable: !0,
                  get: function() {
                      if (s.isBuffer(this)) return this.byteOffset;
                  }
              }), s.poolSize = 8192, s.from = function(p, l, f) {
                  return a(p, l, f);
              }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array), 
              s.alloc = function(p, l, f) {
                  return function(p, l, f) {
                      return u(p), p <= 0 ? o(p) : void 0 !== l ? "string" == typeof f ? o(p).fill(l, f) : o(p).fill(l) : o(p);
                  }(p, l, f);
              }, s.allocUnsafe = function(p) {
                  return h(p);
              }, s.allocUnsafeSlow = function(p) {
                  return h(p);
              }, s.isBuffer = function(l) {
                  return null != l && !0 === l._isBuffer && l !== s.prototype;
              }, s.compare = function(l, f) {
                  if (Ye(l, Uint8Array) && (l = s.from(l, l.offset, l.byteLength)), Ye(f, Uint8Array) && (f = s.from(f, f.offset, f.byteLength)), 
                  !s.isBuffer(l) || !s.isBuffer(f)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                  if (l === f) return 0;
                  let b = l.length, A = f.length;
                  for (let T = 0, O = Math.min(b, A); T < O; ++T) if (l[T] !== f[T]) {
                      b = l[T], A = f[T];
                      break;
                  }
                  return b < A ? -1 : A < b ? 1 : 0;
              }, s.isEncoding = function(l) {
                  switch (String(l).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return !0;

                    default:
                      return !1;
                  }
              }, s.concat = function(l, f) {
                  if (!Array.isArray(l)) throw new TypeError('"list" argument must be an Array of Buffers');
                  if (0 === l.length) return s.alloc(0);
                  let b;
                  if (void 0 === f) for (f = 0, b = 0; b < l.length; ++b) f += l[b].length;
                  let A = s.allocUnsafe(f), T = 0;
                  for (b = 0; b < l.length; ++b) {
                      let O = l[b];
                      if (Ye(O, Uint8Array)) T + O.length > A.length ? (s.isBuffer(O) || (O = s.from(O)), 
                      O.copy(A, T)) : Uint8Array.prototype.set.call(A, O, T); else {
                          if (!s.isBuffer(O)) throw new TypeError('"list" argument must be an Array of Buffers');
                          O.copy(A, T);
                      }
                      T += O.length;
                  }
                  return A;
              }, s.byteLength = C, s.prototype._isBuffer = !0, s.prototype.swap16 = function() {
                  let l = this.length;
                  if (l % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                  for (let f = 0; f < l; f += 2) U(this, f, f + 1);
                  return this;
              }, s.prototype.swap32 = function() {
                  let l = this.length;
                  if (l % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                  for (let f = 0; f < l; f += 4) U(this, f, f + 3), U(this, f + 1, f + 2);
                  return this;
              }, s.prototype.swap64 = function() {
                  let l = this.length;
                  if (l % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                  for (let f = 0; f < l; f += 8) U(this, f, f + 7), U(this, f + 1, f + 6), U(this, f + 2, f + 5), 
                  U(this, f + 3, f + 4);
                  return this;
              }, s.prototype.toString = function() {
                  let l = this.length;
                  return 0 === l ? "" : 0 === arguments.length ? Cr(this, 0, l) : R.apply(this, arguments);
              }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(l) {
                  if (!s.isBuffer(l)) throw new TypeError("Argument must be a Buffer");
                  return this === l || 0 === s.compare(this, l);
              }, s.prototype.inspect = function() {
                  let l = "", f = Jt.INSPECT_MAX_BYTES;
                  return l = this.toString("hex", 0, f).replace(/(.{2})/g, "$1 ").trim(), this.length > f && (l += " ... "), 
                  "<Buffer " + l + ">";
              }, r && (s.prototype[r] = s.prototype.inspect), s.prototype.compare = function(l, f, b, A, T) {
                  if (Ye(l, Uint8Array) && (l = s.from(l, l.offset, l.byteLength)), !s.isBuffer(l)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof l);
                  if (void 0 === f && (f = 0), void 0 === b && (b = l ? l.length : 0), void 0 === A && (A = 0), 
                  void 0 === T && (T = this.length), f < 0 || b > l.length || A < 0 || T > this.length) throw new RangeError("out of range index");
                  if (A >= T && f >= b) return 0;
                  if (A >= T) return -1;
                  if (f >= b) return 1;
                  if (this === l) return 0;
                  let O = (T >>>= 0) - (A >>>= 0), $ = (b >>>= 0) - (f >>>= 0), se = Math.min(O, $), te = this.slice(A, T), oe = l.slice(f, b);
                  for (let J = 0; J < se; ++J) if (te[J] !== oe[J]) {
                      O = te[J], $ = oe[J];
                      break;
                  }
                  return O < $ ? -1 : $ < O ? 1 : 0;
              }, s.prototype.includes = function(l, f, b) {
                  return -1 !== this.indexOf(l, f, b);
              }, s.prototype.indexOf = function(l, f, b) {
                  return N(this, l, f, b, !0);
              }, s.prototype.lastIndexOf = function(l, f, b) {
                  return N(this, l, f, b, !1);
              }, s.prototype.write = function(l, f, b, A) {
                  if (void 0 === f) A = "utf8", b = this.length, f = 0; else if (void 0 === b && "string" == typeof f) A = f, 
                  b = this.length, f = 0; else {
                      if (!isFinite(f)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                      f >>>= 0, isFinite(b) ? (b >>>= 0, void 0 === A && (A = "utf8")) : (A = b, b = void 0);
                  }
                  let T = this.length - f;
                  if ((void 0 === b || b > T) && (b = T), l.length > 0 && (b < 0 || f < 0) || f > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                  A || (A = "utf8");
                  let O = !1;
                  for (;;) switch (A) {
                    case "hex":
                      return K(this, l, f, b);

                    case "utf8":
                    case "utf-8":
                      return z(this, l, f, b);

                    case "ascii":
                    case "latin1":
                    case "binary":
                      return Q(this, l, f, b);

                    case "base64":
                      return de(this, l, f, b);

                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return Gt(this, l, f, b);

                    default:
                      if (O) throw new TypeError("Unknown encoding: " + A);
                      A = ("" + A).toLowerCase(), O = !0;
                  }
              }, s.prototype.toJSON = function() {
                  return {
                      type: "Buffer",
                      data: Array.prototype.slice.call(this._arr || this, 0)
                  };
              };
              let Br = 4096;
              function fs(p, l, f) {
                  let b = "";
                  f = Math.min(p.length, f);
                  for (let A = l; A < f; ++A) b += String.fromCharCode(127 & p[A]);
                  return b;
              }
              function Ng(p, l, f) {
                  let b = "";
                  f = Math.min(p.length, f);
                  for (let A = l; A < f; ++A) b += String.fromCharCode(p[A]);
                  return b;
              }
              function qg(p, l, f) {
                  let b = p.length;
                  (!l || l < 0) && (l = 0), (!f || f < 0 || f > b) && (f = b);
                  let A = "";
                  for (let T = l; T < f; ++T) A += Vg[p[T]];
                  return A;
              }
              function Dg(p, l, f) {
                  let b = p.slice(l, f), A = "";
                  for (let T = 0; T < b.length - 1; T += 2) A += String.fromCharCode(b[T] + 256 * b[T + 1]);
                  return A;
              }
              function ge(p, l, f) {
                  if (p % 1 != 0 || p < 0) throw new RangeError("offset is not uint");
                  if (p + l > f) throw new RangeError("Trying to access beyond buffer length");
              }
              function Ce(p, l, f, b, A, T) {
                  if (!s.isBuffer(p)) throw new TypeError('"buffer" argument must be a Buffer instance');
                  if (l > A || l < T) throw new RangeError('"value" argument is out of bounds');
                  if (f + b > p.length) throw new RangeError("Index out of range");
              }
              function vl(p, l, f, b, A) {
                  Rl(l, b, A, p, f, 7);
                  let T = Number(l & BigInt(4294967295));
                  p[f++] = T, T >>= 8, p[f++] = T, T >>= 8, p[f++] = T, T >>= 8, p[f++] = T;
                  let O = Number(l >> BigInt(32) & BigInt(4294967295));
                  return p[f++] = O, O >>= 8, p[f++] = O, O >>= 8, p[f++] = O, O >>= 8, p[f++] = O, 
                  f;
              }
              function El(p, l, f, b, A) {
                  Rl(l, b, A, p, f, 7);
                  let T = Number(l & BigInt(4294967295));
                  p[f + 7] = T, T >>= 8, p[f + 6] = T, T >>= 8, p[f + 5] = T, T >>= 8, p[f + 4] = T;
                  let O = Number(l >> BigInt(32) & BigInt(4294967295));
                  return p[f + 3] = O, O >>= 8, p[f + 2] = O, O >>= 8, p[f + 1] = O, O >>= 8, p[f] = O, 
                  f + 8;
              }
              function Sl(p, l, f, b, A, T) {
                  if (f + b > p.length) throw new RangeError("Index out of range");
                  if (f < 0) throw new RangeError("Index out of range");
              }
              function Al(p, l, f, b, A) {
                  return l = +l, f >>>= 0, A || Sl(p, 0, f, 4), e.write(p, l, f, b, 23, 4), f + 4;
              }
              function Il(p, l, f, b, A) {
                  return l = +l, f >>>= 0, A || Sl(p, 0, f, 8), e.write(p, l, f, b, 52, 8), f + 8;
              }
              s.prototype.slice = function(l, f) {
                  let b = this.length;
                  (l = ~~l) < 0 ? (l += b) < 0 && (l = 0) : l > b && (l = b), (f = void 0 === f ? b : ~~f) < 0 ? (f += b) < 0 && (f = 0) : f > b && (f = b), 
                  f < l && (f = l);
                  let A = this.subarray(l, f);
                  return Object.setPrototypeOf(A, s.prototype), A;
              }, s.prototype.readUintLE = s.prototype.readUIntLE = function(l, f, b) {
                  l >>>= 0, f >>>= 0, b || ge(l, f, this.length);
                  let A = this[l], T = 1, O = 0;
                  for (;++O < f && (T *= 256); ) A += this[l + O] * T;
                  return A;
              }, s.prototype.readUintBE = s.prototype.readUIntBE = function(l, f, b) {
                  l >>>= 0, f >>>= 0, b || ge(l, f, this.length);
                  let A = this[l + --f], T = 1;
                  for (;f > 0 && (T *= 256); ) A += this[l + --f] * T;
                  return A;
              }, s.prototype.readUint8 = s.prototype.readUInt8 = function(l, f) {
                  return l >>>= 0, f || ge(l, 1, this.length), this[l];
              }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(l, f) {
                  return l >>>= 0, f || ge(l, 2, this.length), this[l] | this[l + 1] << 8;
              }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(l, f) {
                  return l >>>= 0, f || ge(l, 2, this.length), this[l] << 8 | this[l + 1];
              }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(l, f) {
                  return l >>>= 0, f || ge(l, 4, this.length), (this[l] | this[l + 1] << 8 | this[l + 2] << 16) + 16777216 * this[l + 3];
              }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(l, f) {
                  return l >>>= 0, f || ge(l, 4, this.length), 16777216 * this[l] + (this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3]);
              }, s.prototype.readBigUInt64LE = Mt((function(l) {
                  kr(l >>>= 0, "offset");
                  let f = this[l], b = this[l + 7];
                  (void 0 === f || void 0 === b) && li(l, this.length - 8);
                  let A = f + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24, T = this[++l] + 256 * this[++l] + 65536 * this[++l] + b * 2 ** 24;
                  return BigInt(A) + (BigInt(T) << BigInt(32));
              })), s.prototype.readBigUInt64BE = Mt((function(l) {
                  kr(l >>>= 0, "offset");
                  let f = this[l], b = this[l + 7];
                  (void 0 === f || void 0 === b) && li(l, this.length - 8);
                  let A = f * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + this[++l], T = this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b;
                  return (BigInt(A) << BigInt(32)) + BigInt(T);
              })), s.prototype.readIntLE = function(l, f, b) {
                  l >>>= 0, f >>>= 0, b || ge(l, f, this.length);
                  let A = this[l], T = 1, O = 0;
                  for (;++O < f && (T *= 256); ) A += this[l + O] * T;
                  return T *= 128, A >= T && (A -= Math.pow(2, 8 * f)), A;
              }, s.prototype.readIntBE = function(l, f, b) {
                  l >>>= 0, f >>>= 0, b || ge(l, f, this.length);
                  let A = f, T = 1, O = this[l + --A];
                  for (;A > 0 && (T *= 256); ) O += this[l + --A] * T;
                  return T *= 128, O >= T && (O -= Math.pow(2, 8 * f)), O;
              }, s.prototype.readInt8 = function(l, f) {
                  return l >>>= 0, f || ge(l, 1, this.length), 128 & this[l] ? -1 * (255 - this[l] + 1) : this[l];
              }, s.prototype.readInt16LE = function(l, f) {
                  l >>>= 0, f || ge(l, 2, this.length);
                  let b = this[l] | this[l + 1] << 8;
                  return 32768 & b ? 4294901760 | b : b;
              }, s.prototype.readInt16BE = function(l, f) {
                  l >>>= 0, f || ge(l, 2, this.length);
                  let b = this[l + 1] | this[l] << 8;
                  return 32768 & b ? 4294901760 | b : b;
              }, s.prototype.readInt32LE = function(l, f) {
                  return l >>>= 0, f || ge(l, 4, this.length), this[l] | this[l + 1] << 8 | this[l + 2] << 16 | this[l + 3] << 24;
              }, s.prototype.readInt32BE = function(l, f) {
                  return l >>>= 0, f || ge(l, 4, this.length), this[l] << 24 | this[l + 1] << 16 | this[l + 2] << 8 | this[l + 3];
              }, s.prototype.readBigInt64LE = Mt((function(l) {
                  kr(l >>>= 0, "offset");
                  let f = this[l], b = this[l + 7];
                  (void 0 === f || void 0 === b) && li(l, this.length - 8);
                  let A = this[l + 4] + 256 * this[l + 5] + 65536 * this[l + 6] + (b << 24);
                  return (BigInt(A) << BigInt(32)) + BigInt(f + 256 * this[++l] + 65536 * this[++l] + this[++l] * 2 ** 24);
              })), s.prototype.readBigInt64BE = Mt((function(l) {
                  kr(l >>>= 0, "offset");
                  let f = this[l], b = this[l + 7];
                  (void 0 === f || void 0 === b) && li(l, this.length - 8);
                  let A = (f << 24) + 65536 * this[++l] + 256 * this[++l] + this[++l];
                  return (BigInt(A) << BigInt(32)) + BigInt(this[++l] * 2 ** 24 + 65536 * this[++l] + 256 * this[++l] + b);
              })), s.prototype.readFloatLE = function(l, f) {
                  return l >>>= 0, f || ge(l, 4, this.length), e.read(this, l, !0, 23, 4);
              }, s.prototype.readFloatBE = function(l, f) {
                  return l >>>= 0, f || ge(l, 4, this.length), e.read(this, l, !1, 23, 4);
              }, s.prototype.readDoubleLE = function(l, f) {
                  return l >>>= 0, f || ge(l, 8, this.length), e.read(this, l, !0, 52, 8);
              }, s.prototype.readDoubleBE = function(l, f) {
                  return l >>>= 0, f || ge(l, 8, this.length), e.read(this, l, !1, 52, 8);
              }, s.prototype.writeUintLE = s.prototype.writeUIntLE = function(l, f, b, A) {
                  if (l = +l, f >>>= 0, b >>>= 0, !A) {
                      Ce(this, l, f, b, Math.pow(2, 8 * b) - 1, 0);
                  }
                  let T = 1, O = 0;
                  for (this[f] = 255 & l; ++O < b && (T *= 256); ) this[f + O] = l / T & 255;
                  return f + b;
              }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(l, f, b, A) {
                  if (l = +l, f >>>= 0, b >>>= 0, !A) {
                      Ce(this, l, f, b, Math.pow(2, 8 * b) - 1, 0);
                  }
                  let T = b - 1, O = 1;
                  for (this[f + T] = 255 & l; --T >= 0 && (O *= 256); ) this[f + T] = l / O & 255;
                  return f + b;
              }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 1, 255, 0), this[f] = 255 & l, f + 1;
              }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 2, 65535, 0), this[f] = 255 & l, this[f + 1] = l >>> 8, 
                  f + 2;
              }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 2, 65535, 0), this[f] = l >>> 8, this[f + 1] = 255 & l, 
                  f + 2;
              }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 4, 4294967295, 0), this[f + 3] = l >>> 24, 
                  this[f + 2] = l >>> 16, this[f + 1] = l >>> 8, this[f] = 255 & l, f + 4;
              }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 4, 4294967295, 0), this[f] = l >>> 24, 
                  this[f + 1] = l >>> 16, this[f + 2] = l >>> 8, this[f + 3] = 255 & l, f + 4;
              }, s.prototype.writeBigUInt64LE = Mt((function(l, f = 0) {
                  return vl(this, l, f, BigInt(0), BigInt("0xffffffffffffffff"));
              })), s.prototype.writeBigUInt64BE = Mt((function(l, f = 0) {
                  return El(this, l, f, BigInt(0), BigInt("0xffffffffffffffff"));
              })), s.prototype.writeIntLE = function(l, f, b, A) {
                  if (l = +l, f >>>= 0, !A) {
                      let se = Math.pow(2, 8 * b - 1);
                      Ce(this, l, f, b, se - 1, -se);
                  }
                  let T = 0, O = 1, $ = 0;
                  for (this[f] = 255 & l; ++T < b && (O *= 256); ) l < 0 && 0 === $ && 0 !== this[f + T - 1] && ($ = 1), 
                  this[f + T] = (l / O >> 0) - $ & 255;
                  return f + b;
              }, s.prototype.writeIntBE = function(l, f, b, A) {
                  if (l = +l, f >>>= 0, !A) {
                      let se = Math.pow(2, 8 * b - 1);
                      Ce(this, l, f, b, se - 1, -se);
                  }
                  let T = b - 1, O = 1, $ = 0;
                  for (this[f + T] = 255 & l; --T >= 0 && (O *= 256); ) l < 0 && 0 === $ && 0 !== this[f + T + 1] && ($ = 1), 
                  this[f + T] = (l / O >> 0) - $ & 255;
                  return f + b;
              }, s.prototype.writeInt8 = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 1, 127, -128), l < 0 && (l = 255 + l + 1), 
                  this[f] = 255 & l, f + 1;
              }, s.prototype.writeInt16LE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 2, 32767, -32768), this[f] = 255 & l, 
                  this[f + 1] = l >>> 8, f + 2;
              }, s.prototype.writeInt16BE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 2, 32767, -32768), this[f] = l >>> 8, 
                  this[f + 1] = 255 & l, f + 2;
              }, s.prototype.writeInt32LE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 4, 2147483647, -2147483648), this[f] = 255 & l, 
                  this[f + 1] = l >>> 8, this[f + 2] = l >>> 16, this[f + 3] = l >>> 24, f + 4;
              }, s.prototype.writeInt32BE = function(l, f, b) {
                  return l = +l, f >>>= 0, b || Ce(this, l, f, 4, 2147483647, -2147483648), l < 0 && (l = 4294967295 + l + 1), 
                  this[f] = l >>> 24, this[f + 1] = l >>> 16, this[f + 2] = l >>> 8, this[f + 3] = 255 & l, 
                  f + 4;
              }, s.prototype.writeBigInt64LE = Mt((function(l, f = 0) {
                  return vl(this, l, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
              })), s.prototype.writeBigInt64BE = Mt((function(l, f = 0) {
                  return El(this, l, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
              })), s.prototype.writeFloatLE = function(l, f, b) {
                  return Al(this, l, f, !0, b);
              }, s.prototype.writeFloatBE = function(l, f, b) {
                  return Al(this, l, f, !1, b);
              }, s.prototype.writeDoubleLE = function(l, f, b) {
                  return Il(this, l, f, !0, b);
              }, s.prototype.writeDoubleBE = function(l, f, b) {
                  return Il(this, l, f, !1, b);
              }, s.prototype.copy = function(l, f, b, A) {
                  if (!s.isBuffer(l)) throw new TypeError("argument should be a Buffer");
                  if (b || (b = 0), !A && 0 !== A && (A = this.length), f >= l.length && (f = l.length), 
                  f || (f = 0), A > 0 && A < b && (A = b), A === b || 0 === l.length || 0 === this.length) return 0;
                  if (f < 0) throw new RangeError("targetStart out of bounds");
                  if (b < 0 || b >= this.length) throw new RangeError("Index out of range");
                  if (A < 0) throw new RangeError("sourceEnd out of bounds");
                  A > this.length && (A = this.length), l.length - f < A - b && (A = l.length - f + b);
                  let T = A - b;
                  return this === l && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(f, b, A) : Uint8Array.prototype.set.call(l, this.subarray(b, A), f), 
                  T;
              }, s.prototype.fill = function(l, f, b, A) {
                  if ("string" == typeof l) {
                      if ("string" == typeof f ? (A = f, f = 0, b = this.length) : "string" == typeof b && (A = b, 
                      b = this.length), void 0 !== A && "string" != typeof A) throw new TypeError("encoding must be a string");
                      if ("string" == typeof A && !s.isEncoding(A)) throw new TypeError("Unknown encoding: " + A);
                      if (1 === l.length) {
                          let O = l.charCodeAt(0);
                          ("utf8" === A && O < 128 || "latin1" === A) && (l = O);
                      }
                  } else "number" == typeof l ? l &= 255 : "boolean" == typeof l && (l = Number(l));
                  if (f < 0 || this.length < f || this.length < b) throw new RangeError("Out of range index");
                  if (b <= f) return this;
                  let T;
                  if (f >>>= 0, b = void 0 === b ? this.length : b >>> 0, l || (l = 0), "number" == typeof l) for (T = f; T < b; ++T) this[T] = l; else {
                      let O = s.isBuffer(l) ? l : s.from(l, A), $ = O.length;
                      if (0 === $) throw new TypeError('The value "' + l + '" is invalid for argument "value"');
                      for (T = 0; T < b - f; ++T) this[T + f] = O[T % $];
                  }
                  return this;
              };
              let Or = {};
              function cs(p, l, f) {
                  Or[p] = class extends f {
                      constructor() {
                          super(), Object.defineProperty(this, "message", {
                              value: l.apply(this, arguments),
                              writable: !0,
                              configurable: !0
                          }), this.name = `${this.name} [${p}]`, this.stack, delete this.name;
                      }
                      get code() {
                          return p;
                      }
                      set code(A) {
                          Object.defineProperty(this, "code", {
                              configurable: !0,
                              enumerable: !0,
                              value: A,
                              writable: !0
                          });
                      }
                      toString() {
                          return `${this.name} [${p}]: ${this.message}`;
                      }
                  };
              }
              function Tl(p) {
                  let l = "", f = p.length, b = "-" === p[0] ? 1 : 0;
                  for (;f >= b + 4; f -= 3) l = `_${p.slice(f - 3, f)}${l}`;
                  return `${p.slice(0, f)}${l}`;
              }
              function Rl(p, l, f, b, A, T) {
                  if (p > f || p < l) {
                      let $, O = "bigint" == typeof l ? "n" : "";
                      throw $ = T > 3 ? 0 === l || l === BigInt(0) ? `>= 0${O} and < 2${O} ** ${8 * (T + 1)}${O}` : `>= -(2${O} ** ${8 * (T + 1) - 1}${O}) and < 2 ** ${8 * (T + 1) - 1}${O}` : `>= ${l}${O} and <= ${f}${O}`, 
                      new Or.ERR_OUT_OF_RANGE("value", $, p);
                  }
                  !function(p, l, f) {
                      kr(l, "offset"), (void 0 === p[l] || void 0 === p[l + f]) && li(l, p.length - (f + 1));
                  }(b, A, T);
              }
              function kr(p, l) {
                  if ("number" != typeof p) throw new Or.ERR_INVALID_ARG_TYPE(l, "number", p);
              }
              function li(p, l, f) {
                  throw Math.floor(p) !== p ? (kr(p, f), new Or.ERR_OUT_OF_RANGE(f || "offset", "an integer", p)) : l < 0 ? new Or.ERR_BUFFER_OUT_OF_BOUNDS : new Or.ERR_OUT_OF_RANGE(f || "offset", `>= ${f ? 1 : 0} and <= ${l}`, p);
              }
              cs("ERR_BUFFER_OUT_OF_BOUNDS", (function(p) {
                  return p ? `${p} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
              }), RangeError), cs("ERR_INVALID_ARG_TYPE", (function(p, l) {
                  return `The "${p}" argument must be of type number. Received type ${typeof l}`;
              }), TypeError), cs("ERR_OUT_OF_RANGE", (function(p, l, f) {
                  let b = `The value of "${p}" is out of range.`, A = f;
                  return Number.isInteger(f) && Math.abs(f) > 2 ** 32 ? A = Tl(String(f)) : "bigint" == typeof f && (A = String(f), 
                  (f > BigInt(2) ** BigInt(32) || f < -(BigInt(2) ** BigInt(32))) && (A = Tl(A)), 
                  A += "n"), b += ` It must be ${l}. Received ${A}`, b;
              }), RangeError);
              let Fg = /[^+/0-9A-Za-z-_]/g;
              function hs(p, l) {
                  l = l || 1 / 0;
                  let f, b = p.length, A = null, T = [];
                  for (let O = 0; O < b; ++O) {
                      if (f = p.charCodeAt(O), f > 55295 && f < 57344) {
                          if (!A) {
                              if (f > 56319) {
                                  (l -= 3) > -1 && T.push(239, 191, 189);
                                  continue;
                              }
                              if (O + 1 === b) {
                                  (l -= 3) > -1 && T.push(239, 191, 189);
                                  continue;
                              }
                              A = f;
                              continue;
                          }
                          if (f < 56320) {
                              (l -= 3) > -1 && T.push(239, 191, 189), A = f;
                              continue;
                          }
                          f = 65536 + (A - 55296 << 10 | f - 56320);
                      } else A && (l -= 3) > -1 && T.push(239, 191, 189);
                      if (A = null, f < 128) {
                          if ((l -= 1) < 0) break;
                          T.push(f);
                      } else if (f < 2048) {
                          if ((l -= 2) < 0) break;
                          T.push(f >> 6 | 192, 63 & f | 128);
                      } else if (f < 65536) {
                          if ((l -= 3) < 0) break;
                          T.push(f >> 12 | 224, f >> 6 & 63 | 128, 63 & f | 128);
                      } else {
                          if (!(f < 1114112)) throw new Error("Invalid code point");
                          if ((l -= 4) < 0) break;
                          T.push(f >> 18 | 240, f >> 12 & 63 | 128, f >> 6 & 63 | 128, 63 & f | 128);
                      }
                  }
                  return T;
              }
              function Cl(p) {
                  return t.toByteArray(function(p) {
                      if ((p = (p = p.split("=")[0]).trim().replace(Fg, "")).length < 2) return "";
                      for (;p.length % 4 != 0; ) p += "=";
                      return p;
                  }(p));
              }
              function qi(p, l, f, b) {
                  let A;
                  for (A = 0; A < b && !(A + f >= l.length || A >= p.length); ++A) l[A + f] = p[A];
                  return A;
              }
              function Ye(p, l) {
                  return p instanceof l || null != p && null != p.constructor && null != p.constructor.name && p.constructor.name === l.name;
              }
              function ds(p) {
                  return p != p;
              }
              let Vg = function() {
                  let p = "0123456789abcdef", l = new Array(256);
                  for (let f = 0; f < 16; ++f) {
                      let b = 16 * f;
                      for (let A = 0; A < 16; ++A) l[b + A] = p[f] + p[A];
                  }
                  return l;
              }();
              function Mt(p) {
                  return typeof BigInt > "u" ? zg : p;
              }
              function zg() {
                  throw new Error("BigInt not supported");
              }
              return Jt;
          }
          Qt(_e, {
              Buffer: () => x,
              INSPECT_MAX_BYTES: () => ty,
              default: () => Ut,
              kMaxLength: () => ry
          });
          var ui, Vu, Wi, zu, Jt, Ku, Ut, x, ty, ry, ye = we((() => {
              v(), m(), _(), ui = {}, Vu = !1, Wi = {}, zu = !1, Jt = {}, Ku = !1, (Ut = ey()).Buffer, 
              Ut.SlowBuffer, Ut.INSPECT_MAX_BYTES, Ut.kMaxLength, x = Ut.Buffer, ty = Ut.INSPECT_MAX_BYTES, 
              ry = Ut.kMaxLength;
          })), v = we((() => {
              ye();
          })), Gu = M((_s => {
              v(), m(), _(), Object.defineProperty(_s, "__esModule", {
                  value: !0
              });
              _s.default = class {
                  constructor(e) {
                      this.aliasToTopic = {}, this.max = e;
                  }
                  put(e, r) {
                      return !(0 === r || r > this.max) && (this.aliasToTopic[r] = e, this.length = Object.keys(this.aliasToTopic).length, 
                      !0);
                  }
                  getTopicByAlias(e) {
                      return this.aliasToTopic[e];
                  }
                  clear() {
                      this.aliasToTopic = {};
                  }
              };
          })), ce = M(((kA, Qu) => {
              v(), m(), _(), Qu.exports = {
                  ArrayIsArray: t => Array.isArray(t),
                  ArrayPrototypeIncludes: (t, e) => t.includes(e),
                  ArrayPrototypeIndexOf: (t, e) => t.indexOf(e),
                  ArrayPrototypeJoin: (t, e) => t.join(e),
                  ArrayPrototypeMap: (t, e) => t.map(e),
                  ArrayPrototypePop: (t, e) => t.pop(e),
                  ArrayPrototypePush: (t, e) => t.push(e),
                  ArrayPrototypeSlice: (t, e, r) => t.slice(e, r),
                  Error,
                  FunctionPrototypeCall: (t, e, ...r) => t.call(e, ...r),
                  FunctionPrototypeSymbolHasInstance: (t, e) => Function.prototype[Symbol.hasInstance].call(t, e),
                  MathFloor: Math.floor,
                  Number,
                  NumberIsInteger: Number.isInteger,
                  NumberIsNaN: Number.isNaN,
                  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
                  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
                  NumberParseInt: Number.parseInt,
                  ObjectDefineProperties: (t, e) => Object.defineProperties(t, e),
                  ObjectDefineProperty: (t, e, r) => Object.defineProperty(t, e, r),
                  ObjectGetOwnPropertyDescriptor: (t, e) => Object.getOwnPropertyDescriptor(t, e),
                  ObjectKeys: t => Object.keys(t),
                  ObjectSetPrototypeOf: (t, e) => Object.setPrototypeOf(t, e),
                  Promise,
                  PromisePrototypeCatch: (t, e) => t.catch(e),
                  PromisePrototypeThen: (t, e, r) => t.then(e, r),
                  PromiseReject: t => Promise.reject(t),
                  ReflectApply: Reflect.apply,
                  RegExpPrototypeTest: (t, e) => t.test(e),
                  SafeSet: Set,
                  String,
                  StringPrototypeSlice: (t, e, r) => t.slice(e, r),
                  StringPrototypeToLowerCase: t => t.toLowerCase(),
                  StringPrototypeToUpperCase: t => t.toUpperCase(),
                  StringPrototypeTrim: t => t.trim(),
                  Symbol,
                  SymbolFor: Symbol.for,
                  SymbolAsyncIterator: Symbol.asyncIterator,
                  SymbolHasInstance: Symbol.hasInstance,
                  SymbolIterator: Symbol.iterator,
                  TypedArrayPrototypeSet: (t, e, r) => t.set(e, r),
                  Uint8Array
              };
          })), Je = M(((WA, vs) => {
              v(), m(), _();
              var iy = (ye(), X(_e)), ny = Object.getPrototypeOf((async function() {})).constructor, Yu = globalThis.Blob || iy.Blob, sy = typeof Yu < "u" ? function(e) {
                  return e instanceof Yu;
              } : function(e) {
                  return !1;
              }, ms = class extends Error {
                  constructor(e) {
                      if (!Array.isArray(e)) throw new TypeError("Expected input to be an Array, got " + typeof e);
                      let r = "";
                      for (let i = 0; i < e.length; i++) r += `    ${e[i].stack}\n`;
                      super(r), this.name = "AggregateError", this.errors = e;
                  }
              };
              vs.exports = {
                  AggregateError: ms,
                  kEmptyObject: Object.freeze({}),
                  once(t) {
                      let e = !1;
                      return function(...r) {
                          e || (e = !0, t.apply(this, r));
                      };
                  },
                  createDeferredPromise: function() {
                      let t, e;
                      return {
                          promise: new Promise(((i, n) => {
                              t = i, e = n;
                          })),
                          resolve: t,
                          reject: e
                      };
                  },
                  promisify: t => new Promise(((e, r) => {
                      t(((i, ...n) => i ? r(i) : e(...n)));
                  })),
                  debuglog: () => function() {},
                  format: (t, ...e) => t.replace(/%([sdifj])/g, (function(...[r, i]) {
                      let n = e.shift();
                      return "f" === i ? n.toFixed(6) : "j" === i ? JSON.stringify(n) : "s" === i && "object" == typeof n ? `${n.constructor !== Object ? n.constructor.name : ""} {}`.trim() : n.toString();
                  })),
                  inspect(t) {
                      switch (typeof t) {
                        case "string":
                          if (t.includes("'")) {
                              if (!t.includes('"')) return `"${t}"`;
                              if (!t.includes("`") && !t.includes("${")) return `\`${t}\``;
                          }
                          return `'${t}'`;

                        case "number":
                          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;

                        case "bigint":
                          return `${String(t)}n`;

                        case "boolean":
                        case "undefined":
                          return String(t);

                        case "object":
                          return "{}";
                      }
                  },
                  types: {
                      isAsyncFunction: t => t instanceof ny,
                      isArrayBufferView: t => ArrayBuffer.isView(t)
                  },
                  isBlob: sy
              }, vs.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
          })), Hi = M(((XA, $i) => {
              v(), m(), _();
              var {AbortController: Ju, AbortSignal: oy} = typeof self < "u" ? self : typeof window < "u" ? window : void 0;
              $i.exports = Ju, $i.exports.AbortSignal = oy, $i.exports.default = Ju;
          })), Se = M(((lI, ef) => {
              v(), m(), _();
              var {format: ay, inspect: Vi, AggregateError: ly} = Je(), uy = globalThis.AggregateError || ly, fy = Symbol("kIsNodeError"), cy = [ "string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol" ], hy = /^([A-Z][a-z0-9]*)+$/, zi = {};
              function Xt(t, e) {
                  if (!t) throw new zi.ERR_INTERNAL_ASSERTION(e);
              }
              function Xu(t) {
                  let e = "", r = t.length, i = "-" === t[0] ? 1 : 0;
                  for (;r >= i + 4; r -= 3) e = `_${t.slice(r - 3, r)}${e}`;
                  return `${t.slice(0, r)}${e}`;
              }
              function me(t, e, r) {
                  r || (r = Error);
                  class i extends r {
                      constructor(...o) {
                          super(function(t, e, r) {
                              if ("function" == typeof e) return Xt(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), 
                              e(...r);
                              let i = (e.match(/%[dfijoOs]/g) || []).length;
                              return Xt(i === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${i}).`), 
                              0 === r.length ? e : ay(e, ...r);
                          }(t, e, o));
                      }
                      toString() {
                          return `${this.name} [${t}]: ${this.message}`;
                      }
                  }
                  Object.defineProperties(i.prototype, {
                      name: {
                          value: r.name,
                          writable: !0,
                          enumerable: !1,
                          configurable: !0
                      },
                      toString: {
                          value() {
                              return `${this.name} [${t}]: ${this.message}`;
                          },
                          writable: !0,
                          enumerable: !1,
                          configurable: !0
                      }
                  }), i.prototype.code = t, i.prototype[fy] = !0, zi[t] = i;
              }
              function Zu(t) {
                  let e = "__node_internal_" + t.name;
                  return Object.defineProperty(t, "name", {
                      value: e
                  }), t;
              }
              var Es = class extends Error {
                  constructor(e = "The operation was aborted", r = void 0) {
                      if (void 0 !== r && "object" != typeof r) throw new zi.ERR_INVALID_ARG_TYPE("options", "Object", r);
                      super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
                  }
              };
              me("ERR_ASSERTION", "%s", Error), me("ERR_INVALID_ARG_TYPE", ((t, e, r) => {
                  Xt("string" == typeof t, "'name' must be a string"), Array.isArray(e) || (e = [ e ]);
                  let i = "The ";
                  t.endsWith(" argument") ? i += `${t} ` : i += `"${t}" ${t.includes(".") ? "property" : "argument"} `, 
                  i += "must be ";
                  let n = [], o = [], s = [];
                  for (let u of e) Xt("string" == typeof u, "All expected entries have to be of type string"), 
                  cy.includes(u) ? n.push(u.toLowerCase()) : hy.test(u) ? o.push(u) : (Xt("object" !== u, 'The value "object" should be written as "Object"'), 
                  s.push(u));
                  if (o.length > 0) {
                      let u = n.indexOf("object");
                      -1 !== u && (n.splice(n, u, 1), o.push("Object"));
                  }
                  if (n.length > 0) {
                      switch (n.length) {
                        case 1:
                          i += `of type ${n[0]}`;
                          break;

                        case 2:
                          i += `one of type ${n[0]} or ${n[1]}`;
                          break;

                        default:
                          {
                              let u = n.pop();
                              i += `one of type ${n.join(", ")}, or ${u}`;
                          }
                      }
                      (o.length > 0 || s.length > 0) && (i += " or ");
                  }
                  if (o.length > 0) {
                      switch (o.length) {
                        case 1:
                          i += `an instance of ${o[0]}`;
                          break;

                        case 2:
                          i += `an instance of ${o[0]} or ${o[1]}`;
                          break;

                        default:
                          {
                              let u = o.pop();
                              i += `an instance of ${o.join(", ")}, or ${u}`;
                          }
                      }
                      s.length > 0 && (i += " or ");
                  }
                  switch (s.length) {
                    case 0:
                      break;

                    case 1:
                      s[0].toLowerCase() !== s[0] && (i += "an "), i += `${s[0]}`;
                      break;

                    case 2:
                      i += `one of ${s[0]} or ${s[1]}`;
                      break;

                    default:
                      {
                          let u = s.pop();
                          i += `one of ${s.join(", ")}, or ${u}`;
                      }
                  }
                  if (null == r) i += `. Received ${r}`; else if ("function" == typeof r && r.name) i += `. Received function ${r.name}`; else if ("object" == typeof r) {
                      var a;
                      if (null !== (a = r.constructor) && void 0 !== a && a.name) i += `. Received an instance of ${r.constructor.name}`; else {
                          i += `. Received ${Vi(r, {
                              depth: -1
                          })}`;
                      }
                  } else {
                      let u = Vi(r, {
                          colors: !1
                      });
                      u.length > 25 && (u = `${u.slice(0, 25)}...`), i += `. Received type ${typeof r} (${u})`;
                  }
                  return i;
              }), TypeError), me("ERR_INVALID_ARG_VALUE", ((t, e, r = "is invalid") => {
                  let i = Vi(e);
                  return i.length > 128 && (i = i.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${i}`;
              }), TypeError), me("ERR_INVALID_RETURN_VALUE", ((t, e, r) => {
                  var i;
                  return `Expected ${t} to be returned from the "${e}" function but got ${null != r && null !== (i = r.constructor) && void 0 !== i && i.name ? `instance of ${r.constructor.name}` : "type " + typeof r}.`;
              }), TypeError), me("ERR_MISSING_ARGS", ((...t) => {
                  Xt(t.length > 0, "At least one arg needs to be specified");
                  let e, r = t.length;
                  switch (t = (Array.isArray(t) ? t : [ t ]).map((i => `"${i}"`)).join(" or "), r) {
                    case 1:
                      e += `The ${t[0]} argument`;
                      break;

                    case 2:
                      e += `The ${t[0]} and ${t[1]} arguments`;
                      break;

                    default:
                      {
                          let i = t.pop();
                          e += `The ${t.join(", ")}, and ${i} arguments`;
                      }
                  }
                  return `${e} must be specified`;
              }), TypeError), me("ERR_OUT_OF_RANGE", ((t, e, r) => {
                  let i;
                  return Xt(e, 'Missing "range" argument'), Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Xu(String(r)) : "bigint" == typeof r ? (i = String(r), 
                  (r > 2n ** 32n || r < -(2n ** 32n)) && (i = Xu(i)), i += "n") : i = Vi(r), `The value of "${t}" is out of range. It must be ${e}. Received ${i}`;
              }), RangeError), me("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error), 
              me("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error), me("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error), 
              me("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error), me("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error), 
              me("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), 
              me("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error), me("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error), 
              me("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error), 
              me("ERR_STREAM_WRITE_AFTER_END", "write after end", Error), me("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError), 
              ef.exports = {
                  AbortError: Es,
                  aggregateTwoErrors: Zu((function(t, e) {
                      if (t && e && t !== e) {
                          if (Array.isArray(e.errors)) return e.errors.push(t), e;
                          let r = new uy([ e, t ], e.message);
                          return r.code = e.code, r;
                      }
                      return t || e;
                  })),
                  hideStackFrames: Zu,
                  codes: zi
              };
          })), fi = M(((wI, ff) => {
              v(), m(), _();
              var {ArrayIsArray: As, ArrayPrototypeIncludes: sf, ArrayPrototypeJoin: of, ArrayPrototypeMap: yy, NumberIsInteger: Is, NumberIsNaN: by, NumberMAX_SAFE_INTEGER: wy, NumberMIN_SAFE_INTEGER: _y, NumberParseInt: my, ObjectPrototypeHasOwnProperty: vy, RegExpPrototypeExec: af, String: Ey, StringPrototypeToUpperCase: Sy, StringPrototypeTrim: Ay} = ce(), {hideStackFrames: Ue, codes: {ERR_SOCKET_BAD_PORT: Iy, ERR_INVALID_ARG_TYPE: Ae, ERR_INVALID_ARG_VALUE: Mr, ERR_OUT_OF_RANGE: Zt, ERR_UNKNOWN_SIGNAL: tf}} = Se(), {normalizeEncoding: Ty} = Je(), {isAsyncFunction: Ry, isArrayBufferView: Cy} = Je().types, rf = {};
              var Oy = /^[0-7]+$/;
              var My = Ue(((t, e, r = _y, i = wy) => {
                  if ("number" != typeof t) throw new Ae(e, "number", t);
                  if (!Is(t)) throw new Zt(e, "an integer", t);
                  if (t < r || t > i) throw new Zt(e, `>= ${r} && <= ${i}`, t);
              })), Ly = Ue(((t, e, r = -2147483648, i = 2147483647) => {
                  if ("number" != typeof t) throw new Ae(e, "number", t);
                  if (!Is(t)) throw new Zt(e, "an integer", t);
                  if (t < r || t > i) throw new Zt(e, `>= ${r} && <= ${i}`, t);
              })), lf = Ue(((t, e, r = !1) => {
                  if ("number" != typeof t) throw new Ae(e, "number", t);
                  if (!Is(t)) throw new Zt(e, "an integer", t);
                  let i = r ? 1 : 0, n = 4294967295;
                  if (t < i || t > n) throw new Zt(e, `>= ${i} && <= ${n}`, t);
              }));
              function Ts(t, e) {
                  if ("string" != typeof t) throw new Ae(e, "string", t);
              }
              var Ny = Ue(((t, e, r) => {
                  if (!sf(r, t)) {
                      let n = "must be one of: " + of(yy(r, (o => "string" == typeof o ? `'${o}'` : Ey(o))), ", ");
                      throw new Mr(e, t, n);
                  }
              }));
              function uf(t, e) {
                  if ("boolean" != typeof t) throw new Ae(e, "boolean", t);
              }
              function Ss(t, e, r) {
                  return null != t && vy(t, e) ? t[e] : r;
              }
              var qy = Ue(((t, e, r = null) => {
                  let i = Ss(r, "allowArray", !1), n = Ss(r, "allowFunction", !1);
                  if (!Ss(r, "nullable", !1) && null === t || !i && As(t) || "object" != typeof t && (!n || "function" != typeof t)) throw new Ae(e, "Object", t);
              })), Dy = Ue(((t, e) => {
                  if (null != t && "object" != typeof t && "function" != typeof t) throw new Ae(e, "a dictionary", t);
              })), Rs = Ue(((t, e, r = 0) => {
                  if (!As(t)) throw new Ae(e, "Array", t);
                  if (t.length < r) {
                      throw new Mr(e, t, `must be longer than ${r}`);
                  }
              }));
              var $y = Ue(((t, e = "buffer") => {
                  if (!Cy(t)) throw new Ae(e, [ "Buffer", "TypedArray", "DataView" ], t);
              }));
              var zy = Ue(((t, e) => {
                  if (void 0 !== t && (null === t || "object" != typeof t || !("aborted" in t))) throw new Ae(e, "AbortSignal", t);
              })), Ky = Ue(((t, e) => {
                  if ("function" != typeof t) throw new Ae(e, "Function", t);
              })), Gy = Ue(((t, e) => {
                  if ("function" != typeof t || Ry(t)) throw new Ae(e, "Function", t);
              })), Qy = Ue(((t, e) => {
                  if (void 0 !== t) throw new Ae(e, "undefined", t);
              }));
              var Jy = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
              function nf(t, e) {
                  if (typeof t > "u" || !af(Jy, t)) throw new Mr(e, t, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
              }
              ff.exports = {
                  isInt32: function(t) {
                      return t === (0 | t);
                  },
                  isUint32: function(t) {
                      return t === t >>> 0;
                  },
                  parseFileMode: function(t, e, r) {
                      if (typeof t > "u" && (t = r), "string" == typeof t) {
                          if (null === af(Oy, t)) throw new Mr(e, t, "must be a 32-bit unsigned integer or an octal string");
                          t = my(t, 8);
                      }
                      return lf(t, e), t;
                  },
                  validateArray: Rs,
                  validateStringArray: function(t, e) {
                      Rs(t, e);
                      for (let r = 0; r < t.length; r++) Ts(t[r], `${e}[${r}]`);
                  },
                  validateBooleanArray: function(t, e) {
                      Rs(t, e);
                      for (let r = 0; r < t.length; r++) uf(t[r], `${e}[${r}]`);
                  },
                  validateBoolean: uf,
                  validateBuffer: $y,
                  validateDictionary: Dy,
                  validateEncoding: function(t, e) {
                      let r = Ty(e), i = t.length;
                      if ("hex" === r && i % 2 != 0) throw new Mr("encoding", e, `is invalid for data of length ${i}`);
                  },
                  validateFunction: Ky,
                  validateInt32: Ly,
                  validateInteger: My,
                  validateNumber: function(t, e, r = void 0, i) {
                      if ("number" != typeof t) throw new Ae(e, "number", t);
                      if (null != r && t < r || null != i && t > i || (null != r || null != i) && by(t)) throw new Zt(e, `${null != r ? `>= ${r}` : ""}${null != r && null != i ? " && " : ""}${null != i ? `<= ${i}` : ""}`, t);
                  },
                  validateObject: qy,
                  validateOneOf: Ny,
                  validatePlainFunction: Gy,
                  validatePort: function(t, e = "Port", r = !0) {
                      if ("number" != typeof t && "string" != typeof t || "string" == typeof t && 0 === Ay(t).length || +t != +t >>> 0 || t > 65535 || 0 === t && !r) throw new Iy(e, t, r);
                      return 0 | t;
                  },
                  validateSignalName: function(t, e = "signal") {
                      if (Ts(t, e), void 0 === rf[t]) throw void 0 !== rf[Sy(t)] ? new tf(t + " (signals must use all capital letters)") : new tf(t);
                  },
                  validateString: Ts,
                  validateUint32: lf,
                  validateUndefined: Qy,
                  validateUnion: function(t, e, r) {
                      if (!sf(r, t)) throw new Ae(e, `('${of(r, "|")}')`, t);
                  },
                  validateAbortSignal: zy,
                  validateLinkHeaderValue: function(t) {
                      if ("string" == typeof t) return nf(t, "hints"), t;
                      if (As(t)) {
                          let e = t.length, r = "";
                          if (0 === e) return r;
                          for (let i = 0; i < e; i++) {
                              let n = t[i];
                              nf(n, "hints"), r += n, i !== e - 1 && (r += ", ");
                          }
                          return r;
                      }
                      throw new Mr("hints", t, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
                  }
              };
          })), Nt = M(((CI, pf) => {
              v(), m(), _();
              var Xe, Ze, ae = pf.exports = {};
              function Cs() {
                  throw new Error("setTimeout has not been defined");
              }
              function Bs() {
                  throw new Error("clearTimeout has not been defined");
              }
              function cf(t) {
                  if (Xe === setTimeout) return setTimeout(t, 0);
                  if ((Xe === Cs || !Xe) && setTimeout) return Xe = setTimeout, setTimeout(t, 0);
                  try {
                      return Xe(t, 0);
                  } catch {
                      try {
                          return Xe.call(null, t, 0);
                      } catch {
                          return Xe.call(this, t, 0);
                      }
                  }
              }
              !function() {
                  try {
                      Xe = "function" == typeof setTimeout ? setTimeout : Cs;
                  } catch {
                      Xe = Cs;
                  }
                  try {
                      Ze = "function" == typeof clearTimeout ? clearTimeout : Bs;
                  } catch {
                      Ze = Bs;
                  }
              }();
              var er, _t = [], Lr = !1, Ki = -1;
              function eb() {
                  !Lr || !er || (Lr = !1, er.length ? _t = er.concat(_t) : Ki = -1, _t.length && hf());
              }
              function hf() {
                  if (!Lr) {
                      var t = cf(eb);
                      Lr = !0;
                      for (var e = _t.length; e; ) {
                          for (er = _t, _t = []; ++Ki < e; ) er && er[Ki].run();
                          Ki = -1, e = _t.length;
                      }
                      er = null, Lr = !1, function(t) {
                          if (Ze === clearTimeout) return clearTimeout(t);
                          if ((Ze === Bs || !Ze) && clearTimeout) return Ze = clearTimeout, clearTimeout(t);
                          try {
                              return Ze(t);
                          } catch {
                              try {
                                  return Ze.call(null, t);
                              } catch {
                                  return Ze.call(this, t);
                              }
                          }
                      }(t);
                  }
              }
              function df(t, e) {
                  this.fun = t, this.array = e;
              }
              function mt() {}
              ae.nextTick = function(t) {
                  var e = new Array(arguments.length - 1);
                  if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
                  _t.push(new df(t, e)), 1 === _t.length && !Lr && cf(hf);
              }, df.prototype.run = function() {
                  this.fun.apply(null, this.array);
              }, ae.title = "browser", ae.browser = !0, ae.env = {}, ae.argv = [], ae.version = "", 
              ae.versions = {}, ae.on = mt, ae.addListener = mt, ae.once = mt, ae.off = mt, ae.removeListener = mt, 
              ae.removeAllListeners = mt, ae.emit = mt, ae.prependListener = mt, ae.prependOnceListener = mt, 
              ae.listeners = function(t) {
                  return [];
              }, ae.binding = function(t) {
                  throw new Error("process.binding is not supported");
              }, ae.cwd = function() {
                  return "/";
              }, ae.chdir = function(t) {
                  throw new Error("process.chdir is not supported");
              }, ae.umask = function() {
                  return 0;
              };
          })), tt = M(((qI, Pf) => {
              v(), m(), _();
              var {Symbol: Gi, SymbolAsyncIterator: gf, SymbolIterator: yf, SymbolFor: bf} = ce(), wf = Gi("kDestroyed"), _f = Gi("kIsErrored"), Ps = Gi("kIsReadable"), mf = Gi("kIsDisturbed"), tb = bf("nodejs.webstream.isClosedPromise"), rb = bf("nodejs.webstream.controllerErrorFunction");
              function Qi(t, e = !1) {
                  var r;
                  return !(!t || "function" != typeof t.pipe || "function" != typeof t.on || e && ("function" != typeof t.pause || "function" != typeof t.resume) || t._writableState && !1 === (null === (r = t._readableState) || void 0 === r ? void 0 : r.readable) || t._writableState && !t._readableState);
              }
              function Yi(t) {
                  var e;
                  return !(!t || "function" != typeof t.write || "function" != typeof t.on || t._readableState && !1 === (null === (e = t._writableState) || void 0 === e ? void 0 : e.writable));
              }
              function et(t) {
                  return t && (t._readableState || t._writableState || "function" == typeof t.write && "function" == typeof t.on || "function" == typeof t.pipe && "function" == typeof t.on);
              }
              function vf(t) {
                  return !(!t || et(t) || "function" != typeof t.pipeThrough || "function" != typeof t.getReader || "function" != typeof t.cancel);
              }
              function Ef(t) {
                  return !(!t || et(t) || "function" != typeof t.getWriter || "function" != typeof t.abort);
              }
              function Sf(t) {
                  return !(!t || et(t) || "object" != typeof t.readable || "object" != typeof t.writable);
              }
              function Ji(t) {
                  if (!et(t)) return null;
                  let e = t._writableState, r = t._readableState, i = e || r;
                  return !!(t.destroyed || t[wf] || null != i && i.destroyed);
              }
              function Af(t) {
                  if (!Yi(t)) return null;
                  if (!0 === t.writableEnded) return !0;
                  let e = t._writableState;
                  return (null == e || !e.errored) && ("boolean" != typeof e?.ended ? null : e.ended);
              }
              function If(t, e) {
                  if (!Qi(t)) return null;
                  let r = t._readableState;
                  return (null == r || !r.errored) && ("boolean" != typeof r?.endEmitted ? null : !!(r.endEmitted || !1 === e && !0 === r.ended && 0 === r.length));
              }
              function Tf(t) {
                  return t && null != t[Ps] ? t[Ps] : "boolean" != typeof t?.readable ? null : !Ji(t) && (Qi(t) && t.readable && !If(t));
              }
              function Rf(t) {
                  return "boolean" != typeof t?.writable ? null : !Ji(t) && (Yi(t) && t.writable && !Af(t));
              }
              function Cf(t) {
                  return "boolean" == typeof t._closed && "boolean" == typeof t._defaultKeepAlive && "boolean" == typeof t._removedConnection && "boolean" == typeof t._removedContLen;
              }
              function Bf(t) {
                  return "boolean" == typeof t._sent100 && Cf(t);
              }
              Pf.exports = {
                  kDestroyed: wf,
                  isDisturbed: function(t) {
                      var e;
                      return !(!t || !(null !== (e = t[mf]) && void 0 !== e ? e : t.readableDidRead || t.readableAborted));
                  },
                  kIsDisturbed: mf,
                  isErrored: function(t) {
                      var e, r, i, n, o, s, a, u, c, h;
                      return !(!t || !(null !== (e = null !== (r = null !== (i = null !== (n = null !== (o = null !== (s = t[_f]) && void 0 !== s ? s : t.readableErrored) && void 0 !== o ? o : t.writableErrored) && void 0 !== n ? n : null === (a = t._readableState) || void 0 === a ? void 0 : a.errorEmitted) && void 0 !== i ? i : null === (u = t._writableState) || void 0 === u ? void 0 : u.errorEmitted) && void 0 !== r ? r : null === (c = t._readableState) || void 0 === c ? void 0 : c.errored) && void 0 !== e ? e : null !== (h = t._writableState) && void 0 !== h && h.errored));
                  },
                  kIsErrored: _f,
                  isReadable: Tf,
                  kIsReadable: Ps,
                  kIsClosedPromise: tb,
                  kControllerErrorFunction: rb,
                  isClosed: function(t) {
                      if (!et(t)) return null;
                      if ("boolean" == typeof t.closed) return t.closed;
                      let e = t._writableState, r = t._readableState;
                      return "boolean" == typeof e?.closed || "boolean" == typeof r?.closed ? e?.closed || r?.closed : "boolean" == typeof t._closed && Cf(t) ? t._closed : null;
                  },
                  isDestroyed: Ji,
                  isDuplexNodeStream: function(t) {
                      return !(!t || "function" != typeof t.pipe || !t._readableState || "function" != typeof t.on || "function" != typeof t.write);
                  },
                  isFinished: function(t, e) {
                      return et(t) ? !!Ji(t) || !(!1 !== e?.readable && Tf(t) || !1 !== e?.writable && Rf(t)) : null;
                  },
                  isIterable: function(t, e) {
                      return null != t && (!0 === e ? "function" == typeof t[gf] : !1 === e ? "function" == typeof t[yf] : "function" == typeof t[gf] || "function" == typeof t[yf]);
                  },
                  isReadableNodeStream: Qi,
                  isReadableStream: vf,
                  isReadableEnded: function(t) {
                      if (!Qi(t)) return null;
                      if (!0 === t.readableEnded) return !0;
                      let e = t._readableState;
                      return !(!e || e.errored) && ("boolean" != typeof e?.ended ? null : e.ended);
                  },
                  isReadableFinished: If,
                  isReadableErrored: function(t) {
                      var e, r;
                      return et(t) ? t.readableErrored ? t.readableErrored : null !== (e = null === (r = t._readableState) || void 0 === r ? void 0 : r.errored) && void 0 !== e ? e : null : null;
                  },
                  isNodeStream: et,
                  isWebStream: function(t) {
                      return vf(t) || Ef(t) || Sf(t);
                  },
                  isWritable: Rf,
                  isWritableNodeStream: Yi,
                  isWritableStream: Ef,
                  isWritableEnded: Af,
                  isWritableFinished: function(t, e) {
                      if (!Yi(t)) return null;
                      if (!0 === t.writableFinished) return !0;
                      let r = t._writableState;
                      return (null == r || !r.errored) && ("boolean" != typeof r?.finished ? null : !!(r.finished || !1 === e && !0 === r.ended && 0 === r.length));
                  },
                  isWritableErrored: function(t) {
                      var e, r;
                      return et(t) ? t.writableErrored ? t.writableErrored : null !== (e = null === (r = t._writableState) || void 0 === r ? void 0 : r.errored) && void 0 !== e ? e : null : null;
                  },
                  isServerRequest: function(t) {
                      var e;
                      return "boolean" == typeof t._consuming && "boolean" == typeof t._dumped && void 0 === (null === (e = t.req) || void 0 === e ? void 0 : e.upgradeOrConnect);
                  },
                  isServerResponse: Bf,
                  willEmitClose: function(t) {
                      if (!et(t)) return null;
                      let e = t._writableState, r = t._readableState, i = e || r;
                      return !i && Bf(t) || !!(i && i.autoDestroy && i.emitClose && !1 === i.closed);
                  },
                  isTransformStream: Sf
              };
          })), vt = M(((GI, Ls) => {
              v(), m(), _();
              var qt = Nt(), {AbortError: Df, codes: yb} = Se(), {ERR_INVALID_ARG_TYPE: bb, ERR_STREAM_PREMATURE_CLOSE: Of} = yb, {kEmptyObject: ks, once: xs} = Je(), {validateAbortSignal: wb, validateFunction: _b, validateObject: mb, validateBoolean: vb} = fi(), {Promise: Eb, PromisePrototypeThen: Sb} = ce(), {isClosed: Ab, isReadable: kf, isReadableNodeStream: Os, isReadableStream: Ib, isReadableFinished: xf, isReadableErrored: Mf, isWritable: Lf, isWritableNodeStream: Uf, isWritableStream: Tb, isWritableFinished: Nf, isWritableErrored: qf, isNodeStream: Rb, willEmitClose: Cb, kIsClosedPromise: Bb} = tt();
              var Ms = () => {};
              function jf(t, e, r) {
                  var i, n;
                  if (2 === arguments.length ? (r = e, e = ks) : null == e ? e = ks : mb(e, "options"), 
                  _b(r, "callback"), wb(e.signal, "options.signal"), r = xs(r), Ib(t) || Tb(t)) return function(t, e, r) {
                      let i = !1, n = Ms;
                      if (e.signal) if (n = () => {
                          i = !0, r.call(t, new Df(void 0, {
                              cause: e.signal.reason
                          }));
                      }, e.signal.aborted) qt.nextTick(n); else {
                          let s = r;
                          r = xs(((...a) => {
                              e.signal.removeEventListener("abort", n), s.apply(t, a);
                          })), e.signal.addEventListener("abort", n);
                      }
                      let o = (...s) => {
                          i || qt.nextTick((() => r.apply(t, s)));
                      };
                      return Sb(t[Bb].promise, o, o), Ms;
                  }(t, e, r);
                  if (!Rb(t)) throw new bb("stream", [ "ReadableStream", "WritableStream", "Stream" ], t);
                  let o = null !== (i = e.readable) && void 0 !== i ? i : Os(t), s = null !== (n = e.writable) && void 0 !== n ? n : Uf(t), a = t._writableState, u = t._readableState, c = () => {
                      t.writable || g();
                  }, h = Cb(t) && Os(t) === o && Uf(t) === s, d = Nf(t, !1), g = () => {
                      d = !0, t.destroyed && (h = !1), (!h || t.readable && !o) && (!o || y) && r.call(t);
                  }, y = xf(t, !1), w = () => {
                      y = !0, t.destroyed && (h = !1), (!h || t.writable && !s) && (!s || d) && r.call(t);
                  }, E = N => {
                      r.call(t, N);
                  }, S = Ab(t), I = () => {
                      S = !0;
                      let N = qf(t) || Mf(t);
                      return N && "boolean" != typeof N ? r.call(t, N) : o && !y && Os(t, !0) && !xf(t, !1) ? r.call(t, new Of) : !s || d || Nf(t, !1) ? void r.call(t) : r.call(t, new Of);
                  }, C = () => {
                      S = !0;
                      let N = qf(t) || Mf(t);
                      if (N && "boolean" != typeof N) return r.call(t, N);
                      r.call(t);
                  }, R = () => {
                      t.req.on("finish", g);
                  };
                  !function(t) {
                      return t.setHeader && "function" == typeof t.abort;
                  }(t) ? s && !a && (t.on("end", c), t.on("close", c)) : (t.on("complete", g), h || t.on("abort", I), 
                  t.req ? R() : t.on("request", R)), !h && "boolean" == typeof t.aborted && t.on("aborted", I), 
                  t.on("end", w), t.on("finish", g), !1 !== e.error && t.on("error", E), t.on("close", I), 
                  S ? qt.nextTick(I) : null != a && a.errorEmitted || null != u && u.errorEmitted ? h || qt.nextTick(C) : (!o && (!h || kf(t)) && (d || !1 === Lf(t)) || !s && (!h || Lf(t)) && (y || !1 === kf(t)) || u && t.req && t.aborted) && qt.nextTick(C);
                  let U = () => {
                      r = Ms, t.removeListener("aborted", I), t.removeListener("complete", g), t.removeListener("abort", I), 
                      t.removeListener("request", R), t.req && t.req.removeListener("finish", g), t.removeListener("end", c), 
                      t.removeListener("close", c), t.removeListener("finish", g), t.removeListener("end", w), 
                      t.removeListener("error", E), t.removeListener("close", I);
                  };
                  if (e.signal && !S) {
                      let N = () => {
                          let W = r;
                          U(), W.call(t, new Df(void 0, {
                              cause: e.signal.reason
                          }));
                      };
                      if (e.signal.aborted) qt.nextTick(N); else {
                          let W = r;
                          r = xs(((...K) => {
                              e.signal.removeEventListener("abort", N), W.apply(t, K);
                          })), e.signal.addEventListener("abort", N);
                      }
                  }
                  return U;
              }
              Ls.exports = jf, Ls.exports.finished = function(t, e) {
                  var r;
                  let i = !1;
                  return null === e && (e = ks), null !== (r = e) && void 0 !== r && r.cleanup && (vb(e.cleanup, "cleanup"), 
                  i = e.cleanup), new Eb(((n, o) => {
                      let s = jf(t, e, (a => {
                          i && s(), a ? o(a) : n();
                      }));
                  }));
              };
          })), tr = M(((nT, Gf) => {
              v(), m(), _();
              var rt = Nt(), {aggregateTwoErrors: xb, codes: {ERR_MULTIPLE_CALLBACK: Mb}, AbortError: Lb} = Se(), {Symbol: $f} = ce(), {kDestroyed: Ub, isDestroyed: Nb, isFinished: qb, isServerRequest: Db} = tt(), Hf = $f("kDestroy"), Us = $f("kConstruct");
              function Vf(t, e, r) {
                  t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
              }
              function Ff(t, e, r) {
                  let i = !1;
                  function n(o) {
                      if (i) return;
                      i = !0;
                      let s = t._readableState, a = t._writableState;
                      Vf(o, a, s), a && (a.closed = !0), s && (s.closed = !0), "function" == typeof r && r(o), 
                      o ? rt.nextTick(Fb, t, o) : rt.nextTick(zf, t);
                  }
                  try {
                      t._destroy(e || null, n);
                  } catch (o) {
                      n(o);
                  }
              }
              function Fb(t, e) {
                  Ns(t, e), zf(t);
              }
              function zf(t) {
                  let e = t._readableState, r = t._writableState;
                  r && (r.closeEmitted = !0), e && (e.closeEmitted = !0), (null != r && r.emitClose || null != e && e.emitClose) && t.emit("close");
              }
              function Ns(t, e) {
                  let r = t._readableState, i = t._writableState;
                  null != i && i.errorEmitted || null != r && r.errorEmitted || (i && (i.errorEmitted = !0), 
                  r && (r.errorEmitted = !0), t.emit("error", e));
              }
              function qs(t, e, r) {
                  let i = t._readableState, n = t._writableState;
                  if (null != n && n.destroyed || null != i && i.destroyed) return this;
                  null != i && i.autoDestroy || null != n && n.autoDestroy ? t.destroy(e) : e && (e.stack, 
                  n && !n.errored && (n.errored = e), i && !i.errored && (i.errored = e), r ? rt.nextTick(Ns, t, e) : Ns(t, e));
              }
              function Hb(t) {
                  let e = !1;
                  function r(i) {
                      if (e) return void qs(t, i ?? new Mb);
                      e = !0;
                      let n = t._readableState, o = t._writableState, s = o || n;
                      n && (n.constructed = !0), o && (o.constructed = !0), s.destroyed ? t.emit(Hf, i) : i ? qs(t, i, !0) : rt.nextTick(Vb, t);
                  }
                  try {
                      t._construct((i => {
                          rt.nextTick(r, i);
                      }));
                  } catch (i) {
                      rt.nextTick(r, i);
                  }
              }
              function Vb(t) {
                  t.emit(Us);
              }
              function Wf(t) {
                  return t?.setHeader && "function" == typeof t.abort;
              }
              function Kf(t) {
                  t.emit("close");
              }
              function zb(t, e) {
                  t.emit("error", e), rt.nextTick(Kf, t);
              }
              Gf.exports = {
                  construct: function(t, e) {
                      if ("function" != typeof t._construct) return;
                      let r = t._readableState, i = t._writableState;
                      r && (r.constructed = !1), i && (i.constructed = !1), t.once(Us, e), !(t.listenerCount(Us) > 1) && rt.nextTick(Hb, t);
                  },
                  destroyer: function(t, e) {
                      !t || Nb(t) || (!e && !qb(t) && (e = new Lb), Db(t) ? (t.socket = null, t.destroy(e)) : Wf(t) ? t.abort() : Wf(t.req) ? t.req.abort() : "function" == typeof t.destroy ? t.destroy(e) : "function" == typeof t.close ? t.close() : e ? rt.nextTick(zb, t, e) : rt.nextTick(Kf, t), 
                      t.destroyed || (t[Ub] = !0));
                  },
                  destroy: function(t, e) {
                      let r = this._readableState, i = this._writableState, n = i || r;
                      return null != i && i.destroyed || null != r && r.destroyed ? ("function" == typeof e && e(), 
                      this) : (Vf(t, i, r), i && (i.destroyed = !0), r && (r.destroyed = !0), n.constructed ? Ff(this, t, e) : this.once(Hf, (function(o) {
                          Ff(this, xb(o, t), e);
                      })), this);
                  },
                  undestroy: function() {
                      let t = this._readableState, e = this._writableState;
                      t && (t.constructed = !0, t.closed = !1, t.closeEmitted = !1, t.destroyed = !1, 
                      t.errored = null, t.errorEmitted = !1, t.reading = !1, t.ended = !1 === t.readable, 
                      t.endEmitted = !1 === t.readable), e && (e.constructed = !0, e.destroyed = !1, e.closed = !1, 
                      e.closeEmitted = !1, e.errored = null, e.errorEmitted = !1, e.finalCalled = !1, 
                      e.prefinished = !1, e.ended = !1 === e.writable, e.ending = !1 === e.writable, e.finished = !1 === e.writable);
                  },
                  errorOrDestroy: qs
              };
          }));
          function Y() {
              Y.init.call(this);
          }
          function Xi(t) {
              if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
          }
          function nc(t) {
              return void 0 === t._maxListeners ? Y.defaultMaxListeners : t._maxListeners;
          }
          function Xf(t, e, r, i) {
              var n, o, s, a;
              if (Xi(r), void 0 === (o = t._events) ? (o = t._events = Object.create(null), t._eventsCount = 0) : (void 0 !== o.newListener && (t.emit("newListener", e, r.listener ? r.listener : r), 
              o = t._events), s = o[e]), void 0 === s) s = o[e] = r, ++t._eventsCount; else if ("function" == typeof s ? s = o[e] = i ? [ r, s ] : [ s, r ] : i ? s.unshift(r) : s.push(r), 
              (n = nc(t)) > 0 && s.length > n && !s.warned) {
                  s.warned = !0;
                  var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = s.length, 
                  a = u, console && console.warn && console.warn(a);
              }
              return t;
          }
          function Gb() {
              if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 
              0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
          }
          function Zf(t, e, r) {
              var i = {
                  fired: !1,
                  wrapFn: void 0,
                  target: t,
                  type: e,
                  listener: r
              }, n = Gb.bind(i);
              return n.listener = r, i.wrapFn = n, n;
          }
          function ec(t, e, r) {
              var i = t._events;
              if (void 0 === i) return [];
              var n = i[e];
              return void 0 === n ? [] : "function" == typeof n ? r ? [ n.listener || n ] : [ n ] : r ? function(o) {
                  for (var s = new Array(o.length), a = 0; a < s.length; ++a) s[a] = o[a].listener || o[a];
                  return s;
              }(n) : sc(n, n.length);
          }
          function tc(t) {
              var e = this._events;
              if (void 0 !== e) {
                  var r = e[t];
                  if ("function" == typeof r) return 1;
                  if (void 0 !== r) return r.length;
              }
              return 0;
          }
          function sc(t, e) {
              for (var r = new Array(e), i = 0; i < e; ++i) r[i] = t[i];
              return r;
          }
          var rc, ic, Ur, Qf, Yf, Jf, Be, Ds = we((() => {
              v(), m(), _(), Ur = "object" == typeof Reflect ? Reflect : null, Qf = Ur && "function" == typeof Ur.apply ? Ur.apply : function(t, e, r) {
                  return Function.prototype.apply.call(t, e, r);
              }, ic = Ur && "function" == typeof Ur.ownKeys ? Ur.ownKeys : Object.getOwnPropertySymbols ? function(t) {
                  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
              } : function(t) {
                  return Object.getOwnPropertyNames(t);
              }, Yf = Number.isNaN || function(t) {
                  return t != t;
              }, rc = Y, Y.EventEmitter = Y, Y.prototype._events = void 0, Y.prototype._eventsCount = 0, 
              Y.prototype._maxListeners = void 0, Jf = 10, Object.defineProperty(Y, "defaultMaxListeners", {
                  enumerable: !0,
                  get: function() {
                      return Jf;
                  },
                  set: function(t) {
                      if ("number" != typeof t || t < 0 || Yf(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
                      Jf = t;
                  }
              }), Y.init = function() {
                  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), 
                  this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
              }, Y.prototype.setMaxListeners = function(t) {
                  if ("number" != typeof t || t < 0 || Yf(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
                  return this._maxListeners = t, this;
              }, Y.prototype.getMaxListeners = function() {
                  return nc(this);
              }, Y.prototype.emit = function(t) {
                  for (var e = [], r = 1; r < arguments.length; r++) e.push(arguments[r]);
                  var i = "error" === t, n = this._events;
                  if (void 0 !== n) i = i && void 0 === n.error; else if (!i) return !1;
                  if (i) {
                      var o;
                      if (e.length > 0 && (o = e[0]), o instanceof Error) throw o;
                      var s = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
                      throw s.context = o, s;
                  }
                  var a = n[t];
                  if (void 0 === a) return !1;
                  if ("function" == typeof a) Qf(a, this, e); else {
                      var u = a.length, c = sc(a, u);
                      for (r = 0; r < u; ++r) Qf(c[r], this, e);
                  }
                  return !0;
              }, Y.prototype.addListener = function(t, e) {
                  return Xf(this, t, e, !1);
              }, Y.prototype.on = Y.prototype.addListener, Y.prototype.prependListener = function(t, e) {
                  return Xf(this, t, e, !0);
              }, Y.prototype.once = function(t, e) {
                  return Xi(e), this.on(t, Zf(this, t, e)), this;
              }, Y.prototype.prependOnceListener = function(t, e) {
                  return Xi(e), this.prependListener(t, Zf(this, t, e)), this;
              }, Y.prototype.removeListener = function(t, e) {
                  var r, i, n, o, s;
                  if (Xi(e), void 0 === (i = this._events)) return this;
                  if (void 0 === (r = i[t])) return this;
                  if (r === e || r.listener === e) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete i[t], 
                  i.removeListener && this.emit("removeListener", t, r.listener || e)); else if ("function" != typeof r) {
                      for (n = -1, o = r.length - 1; o >= 0; o--) if (r[o] === e || r[o].listener === e) {
                          s = r[o].listener, n = o;
                          break;
                      }
                      if (n < 0) return this;
                      0 === n ? r.shift() : function(a, u) {
                          for (;u + 1 < a.length; u++) a[u] = a[u + 1];
                          a.pop();
                      }(r, n), 1 === r.length && (i[t] = r[0]), void 0 !== i.removeListener && this.emit("removeListener", t, s || e);
                  }
                  return this;
              }, Y.prototype.off = Y.prototype.removeListener, Y.prototype.removeAllListeners = function(t) {
                  var e, r, i;
                  if (void 0 === (r = this._events)) return this;
                  if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), 
                  this._eventsCount = 0) : void 0 !== r[t] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[t]), 
                  this;
                  if (0 === arguments.length) {
                      var n, o = Object.keys(r);
                      for (i = 0; i < o.length; ++i) "removeListener" !== (n = o[i]) && this.removeAllListeners(n);
                      return this.removeAllListeners("removeListener"), this._events = Object.create(null), 
                      this._eventsCount = 0, this;
                  }
                  if ("function" == typeof (e = r[t])) this.removeListener(t, e); else if (void 0 !== e) for (i = e.length - 1; i >= 0; i--) this.removeListener(t, e[i]);
                  return this;
              }, Y.prototype.listeners = function(t) {
                  return ec(this, t, !0);
              }, Y.prototype.rawListeners = function(t) {
                  return ec(this, t, !1);
              }, Y.listenerCount = function(t, e) {
                  return "function" == typeof t.listenerCount ? t.listenerCount(e) : tc.call(t, e);
              }, Y.prototype.listenerCount = tc, Y.prototype.eventNames = function() {
                  return this._eventsCount > 0 ? ic(this._events) : [];
              }, (Be = rc).EventEmitter, Be.defaultMaxListeners, Be.init, Be.listenerCount, Be.EventEmitter, 
              Be.defaultMaxListeners, Be.init, Be.listenerCount;
          })), rr = {};
          Qt(rr, {
              EventEmitter: () => Qb,
              default: () => Be,
              defaultMaxListeners: () => Yb,
              init: () => Jb,
              listenerCount: () => Xb,
              on: () => Zb,
              once: () => ew
          });
          var Qb, Yb, Jb, Xb, Zb, ew, ir = we((() => {
              v(), m(), _(), Ds(), Ds(), Be.once = function(t, e) {
                  return new Promise(((r, i) => {
                      function n(...s) {
                          void 0 !== o && t.removeListener("error", o), r(s);
                      }
                      let o;
                      "error" !== e && (o = s => {
                          t.removeListener(name, n), i(s);
                      }, t.once("error", o)), t.once(e, n);
                  }));
              }, Be.on = function(t, e) {
                  let r = [], i = [], n = null, o = !1, s = {
                      async next() {
                          let c = r.shift();
                          if (c) return createIterResult(c, !1);
                          if (n) {
                              let h = Promise.reject(n);
                              return n = null, h;
                          }
                          return o ? createIterResult(void 0, !0) : new Promise(((h, d) => i.push({
                              resolve: h,
                              reject: d
                          })));
                      },
                      async return() {
                          t.removeListener(e, a), t.removeListener("error", u), o = !0;
                          for (let c of i) c.resolve(createIterResult(void 0, !0));
                          return createIterResult(void 0, !0);
                      },
                      throw(c) {
                          n = c, t.removeListener(e, a), t.removeListener("error", u);
                      },
                      [Symbol.asyncIterator]() {
                          return this;
                      }
                  };
                  return t.on(e, a), t.on("error", u), s;
                  function a(...c) {
                      let h = i.shift();
                      h ? h.resolve(createIterResult(c, !1)) : r.push(c);
                  }
                  function u(c) {
                      o = !0;
                      let h = i.shift();
                      h ? h.reject(c) : n = c, s.return();
                  }
              }, ({EventEmitter: Qb, defaultMaxListeners: Yb, init: Jb, listenerCount: Xb, on: Zb, once: ew} = Be);
          })), tn = M(((LT, ac) => {
              v(), m(), _();
              var {ArrayIsArray: tw, ObjectSetPrototypeOf: oc} = ce(), {EventEmitter: Zi} = (ir(), 
              X(rr));
              function en(t) {
                  Zi.call(this, t);
              }
              function js(t, e, r) {
                  if ("function" == typeof t.prependListener) return t.prependListener(e, r);
                  t._events && t._events[e] ? tw(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [ r, t._events[e] ] : t.on(e, r);
              }
              oc(en.prototype, Zi.prototype), oc(en, Zi), en.prototype.pipe = function(t, e) {
                  let r = this;
                  function i(h) {
                      t.writable && !1 === t.write(h) && r.pause && r.pause();
                  }
                  function n() {
                      r.readable && r.resume && r.resume();
                  }
                  r.on("data", i), t.on("drain", n), !t._isStdio && (!e || !1 !== e.end) && (r.on("end", s), 
                  r.on("close", a));
                  let o = !1;
                  function s() {
                      o || (o = !0, t.end());
                  }
                  function a() {
                      o || (o = !0, "function" == typeof t.destroy && t.destroy());
                  }
                  function u(h) {
                      c(), 0 === Zi.listenerCount(this, "error") && this.emit("error", h);
                  }
                  function c() {
                      r.removeListener("data", i), t.removeListener("drain", n), r.removeListener("end", s), 
                      r.removeListener("close", a), r.removeListener("error", u), t.removeListener("error", u), 
                      r.removeListener("end", c), r.removeListener("close", c), t.removeListener("close", c);
                  }
                  return js(r, "error", u), js(t, "error", u), r.on("end", c), r.on("close", c), t.on("close", c), 
                  t.emit("pipe", r), t;
              }, ac.exports = {
                  Stream: en,
                  prependListener: js
              };
          })), ci = M(((VT, rn) => {
              v(), m(), _();
              var {AbortError: lc, codes: rw} = Se(), {isNodeStream: uc, isWebStream: iw, kControllerErrorFunction: nw} = tt(), sw = vt(), {ERR_INVALID_ARG_TYPE: fc} = rw;
              rn.exports.addAbortSignal = function(e, r) {
                  if (((t, e) => {
                      if ("object" != typeof t || !("aborted" in t)) throw new fc(e, "AbortSignal", t);
                  })(e, "signal"), !uc(r) && !iw(r)) throw new fc("stream", [ "ReadableStream", "WritableStream", "Stream" ], r);
                  return rn.exports.addAbortSignalNoValidate(e, r);
              }, rn.exports.addAbortSignalNoValidate = function(t, e) {
                  if ("object" != typeof t || !("aborted" in t)) return e;
                  let r = uc(e) ? () => {
                      e.destroy(new lc(void 0, {
                          cause: t.reason
                      }));
                  } : () => {
                      e[nw](new lc(void 0, {
                          cause: t.reason
                      }));
                  };
                  return t.aborted ? r() : (t.addEventListener("abort", r), sw(e, (() => t.removeEventListener("abort", r)))), 
                  e;
              };
          })), dc = M(((r2, hc) => {
              v(), m(), _();
              var {StringPrototypeSlice: cc, SymbolIterator: aw, TypedArrayPrototypeSet: nn, Uint8Array: lw} = ce(), {Buffer: Fs} = (ye(), 
              X(_e)), {inspect: uw} = Je();
              hc.exports = class {
                  constructor() {
                      this.head = null, this.tail = null, this.length = 0;
                  }
                  push(e) {
                      let r = {
                          data: e,
                          next: null
                      };
                      this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
                  }
                  unshift(e) {
                      let r = {
                          data: e,
                          next: this.head
                      };
                      0 === this.length && (this.tail = r), this.head = r, ++this.length;
                  }
                  shift() {
                      if (0 === this.length) return;
                      let e = this.head.data;
                      return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, 
                      --this.length, e;
                  }
                  clear() {
                      this.head = this.tail = null, this.length = 0;
                  }
                  join(e) {
                      if (0 === this.length) return "";
                      let r = this.head, i = "" + r.data;
                      for (;null !== (r = r.next); ) i += e + r.data;
                      return i;
                  }
                  concat(e) {
                      if (0 === this.length) return Fs.alloc(0);
                      let r = Fs.allocUnsafe(e >>> 0), i = this.head, n = 0;
                      for (;i; ) nn(r, i.data, n), n += i.data.length, i = i.next;
                      return r;
                  }
                  consume(e, r) {
                      let i = this.head.data;
                      if (e < i.length) {
                          let n = i.slice(0, e);
                          return this.head.data = i.slice(e), n;
                      }
                      return e === i.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
                  }
                  first() {
                      return this.head.data;
                  }
                  * [aw]() {
                      for (let e = this.head; e; e = e.next) yield e.data;
                  }
                  _getString(e) {
                      let r = "", i = this.head, n = 0;
                      do {
                          let o = i.data;
                          if (!(e > o.length)) {
                              e === o.length ? (r += o, ++n, i.next ? this.head = i.next : this.head = this.tail = null) : (r += cc(o, 0, e), 
                              this.head = i, i.data = cc(o, e));
                              break;
                          }
                          r += o, e -= o.length, ++n;
                      } while (null !== (i = i.next));
                      return this.length -= n, r;
                  }
                  _getBuffer(e) {
                      let r = Fs.allocUnsafe(e), i = e, n = this.head, o = 0;
                      do {
                          let s = n.data;
                          if (!(e > s.length)) {
                              e === s.length ? (nn(r, s, i - e), ++o, n.next ? this.head = n.next : this.head = this.tail = null) : (nn(r, new lw(s.buffer, s.byteOffset, e), i - e), 
                              this.head = n, n.data = s.slice(e));
                              break;
                          }
                          nn(r, s, i - e), e -= s.length, ++o;
                      } while (null !== (n = n.next));
                      return this.length -= o, r;
                  }
                  [Symbol.for("nodejs.util.inspect.custom")](e, r) {
                      return uw(this, {
                          ...r,
                          depth: 0,
                          customInspect: !1
                      });
                  }
              };
          })), sn = M(((h2, gc) => {
              v(), m(), _();
              var {MathFloor: fw, NumberIsInteger: cw} = ce(), {ERR_INVALID_ARG_VALUE: hw} = Se().codes;
              function pc(t) {
                  return t ? 16 : 16384;
              }
              gc.exports = {
                  getHighWaterMark: function(t, e, r, i) {
                      let n = function(t, e, r) {
                          return null != t.highWaterMark ? t.highWaterMark : e ? t[r] : null;
                      }(e, i, r);
                      if (null != n) {
                          if (!cw(n) || n < 0) {
                              throw new hw(i ? `options.${r}` : "options.highWaterMark", n);
                          }
                          return fw(n);
                      }
                      return pc(t.objectMode);
                  },
                  getDefaultHighWaterMark: pc
              };
          }));
          function wc(t) {
              var e = t.length;
              if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
              var r = t.indexOf("=");
              return -1 === r && (r = e), [ r, r === e ? 0 : 4 - r % 4 ];
          }
          function gw(t, e, r) {
              for (var i, n, o = [], s = e; s < r; s += 3) i = (t[s] << 16 & 16711680) + (t[s + 1] << 8 & 65280) + (255 & t[s + 2]), 
              o.push($e[(n = i) >> 18 & 63] + $e[n >> 12 & 63] + $e[n >> 6 & 63] + $e[63 & n]);
              return o.join("");
          }
          function Et(t) {
              if (t > 2147483647) throw new RangeError('The value "' + t + '" is invalid for option "size"');
              var e = new Uint8Array(t);
              return Object.setPrototypeOf(e, k.prototype), e;
          }
          function k(t, e, r) {
              if ("number" == typeof t) {
                  if ("string" == typeof e) throw new TypeError('The "string" argument must be of type string. Received type number');
                  return Vs(t);
              }
              return Cc(t, e, r);
          }
          function Cc(t, e, r) {
              if ("string" == typeof t) return function(o, s) {
                  if ("string" == typeof s && "" !== s || (s = "utf8"), !k.isEncoding(s)) throw new TypeError("Unknown encoding: " + s);
                  var a = 0 | Pc(o, s), u = Et(a), c = u.write(o, s);
                  return c !== a && (u = u.slice(0, c)), u;
              }(t, e);
              if (ArrayBuffer.isView(t)) return Ws(t);
              if (null == t) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
              if (St(t, ArrayBuffer) || t && St(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (St(t, SharedArrayBuffer) || t && St(t.buffer, SharedArrayBuffer))) return function(t, e, r) {
                  if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
                  if (t.byteLength < e + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
                  var i;
                  return i = void 0 === e && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, e) : new Uint8Array(t, e, r), 
                  Object.setPrototypeOf(i, k.prototype), i;
              }(t, e, r);
              if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number');
              var i = t.valueOf && t.valueOf();
              if (null != i && i !== t) return k.from(i, e, r);
              var n = function(o) {
                  if (k.isBuffer(o)) {
                      var s = 0 | Gs(o.length), a = Et(s);
                      return 0 === a.length || o.copy(a, 0, 0, s), a;
                  }
                  return void 0 !== o.length ? "number" != typeof o.length || Qs(o.length) ? Et(0) : Ws(o) : "Buffer" === o.type && Array.isArray(o.data) ? Ws(o.data) : void 0;
              }(t);
              if (n) return n;
              if (typeof Symbol < "u" && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return k.from(t[Symbol.toPrimitive]("string"), e, r);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
          }
          function Bc(t) {
              if ("number" != typeof t) throw new TypeError('"size" argument must be of type number');
              if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"');
          }
          function Vs(t) {
              return Bc(t), Et(t < 0 ? 0 : 0 | Gs(t));
          }
          function Ws(t) {
              for (var e = t.length < 0 ? 0 : 0 | Gs(t.length), r = Et(e), i = 0; i < e; i += 1) r[i] = 255 & t[i];
              return r;
          }
          function Gs(t) {
              if (t >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
              return 0 | t;
          }
          function Pc(t, e) {
              if (k.isBuffer(t)) return t.length;
              if (ArrayBuffer.isView(t) || St(t, ArrayBuffer)) return t.byteLength;
              if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
              var r = t.length, i = arguments.length > 2 && !0 === arguments[2];
              if (!i && 0 === r) return 0;
              for (var n = !1; ;) switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r;

                case "utf8":
                case "utf-8":
                  return zs(t).length;

                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * r;

                case "hex":
                  return r >>> 1;

                case "base64":
                  return Mc(t).length;

                default:
                  if (n) return i ? -1 : zs(t).length;
                  e = ("" + e).toLowerCase(), n = !0;
              }
          }
          function bw(t, e, r) {
              var i = !1;
              if ((void 0 === e || e < 0) && (e = 0), e > this.length || ((void 0 === r || r > this.length) && (r = this.length), 
              r <= 0) || (r >>>= 0) <= (e >>>= 0)) return "";
              for (t || (t = "utf8"); ;) switch (t) {
                case "hex":
                  return Tw(this, e, r);

                case "utf8":
                case "utf-8":
                  return kc(this, e, r);

                case "ascii":
                  return Aw(this, e, r);

                case "latin1":
                case "binary":
                  return Iw(this, e, r);

                case "base64":
                  return Sw(this, e, r);

                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return Rw(this, e, r);

                default:
                  if (i) throw new TypeError("Unknown encoding: " + t);
                  t = (t + "").toLowerCase(), i = !0;
              }
          }
          function sr(t, e, r) {
              var i = t[e];
              t[e] = t[r], t[r] = i;
          }
          function vc(t, e, r, i, n) {
              if (0 === t.length) return -1;
              if ("string" == typeof r ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), 
              Qs(r = +r) && (r = n ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
                  if (n) return -1;
                  r = t.length - 1;
              } else if (r < 0) {
                  if (!n) return -1;
                  r = 0;
              }
              if ("string" == typeof e && (e = k.from(e, i)), k.isBuffer(e)) return 0 === e.length ? -1 : Ec(t, e, r, i, n);
              if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Ec(t, [ e ], r, i, n);
              throw new TypeError("val must be string, number or Buffer");
          }
          function Ec(t, e, r, i, n) {
              var o, s = 1, a = t.length, u = e.length;
              if (void 0 !== i && ("ucs2" === (i = String(i).toLowerCase()) || "ucs-2" === i || "utf16le" === i || "utf-16le" === i)) {
                  if (t.length < 2 || e.length < 2) return -1;
                  s = 2, a /= 2, u /= 2, r /= 2;
              }
              function c(y, w) {
                  return 1 === s ? y[w] : y.readUInt16BE(w * s);
              }
              if (n) {
                  var h = -1;
                  for (o = r; o < a; o++) if (c(t, o) === c(e, -1 === h ? 0 : o - h)) {
                      if (-1 === h && (h = o), o - h + 1 === u) return h * s;
                  } else -1 !== h && (o -= o - h), h = -1;
              } else for (r + u > a && (r = a - u), o = r; o >= 0; o--) {
                  for (var d = !0, g = 0; g < u; g++) if (c(t, o + g) !== c(e, g)) {
                      d = !1;
                      break;
                  }
                  if (d) return o;
              }
              return -1;
          }
          function ww(t, e, r, i) {
              r = Number(r) || 0;
              var n = t.length - r;
              i ? (i = Number(i)) > n && (i = n) : i = n;
              var o = e.length;
              i > o / 2 && (i = o / 2);
              for (var s = 0; s < i; ++s) {
                  var a = parseInt(e.substr(2 * s, 2), 16);
                  if (Qs(a)) return s;
                  t[r + s] = a;
              }
              return s;
          }
          function _w(t, e, r, i) {
              return un(zs(e, t.length - r), t, r, i);
          }
          function Oc(t, e, r, i) {
              return un(function(n) {
                  for (var o = [], s = 0; s < n.length; ++s) o.push(255 & n.charCodeAt(s));
                  return o;
              }(e), t, r, i);
          }
          function mw(t, e, r, i) {
              return Oc(t, e, r, i);
          }
          function vw(t, e, r, i) {
              return un(Mc(e), t, r, i);
          }
          function Ew(t, e, r, i) {
              return un(function(n, o) {
                  for (var s, a, u, c = [], h = 0; h < n.length && !((o -= 2) < 0); ++h) a = (s = n.charCodeAt(h)) >> 8, 
                  u = s % 256, c.push(u), c.push(a);
                  return c;
              }(e, t.length - r), t, r, i);
          }
          function Sw(t, e, r) {
              return 0 === e && r === t.length ? Hs.fromByteArray(t) : Hs.fromByteArray(t.slice(e, r));
          }
          function kc(t, e, r) {
              r = Math.min(t.length, r);
              for (var i = [], n = e; n < r; ) {
                  var o, s, a, u, c = t[n], h = null, d = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
                  if (n + d <= r) switch (d) {
                    case 1:
                      c < 128 && (h = c);
                      break;

                    case 2:
                      128 == (192 & (o = t[n + 1])) && (u = (31 & c) << 6 | 63 & o) > 127 && (h = u);
                      break;

                    case 3:
                      o = t[n + 1], s = t[n + 2], 128 == (192 & o) && 128 == (192 & s) && (u = (15 & c) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (u < 55296 || u > 57343) && (h = u);
                      break;

                    case 4:
                      o = t[n + 1], s = t[n + 2], a = t[n + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (u = (15 & c) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && u < 1114112 && (h = u);
                  }
                  null === h ? (h = 65533, d = 1) : h > 65535 && (h -= 65536, i.push(h >>> 10 & 1023 | 55296), 
                  h = 56320 | 1023 & h), i.push(h), n += d;
              }
              return function(g) {
                  var y = g.length;
                  if (y <= 4096) return String.fromCharCode.apply(String, g);
                  for (var w = "", E = 0; E < y; ) w += String.fromCharCode.apply(String, g.slice(E, E += 4096));
                  return w;
              }(i);
          }
          function Aw(t, e, r) {
              var i = "";
              r = Math.min(t.length, r);
              for (var n = e; n < r; ++n) i += String.fromCharCode(127 & t[n]);
              return i;
          }
          function Iw(t, e, r) {
              var i = "";
              r = Math.min(t.length, r);
              for (var n = e; n < r; ++n) i += String.fromCharCode(t[n]);
              return i;
          }
          function Tw(t, e, r) {
              var i = t.length;
              (!e || e < 0) && (e = 0), (!r || r < 0 || r > i) && (r = i);
              for (var n = "", o = e; o < r; ++o) n += Bw[t[o]];
              return n;
          }
          function Rw(t, e, r) {
              for (var i = t.slice(e, r), n = "", o = 0; o < i.length; o += 2) n += String.fromCharCode(i[o] + 256 * i[o + 1]);
              return n;
          }
          function be(t, e, r) {
              if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
              if (t + e > r) throw new RangeError("Trying to access beyond buffer length");
          }
          function Pe(t, e, r, i, n, o) {
              if (!k.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
              if (e > n || e < o) throw new RangeError('"value" argument is out of bounds');
              if (r + i > t.length) throw new RangeError("Index out of range");
          }
          function xc(t, e, r, i, n, o) {
              if (r + i > t.length) throw new RangeError("Index out of range");
              if (r < 0) throw new RangeError("Index out of range");
          }
          function Sc(t, e, r, i, n) {
              return e = +e, r >>>= 0, n || xc(t, 0, r, 4), Nr.write(t, e, r, i, 23, 4), r + 4;
          }
          function Ac(t, e, r, i, n) {
              return e = +e, r >>>= 0, n || xc(t, 0, r, 8), Nr.write(t, e, r, i, 52, 8), r + 8;
          }
          function zs(t, e) {
              var r;
              e = e || 1 / 0;
              for (var i = t.length, n = null, o = [], s = 0; s < i; ++s) {
                  if ((r = t.charCodeAt(s)) > 55295 && r < 57344) {
                      if (!n) {
                          if (r > 56319) {
                              (e -= 3) > -1 && o.push(239, 191, 189);
                              continue;
                          }
                          if (s + 1 === i) {
                              (e -= 3) > -1 && o.push(239, 191, 189);
                              continue;
                          }
                          n = r;
                          continue;
                      }
                      if (r < 56320) {
                          (e -= 3) > -1 && o.push(239, 191, 189), n = r;
                          continue;
                      }
                      r = 65536 + (n - 55296 << 10 | r - 56320);
                  } else n && (e -= 3) > -1 && o.push(239, 191, 189);
                  if (n = null, r < 128) {
                      if ((e -= 1) < 0) break;
                      o.push(r);
                  } else if (r < 2048) {
                      if ((e -= 2) < 0) break;
                      o.push(r >> 6 | 192, 63 & r | 128);
                  } else if (r < 65536) {
                      if ((e -= 3) < 0) break;
                      o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128);
                  } else {
                      if (!(r < 1114112)) throw new Error("Invalid code point");
                      if ((e -= 4) < 0) break;
                      o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128);
                  }
              }
              return o;
          }
          function Mc(t) {
              return Hs.toByteArray(function(e) {
                  if ((e = (e = e.split("=")[0]).trim().replace(Cw, "")).length < 2) return "";
                  for (;e.length % 4 != 0; ) e += "=";
                  return e;
              }(t));
          }
          function un(t, e, r, i) {
              for (var n = 0; n < i && !(n + r >= e.length || n >= t.length); ++n) e[n + r] = t[n];
              return n;
          }
          function St(t, e) {
              return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name;
          }
          function Qs(t) {
              return t != t;
          }
          function Ic(t, e) {
              for (var r in t) e[r] = t[r];
          }
          function or(t, e, r) {
              return it(t, e, r);
          }
          function hi(t) {
              var e;
              switch (this.encoding = function(r) {
                  var i = function(n) {
                      if (!n) return "utf8";
                      for (var o; ;) switch (n) {
                        case "utf8":
                        case "utf-8":
                          return "utf8";

                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                          return "utf16le";

                        case "latin1":
                        case "binary":
                          return "latin1";

                        case "base64":
                        case "ascii":
                        case "hex":
                          return n;

                        default:
                          if (o) return;
                          n = ("" + n).toLowerCase(), o = !0;
                      }
                  }(r);
                  if ("string" != typeof i && (Ks.isEncoding === Tc || !Tc(r))) throw new Error("Unknown encoding: " + r);
                  return i || r;
              }(t), this.encoding) {
                case "utf16le":
                  this.text = kw, this.end = xw, e = 4;
                  break;

                case "utf8":
                  this.fillLast = Ow, e = 4;
                  break;

                case "base64":
                  this.text = Mw, this.end = Lw, e = 3;
                  break;

                default:
                  return this.write = Uw, void (this.end = Nw);
              }
              this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Ks.allocUnsafe(e);
          }
          function $s(t) {
              return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2;
          }
          function Ow(t) {
              var e = this.lastTotal - this.lastNeed, r = function(i, n, o) {
                  if (128 != (192 & n[0])) return i.lastNeed = 0, "";
                  if (i.lastNeed > 1 && n.length > 1) {
                      if (128 != (192 & n[1])) return i.lastNeed = 1, "";
                      if (i.lastNeed > 2 && n.length > 2 && 128 != (192 & n[2])) return i.lastNeed = 2, 
                      "";
                  }
              }(this, t);
              return void 0 !== r ? r : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), 
              this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), 
              void (this.lastNeed -= t.length));
          }
          function kw(t, e) {
              if ((t.length - e) % 2 == 0) {
                  var r = t.toString("utf16le", e);
                  if (r) {
                      var i = r.charCodeAt(r.length - 1);
                      if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], 
                      this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
                  }
                  return r;
              }
              return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], 
              t.toString("utf16le", e, t.length - 1);
          }
          function xw(t) {
              var e = t && t.length ? this.write(t) : "";
              if (this.lastNeed) {
                  var r = this.lastTotal - this.lastNeed;
                  return e + this.lastChar.toString("utf16le", 0, r);
              }
              return e;
          }
          function Mw(t, e) {
              var r = (t.length - e) % 3;
              return 0 === r ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, 
              1 === r ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], 
              this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
          }
          function Lw(t) {
              var e = t && t.length ? this.write(t) : "";
              return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
          }
          function Uw(t) {
              return t.toString(this.encoding);
          }
          function Nw(t) {
              return t && t.length ? this.write(t) : "";
          }
          var Rc, $e, ke, yc, on, nr, yw, At, Hs, Nr, _c, Cw, Bw, an, ln, it, ar, Ks, Tc, Ys = we((() => {
              for (v(), m(), _(), Rc = {
                  byteLength: function(t) {
                      var e = wc(t), r = e[0], i = e[1];
                      return 3 * (r + i) / 4 - i;
                  },
                  toByteArray: function(t) {
                      var e, r, d, i = wc(t), n = i[0], o = i[1], s = new yc(3 * (n + (d = o)) / 4 - d), a = 0, u = o > 0 ? n - 4 : n;
                      for (r = 0; r < u; r += 4) e = ke[t.charCodeAt(r)] << 18 | ke[t.charCodeAt(r + 1)] << 12 | ke[t.charCodeAt(r + 2)] << 6 | ke[t.charCodeAt(r + 3)], 
                      s[a++] = e >> 16 & 255, s[a++] = e >> 8 & 255, s[a++] = 255 & e;
                      return 2 === o && (e = ke[t.charCodeAt(r)] << 2 | ke[t.charCodeAt(r + 1)] >> 4, 
                      s[a++] = 255 & e), 1 === o && (e = ke[t.charCodeAt(r)] << 10 | ke[t.charCodeAt(r + 1)] << 4 | ke[t.charCodeAt(r + 2)] >> 2, 
                      s[a++] = e >> 8 & 255, s[a++] = 255 & e), s;
                  },
                  fromByteArray: function(t) {
                      for (var e, r = t.length, i = r % 3, n = [], o = 0, s = r - i; o < s; o += 16383) n.push(gw(t, o, o + 16383 > s ? s : o + 16383));
                      return 1 === i ? (e = t[r - 1], n.push($e[e >> 2] + $e[e << 4 & 63] + "==")) : 2 === i && (e = (t[r - 2] << 8) + t[r - 1], 
                      n.push($e[e >> 10] + $e[e >> 4 & 63] + $e[e << 2 & 63] + "=")), n.join("");
                  }
              }, $e = [], ke = [], yc = typeof Uint8Array < "u" ? Uint8Array : Array, on = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 
              nr = 0, 64; nr < 64; ++nr) $e[nr] = on[nr], ke[on.charCodeAt(nr)] = nr;
              ke["-".charCodeAt(0)] = 62, ke["_".charCodeAt(0)] = 63, yw = {
                  read: function(t, e, r, i, n) {
                      var o, s, a = 8 * n - i - 1, u = (1 << a) - 1, c = u >> 1, h = -7, d = r ? n - 1 : 0, g = r ? -1 : 1, y = t[e + d];
                      for (d += g, o = y & (1 << -h) - 1, y >>= -h, h += a; h > 0; o = 256 * o + t[e + d], 
                      d += g, h -= 8) ;
                      for (s = o & (1 << -h) - 1, o >>= -h, h += i; h > 0; s = 256 * s + t[e + d], d += g, 
                      h -= 8) ;
                      if (0 === o) o = 1 - c; else {
                          if (o === u) return s ? NaN : 1 / 0 * (y ? -1 : 1);
                          s += Math.pow(2, i), o -= c;
                      }
                      return (y ? -1 : 1) * s * Math.pow(2, o - i);
                  },
                  write: function(t, e, r, i, n, o) {
                      var s, a, u, c = 8 * o - n - 1, h = (1 << c) - 1, d = h >> 1, g = 23 === n ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = i ? 0 : o - 1, w = i ? 1 : -1, E = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e) / Math.LN2), 
                      e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (e += s + d >= 1 ? g / u : g * Math.pow(2, 1 - d)) * u >= 2 && (s++, 
                      u /= 2), s + d >= h ? (a = 0, s = h) : s + d >= 1 ? (a = (e * u - 1) * Math.pow(2, n), 
                      s += d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, n), s = 0)); n >= 8; t[r + y] = 255 & a, 
                      y += w, a /= 256, n -= 8) ;
                      for (s = s << n | a, c += n; c > 0; t[r + y] = 255 & s, y += w, s /= 256, c -= 8) ;
                      t[r + y - w] |= 128 * E;
                  }
              }, At = {}, Hs = Rc, Nr = yw, _c = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null, 
              At.Buffer = k, At.SlowBuffer = function(t) {
                  return +t != t && (t = 0), k.alloc(+t);
              }, At.INSPECT_MAX_BYTES = 50, At.kMaxLength = 2147483647, k.TYPED_ARRAY_SUPPORT = function() {
                  try {
                      var t = new Uint8Array(1), e = {
                          foo: function() {
                              return 42;
                          }
                      };
                      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), 
                      42 === t.foo();
                  } catch {
                      return !1;
                  }
              }(), k.TYPED_ARRAY_SUPPORT || typeof console > "u" || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), 
              Object.defineProperty(k.prototype, "parent", {
                  enumerable: !0,
                  get: function() {
                      if (k.isBuffer(this)) return this.buffer;
                  }
              }), Object.defineProperty(k.prototype, "offset", {
                  enumerable: !0,
                  get: function() {
                      if (k.isBuffer(this)) return this.byteOffset;
                  }
              }), k.poolSize = 8192, k.from = function(t, e, r) {
                  return Cc(t, e, r);
              }, Object.setPrototypeOf(k.prototype, Uint8Array.prototype), Object.setPrototypeOf(k, Uint8Array), 
              k.alloc = function(t, e, r) {
                  return function(i, n, o) {
                      return Bc(i), i <= 0 ? Et(i) : void 0 !== n ? "string" == typeof o ? Et(i).fill(n, o) : Et(i).fill(n) : Et(i);
                  }(t, e, r);
              }, k.allocUnsafe = function(t) {
                  return Vs(t);
              }, k.allocUnsafeSlow = function(t) {
                  return Vs(t);
              }, k.isBuffer = function(t) {
                  return null != t && !0 === t._isBuffer && t !== k.prototype;
              }, k.compare = function(t, e) {
                  if (St(t, Uint8Array) && (t = k.from(t, t.offset, t.byteLength)), St(e, Uint8Array) && (e = k.from(e, e.offset, e.byteLength)), 
                  !k.isBuffer(t) || !k.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                  if (t === e) return 0;
                  for (var r = t.length, i = e.length, n = 0, o = Math.min(r, i); n < o; ++n) if (t[n] !== e[n]) {
                      r = t[n], i = e[n];
                      break;
                  }
                  return r < i ? -1 : i < r ? 1 : 0;
              }, k.isEncoding = function(t) {
                  switch (String(t).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return !0;

                    default:
                      return !1;
                  }
              }, k.concat = function(t, e) {
                  if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                  if (0 === t.length) return k.alloc(0);
                  var r;
                  if (void 0 === e) for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
                  var i = k.allocUnsafe(e), n = 0;
                  for (r = 0; r < t.length; ++r) {
                      var o = t[r];
                      if (St(o, Uint8Array) && (o = k.from(o)), !k.isBuffer(o)) throw new TypeError('"list" argument must be an Array of Buffers');
                      o.copy(i, n), n += o.length;
                  }
                  return i;
              }, k.byteLength = Pc, k.prototype._isBuffer = !0, k.prototype.swap16 = function() {
                  var t = this.length;
                  if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                  for (var e = 0; e < t; e += 2) sr(this, e, e + 1);
                  return this;
              }, k.prototype.swap32 = function() {
                  var t = this.length;
                  if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                  for (var e = 0; e < t; e += 4) sr(this, e, e + 3), sr(this, e + 1, e + 2);
                  return this;
              }, k.prototype.swap64 = function() {
                  var t = this.length;
                  if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                  for (var e = 0; e < t; e += 8) sr(this, e, e + 7), sr(this, e + 1, e + 6), sr(this, e + 2, e + 5), 
                  sr(this, e + 3, e + 4);
                  return this;
              }, k.prototype.toString = function() {
                  var t = this.length;
                  return 0 === t ? "" : 0 === arguments.length ? kc(this, 0, t) : bw.apply(this, arguments);
              }, k.prototype.toLocaleString = k.prototype.toString, k.prototype.equals = function(t) {
                  if (!k.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
                  return this === t || 0 === k.compare(this, t);
              }, k.prototype.inspect = function() {
                  var t = "", e = At.INSPECT_MAX_BYTES;
                  return t = this.toString("hex", 0, e).replace(/(.{2})/g, "$1 ").trim(), this.length > e && (t += " ... "), 
                  "<Buffer " + t + ">";
              }, _c && (k.prototype[_c] = k.prototype.inspect), k.prototype.compare = function(t, e, r, i, n) {
                  if (St(t, Uint8Array) && (t = k.from(t, t.offset, t.byteLength)), !k.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
                  if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === i && (i = 0), 
                  void 0 === n && (n = this.length), e < 0 || r > t.length || i < 0 || n > this.length) throw new RangeError("out of range index");
                  if (i >= n && e >= r) return 0;
                  if (i >= n) return -1;
                  if (e >= r) return 1;
                  if (this === t) return 0;
                  for (var o = (n >>>= 0) - (i >>>= 0), s = (r >>>= 0) - (e >>>= 0), a = Math.min(o, s), u = this.slice(i, n), c = t.slice(e, r), h = 0; h < a; ++h) if (u[h] !== c[h]) {
                      o = u[h], s = c[h];
                      break;
                  }
                  return o < s ? -1 : s < o ? 1 : 0;
              }, k.prototype.includes = function(t, e, r) {
                  return -1 !== this.indexOf(t, e, r);
              }, k.prototype.indexOf = function(t, e, r) {
                  return vc(this, t, e, r, !0);
              }, k.prototype.lastIndexOf = function(t, e, r) {
                  return vc(this, t, e, r, !1);
              }, k.prototype.write = function(t, e, r, i) {
                  if (void 0 === e) i = "utf8", r = this.length, e = 0; else if (void 0 === r && "string" == typeof e) i = e, 
                  r = this.length, e = 0; else {
                      if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                      e >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === i && (i = "utf8")) : (i = r, r = void 0);
                  }
                  var n = this.length - e;
                  if ((void 0 === r || r > n) && (r = n), t.length > 0 && (r < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                  i || (i = "utf8");
                  for (var o = !1; ;) switch (i) {
                    case "hex":
                      return ww(this, t, e, r);

                    case "utf8":
                    case "utf-8":
                      return _w(this, t, e, r);

                    case "ascii":
                      return Oc(this, t, e, r);

                    case "latin1":
                    case "binary":
                      return mw(this, t, e, r);

                    case "base64":
                      return vw(this, t, e, r);

                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return Ew(this, t, e, r);

                    default:
                      if (o) throw new TypeError("Unknown encoding: " + i);
                      i = ("" + i).toLowerCase(), o = !0;
                  }
              }, k.prototype.toJSON = function() {
                  return {
                      type: "Buffer",
                      data: Array.prototype.slice.call(this._arr || this, 0)
                  };
              }, k.prototype.slice = function(t, e) {
                  var r = this.length;
                  (t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), 
                  e < t && (e = t);
                  var i = this.subarray(t, e);
                  return Object.setPrototypeOf(i, k.prototype), i;
              }, k.prototype.readUIntLE = function(t, e, r) {
                  t >>>= 0, e >>>= 0, r || be(t, e, this.length);
                  for (var i = this[t], n = 1, o = 0; ++o < e && (n *= 256); ) i += this[t + o] * n;
                  return i;
              }, k.prototype.readUIntBE = function(t, e, r) {
                  t >>>= 0, e >>>= 0, r || be(t, e, this.length);
                  for (var i = this[t + --e], n = 1; e > 0 && (n *= 256); ) i += this[t + --e] * n;
                  return i;
              }, k.prototype.readUInt8 = function(t, e) {
                  return t >>>= 0, e || be(t, 1, this.length), this[t];
              }, k.prototype.readUInt16LE = function(t, e) {
                  return t >>>= 0, e || be(t, 2, this.length), this[t] | this[t + 1] << 8;
              }, k.prototype.readUInt16BE = function(t, e) {
                  return t >>>= 0, e || be(t, 2, this.length), this[t] << 8 | this[t + 1];
              }, k.prototype.readUInt32LE = function(t, e) {
                  return t >>>= 0, e || be(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
              }, k.prototype.readUInt32BE = function(t, e) {
                  return t >>>= 0, e || be(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
              }, k.prototype.readIntLE = function(t, e, r) {
                  t >>>= 0, e >>>= 0, r || be(t, e, this.length);
                  for (var i = this[t], n = 1, o = 0; ++o < e && (n *= 256); ) i += this[t + o] * n;
                  return i >= (n *= 128) && (i -= Math.pow(2, 8 * e)), i;
              }, k.prototype.readIntBE = function(t, e, r) {
                  t >>>= 0, e >>>= 0, r || be(t, e, this.length);
                  for (var i = e, n = 1, o = this[t + --i]; i > 0 && (n *= 256); ) o += this[t + --i] * n;
                  return o >= (n *= 128) && (o -= Math.pow(2, 8 * e)), o;
              }, k.prototype.readInt8 = function(t, e) {
                  return t >>>= 0, e || be(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
              }, k.prototype.readInt16LE = function(t, e) {
                  t >>>= 0, e || be(t, 2, this.length);
                  var r = this[t] | this[t + 1] << 8;
                  return 32768 & r ? 4294901760 | r : r;
              }, k.prototype.readInt16BE = function(t, e) {
                  t >>>= 0, e || be(t, 2, this.length);
                  var r = this[t + 1] | this[t] << 8;
                  return 32768 & r ? 4294901760 | r : r;
              }, k.prototype.readInt32LE = function(t, e) {
                  return t >>>= 0, e || be(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
              }, k.prototype.readInt32BE = function(t, e) {
                  return t >>>= 0, e || be(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
              }, k.prototype.readFloatLE = function(t, e) {
                  return t >>>= 0, e || be(t, 4, this.length), Nr.read(this, t, !0, 23, 4);
              }, k.prototype.readFloatBE = function(t, e) {
                  return t >>>= 0, e || be(t, 4, this.length), Nr.read(this, t, !1, 23, 4);
              }, k.prototype.readDoubleLE = function(t, e) {
                  return t >>>= 0, e || be(t, 8, this.length), Nr.read(this, t, !0, 52, 8);
              }, k.prototype.readDoubleBE = function(t, e) {
                  return t >>>= 0, e || be(t, 8, this.length), Nr.read(this, t, !1, 52, 8);
              }, k.prototype.writeUIntLE = function(t, e, r, i) {
                  t = +t, e >>>= 0, r >>>= 0, i || Pe(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                  var n = 1, o = 0;
                  for (this[e] = 255 & t; ++o < r && (n *= 256); ) this[e + o] = t / n & 255;
                  return e + r;
              }, k.prototype.writeUIntBE = function(t, e, r, i) {
                  t = +t, e >>>= 0, r >>>= 0, i || Pe(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
                  var n = r - 1, o = 1;
                  for (this[e + n] = 255 & t; --n >= 0 && (o *= 256); ) this[e + n] = t / o & 255;
                  return e + r;
              }, k.prototype.writeUInt8 = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 1, 255, 0), this[e] = 255 & t, e + 1;
              }, k.prototype.writeUInt16LE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 2, 65535, 0), this[e] = 255 & t, this[e + 1] = t >>> 8, 
                  e + 2;
              }, k.prototype.writeUInt16BE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = 255 & t, 
                  e + 2;
              }, k.prototype.writeUInt32LE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, 
                  this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t, e + 4;
              }, k.prototype.writeUInt32BE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, 
                  this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4;
              }, k.prototype.writeIntLE = function(t, e, r, i) {
                  if (t = +t, e >>>= 0, !i) {
                      var n = Math.pow(2, 8 * r - 1);
                      Pe(this, t, e, r, n - 1, -n);
                  }
                  var o = 0, s = 1, a = 0;
                  for (this[e] = 255 & t; ++o < r && (s *= 256); ) t < 0 && 0 === a && 0 !== this[e + o - 1] && (a = 1), 
                  this[e + o] = (t / s >> 0) - a & 255;
                  return e + r;
              }, k.prototype.writeIntBE = function(t, e, r, i) {
                  if (t = +t, e >>>= 0, !i) {
                      var n = Math.pow(2, 8 * r - 1);
                      Pe(this, t, e, r, n - 1, -n);
                  }
                  var o = r - 1, s = 1, a = 0;
                  for (this[e + o] = 255 & t; --o >= 0 && (s *= 256); ) t < 0 && 0 === a && 0 !== this[e + o + 1] && (a = 1), 
                  this[e + o] = (t / s >> 0) - a & 255;
                  return e + r;
              }, k.prototype.writeInt8 = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 1, 127, -128), t < 0 && (t = 255 + t + 1), 
                  this[e] = 255 & t, e + 1;
              }, k.prototype.writeInt16LE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 2, 32767, -32768), this[e] = 255 & t, 
                  this[e + 1] = t >>> 8, e + 2;
              }, k.prototype.writeInt16BE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, 
                  this[e + 1] = 255 & t, e + 2;
              }, k.prototype.writeInt32LE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 4, 2147483647, -2147483648), this[e] = 255 & t, 
                  this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4;
              }, k.prototype.writeInt32BE = function(t, e, r) {
                  return t = +t, e >>>= 0, r || Pe(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), 
                  this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, 
                  e + 4;
              }, k.prototype.writeFloatLE = function(t, e, r) {
                  return Sc(this, t, e, !0, r);
              }, k.prototype.writeFloatBE = function(t, e, r) {
                  return Sc(this, t, e, !1, r);
              }, k.prototype.writeDoubleLE = function(t, e, r) {
                  return Ac(this, t, e, !0, r);
              }, k.prototype.writeDoubleBE = function(t, e, r) {
                  return Ac(this, t, e, !1, r);
              }, k.prototype.copy = function(t, e, r, i) {
                  if (!k.isBuffer(t)) throw new TypeError("argument should be a Buffer");
                  if (r || (r = 0), i || 0 === i || (i = this.length), e >= t.length && (e = t.length), 
                  e || (e = 0), i > 0 && i < r && (i = r), i === r || 0 === t.length || 0 === this.length) return 0;
                  if (e < 0) throw new RangeError("targetStart out of bounds");
                  if (r < 0 || r >= this.length) throw new RangeError("Index out of range");
                  if (i < 0) throw new RangeError("sourceEnd out of bounds");
                  i > this.length && (i = this.length), t.length - e < i - r && (i = t.length - e + r);
                  var n = i - r;
                  if (this === t && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(e, r, i); else if (this === t && r < e && e < i) for (var o = n - 1; o >= 0; --o) t[o + e] = this[o + r]; else Uint8Array.prototype.set.call(t, this.subarray(r, i), e);
                  return n;
              }, k.prototype.fill = function(t, e, r, i) {
                  if ("string" == typeof t) {
                      if ("string" == typeof e ? (i = e, e = 0, r = this.length) : "string" == typeof r && (i = r, 
                      r = this.length), void 0 !== i && "string" != typeof i) throw new TypeError("encoding must be a string");
                      if ("string" == typeof i && !k.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
                      if (1 === t.length) {
                          var n = t.charCodeAt(0);
                          ("utf8" === i && n < 128 || "latin1" === i) && (t = n);
                      }
                  } else "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t));
                  if (e < 0 || this.length < e || this.length < r) throw new RangeError("Out of range index");
                  if (r <= e) return this;
                  var o;
                  if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), "number" == typeof t) for (o = e; o < r; ++o) this[o] = t; else {
                      var s = k.isBuffer(t) ? t : k.from(t, i), a = s.length;
                      if (0 === a) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                      for (o = 0; o < r - e; ++o) this[o + e] = s[o % a];
                  }
                  return this;
              }, Cw = /[^+/0-9A-Za-z-_]/g, Bw = function() {
                  for (var t = new Array(256), e = 0; e < 16; ++e) for (var r = 16 * e, i = 0; i < 16; ++i) t[r + i] = "0123456789abcdef"[e] + "0123456789abcdef"[i];
                  return t;
              }(), At.Buffer, At.INSPECT_MAX_BYTES, At.kMaxLength, an = {}, (it = (ln = At).Buffer).from && it.alloc && it.allocUnsafe && it.allocUnsafeSlow ? an = ln : (Ic(ln, an), 
              an.Buffer = or), or.prototype = Object.create(it.prototype), Ic(it, or), or.from = function(t, e, r) {
                  if ("number" == typeof t) throw new TypeError("Argument must not be a number");
                  return it(t, e, r);
              }, or.alloc = function(t, e, r) {
                  if ("number" != typeof t) throw new TypeError("Argument must be a number");
                  var i = it(t);
                  return void 0 !== e ? "string" == typeof r ? i.fill(e, r) : i.fill(e) : i.fill(0), 
                  i;
              }, or.allocUnsafe = function(t) {
                  if ("number" != typeof t) throw new TypeError("Argument must be a number");
                  return it(t);
              }, or.allocUnsafeSlow = function(t) {
                  if ("number" != typeof t) throw new TypeError("Argument must be a number");
                  return ln.SlowBuffer(t);
              }, ar = {}, Ks = an.Buffer, Tc = Ks.isEncoding || function(t) {
                  switch ((t = "" + t) && t.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw":
                      return !0;

                    default:
                      return !1;
                  }
              }, ar.StringDecoder = hi, hi.prototype.write = function(t) {
                  if (0 === t.length) return "";
                  var e, r;
                  if (this.lastNeed) {
                      if (void 0 === (e = this.fillLast(t))) return "";
                      r = this.lastNeed, this.lastNeed = 0;
                  } else r = 0;
                  return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
              }, hi.prototype.end = function(t) {
                  var e = t && t.length ? this.write(t) : "";
                  return this.lastNeed ? e + "" : e;
              }, hi.prototype.text = function(t, e) {
                  var r = function(n, o, s) {
                      var a = o.length - 1;
                      if (a < s) return 0;
                      var u = $s(o[a]);
                      return u >= 0 ? (u > 0 && (n.lastNeed = u - 1), u) : --a < s || -2 === u ? 0 : (u = $s(o[a])) >= 0 ? (u > 0 && (n.lastNeed = u - 2), 
                      u) : --a < s || -2 === u ? 0 : (u = $s(o[a])) >= 0 ? (u > 0 && (2 === u ? u = 0 : n.lastNeed = u - 3), 
                      u) : 0;
                  }(this, t, e);
                  if (!this.lastNeed) return t.toString("utf8", e);
                  this.lastTotal = r;
                  var i = t.length - (r - this.lastNeed);
                  return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i);
              }, hi.prototype.fillLast = function(t) {
                  if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), 
                  this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
              }, ar.StringDecoder, ar.StringDecoder;
          })), Lc = {};
          Qt(Lc, {
              StringDecoder: () => qw,
              default: () => ar
          });
          var qw, Uc = we((() => {
              v(), m(), _(), Ys(), Ys(), qw = ar.StringDecoder;
          })), Js = M((($2, jc) => {
              v(), m(), _();
              var Nc = Nt(), {PromisePrototypeThen: Dw, SymbolAsyncIterator: qc, SymbolIterator: Dc} = ce(), {Buffer: jw} = (ye(), 
              X(_e)), {ERR_INVALID_ARG_TYPE: Fw, ERR_STREAM_NULL_VALUES: Ww} = Se().codes;
              jc.exports = function(t, e, r) {
                  let i, n;
                  if ("string" == typeof e || e instanceof jw) return new t({
                      objectMode: !0,
                      ...r,
                      read() {
                          this.push(e), this.push(null);
                      }
                  });
                  if (e && e[qc]) n = !0, i = e[qc](); else {
                      if (!e || !e[Dc]) throw new Fw("iterable", [ "Iterable" ], e);
                      n = !1, i = e[Dc]();
                  }
                  let o = new t({
                      objectMode: !0,
                      highWaterMark: 1,
                      ...r
                  }), s = !1;
                  return o._read = function() {
                      s || (s = !0, async function() {
                          for (;;) {
                              try {
                                  let {value: c, done: h} = n ? await i.next() : i.next();
                                  if (h) o.push(null); else {
                                      let d = c && "function" == typeof c.then ? await c : c;
                                      if (null === d) throw s = !1, new Ww;
                                      if (o.push(d)) continue;
                                      s = !1;
                                  }
                              } catch (c) {
                                  o.destroy(c);
                              }
                              break;
                          }
                      }());
                  }, o._destroy = function(c, h) {
                      Dw(async function(c) {
                          let h = null != c, d = "function" == typeof i.throw;
                          if (h && d) {
                              let {value: g, done: y} = await i.throw(c);
                              if (await g, y) return;
                          }
                          if ("function" == typeof i.return) {
                              let {value: g} = await i.return();
                              await g;
                          }
                      }(c), (() => Nc.nextTick(h, c)), (d => Nc.nextTick(h, d || c)));
                  }, o;
              };
          })), di = M(((Z2, Zc) => {
              v(), m(), _();
              var He = Nt(), {ArrayPrototypeIndexOf: Hw, NumberIsInteger: Vw, NumberIsNaN: zw, NumberParseInt: Kw, ObjectDefineProperties: $c, ObjectKeys: Gw, ObjectSetPrototypeOf: Hc, Promise: Qw, SafeSet: Yw, SymbolAsyncIterator: Jw, Symbol: Xw} = ce();
              Zc.exports = F, F.ReadableState = io;
              var {EventEmitter: Zw} = (ir(), X(rr)), {Stream: Dt, prependListener: e_} = tn(), {Buffer: Xs} = (ye(), 
              X(_e)), {addAbortSignal: t_} = ci(), r_ = vt(), H = Je().debuglog("stream", (t => {
                  H = t;
              })), i_ = dc(), Dr = tr(), {getHighWaterMark: n_, getDefaultHighWaterMark: s_} = sn(), {aggregateTwoErrors: Fc, codes: {ERR_INVALID_ARG_TYPE: o_, ERR_METHOD_NOT_IMPLEMENTED: a_, ERR_OUT_OF_RANGE: l_, ERR_STREAM_PUSH_AFTER_EOF: u_, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: f_}} = Se(), {validateObject: c_} = fi(), lr = Xw("kPaused"), {StringDecoder: Vc} = (Uc(), 
              X(Lc)), h_ = Js();
              Hc(F.prototype, Dt.prototype), Hc(F, Dt);
              var Zs = () => {}, {errorOrDestroy: qr} = Dr;
              function io(t, e, r) {
                  "boolean" != typeof r && (r = e instanceof nt()), this.objectMode = !(!t || !t.objectMode), 
                  r && (this.objectMode = this.objectMode || !(!t || !t.readableObjectMode)), this.highWaterMark = t ? n_(this, t, "readableHighWaterMark", r) : s_(!1), 
                  this.buffer = new i_, this.length = 0, this.pipes = [], this.flowing = null, this.ended = !1, 
                  this.endEmitted = !1, this.reading = !1, this.constructed = !0, this.sync = !0, 
                  this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, 
                  this.resumeScheduled = !1, this[lr] = null, this.errorEmitted = !1, this.emitClose = !t || !1 !== t.emitClose, 
                  this.autoDestroy = !t || !1 !== t.autoDestroy, this.destroyed = !1, this.errored = null, 
                  this.closed = !1, this.closeEmitted = !1, this.defaultEncoding = t && t.defaultEncoding || "utf8", 
                  this.awaitDrainWriters = null, this.multiAwaitDrain = !1, this.readingMore = !1, 
                  this.dataEmitted = !1, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new Vc(t.encoding), 
                  this.encoding = t.encoding);
              }
              function F(t) {
                  if (!(this instanceof F)) return new F(t);
                  let e = this instanceof nt();
                  this._readableState = new io(t, this, e), t && ("function" == typeof t.read && (this._read = t.read), 
                  "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.construct && (this._construct = t.construct), 
                  t.signal && !e && t_(t.signal, this)), Dt.call(this, t), Dr.construct(this, (() => {
                      this._readableState.needReadable && fn(this, this._readableState);
                  }));
              }
              function zc(t, e, r, i) {
                  H("readableAddChunk", e);
                  let o, n = t._readableState;
                  if (n.objectMode || ("string" == typeof e ? (r = r || n.defaultEncoding, n.encoding !== r && (i && n.encoding ? e = Xs.from(e, r).toString(n.encoding) : (e = Xs.from(e, r), 
                  r = ""))) : e instanceof Xs ? r = "" : Dt._isUint8Array(e) ? (e = Dt._uint8ArrayToBuffer(e), 
                  r = "") : null != e && (o = new o_("chunk", [ "string", "Buffer", "Uint8Array" ], e))), 
                  o) qr(t, o); else if (null === e) n.reading = !1, function(t, e) {
                      if (H("onEofChunk"), !e.ended) {
                          if (e.decoder) {
                              let r = e.decoder.end();
                              r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
                          }
                          e.ended = !0, e.sync ? cn(t) : (e.needReadable = !1, e.emittedReadable = !0, Kc(t));
                      }
                  }(t, n); else if (n.objectMode || e && e.length > 0) if (i) if (n.endEmitted) qr(t, new f_); else {
                      if (n.destroyed || n.errored) return !1;
                      eo(t, n, e, !0);
                  } else if (n.ended) qr(t, new u_); else {
                      if (n.destroyed || n.errored) return !1;
                      n.reading = !1, n.decoder && !r ? (e = n.decoder.write(e), n.objectMode || 0 !== e.length ? eo(t, n, e, !1) : fn(t, n)) : eo(t, n, e, !1);
                  } else i || (n.reading = !1, fn(t, n));
                  return !n.ended && (n.length < n.highWaterMark || 0 === n.length);
              }
              function eo(t, e, r, i) {
                  e.flowing && 0 === e.length && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, 
                  e.dataEmitted = !0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, 
                  i ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && cn(t)), fn(t, e);
              }
              F.prototype.destroy = Dr.destroy, F.prototype._undestroy = Dr.undestroy, F.prototype._destroy = function(t, e) {
                  e(t);
              }, F.prototype[Zw.captureRejectionSymbol] = function(t) {
                  this.destroy(t);
              }, F.prototype.push = function(t, e) {
                  return zc(this, t, e, !1);
              }, F.prototype.unshift = function(t, e) {
                  return zc(this, t, e, !0);
              }, F.prototype.isPaused = function() {
                  let t = this._readableState;
                  return !0 === t[lr] || !1 === t.flowing;
              }, F.prototype.setEncoding = function(t) {
                  let e = new Vc(t);
                  this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
                  let r = this._readableState.buffer, i = "";
                  for (let n of r) i += e.write(n);
                  return r.clear(), "" !== i && r.push(i), this._readableState.length = i.length, 
                  this;
              };
              var ro;
              function Wc(t, e) {
                  return t <= 0 || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : zw(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
              }
              function cn(t) {
                  let e = t._readableState;
                  H("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (H("emitReadable", e.flowing), 
                  e.emittedReadable = !0, He.nextTick(Kc, t));
              }
              function Kc(t) {
                  let e = t._readableState;
                  H("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), 
                  e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, 
                  Qc(t);
              }
              function fn(t, e) {
                  !e.readingMore && e.constructed && (e.readingMore = !0, He.nextTick(y_, t, e));
              }
              function y_(t, e) {
                  for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && 0 === e.length); ) {
                      let r = e.length;
                      if (H("maybeReadMore read 0"), t.read(0), r === e.length) break;
                  }
                  e.readingMore = !1;
              }
              function Gc(t) {
                  let e = t._readableState;
                  e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !1 === e[lr] ? e.flowing = !0 : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
              }
              function w_(t) {
                  H("readable nexttick read 0"), t.read(0);
              }
              function m_(t, e) {
                  H("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = !1, t.emit("resume"), 
                  Qc(t), e.flowing && !e.reading && t.read(0);
              }
              function Qc(t) {
                  let e = t._readableState;
                  for (H("flow", e.flowing); e.flowing && null !== t.read(); ) ;
              }
              function Yc(t, e) {
                  "function" != typeof t.read && (t = F.wrap(t, {
                      objectMode: !0
                  }));
                  let r = async function*(t, e) {
                      let r = Zs;
                      function i(s) {
                          this === t ? (r(), r = Zs) : r = s;
                      }
                      t.on("readable", i);
                      let n, o = r_(t, {
                          writable: !1
                      }, (s => {
                          n = s ? Fc(n, s) : null, r(), r = Zs;
                      }));
                      try {
                          for (;;) {
                              let s = t.destroyed ? null : t.read();
                              if (null !== s) yield s; else {
                                  if (n) throw n;
                                  if (null === n) return;
                                  await new Qw(i);
                              }
                          }
                      } catch (s) {
                          throw n = Fc(n, s), n;
                      } finally {
                          !n && !1 === e?.destroyOnReturn || void 0 !== n && !t._readableState.autoDestroy ? (t.off("readable", i), 
                          o()) : Dr.destroyer(t, null);
                      }
                  }(t, e);
                  return r.stream = t, r;
              }
              function Jc(t, e) {
                  if (0 === e.length) return null;
                  let r;
                  return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (r = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.first() : e.buffer.concat(e.length), 
                  e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
              }
              function to(t) {
                  let e = t._readableState;
                  H("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, He.nextTick(E_, e, t));
              }
              function E_(t, e) {
                  if (H("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && 0 === t.length) if (t.endEmitted = !0, 
                  e.emit("end"), e.writable && !1 === e.allowHalfOpen) He.nextTick(S_, e); else if (t.autoDestroy) {
                      let r = e._writableState;
                      (!r || r.autoDestroy && (r.finished || !1 === r.writable)) && e.destroy();
                  }
              }
              function S_(t) {
                  t.writable && !t.writableEnded && !t.destroyed && t.end();
              }
              function Xc() {
                  return void 0 === ro && (ro = {}), ro;
              }
              F.prototype.read = function(t) {
                  H("read", t), void 0 === t ? t = NaN : Vw(t) || (t = Kw(t, 10));
                  let e = this._readableState, r = t;
                  if (t > e.highWaterMark && (e.highWaterMark = function(t) {
                      if (t > 1073741824) throw new l_("size", "<= 1GiB", t);
                      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, 
                      ++t;
                  }(t)), 0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && ((0 !== e.highWaterMark ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return H("read: emitReadable", e.length, e.ended), 
                  0 === e.length && e.ended ? to(this) : cn(this), null;
                  if (0 === (t = Wc(t, e)) && e.ended) return 0 === e.length && to(this), null;
                  let n, i = e.needReadable;
                  if (H("need readable", i), (0 === e.length || e.length - t < e.highWaterMark) && (i = !0, 
                  H("length less than watermark", i)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed) i = !1, 
                  H("reading, ended or constructing", i); else if (i) {
                      H("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0);
                      try {
                          this._read(e.highWaterMark);
                      } catch (o) {
                          qr(this, o);
                      }
                      e.sync = !1, e.reading || (t = Wc(r, e));
                  }
                  return n = t > 0 ? Jc(t, e) : null, null === n ? (e.needReadable = e.length <= e.highWaterMark, 
                  t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), 
                  0 === e.length && (e.ended || (e.needReadable = !0), r !== t && e.ended && to(this)), 
                  null !== n && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = !0, this.emit("data", n)), 
                  n;
              }, F.prototype._read = function(t) {
                  throw new a_("_read()");
              }, F.prototype.pipe = function(t, e) {
                  let r = this, i = this._readableState;
                  1 === i.pipes.length && (i.multiAwaitDrain || (i.multiAwaitDrain = !0, i.awaitDrainWriters = new Yw(i.awaitDrainWriters ? [ i.awaitDrainWriters ] : []))), 
                  i.pipes.push(t), H("pipe count=%d opts=%j", i.pipes.length, e);
                  let o = e && !1 === e.end || t === He.stdout || t === He.stderr ? S : a;
                  function s(I, C) {
                      H("onunpipe"), I === r && C && !1 === C.hasUnpiped && (C.hasUnpiped = !0, H("cleanup"), 
                      t.removeListener("close", w), t.removeListener("finish", E), u && t.removeListener("drain", u), 
                      t.removeListener("error", y), t.removeListener("unpipe", s), r.removeListener("end", a), 
                      r.removeListener("end", S), r.removeListener("data", g), c = !0, u && i.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && u());
                  }
                  function a() {
                      H("onend"), t.end();
                  }
                  i.endEmitted ? He.nextTick(o) : r.once("end", o), t.on("unpipe", s);
                  let u, c = !1;
                  function d() {
                      c || (1 === i.pipes.length && i.pipes[0] === t ? (H("false write response, pause", 0), 
                      i.awaitDrainWriters = t, i.multiAwaitDrain = !1) : i.pipes.length > 1 && i.pipes.includes(t) && (H("false write response, pause", i.awaitDrainWriters.size), 
                      i.awaitDrainWriters.add(t)), r.pause()), u || (u = function(t, e) {
                          return function() {
                              let i = t._readableState;
                              i.awaitDrainWriters === e ? (H("pipeOnDrain", 1), i.awaitDrainWriters = null) : i.multiAwaitDrain && (H("pipeOnDrain", i.awaitDrainWriters.size), 
                              i.awaitDrainWriters.delete(e)), (!i.awaitDrainWriters || 0 === i.awaitDrainWriters.size) && t.listenerCount("data") && t.resume();
                          };
                      }(r, t), t.on("drain", u));
                  }
                  function g(I) {
                      H("ondata");
                      let C = t.write(I);
                      H("dest.write", C), !1 === C && d();
                  }
                  function y(I) {
                      if (H("onerror", I), S(), t.removeListener("error", y), 0 === t.listenerCount("error")) {
                          let C = t._writableState || t._readableState;
                          C && !C.errorEmitted ? qr(t, I) : t.emit("error", I);
                      }
                  }
                  function w() {
                      t.removeListener("finish", E), S();
                  }
                  function E() {
                      H("onfinish"), t.removeListener("close", w), S();
                  }
                  function S() {
                      H("unpipe"), r.unpipe(t);
                  }
                  return r.on("data", g), e_(t, "error", y), t.once("close", w), t.once("finish", E), 
                  t.emit("pipe", r), !0 === t.writableNeedDrain ? i.flowing && d() : i.flowing || (H("pipe resume"), 
                  r.resume()), t;
              }, F.prototype.unpipe = function(t) {
                  let e = this._readableState;
                  if (0 === e.pipes.length) return this;
                  if (!t) {
                      let n = e.pipes;
                      e.pipes = [], this.pause();
                      for (let o = 0; o < n.length; o++) n[o].emit("unpipe", this, {
                          hasUnpiped: !1
                      });
                      return this;
                  }
                  let i = Hw(e.pipes, t);
                  return -1 === i || (e.pipes.splice(i, 1), 0 === e.pipes.length && this.pause(), 
                  t.emit("unpipe", this, {
                      hasUnpiped: !1
                  })), this;
              }, F.prototype.on = function(t, e) {
                  let r = Dt.prototype.on.call(this, t, e), i = this._readableState;
                  return "data" === t ? (i.readableListening = this.listenerCount("readable") > 0, 
                  !1 !== i.flowing && this.resume()) : "readable" === t && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, 
                  i.flowing = !1, i.emittedReadable = !1, H("on readable", i.length, i.reading), i.length ? cn(this) : i.reading || He.nextTick(w_, this)), 
                  r;
              }, F.prototype.addListener = F.prototype.on, F.prototype.removeListener = function(t, e) {
                  let r = Dt.prototype.removeListener.call(this, t, e);
                  return "readable" === t && He.nextTick(Gc, this), r;
              }, F.prototype.off = F.prototype.removeListener, F.prototype.removeAllListeners = function(t) {
                  let e = Dt.prototype.removeAllListeners.apply(this, arguments);
                  return ("readable" === t || void 0 === t) && He.nextTick(Gc, this), e;
              }, F.prototype.resume = function() {
                  let t = this._readableState;
                  return t.flowing || (H("resume"), t.flowing = !t.readableListening, function(t, e) {
                      e.resumeScheduled || (e.resumeScheduled = !0, He.nextTick(m_, t, e));
                  }(this, t)), t[lr] = !1, this;
              }, F.prototype.pause = function() {
                  return H("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (H("pause"), 
                  this._readableState.flowing = !1, this.emit("pause")), this._readableState[lr] = !0, 
                  this;
              }, F.prototype.wrap = function(t) {
                  let e = !1;
                  t.on("data", (i => {
                      !this.push(i) && t.pause && (e = !0, t.pause());
                  })), t.on("end", (() => {
                      this.push(null);
                  })), t.on("error", (i => {
                      qr(this, i);
                  })), t.on("close", (() => {
                      this.destroy();
                  })), t.on("destroy", (() => {
                      this.destroy();
                  })), this._read = () => {
                      e && t.resume && (e = !1, t.resume());
                  };
                  let r = Gw(t);
                  for (let i = 1; i < r.length; i++) {
                      let n = r[i];
                      void 0 === this[n] && "function" == typeof t[n] && (this[n] = t[n].bind(t));
                  }
                  return this;
              }, F.prototype[Jw] = function() {
                  return Yc(this);
              }, F.prototype.iterator = function(t) {
                  return void 0 !== t && c_(t, "options"), Yc(this, t);
              }, $c(F.prototype, {
                  readable: {
                      __proto__: null,
                      get() {
                          let t = this._readableState;
                          return !(!t || !1 === t.readable || t.destroyed || t.errorEmitted || t.endEmitted);
                      },
                      set(t) {
                          this._readableState && (this._readableState.readable = !!t);
                      }
                  },
                  readableDidRead: {
                      __proto__: null,
                      enumerable: !1,
                      get: function() {
                          return this._readableState.dataEmitted;
                      }
                  },
                  readableAborted: {
                      __proto__: null,
                      enumerable: !1,
                      get: function() {
                          return !(!1 === this._readableState.readable || !this._readableState.destroyed && !this._readableState.errored || this._readableState.endEmitted);
                      }
                  },
                  readableHighWaterMark: {
                      __proto__: null,
                      enumerable: !1,
                      get: function() {
                          return this._readableState.highWaterMark;
                      }
                  },
                  readableBuffer: {
                      __proto__: null,
                      enumerable: !1,
                      get: function() {
                          return this._readableState && this._readableState.buffer;
                      }
                  },
                  readableFlowing: {
                      __proto__: null,
                      enumerable: !1,
                      get: function() {
                          return this._readableState.flowing;
                      },
                      set: function(t) {
                          this._readableState && (this._readableState.flowing = t);
                      }
                  },
                  readableLength: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return this._readableState.length;
                      }
                  },
                  readableObjectMode: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return !!this._readableState && this._readableState.objectMode;
                      }
                  },
                  readableEncoding: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return this._readableState ? this._readableState.encoding : null;
                      }
                  },
                  errored: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return this._readableState ? this._readableState.errored : null;
                      }
                  },
                  closed: {
                      __proto__: null,
                      get() {
                          return !!this._readableState && this._readableState.closed;
                      }
                  },
                  destroyed: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return !!this._readableState && this._readableState.destroyed;
                      },
                      set(t) {
                          this._readableState && (this._readableState.destroyed = t);
                      }
                  },
                  readableEnded: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return !!this._readableState && this._readableState.endEmitted;
                      }
                  }
              }), $c(io.prototype, {
                  pipesCount: {
                      __proto__: null,
                      get() {
                          return this.pipes.length;
                      }
                  },
                  paused: {
                      __proto__: null,
                      get() {
                          return !1 !== this[lr];
                      },
                      set(t) {
                          this[lr] = !!t;
                      }
                  }
              }), F._fromList = Jc, F.from = function(t, e) {
                  return h_(F, t, e);
              }, F.fromWeb = function(t, e) {
                  return Xc().newStreamReadableFromReadableStream(t, e);
              }, F.toWeb = function(t, e) {
                  return Xc().newReadableStreamFromStreamReadable(t, e);
              }, F.wrap = function(t, e) {
                  var r, i;
                  return new F({
                      objectMode: null === (r = null !== (i = t.readableObjectMode) && void 0 !== i ? i : t.objectMode) || void 0 === r || r,
                      ...e,
                      destroy(n, o) {
                          Dr.destroyer(t, n), o(n);
                      }
                  }).wrap(t);
              };
          })), fo = M(((uR, ch) => {
              v(), m(), _();
              var ur = Nt(), {ArrayPrototypeSlice: rh, Error: A_, FunctionPrototypeSymbolHasInstance: ih, ObjectDefineProperty: nh, ObjectDefineProperties: I_, ObjectSetPrototypeOf: sh, StringPrototypeToLowerCase: T_, Symbol: R_, SymbolHasInstance: C_} = ce();
              ch.exports = ie, ie.WritableState = yi;
              var {EventEmitter: B_} = (ir(), X(rr)), pi = tn().Stream, {Buffer: hn} = (ye(), 
              X(_e)), gn = tr(), {addAbortSignal: P_} = ci(), {getHighWaterMark: O_, getDefaultHighWaterMark: k_} = sn(), {ERR_INVALID_ARG_TYPE: x_, ERR_METHOD_NOT_IMPLEMENTED: M_, ERR_MULTIPLE_CALLBACK: oh, ERR_STREAM_CANNOT_PIPE: L_, ERR_STREAM_DESTROYED: gi, ERR_STREAM_ALREADY_FINISHED: U_, ERR_STREAM_NULL_VALUES: N_, ERR_STREAM_WRITE_AFTER_END: q_, ERR_UNKNOWN_ENCODING: ah} = Se().codes, {errorOrDestroy: jr} = gn;
              function oo() {}
              sh(ie.prototype, pi.prototype), sh(ie, pi);
              var Fr = R_("kOnFinished");
              function yi(t, e, r) {
                  "boolean" != typeof r && (r = e instanceof nt()), this.objectMode = !(!t || !t.objectMode), 
                  r && (this.objectMode = this.objectMode || !(!t || !t.writableObjectMode)), this.highWaterMark = t ? O_(this, t, "writableHighWaterMark", r) : k_(!1), 
                  this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, 
                  this.destroyed = !1;
                  let i = !(!t || !1 !== t.decodeStrings);
                  this.decodeStrings = !i, this.defaultEncoding = t && t.defaultEncoding || "utf8", 
                  this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, 
                  this.onwrite = j_.bind(void 0, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, 
                  pn(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, 
                  this.emitClose = !t || !1 !== t.emitClose, this.autoDestroy = !t || !1 !== t.autoDestroy, 
                  this.errored = null, this.closed = !1, this.closeEmitted = !1, this[Fr] = [];
              }
              function pn(t) {
                  t.buffered = [], t.bufferedIndex = 0, t.allBuffers = !0, t.allNoop = !0;
              }
              function ie(t) {
                  let e = this instanceof nt();
                  if (!e && !ih(ie, this)) return new ie(t);
                  this._writableState = new yi(t, this, e), t && ("function" == typeof t.write && (this._write = t.write), 
                  "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), 
                  "function" == typeof t.final && (this._final = t.final), "function" == typeof t.construct && (this._construct = t.construct), 
                  t.signal && P_(t.signal, this)), pi.call(this, t), gn.construct(this, (() => {
                      let r = this._writableState;
                      r.writing || lo(this, r), uo(this, r);
                  }));
              }
              function lh(t, e, r, i) {
                  let o, n = t._writableState;
                  if ("function" == typeof r) i = r, r = n.defaultEncoding; else {
                      if (r) {
                          if ("buffer" !== r && !hn.isEncoding(r)) throw new ah(r);
                      } else r = n.defaultEncoding;
                      "function" != typeof i && (i = oo);
                  }
                  if (null === e) throw new N_;
                  if (!n.objectMode) if ("string" == typeof e) !1 !== n.decodeStrings && (e = hn.from(e, r), 
                  r = "buffer"); else if (e instanceof hn) r = "buffer"; else {
                      if (!pi._isUint8Array(e)) throw new x_("chunk", [ "string", "Buffer", "Uint8Array" ], e);
                      e = pi._uint8ArrayToBuffer(e), r = "buffer";
                  }
                  return n.ending ? o = new q_ : n.destroyed && (o = new gi("write")), o ? (ur.nextTick(i, o), 
                  jr(t, o, !0), o) : (n.pendingcb++, function(t, e, r, i, n) {
                      let o = e.objectMode ? 1 : r.length;
                      e.length += o;
                      let s = e.length < e.highWaterMark;
                      return s || (e.needDrain = !0), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({
                          chunk: r,
                          encoding: i,
                          callback: n
                      }), e.allBuffers && "buffer" !== i && (e.allBuffers = !1), e.allNoop && n !== oo && (e.allNoop = !1)) : (e.writelen = o, 
                      e.writecb = n, e.writing = !0, e.sync = !0, t._write(r, i, e.onwrite), e.sync = !1), 
                      s && !e.errored && !e.destroyed;
                  }(t, n, e, r, i));
              }
              function eh(t, e, r, i, n, o, s) {
                  e.writelen = i, e.writecb = s, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new gi("write")) : r ? t._writev(n, e.onwrite) : t._write(n, o, e.onwrite), 
                  e.sync = !1;
              }
              function th(t, e, r, i) {
                  --e.pendingcb, i(r), ao(e), jr(t, r);
              }
              function j_(t, e) {
                  let r = t._writableState, i = r.sync, n = r.writecb;
                  "function" == typeof n ? (r.writing = !1, r.writecb = null, r.length -= r.writelen, 
                  r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), 
                  i ? ur.nextTick(th, t, r, e, n) : th(t, r, e, n)) : (r.buffered.length > r.bufferedIndex && lo(t, r), 
                  i ? null !== r.afterWriteTickInfo && r.afterWriteTickInfo.cb === n ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = {
                      count: 1,
                      cb: n,
                      stream: t,
                      state: r
                  }, ur.nextTick(F_, r.afterWriteTickInfo)) : uh(t, r, 1, n))) : jr(t, new oh);
              }
              function F_({stream: t, state: e, count: r, cb: i}) {
                  return e.afterWriteTickInfo = null, uh(t, e, r, i);
              }
              function uh(t, e, r, i) {
                  for (!e.ending && !t.destroyed && 0 === e.length && e.needDrain && (e.needDrain = !1, 
                  t.emit("drain")); r-- > 0; ) e.pendingcb--, i();
                  e.destroyed && ao(e), uo(t, e);
              }
              function ao(t) {
                  if (t.writing) return;
                  for (let n = t.bufferedIndex; n < t.buffered.length; ++n) {
                      var e;
                      let {chunk: o, callback: s} = t.buffered[n], a = t.objectMode ? 1 : o.length;
                      t.length -= a, s(null !== (e = t.errored) && void 0 !== e ? e : new gi("write"));
                  }
                  let r = t[Fr].splice(0);
                  for (let n = 0; n < r.length; n++) {
                      var i;
                      r[n](null !== (i = t.errored) && void 0 !== i ? i : new gi("end"));
                  }
                  pn(t);
              }
              function lo(t, e) {
                  if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed) return;
                  let {buffered: r, bufferedIndex: i, objectMode: n} = e, o = r.length - i;
                  if (!o) return;
                  let s = i;
                  if (e.bufferProcessing = !0, o > 1 && t._writev) {
                      e.pendingcb -= o - 1;
                      let a = e.allNoop ? oo : c => {
                          for (let h = s; h < r.length; ++h) r[h].callback(c);
                      }, u = e.allNoop && 0 === s ? r : rh(r, s);
                      u.allBuffers = e.allBuffers, eh(t, e, !0, e.length, u, "", a), pn(e);
                  } else {
                      do {
                          let {chunk: a, encoding: u, callback: c} = r[s];
                          r[s++] = null, eh(t, e, !1, n ? 1 : a.length, a, u, c);
                      } while (s < r.length && !e.writing);
                      s === r.length ? pn(e) : s > 256 ? (r.splice(0, s), e.bufferedIndex = 0) : e.bufferedIndex = s;
                  }
                  e.bufferProcessing = !1;
              }
              function dn(t) {
                  return t.ending && !t.destroyed && t.constructed && 0 === t.length && !t.errored && 0 === t.buffered.length && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
              }
              function $_(t, e) {
                  !e.prefinished && !e.finalCalled && ("function" != typeof t._final || e.destroyed ? (e.prefinished = !0, 
                  t.emit("prefinish")) : (e.finalCalled = !0, function(t, e) {
                      let r = !1;
                      function i(n) {
                          if (r) jr(t, n ?? oh()); else if (r = !0, e.pendingcb--, n) {
                              let o = e[Fr].splice(0);
                              for (let s = 0; s < o.length; s++) o[s](n);
                              jr(t, n, e.sync);
                          } else dn(e) && (e.prefinished = !0, t.emit("prefinish"), e.pendingcb++, ur.nextTick(so, t, e));
                      }
                      e.sync = !0, e.pendingcb++;
                      try {
                          t._final(i);
                      } catch (n) {
                          i(n);
                      }
                      e.sync = !1;
                  }(t, e)));
              }
              function uo(t, e, r) {
                  dn(e) && ($_(t, e), 0 === e.pendingcb && (r ? (e.pendingcb++, ur.nextTick(((i, n) => {
                      dn(n) ? so(i, n) : n.pendingcb--;
                  }), t, e)) : dn(e) && (e.pendingcb++, so(t, e))));
              }
              function so(t, e) {
                  e.pendingcb--, e.finished = !0;
                  let r = e[Fr].splice(0);
                  for (let i = 0; i < r.length; i++) r[i]();
                  if (t.emit("finish"), e.autoDestroy) {
                      let i = t._readableState;
                      (!i || i.autoDestroy && (i.endEmitted || !1 === i.readable)) && t.destroy();
                  }
              }
              yi.prototype.getBuffer = function() {
                  return rh(this.buffered, this.bufferedIndex);
              }, nh(yi.prototype, "bufferedRequestCount", {
                  __proto__: null,
                  get() {
                      return this.buffered.length - this.bufferedIndex;
                  }
              }), nh(ie, C_, {
                  __proto__: null,
                  value: function(t) {
                      return !!ih(this, t) || this === ie && (t && t._writableState instanceof yi);
                  }
              }), ie.prototype.pipe = function() {
                  jr(this, new L_);
              }, ie.prototype.write = function(t, e, r) {
                  return !0 === lh(this, t, e, r);
              }, ie.prototype.cork = function() {
                  this._writableState.corked++;
              }, ie.prototype.uncork = function() {
                  let t = this._writableState;
                  t.corked && (t.corked--, t.writing || lo(this, t));
              }, ie.prototype.setDefaultEncoding = function(e) {
                  if ("string" == typeof e && (e = T_(e)), !hn.isEncoding(e)) throw new ah(e);
                  return this._writableState.defaultEncoding = e, this;
              }, ie.prototype._write = function(t, e, r) {
                  if (!this._writev) throw new M_("_write()");
                  this._writev([ {
                      chunk: t,
                      encoding: e
                  } ], r);
              }, ie.prototype._writev = null, ie.prototype.end = function(t, e, r) {
                  let n, i = this._writableState;
                  if ("function" == typeof t ? (r = t, t = null, e = null) : "function" == typeof e && (r = e, 
                  e = null), null != t) {
                      let o = lh(this, t, e);
                      o instanceof A_ && (n = o);
                  }
                  return i.corked && (i.corked = 1, this.uncork()), n || (i.errored || i.ending ? i.finished ? n = new U_("end") : i.destroyed && (n = new gi("end")) : (i.ending = !0, 
                  uo(this, i, !0), i.ended = !0)), "function" == typeof r && (n || i.finished ? ur.nextTick(r, n) : i[Fr].push(r)), 
                  this;
              }, I_(ie.prototype, {
                  closed: {
                      __proto__: null,
                      get() {
                          return !!this._writableState && this._writableState.closed;
                      }
                  },
                  destroyed: {
                      __proto__: null,
                      get() {
                          return !!this._writableState && this._writableState.destroyed;
                      },
                      set(t) {
                          this._writableState && (this._writableState.destroyed = t);
                      }
                  },
                  writable: {
                      __proto__: null,
                      get() {
                          let t = this._writableState;
                          return !(!t || !1 === t.writable || t.destroyed || t.errored || t.ending || t.ended);
                      },
                      set(t) {
                          this._writableState && (this._writableState.writable = !!t);
                      }
                  },
                  writableFinished: {
                      __proto__: null,
                      get() {
                          return !!this._writableState && this._writableState.finished;
                      }
                  },
                  writableObjectMode: {
                      __proto__: null,
                      get() {
                          return !!this._writableState && this._writableState.objectMode;
                      }
                  },
                  writableBuffer: {
                      __proto__: null,
                      get() {
                          return this._writableState && this._writableState.getBuffer();
                      }
                  },
                  writableEnded: {
                      __proto__: null,
                      get() {
                          return !!this._writableState && this._writableState.ending;
                      }
                  },
                  writableNeedDrain: {
                      __proto__: null,
                      get() {
                          let t = this._writableState;
                          return !!t && (!t.destroyed && !t.ending && t.needDrain);
                      }
                  },
                  writableHighWaterMark: {
                      __proto__: null,
                      get() {
                          return this._writableState && this._writableState.highWaterMark;
                      }
                  },
                  writableCorked: {
                      __proto__: null,
                      get() {
                          return this._writableState ? this._writableState.corked : 0;
                      }
                  },
                  writableLength: {
                      __proto__: null,
                      get() {
                          return this._writableState && this._writableState.length;
                      }
                  },
                  errored: {
                      __proto__: null,
                      enumerable: !1,
                      get() {
                          return this._writableState ? this._writableState.errored : null;
                      }
                  },
                  writableAborted: {
                      __proto__: null,
                      enumerable: !1,
                      get: function() {
                          return !(!1 === this._writableState.writable || !this._writableState.destroyed && !this._writableState.errored || this._writableState.finished);
                      }
                  }
              });
              var no, H_ = gn.destroy;
              function fh() {
                  return void 0 === no && (no = {}), no;
              }
              ie.prototype.destroy = function(t, e) {
                  let r = this._writableState;
                  return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[Fr].length) && ur.nextTick(ao, r), 
                  H_.call(this, t, e), this;
              }, ie.prototype._undestroy = gn.undestroy, ie.prototype._destroy = function(t, e) {
                  e(t);
              }, ie.prototype[B_.captureRejectionSymbol] = function(t) {
                  this.destroy(t);
              }, ie.fromWeb = function(t, e) {
                  return fh().newStreamWritableFromWritableStream(t, e);
              }, ie.toWeb = function(t) {
                  return fh().newWritableStreamFromStreamWritable(t);
              };
          })), Sh = M(((_R, Eh) => {
              v(), m(), _();
              var co = Nt(), V_ = (ye(), X(_e)), {isReadable: z_, isWritable: K_, isIterable: hh, isNodeStream: G_, isReadableNodeStream: dh, isWritableNodeStream: ph, isDuplexNodeStream: Q_} = tt(), gh = vt(), {AbortError: vh, codes: {ERR_INVALID_ARG_TYPE: Y_, ERR_INVALID_RETURN_VALUE: yh}} = Se(), {destroyer: Wr} = tr(), J_ = nt(), X_ = di(), {createDeferredPromise: bh} = Je(), wh = Js(), _h = globalThis.Blob || V_.Blob, Z_ = typeof _h < "u" ? function(e) {
                  return e instanceof _h;
              } : function(e) {
                  return !1;
              }, e0 = globalThis.AbortController || Hi().AbortController, {FunctionPrototypeCall: mh} = ce(), fr = class extends J_ {
                  constructor(e) {
                      super(e), !1 === e?.readable && (this._readableState.readable = !1, this._readableState.ended = !0, 
                      this._readableState.endEmitted = !0), !1 === e?.writable && (this._writableState.writable = !1, 
                      this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
                  }
              };
              function yn(t) {
                  let o, s, a, u, c, e = t.readable && "function" != typeof t.readable.read ? X_.wrap(t.readable) : t.readable, r = t.writable, i = !!z_(e), n = !!K_(r);
                  function h(d) {
                      let g = u;
                      u = null, g ? g(d) : d && c.destroy(d);
                  }
                  return c = new fr({
                      readableObjectMode: !(null == e || !e.readableObjectMode),
                      writableObjectMode: !(null == r || !r.writableObjectMode),
                      readable: i,
                      writable: n
                  }), n && (gh(r, (d => {
                      n = !1, d && Wr(e, d), h(d);
                  })), c._write = function(d, g, y) {
                      r.write(d, g) ? y() : o = y;
                  }, c._final = function(d) {
                      r.end(), s = d;
                  }, r.on("drain", (function() {
                      if (o) {
                          let d = o;
                          o = null, d();
                      }
                  })), r.on("finish", (function() {
                      if (s) {
                          let d = s;
                          s = null, d();
                      }
                  }))), i && (gh(e, (d => {
                      i = !1, d && Wr(e, d), h(d);
                  })), e.on("readable", (function() {
                      if (a) {
                          let d = a;
                          a = null, d();
                      }
                  })), e.on("end", (function() {
                      c.push(null);
                  })), c._read = function() {
                      for (;;) {
                          let d = e.read();
                          if (null === d) return void (a = c._read);
                          if (!c.push(d)) return;
                      }
                  }), c._destroy = function(d, g) {
                      !d && null !== u && (d = new vh), a = null, o = null, s = null, null === u ? g(d) : (u = g, 
                      Wr(r, d), Wr(e, d));
                  }, c;
              }
              Eh.exports = function t(e, r) {
                  if (Q_(e)) return e;
                  if (dh(e)) return yn({
                      readable: e
                  });
                  if (ph(e)) return yn({
                      writable: e
                  });
                  if (G_(e)) return yn({
                      writable: !1,
                      readable: !1
                  });
                  if ("function" == typeof e) {
                      let {value: n, write: o, final: s, destroy: a} = function(t) {
                          let {promise: e, resolve: r} = bh(), i = new e0, n = i.signal;
                          return {
                              value: t(async function*() {
                                  for (;;) {
                                      let s = e;
                                      e = null;
                                      let {chunk: a, done: u, cb: c} = await s;
                                      if (co.nextTick(c), u) return;
                                      if (n.aborted) throw new vh(void 0, {
                                          cause: n.reason
                                      });
                                      ({promise: e, resolve: r} = bh()), yield a;
                                  }
                              }(), {
                                  signal: n
                              }),
                              write(s, a, u) {
                                  let c = r;
                                  r = null, c({
                                      chunk: s,
                                      done: !1,
                                      cb: u
                                  });
                              },
                              final(s) {
                                  let a = r;
                                  r = null, a({
                                      done: !0,
                                      cb: s
                                  });
                              },
                              destroy(s, a) {
                                  i.abort(), a(s);
                              }
                          };
                      }(e);
                      if (hh(n)) return wh(fr, n, {
                          objectMode: !0,
                          write: o,
                          final: s,
                          destroy: a
                      });
                      let u = n?.then;
                      if ("function" == typeof u) {
                          let c, h = mh(u, n, (d => {
                              if (null != d) throw new yh("nully", "body", d);
                          }), (d => {
                              Wr(c, d);
                          }));
                          return c = new fr({
                              objectMode: !0,
                              readable: !1,
                              write: o,
                              final(d) {
                                  s((async () => {
                                      try {
                                          await h, co.nextTick(d, null);
                                      } catch (g) {
                                          co.nextTick(d, g);
                                      }
                                  }));
                              },
                              destroy: a
                          });
                      }
                      throw new yh("Iterable, AsyncIterable or AsyncFunction", r, n);
                  }
                  if (Z_(e)) return t(e.arrayBuffer());
                  if (hh(e)) return wh(fr, e, {
                      objectMode: !0,
                      writable: !1
                  });
                  if ("object" == typeof e?.writable || "object" == typeof e?.readable) {
                      return yn({
                          readable: null != e && e.readable ? dh(e?.readable) ? e?.readable : t(e.readable) : void 0,
                          writable: null != e && e.writable ? ph(e?.writable) ? e?.writable : t(e.writable) : void 0
                      });
                  }
                  let i = e?.then;
                  if ("function" == typeof i) {
                      let n;
                      return mh(i, e, (o => {
                          null != o && n.push(o), n.push(null);
                      }), (o => {
                          Wr(n, o);
                      })), n = new fr({
                          objectMode: !0,
                          writable: !1,
                          read() {}
                      });
                  }
                  throw new Y_(r, [ "Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise" ], e);
              };
          })), nt = M(((BR, Th) => {
              v(), m(), _();
              var {ObjectDefineProperties: r0, ObjectGetOwnPropertyDescriptor: It, ObjectKeys: i0, ObjectSetPrototypeOf: Ah} = ce();
              Th.exports = Ve;
              var ho, po, go = di(), Ne = fo();
              Ah(Ve.prototype, go.prototype), Ah(Ve, go);
              {
                  let t = i0(Ne.prototype);
                  for (let e = 0; e < t.length; e++) {
                      let r = t[e];
                      Ve.prototype[r] || (Ve.prototype[r] = Ne.prototype[r]);
                  }
              }
              function Ve(t) {
                  if (!(this instanceof Ve)) return new Ve(t);
                  go.call(this, t), Ne.call(this, t), t ? (this.allowHalfOpen = !1 !== t.allowHalfOpen, 
                  !1 === t.readable && (this._readableState.readable = !1, this._readableState.ended = !0, 
                  this._readableState.endEmitted = !0), !1 === t.writable && (this._writableState.writable = !1, 
                  this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
              }
              function Ih() {
                  return void 0 === ho && (ho = {}), ho;
              }
              r0(Ve.prototype, {
                  writable: {
                      __proto__: null,
                      ...It(Ne.prototype, "writable")
                  },
                  writableHighWaterMark: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableHighWaterMark")
                  },
                  writableObjectMode: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableObjectMode")
                  },
                  writableBuffer: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableBuffer")
                  },
                  writableLength: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableLength")
                  },
                  writableFinished: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableFinished")
                  },
                  writableCorked: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableCorked")
                  },
                  writableEnded: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableEnded")
                  },
                  writableNeedDrain: {
                      __proto__: null,
                      ...It(Ne.prototype, "writableNeedDrain")
                  },
                  destroyed: {
                      __proto__: null,
                      get() {
                          return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
                      },
                      set(t) {
                          this._readableState && this._writableState && (this._readableState.destroyed = t, 
                          this._writableState.destroyed = t);
                      }
                  }
              }), Ve.fromWeb = function(t, e) {
                  return Ih().newStreamDuplexFromReadableWritablePair(t, e);
              }, Ve.toWeb = function(t) {
                  return Ih().newReadableWritablePairFromDuplex(t);
              }, Ve.from = function(t) {
                  return po || (po = Sh()), po(t, "body");
              };
          })), wo = M(((DR, Ch) => {
              v(), m(), _();
              var {ObjectSetPrototypeOf: Rh, Symbol: n0} = ce();
              Ch.exports = Tt;
              var {ERR_METHOD_NOT_IMPLEMENTED: s0} = Se().codes, bo = nt(), {getHighWaterMark: o0} = sn();
              Rh(Tt.prototype, bo.prototype), Rh(Tt, bo);
              var bi = n0("kCallback");
              function Tt(t) {
                  if (!(this instanceof Tt)) return new Tt(t);
                  let e = t ? o0(this, t, "readableHighWaterMark", !0) : null;
                  0 === e && (t = {
                      ...t,
                      highWaterMark: null,
                      readableHighWaterMark: e,
                      writableHighWaterMark: t.writableHighWaterMark || 0
                  }), bo.call(this, t), this._readableState.sync = !1, this[bi] = null, t && ("function" == typeof t.transform && (this._transform = t.transform), 
                  "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", a0);
              }
              function yo(t) {
                  "function" != typeof this._flush || this.destroyed ? (this.push(null), t && t()) : this._flush(((e, r) => {
                      e ? t ? t(e) : this.destroy(e) : (null != r && this.push(r), this.push(null), t && t());
                  }));
              }
              function a0() {
                  this._final !== yo && yo.call(this);
              }
              Tt.prototype._final = yo, Tt.prototype._transform = function(t, e, r) {
                  throw new s0("_transform()");
              }, Tt.prototype._write = function(t, e, r) {
                  let i = this._readableState, n = this._writableState, o = i.length;
                  this._transform(t, e, ((s, a) => {
                      s ? r(s) : (null != a && this.push(a), n.ended || o === i.length || i.length < i.highWaterMark ? r() : this[bi] = r);
                  }));
              }, Tt.prototype._read = function() {
                  if (this[bi]) {
                      let t = this[bi];
                      this[bi] = null, t();
                  }
              };
          })), mo = M(((QR, Ph) => {
              v(), m(), _();
              var {ObjectSetPrototypeOf: Bh} = ce();
              Ph.exports = $r;
              var _o = wo();
              function $r(t) {
                  if (!(this instanceof $r)) return new $r(t);
                  _o.call(this, t);
              }
              Bh($r.prototype, _o.prototype), Bh($r, _o), $r.prototype._transform = function(t, e, r) {
                  r(null, t);
              };
          })), mn = M(((sC, Lh) => {
              v(), m(), _();
              var Ao, Io, wi = Nt(), {ArrayIsArray: l0, Promise: u0, SymbolAsyncIterator: f0} = ce(), _n = vt(), {once: c0} = Je(), h0 = tr(), Oh = nt(), {aggregateTwoErrors: d0, codes: {ERR_INVALID_ARG_TYPE: Co, ERR_INVALID_RETURN_VALUE: vo, ERR_MISSING_ARGS: p0, ERR_STREAM_DESTROYED: g0, ERR_STREAM_PREMATURE_CLOSE: y0}, AbortError: b0} = Se(), {validateFunction: w0, validateAbortSignal: _0} = fi(), {isIterable: cr, isReadable: Eo, isReadableNodeStream: wn, isNodeStream: kh, isTransformStream: Hr, isWebStream: m0, isReadableStream: So, isReadableEnded: v0} = tt(), E0 = globalThis.AbortController || Hi().AbortController;
              function xh(t, e, r) {
                  let i = !1;
                  return t.on("close", (() => {
                      i = !0;
                  })), {
                      destroy: o => {
                          i || (i = !0, h0.destroyer(t, o || new g0("pipe")));
                      },
                      cleanup: _n(t, {
                          readable: e,
                          writable: r
                      }, (o => {
                          i = !o;
                      }))
                  };
              }
              function To(t) {
                  if (cr(t)) return t;
                  if (wn(t)) return async function*(t) {
                      Io || (Io = di()), yield* Io.prototype[f0].call(t);
                  }(t);
                  throw new Co("val", [ "Readable", "Iterable", "AsyncIterable" ], t);
              }
              async function bn(t, e, r, {end: i}) {
                  let n, o = null, s = c => {
                      if (c && (n = c), o) {
                          let h = o;
                          o = null, h();
                      }
                  }, a = () => new u0(((c, h) => {
                      n ? h(n) : o = () => {
                          n ? h(n) : c();
                      };
                  }));
                  e.on("drain", s);
                  let u = _n(e, {
                      readable: !1
                  }, s);
                  try {
                      e.writableNeedDrain && await a();
                      for await (let c of t) e.write(c) || await a();
                      i && e.end(), await a(), r();
                  } catch (c) {
                      r(n !== c ? d0(n, c) : c);
                  } finally {
                      u(), e.off("drain", s);
                  }
              }
              async function Ro(t, e, r, {end: i}) {
                  Hr(e) && (e = e.writable);
                  let n = e.getWriter();
                  try {
                      for await (let o of t) await n.ready, n.write(o).catch((() => {}));
                      await n.ready, i && await n.close(), r();
                  } catch (o) {
                      try {
                          await n.abort(o), r(o);
                      } catch (s) {
                          r(s);
                      }
                  }
              }
              function Mh(t, e, r) {
                  if (1 === t.length && l0(t[0]) && (t = t[0]), t.length < 2) throw new p0("streams");
                  let i = new E0, n = i.signal, o = r?.signal, s = [];
                  function a() {
                      y(new b0);
                  }
                  _0(o, "options.signal"), o?.addEventListener("abort", a);
                  let u, c, w, h = [], d = 0;
                  function g(C) {
                      y(C, 0 == --d);
                  }
                  function y(C, R) {
                      if (C && (!u || "ERR_STREAM_PREMATURE_CLOSE" === u.code) && (u = C), u || R) {
                          for (;h.length; ) h.shift()(u);
                          o?.removeEventListener("abort", a), i.abort(), R && (u || s.forEach((U => U())), 
                          wi.nextTick(e, u, c));
                      }
                  }
                  for (let C = 0; C < t.length; C++) {
                      let R = t[C], U = C < t.length - 1, N = C > 0, W = U || !1 !== r?.end, K = C === t.length - 1;
                      if (kh(R)) {
                          let z = function(Q) {
                              Q && "AbortError" !== Q.name && "ERR_STREAM_PREMATURE_CLOSE" !== Q.code && g(Q);
                          };
                          if (W) {
                              let {destroy: Q, cleanup: de} = xh(R, U, N);
                              h.push(Q), Eo(R) && K && s.push(de);
                          }
                          R.on("error", z), Eo(R) && K && s.push((() => {
                              R.removeListener("error", z);
                          }));
                      }
                      if (0 === C) if ("function" == typeof R) {
                          if (w = R({
                              signal: n
                          }), !cr(w)) throw new vo("Iterable, AsyncIterable or Stream", "source", w);
                      } else w = cr(R) || wn(R) || Hr(R) ? R : Oh.from(R); else if ("function" == typeof R) {
                          var E;
                          if (Hr(w)) w = To(null === (E = w) || void 0 === E ? void 0 : E.readable); else w = To(w);
                          if (w = R(w, {
                              signal: n
                          }), U) {
                              if (!cr(w, !0)) throw new vo("AsyncIterable", `transform[${C - 1}]`, w);
                          } else {
                              var S;
                              Ao || (Ao = mo());
                              let z = new Ao({
                                  objectMode: !0
                              }), Q = null === (S = w) || void 0 === S ? void 0 : S.then;
                              if ("function" == typeof Q) d++, Q.call(w, (pe => {
                                  c = pe, null != pe && z.write(pe), W && z.end(), wi.nextTick(g);
                              }), (pe => {
                                  z.destroy(pe), wi.nextTick(g, pe);
                              })); else if (cr(w, !0)) d++, bn(w, z, g, {
                                  end: W
                              }); else {
                                  if (!So(w) && !Hr(w)) throw new vo("AsyncIterable or Promise", "destination", w);
                                  {
                                      let pe = w.readable || w;
                                      d++, bn(pe, z, g, {
                                          end: W
                                      });
                                  }
                              }
                              w = z;
                              let {destroy: de, cleanup: Gt} = xh(w, !1, !0);
                              h.push(de), K && s.push(Gt);
                          }
                      } else if (kh(R)) {
                          if (wn(w)) {
                              d += 2;
                              let z = T0(w, R, g, {
                                  end: W
                              });
                              Eo(R) && K && s.push(z);
                          } else if (Hr(w) || So(w)) {
                              let z = w.readable || w;
                              d++, bn(z, R, g, {
                                  end: W
                              });
                          } else {
                              if (!cr(w)) throw new Co("val", [ "Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream" ], w);
                              d++, bn(w, R, g, {
                                  end: W
                              });
                          }
                          w = R;
                      } else if (m0(R)) {
                          if (wn(w)) d++, Ro(To(w), R, g, {
                              end: W
                          }); else if (So(w) || cr(w)) d++, Ro(w, R, g, {
                              end: W
                          }); else {
                              if (!Hr(w)) throw new Co("val", [ "Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream" ], w);
                              d++, Ro(w.readable, R, g, {
                                  end: W
                              });
                          }
                          w = R;
                      } else w = Oh.from(R);
                  }
                  return (null != n && n.aborted || null != o && o.aborted) && wi.nextTick(a), w;
              }
              function T0(t, e, r, {end: i}) {
                  let n = !1;
                  if (e.on("close", (() => {
                      n || r(new y0);
                  })), t.pipe(e, {
                      end: !1
                  }), i) {
                      let s = function() {
                          n = !0, e.end();
                      };
                      v0(t) ? wi.nextTick(s) : t.once("end", s);
                  } else r();
                  return _n(t, {
                      readable: !0,
                      writable: !1
                  }, (s => {
                      let a = t._readableState;
                      s && "ERR_STREAM_PREMATURE_CLOSE" === s.code && a && a.ended && !a.errored && !a.errorEmitted ? t.once("end", r).once("error", r) : r(s);
                  })), _n(e, {
                      readable: !1,
                      writable: !0
                  }, r);
              }
              Lh.exports = {
                  pipelineImpl: Mh,
                  pipeline: function(...t) {
                      return Mh(t, c0(function(t) {
                          return w0(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
                      }(t)));
                  }
              };
          })), Po = M(((gC, Fh) => {
              v(), m(), _();
              var {pipeline: R0} = mn(), vn = nt(), {destroyer: C0} = tr(), {isNodeStream: En, isReadable: Uh, isWritable: Nh, isWebStream: Bo, isTransformStream: hr, isWritableStream: qh, isReadableStream: Dh} = tt(), {AbortError: B0, codes: {ERR_INVALID_ARG_VALUE: jh, ERR_MISSING_ARGS: P0}} = Se(), O0 = vt();
              Fh.exports = function(...e) {
                  if (0 === e.length) throw new P0("streams");
                  if (1 === e.length) return vn.from(e[0]);
                  let i, n, o, s, a, r = [ ...e ];
                  if ("function" == typeof e[0] && (e[0] = vn.from(e[0])), "function" == typeof e[e.length - 1]) {
                      let y = e.length - 1;
                      e[y] = vn.from(e[y]);
                  }
                  for (let y = 0; y < e.length; ++y) if (En(e[y]) || Bo(e[y])) {
                      if (y < e.length - 1 && !(Uh(e[y]) || Dh(e[y]) || hr(e[y]))) throw new jh(`streams[${y}]`, r[y], "must be readable");
                      if (y > 0 && !(Nh(e[y]) || qh(e[y]) || hr(e[y]))) throw new jh(`streams[${y}]`, r[y], "must be writable");
                  }
                  let c = e[0], h = R0(e, (function(y) {
                      let w = s;
                      s = null, w ? w(y) : y ? a.destroy(y) : !g && !d && a.destroy();
                  })), d = !!(Nh(c) || qh(c) || hr(c)), g = !!(Uh(h) || Dh(h) || hr(h));
                  if (a = new vn({
                      writableObjectMode: !(null == c || !c.writableObjectMode),
                      readableObjectMode: !(null == h || !h.writableObjectMode),
                      writable: d,
                      readable: g
                  }), d) {
                      if (En(c)) a._write = function(w, E, S) {
                          c.write(w, E) ? S() : i = S;
                      }, a._final = function(w) {
                          c.end(), n = w;
                      }, c.on("drain", (function() {
                          if (i) {
                              let w = i;
                              i = null, w();
                          }
                      })); else if (Bo(c)) {
                          let E = (hr(c) ? c.writable : c).getWriter();
                          a._write = async function(S, I, C) {
                              try {
                                  await E.ready, E.write(S).catch((() => {})), C();
                              } catch (R) {
                                  C(R);
                              }
                          }, a._final = async function(S) {
                              try {
                                  await E.ready, E.close().catch((() => {})), n = S;
                              } catch (I) {
                                  S(I);
                              }
                          };
                      }
                      let y = hr(h) ? h.readable : h;
                      O0(y, (() => {
                          if (n) {
                              let w = n;
                              n = null, w();
                          }
                      }));
                  }
                  if (g) if (En(h)) h.on("readable", (function() {
                      if (o) {
                          let y = o;
                          o = null, y();
                      }
                  })), h.on("end", (function() {
                      a.push(null);
                  })), a._read = function() {
                      for (;;) {
                          let y = h.read();
                          if (null === y) return void (o = a._read);
                          if (!a.push(y)) return;
                      }
                  }; else if (Bo(h)) {
                      let w = (hr(h) ? h.readable : h).getReader();
                      a._read = async function() {
                          for (;;) try {
                              let {value: E, done: S} = await w.read();
                              if (!a.push(E)) return;
                              if (S) return void a.push(null);
                          } catch {
                              return;
                          }
                      };
                  }
                  return a._destroy = function(y, w) {
                      !y && null !== s && (y = new B0), o = null, i = null, n = null, null === s ? w(y) : (s = w, 
                      En(h) && C0(h, y));
                  }, a;
              };
          })), Qh = M(((IC, xo) => {
              v(), m(), _();
              var Vh = globalThis.AbortController || Hi().AbortController, {codes: {ERR_INVALID_ARG_VALUE: k0, ERR_INVALID_ARG_TYPE: _i, ERR_MISSING_ARGS: x0, ERR_OUT_OF_RANGE: M0}, AbortError: st} = Se(), {validateAbortSignal: dr, validateInteger: L0, validateObject: pr} = fi(), U0 = ce().Symbol("kWeak"), {finished: N0} = vt(), q0 = Po(), {addAbortSignalNoValidate: D0} = ci(), {isWritable: j0, isNodeStream: F0} = tt(), {ArrayPrototypePush: W0, MathFloor: $0, Number: H0, NumberIsNaN: V0, Promise: Wh, PromiseReject: $h, PromisePrototypeThen: z0, Symbol: zh} = ce(), Sn = zh("kEmpty"), Hh = zh("kEof");
              function An(t, e) {
                  if ("function" != typeof t) throw new _i("fn", [ "Function", "AsyncFunction" ], t);
                  null != e && pr(e, "options"), null != e?.signal && dr(e.signal, "options.signal");
                  let r = 1;
                  return null != e?.concurrency && (r = $0(e.concurrency)), L0(r, "concurrency", 1), 
                  async function*() {
                      var n, o;
                      let s = new Vh, a = this, u = [], c = s.signal, h = {
                          signal: c
                      }, d = () => s.abort();
                      null != e && null !== (n = e.signal) && void 0 !== n && n.aborted && d(), null == e || null === (o = e.signal) || void 0 === o || o.addEventListener("abort", d);
                      let g, y, w = !1;
                      function E() {
                          w = !0;
                      }
                      !async function() {
                          try {
                              for await (let R of a) {
                                  var I;
                                  if (w) return;
                                  if (c.aborted) throw new st;
                                  try {
                                      R = t(R, h);
                                  } catch (U) {
                                      R = $h(U);
                                  }
                                  R !== Sn && ("function" == typeof (null === (I = R) || void 0 === I ? void 0 : I.catch) && R.catch(E), 
                                  u.push(R), g && (g(), g = null), !w && u.length && u.length >= r && await new Wh((U => {
                                      y = U;
                                  })));
                              }
                              u.push(Hh);
                          } catch (R) {
                              let U = $h(R);
                              z0(U, void 0, E), u.push(U);
                          } finally {
                              var C;
                              w = !0, g && (g(), g = null), null == e || null === (C = e.signal) || void 0 === C || C.removeEventListener("abort", d);
                          }
                      }();
                      try {
                          for (;;) {
                              for (;u.length > 0; ) {
                                  let I = await u[0];
                                  if (I === Hh) return;
                                  if (c.aborted) throw new st;
                                  I !== Sn && (yield I), u.shift(), y && (y(), y = null);
                              }
                              await new Wh((I => {
                                  g = I;
                              }));
                          }
                      } finally {
                          s.abort(), w = !0, y && (y(), y = null);
                      }
                  }.call(this);
              }
              async function Kh(t, e = void 0) {
                  for await (let r of ko.call(this, t, e)) return !0;
                  return !1;
              }
              function ko(t, e) {
                  if ("function" != typeof t) throw new _i("fn", [ "Function", "AsyncFunction" ], t);
                  return An.call(this, (async function(i, n) {
                      return await t(i, n) ? i : Sn;
                  }), e);
              }
              var Oo = class extends x0 {
                  constructor() {
                      super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
                  }
              };
              function Gh(t) {
                  if (t = H0(t), V0(t)) return 0;
                  if (t < 0) throw new M0("number", ">= 0", t);
                  return t;
              }
              xo.exports.streamReturningOperators = {
                  asIndexedPairs: function(t = void 0) {
                      return null != t && pr(t, "options"), null != t?.signal && dr(t.signal, "options.signal"), 
                      async function*() {
                          let r = 0;
                          for await (let n of this) {
                              var i;
                              if (null != t && null !== (i = t.signal) && void 0 !== i && i.aborted) throw new st({
                                  cause: t.signal.reason
                              });
                              yield [ r++, n ];
                          }
                      }.call(this);
                  },
                  drop: function(t, e = void 0) {
                      return null != e && pr(e, "options"), null != e?.signal && dr(e.signal, "options.signal"), 
                      t = Gh(t), async function*() {
                          var i;
                          if (null != e && null !== (i = e.signal) && void 0 !== i && i.aborted) throw new st;
                          for await (let o of this) {
                              var n;
                              if (null != e && null !== (n = e.signal) && void 0 !== n && n.aborted) throw new st;
                              t-- <= 0 && (yield o);
                          }
                      }.call(this);
                  },
                  filter: ko,
                  flatMap: function(t, e) {
                      let r = An.call(this, t, e);
                      return async function*() {
                          for await (let n of r) yield* n;
                      }.call(this);
                  },
                  map: An,
                  take: function(t, e = void 0) {
                      return null != e && pr(e, "options"), null != e?.signal && dr(e.signal, "options.signal"), 
                      t = Gh(t), async function*() {
                          var i;
                          if (null != e && null !== (i = e.signal) && void 0 !== i && i.aborted) throw new st;
                          for await (let o of this) {
                              var n;
                              if (null != e && null !== (n = e.signal) && void 0 !== n && n.aborted) throw new st;
                              if (!(t-- > 0)) return;
                              yield o;
                          }
                      }.call(this);
                  },
                  compose: function(t, e) {
                      if (null != e && pr(e, "options"), null != e?.signal && dr(e.signal, "options.signal"), 
                      F0(t) && !j0(t)) throw new k0("stream", t, "must be writable");
                      let r = q0(this, t);
                      return null != e && e.signal && D0(e.signal, r), r;
                  }
              }, xo.exports.promiseReturningOperators = {
                  every: async function(t, e = void 0) {
                      if ("function" != typeof t) throw new _i("fn", [ "Function", "AsyncFunction" ], t);
                      return !await Kh.call(this, (async (...r) => !await t(...r)), e);
                  },
                  forEach: async function(t, e) {
                      if ("function" != typeof t) throw new _i("fn", [ "Function", "AsyncFunction" ], t);
                      for await (let i of An.call(this, (async function(i, n) {
                          return await t(i, n), Sn;
                      }), e)) ;
                  },
                  reduce: async function(t, e, r) {
                      var i;
                      if ("function" != typeof t) throw new _i("reducer", [ "Function", "AsyncFunction" ], t);
                      null != r && pr(r, "options"), null != r?.signal && dr(r.signal, "options.signal");
                      let n = arguments.length > 1;
                      if (null != r && null !== (i = r.signal) && void 0 !== i && i.aborted) {
                          let c = new st(void 0, {
                              cause: r.signal.reason
                          });
                          throw this.once("error", (() => {})), await N0(this.destroy(c)), c;
                      }
                      let o = new Vh, s = o.signal;
                      if (null != r && r.signal) {
                          let c = {
                              once: !0,
                              [U0]: this
                          };
                          r.signal.addEventListener("abort", (() => o.abort()), c);
                      }
                      let a = !1;
                      try {
                          for await (let c of this) {
                              var u;
                              if (a = !0, null != r && null !== (u = r.signal) && void 0 !== u && u.aborted) throw new st;
                              n ? e = await t(e, c, {
                                  signal: s
                              }) : (e = c, n = !0);
                          }
                          if (!a && !n) throw new Oo;
                      } finally {
                          o.abort();
                      }
                      return e;
                  },
                  toArray: async function(t) {
                      null != t && pr(t, "options"), null != t?.signal && dr(t.signal, "options.signal");
                      let e = [];
                      for await (let i of this) {
                          var r;
                          if (null != t && null !== (r = t.signal) && void 0 !== r && r.aborted) throw new st(void 0, {
                              cause: t.signal.reason
                          });
                          W0(e, i);
                      }
                      return e;
                  },
                  some: Kh,
                  find: async function(t, e) {
                      for await (let r of ko.call(this, t, e)) return r;
                  }
              };
          })), Mo = M(((LC, Yh) => {
              v(), m(), _();
              var {ArrayPrototypePop: im, Promise: nm} = ce(), {isIterable: sm, isNodeStream: om, isWebStream: am} = tt(), {pipelineImpl: lm} = mn(), {finished: um} = vt();
              Lo(), Yh.exports = {
                  finished: um,
                  pipeline: function(...t) {
                      return new nm(((e, r) => {
                          let i, n, o = t[t.length - 1];
                          if (o && "object" == typeof o && !om(o) && !sm(o) && !am(o)) {
                              let s = im(t);
                              i = s.signal, n = s.end;
                          }
                          lm(t, ((s, a) => {
                              s ? r(s) : e(a);
                          }), {
                              signal: i,
                              end: n
                          });
                      }));
                  }
              };
          })), Lo = M(((VC, sd) => {
              v(), m(), _();
              var {Buffer: cm} = (ye(), X(_e)), {ObjectDefineProperty: Rt, ObjectKeys: Zh, ReflectApply: ed} = ce(), {promisify: {custom: td}} = Je(), {streamReturningOperators: Jh, promiseReturningOperators: Xh} = Qh(), {codes: {ERR_ILLEGAL_CONSTRUCTOR: rd}} = Se(), hm = Po(), {pipeline: id} = mn(), {destroyer: dm} = tr(), nd = vt(), Uo = Mo(), No = tt(), le = sd.exports = tn().Stream;
              le.isDisturbed = No.isDisturbed, le.isErrored = No.isErrored, le.isReadable = No.isReadable, 
              le.Readable = di();
              for (let t of Zh(Jh)) {
                  let r = function(...i) {
                      if (new.target) throw rd();
                      return le.Readable.from(ed(e, this, i));
                  };
                  r;
                  let e = Jh[t];
                  Rt(r, "name", {
                      __proto__: null,
                      value: e.name
                  }), Rt(r, "length", {
                      __proto__: null,
                      value: e.length
                  }), Rt(le.Readable.prototype, t, {
                      __proto__: null,
                      value: r,
                      enumerable: !1,
                      configurable: !0,
                      writable: !0
                  });
              }
              for (let t of Zh(Xh)) {
                  let r = function(...n) {
                      if (new.target) throw rd();
                      return ed(e, this, n);
                  };
                  r;
                  let e = Xh[t];
                  Rt(r, "name", {
                      __proto__: null,
                      value: e.name
                  }), Rt(r, "length", {
                      __proto__: null,
                      value: e.length
                  }), Rt(le.Readable.prototype, t, {
                      __proto__: null,
                      value: r,
                      enumerable: !1,
                      configurable: !0,
                      writable: !0
                  });
              }
              le.Writable = fo(), le.Duplex = nt(), le.Transform = wo(), le.PassThrough = mo(), 
              le.pipeline = id;
              var {addAbortSignal: pm} = ci();
              le.addAbortSignal = pm, le.finished = nd, le.destroy = dm, le.compose = hm, Rt(le, "promises", {
                  __proto__: null,
                  configurable: !0,
                  enumerable: !0,
                  get: () => Uo
              }), Rt(id, td, {
                  __proto__: null,
                  enumerable: !0,
                  get: () => Uo.pipeline
              }), Rt(nd, td, {
                  __proto__: null,
                  enumerable: !0,
                  get: () => Uo.finished
              }), le.Stream = le, le._isUint8Array = function(e) {
                  return e instanceof Uint8Array;
              }, le._uint8ArrayToBuffer = function(e) {
                  return cm.from(e.buffer, e.byteOffset, e.byteLength);
              };
          })), jt = M(((tB, ue) => {
              v(), m(), _();
              var he = Lo(), gm = Mo(), ym = he.Readable.destroy;
              ue.exports = he.Readable, ue.exports._uint8ArrayToBuffer = he._uint8ArrayToBuffer, 
              ue.exports._isUint8Array = he._isUint8Array, ue.exports.isDisturbed = he.isDisturbed, 
              ue.exports.isErrored = he.isErrored, ue.exports.isReadable = he.isReadable, ue.exports.Readable = he.Readable, 
              ue.exports.Writable = he.Writable, ue.exports.Duplex = he.Duplex, ue.exports.Transform = he.Transform, 
              ue.exports.PassThrough = he.PassThrough, ue.exports.addAbortSignal = he.addAbortSignal, 
              ue.exports.finished = he.finished, ue.exports.destroy = he.destroy, ue.exports.destroy = ym, 
              ue.exports.pipeline = he.pipeline, ue.exports.compose = he.compose, Object.defineProperty(he, "promises", {
                  configurable: !0,
                  enumerable: !0,
                  get: () => gm
              }), ue.exports.Stream = he.Stream, ue.exports.default = ue.exports;
          })), od = M(((cB, Do) => {
              v(), m(), _(), "function" == typeof Object.create ? Do.exports = function(e, r) {
                  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
                      constructor: {
                          value: e,
                          enumerable: !1,
                          writable: !0,
                          configurable: !0
                      }
                  }));
              } : Do.exports = function(e, r) {
                  if (r) {
                      e.super_ = r;
                      var i = function() {};
                      i.prototype = r.prototype, e.prototype = new i, e.prototype.constructor = e;
                  }
              };
          })), ud = M(((vB, ld) => {
              v(), m(), _();
              var {Buffer: ze} = (ye(), X(_e)), ad = Symbol.for("BufferList");
              function ee(t) {
                  if (!(this instanceof ee)) return new ee(t);
                  ee._init.call(this, t);
              }
              ee._init = function(e) {
                  Object.defineProperty(this, ad, {
                      value: !0
                  }), this._bufs = [], this.length = 0, e && this.append(e);
              }, ee.prototype._new = function(e) {
                  return new ee(e);
              }, ee.prototype._offset = function(e) {
                  if (0 === e) return [ 0, 0 ];
                  let r = 0;
                  for (let i = 0; i < this._bufs.length; i++) {
                      let n = r + this._bufs[i].length;
                      if (e < n || i === this._bufs.length - 1) return [ i, e - r ];
                      r = n;
                  }
              }, ee.prototype._reverseOffset = function(t) {
                  let e = t[0], r = t[1];
                  for (let i = 0; i < e; i++) r += this._bufs[i].length;
                  return r;
              }, ee.prototype.get = function(e) {
                  if (e > this.length || e < 0) return;
                  let r = this._offset(e);
                  return this._bufs[r[0]][r[1]];
              }, ee.prototype.slice = function(e, r) {
                  return "number" == typeof e && e < 0 && (e += this.length), "number" == typeof r && r < 0 && (r += this.length), 
                  this.copy(null, 0, e, r);
              }, ee.prototype.copy = function(e, r, i, n) {
                  if (("number" != typeof i || i < 0) && (i = 0), ("number" != typeof n || n > this.length) && (n = this.length), 
                  i >= this.length || n <= 0) return e || ze.alloc(0);
                  let o = !!e, s = this._offset(i), a = n - i, u = a, c = o && r || 0, h = s[1];
                  if (0 === i && n === this.length) {
                      if (!o) return 1 === this._bufs.length ? this._bufs[0] : ze.concat(this._bufs, this.length);
                      for (let d = 0; d < this._bufs.length; d++) this._bufs[d].copy(e, c), c += this._bufs[d].length;
                      return e;
                  }
                  if (u <= this._bufs[s[0]].length - h) return o ? this._bufs[s[0]].copy(e, r, h, h + u) : this._bufs[s[0]].slice(h, h + u);
                  o || (e = ze.allocUnsafe(a));
                  for (let d = s[0]; d < this._bufs.length; d++) {
                      let g = this._bufs[d].length - h;
                      if (!(u > g)) {
                          this._bufs[d].copy(e, c, h, h + u), c += g;
                          break;
                      }
                      this._bufs[d].copy(e, c, h), c += g, u -= g, h && (h = 0);
                  }
                  return e.length > c ? e.slice(0, c) : e;
              }, ee.prototype.shallowSlice = function(e, r) {
                  if (e = e || 0, r = "number" != typeof r ? this.length : r, e < 0 && (e += this.length), 
                  r < 0 && (r += this.length), e === r) return this._new();
                  let i = this._offset(e), n = this._offset(r), o = this._bufs.slice(i[0], n[0] + 1);
                  return 0 === n[1] ? o.pop() : o[o.length - 1] = o[o.length - 1].slice(0, n[1]), 
                  0 !== i[1] && (o[0] = o[0].slice(i[1])), this._new(o);
              }, ee.prototype.toString = function(e, r, i) {
                  return this.slice(r, i).toString(e);
              }, ee.prototype.consume = function(e) {
                  if (e = Math.trunc(e), Number.isNaN(e) || e <= 0) return this;
                  for (;this._bufs.length; ) {
                      if (!(e >= this._bufs[0].length)) {
                          this._bufs[0] = this._bufs[0].slice(e), this.length -= e;
                          break;
                      }
                      e -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
                  }
                  return this;
              }, ee.prototype.duplicate = function() {
                  let e = this._new();
                  for (let r = 0; r < this._bufs.length; r++) e.append(this._bufs[r]);
                  return e;
              }, ee.prototype.append = function(e) {
                  if (null == e) return this;
                  if (e.buffer) this._appendBuffer(ze.from(e.buffer, e.byteOffset, e.byteLength)); else if (Array.isArray(e)) for (let r = 0; r < e.length; r++) this.append(e[r]); else if (this._isBufferList(e)) for (let r = 0; r < e._bufs.length; r++) this.append(e._bufs[r]); else "number" == typeof e && (e = e.toString()), 
                  this._appendBuffer(ze.from(e));
                  return this;
              }, ee.prototype._appendBuffer = function(e) {
                  this._bufs.push(e), this.length += e.length;
              }, ee.prototype.indexOf = function(t, e, r) {
                  if (void 0 === r && "string" == typeof e && (r = e, e = void 0), "function" == typeof t || Array.isArray(t)) throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
                  if ("number" == typeof t ? t = ze.from([ t ]) : "string" == typeof t ? t = ze.from(t, r) : this._isBufferList(t) ? t = t.slice() : Array.isArray(t.buffer) ? t = ze.from(t.buffer, t.byteOffset, t.byteLength) : ze.isBuffer(t) || (t = ze.from(t)), 
                  e = Number(e || 0), isNaN(e) && (e = 0), e < 0 && (e = this.length + e), e < 0 && (e = 0), 
                  0 === t.length) return e > this.length ? this.length : e;
                  let i = this._offset(e), n = i[0], o = i[1];
                  for (;n < this._bufs.length; n++) {
                      let s = this._bufs[n];
                      for (;o < s.length; ) if (s.length - o >= t.length) {
                          let u = s.indexOf(t, o);
                          if (-1 !== u) return this._reverseOffset([ n, u ]);
                          o = s.length - t.length + 1;
                      } else {
                          let u = this._reverseOffset([ n, o ]);
                          if (this._match(u, t)) return u;
                          o++;
                      }
                      o = 0;
                  }
                  return -1;
              }, ee.prototype._match = function(t, e) {
                  if (this.length - t < e.length) return !1;
                  for (let r = 0; r < e.length; r++) if (this.get(t + r) !== e[r]) return !1;
                  return !0;
              }, function() {
                  let t = {
                      readDoubleBE: 8,
                      readDoubleLE: 8,
                      readFloatBE: 4,
                      readFloatLE: 4,
                      readBigInt64BE: 8,
                      readBigInt64LE: 8,
                      readBigUInt64BE: 8,
                      readBigUInt64LE: 8,
                      readInt32BE: 4,
                      readInt32LE: 4,
                      readUInt32BE: 4,
                      readUInt32LE: 4,
                      readInt16BE: 2,
                      readInt16LE: 2,
                      readUInt16BE: 2,
                      readUInt16LE: 2,
                      readInt8: 1,
                      readUInt8: 1,
                      readIntBE: null,
                      readIntLE: null,
                      readUIntBE: null,
                      readUIntLE: null
                  };
                  for (let e in t) !function(r) {
                      ee.prototype[r] = null === t[r] ? function(i, n) {
                          return this.slice(i, i + n)[r](0, n);
                      } : function(i = 0) {
                          return this.slice(i, i + t[r])[r](0);
                      };
                  }(e);
              }(), ee.prototype._isBufferList = function(e) {
                  return e instanceof ee || ee.isBufferList(e);
              }, ee.isBufferList = function(e) {
                  return null != e && e[ad];
              }, ld.exports = ee;
          })), fd = M(((OB, In) => {
              v(), m(), _();
              var jo = jt().Duplex, bm = od(), mi = ud();
              function Ee(t) {
                  if (!(this instanceof Ee)) return new Ee(t);
                  if ("function" == typeof t) {
                      this._callback = t;
                      let e = function(i) {
                          this._callback && (this._callback(i), this._callback = null);
                      }.bind(this);
                      this.on("pipe", (function(i) {
                          i.on("error", e);
                      })), this.on("unpipe", (function(i) {
                          i.removeListener("error", e);
                      })), t = null;
                  }
                  mi._init.call(this, t), jo.call(this);
              }
              bm(Ee, jo), Object.assign(Ee.prototype, mi.prototype), Ee.prototype._new = function(e) {
                  return new Ee(e);
              }, Ee.prototype._write = function(e, r, i) {
                  this._appendBuffer(e), "function" == typeof i && i();
              }, Ee.prototype._read = function(e) {
                  if (!this.length) return this.push(null);
                  e = Math.min(e, this.length), this.push(this.slice(0, e)), this.consume(e);
              }, Ee.prototype.end = function(e) {
                  jo.prototype.end.call(this, e), this._callback && (this._callback(null, this.slice()), 
                  this._callback = null);
              }, Ee.prototype._destroy = function(e, r) {
                  this._bufs.length = 0, this.length = 0, r(e);
              }, Ee.prototype._isBufferList = function(e) {
                  return e instanceof Ee || e instanceof mi || Ee.isBufferList(e);
              }, Ee.isBufferList = mi.isBufferList, In.exports = Ee, In.exports.BufferListStream = Ee, 
              In.exports.BufferList = mi;
          })), hd = M(((FB, cd) => {
              v(), m(), _();
              cd.exports = class {
                  constructor() {
                      this.cmd = null, this.retain = !1, this.qos = 0, this.dup = !1, this.length = -1, 
                      this.topic = null, this.payload = null;
                  }
              };
          })), Wo = M(((JB, dd) => {
              v(), m(), _();
              var L = dd.exports, {Buffer: Oe} = (ye(), X(_e));
              L.types = {
                  0: "reserved",
                  1: "connect",
                  2: "connack",
                  3: "publish",
                  4: "puback",
                  5: "pubrec",
                  6: "pubrel",
                  7: "pubcomp",
                  8: "subscribe",
                  9: "suback",
                  10: "unsubscribe",
                  11: "unsuback",
                  12: "pingreq",
                  13: "pingresp",
                  14: "disconnect",
                  15: "auth"
              }, L.requiredHeaderFlags = {
                  1: 0,
                  2: 0,
                  4: 0,
                  5: 0,
                  6: 2,
                  7: 0,
                  8: 2,
                  9: 0,
                  10: 2,
                  11: 0,
                  12: 0,
                  13: 0,
                  14: 0,
                  15: 0
              }, L.requiredHeaderFlagsErrors = {};
              for (let t in L.requiredHeaderFlags) {
                  let e = L.requiredHeaderFlags[t];
                  L.requiredHeaderFlagsErrors[t] = "Invalid header flag bits, must be 0x" + e.toString(16) + " for " + L.types[t] + " packet";
              }
              L.codes = {};
              for (let t in L.types) {
                  let e = L.types[t];
                  L.codes[e] = t;
              }
              L.CMD_SHIFT = 4, L.CMD_MASK = 240, L.DUP_MASK = 8, L.QOS_MASK = 3, L.QOS_SHIFT = 1, 
              L.RETAIN_MASK = 1, L.VARBYTEINT_MASK = 127, L.VARBYTEINT_FIN_MASK = 128, L.VARBYTEINT_MAX = 268435455, 
              L.SESSIONPRESENT_MASK = 1, L.SESSIONPRESENT_HEADER = Oe.from([ L.SESSIONPRESENT_MASK ]), 
              L.CONNACK_HEADER = Oe.from([ L.codes.connack << L.CMD_SHIFT ]), L.USERNAME_MASK = 128, 
              L.PASSWORD_MASK = 64, L.WILL_RETAIN_MASK = 32, L.WILL_QOS_MASK = 24, L.WILL_QOS_SHIFT = 3, 
              L.WILL_FLAG_MASK = 4, L.CLEAN_SESSION_MASK = 2, L.CONNECT_HEADER = Oe.from([ L.codes.connect << L.CMD_SHIFT ]), 
              L.properties = {
                  sessionExpiryInterval: 17,
                  willDelayInterval: 24,
                  receiveMaximum: 33,
                  maximumPacketSize: 39,
                  topicAliasMaximum: 34,
                  requestResponseInformation: 25,
                  requestProblemInformation: 23,
                  userProperties: 38,
                  authenticationMethod: 21,
                  authenticationData: 22,
                  payloadFormatIndicator: 1,
                  messageExpiryInterval: 2,
                  contentType: 3,
                  responseTopic: 8,
                  correlationData: 9,
                  maximumQoS: 36,
                  retainAvailable: 37,
                  assignedClientIdentifier: 18,
                  reasonString: 31,
                  wildcardSubscriptionAvailable: 40,
                  subscriptionIdentifiersAvailable: 41,
                  sharedSubscriptionAvailable: 42,
                  serverKeepAlive: 19,
                  responseInformation: 26,
                  serverReference: 28,
                  topicAlias: 35,
                  subscriptionIdentifier: 11
              }, L.propertiesCodes = {};
              for (let t in L.properties) {
                  let e = L.properties[t];
                  L.propertiesCodes[e] = t;
              }
              function Ft(t) {
                  return [ 0, 1, 2 ].map((e => [ 0, 1 ].map((r => [ 0, 1 ].map((i => {
                      let n = Oe.alloc(1);
                      return n.writeUInt8(L.codes[t] << L.CMD_SHIFT | (r ? L.DUP_MASK : 0) | e << L.QOS_SHIFT | i, 0, !0), 
                      n;
                  }))))));
              }
              L.propertiesTypes = {
                  sessionExpiryInterval: "int32",
                  willDelayInterval: "int32",
                  receiveMaximum: "int16",
                  maximumPacketSize: "int32",
                  topicAliasMaximum: "int16",
                  requestResponseInformation: "byte",
                  requestProblemInformation: "byte",
                  userProperties: "pair",
                  authenticationMethod: "string",
                  authenticationData: "binary",
                  payloadFormatIndicator: "byte",
                  messageExpiryInterval: "int32",
                  contentType: "string",
                  responseTopic: "string",
                  correlationData: "binary",
                  maximumQoS: "int8",
                  retainAvailable: "byte",
                  assignedClientIdentifier: "string",
                  reasonString: "string",
                  wildcardSubscriptionAvailable: "byte",
                  subscriptionIdentifiersAvailable: "byte",
                  sharedSubscriptionAvailable: "byte",
                  serverKeepAlive: "int16",
                  responseInformation: "string",
                  serverReference: "string",
                  topicAlias: "int16",
                  subscriptionIdentifier: "var"
              }, L.PUBLISH_HEADER = Ft("publish"), L.SUBSCRIBE_HEADER = Ft("subscribe"), L.SUBSCRIBE_OPTIONS_QOS_MASK = 3, 
              L.SUBSCRIBE_OPTIONS_NL_MASK = 1, L.SUBSCRIBE_OPTIONS_NL_SHIFT = 2, L.SUBSCRIBE_OPTIONS_RAP_MASK = 1, 
              L.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3, L.SUBSCRIBE_OPTIONS_RH_MASK = 3, L.SUBSCRIBE_OPTIONS_RH_SHIFT = 4, 
              L.SUBSCRIBE_OPTIONS_RH = [ 0, 16, 32 ], L.SUBSCRIBE_OPTIONS_NL = 4, L.SUBSCRIBE_OPTIONS_RAP = 8, 
              L.SUBSCRIBE_OPTIONS_QOS = [ 0, 1, 2 ], L.UNSUBSCRIBE_HEADER = Ft("unsubscribe"), 
              L.ACKS = {
                  unsuback: Ft("unsuback"),
                  puback: Ft("puback"),
                  pubcomp: Ft("pubcomp"),
                  pubrel: Ft("pubrel"),
                  pubrec: Ft("pubrec")
              }, L.SUBACK_HEADER = Oe.from([ L.codes.suback << L.CMD_SHIFT ]), L.VERSION3 = Oe.from([ 3 ]), 
              L.VERSION4 = Oe.from([ 4 ]), L.VERSION5 = Oe.from([ 5 ]), L.VERSION131 = Oe.from([ 131 ]), 
              L.VERSION132 = Oe.from([ 132 ]), L.QOS = [ 0, 1, 2 ].map((t => Oe.from([ t ]))), 
              L.EMPTY = {
                  pingreq: Oe.from([ L.codes.pingreq << 4, 0 ]),
                  pingresp: Oe.from([ L.codes.pingresp << 4, 0 ]),
                  disconnect: Oe.from([ L.codes.disconnect << 4, 0 ])
              }, L.MQTT5_PUBACK_PUBREC_CODES = {
                  0: "Success",
                  16: "No matching subscribers",
                  128: "Unspecified error",
                  131: "Implementation specific error",
                  135: "Not authorized",
                  144: "Topic Name invalid",
                  145: "Packet identifier in use",
                  151: "Quota exceeded",
                  153: "Payload format invalid"
              }, L.MQTT5_PUBREL_PUBCOMP_CODES = {
                  0: "Success",
                  146: "Packet Identifier not found"
              }, L.MQTT5_SUBACK_CODES = {
                  0: "Granted QoS 0",
                  1: "Granted QoS 1",
                  2: "Granted QoS 2",
                  128: "Unspecified error",
                  131: "Implementation specific error",
                  135: "Not authorized",
                  143: "Topic Filter invalid",
                  145: "Packet Identifier in use",
                  151: "Quota exceeded",
                  158: "Shared Subscriptions not supported",
                  161: "Subscription Identifiers not supported",
                  162: "Wildcard Subscriptions not supported"
              }, L.MQTT5_UNSUBACK_CODES = {
                  0: "Success",
                  17: "No subscription existed",
                  128: "Unspecified error",
                  131: "Implementation specific error",
                  135: "Not authorized",
                  143: "Topic Filter invalid",
                  145: "Packet Identifier in use"
              }, L.MQTT5_DISCONNECT_CODES = {
                  0: "Normal disconnection",
                  4: "Disconnect with Will Message",
                  128: "Unspecified error",
                  129: "Malformed Packet",
                  130: "Protocol Error",
                  131: "Implementation specific error",
                  135: "Not authorized",
                  137: "Server busy",
                  139: "Server shutting down",
                  141: "Keep Alive timeout",
                  142: "Session taken over",
                  143: "Topic Filter invalid",
                  144: "Topic Name invalid",
                  147: "Receive Maximum exceeded",
                  148: "Topic Alias invalid",
                  149: "Packet too large",
                  150: "Message rate too high",
                  151: "Quota exceeded",
                  152: "Administrative action",
                  153: "Payload format invalid",
                  154: "Retain not supported",
                  155: "QoS not supported",
                  156: "Use another server",
                  157: "Server moved",
                  158: "Shared Subscriptions not supported",
                  159: "Connection rate exceeded",
                  160: "Maximum connect time",
                  161: "Subscription Identifiers not supported",
                  162: "Wildcard Subscriptions not supported"
              }, L.MQTT5_AUTH_CODES = {
                  0: "Success",
                  24: "Continue authentication",
                  25: "Re-authenticate"
              };
          })), gd = M(((aP, pd) => {
              v(), m(), _();
              var Vr = 1e3, zr = 6e4, Kr = 60 * zr, gr = 24 * Kr, wm = 7 * gr, _m = 365.25 * gr;
              function Tn(t, e, r, i) {
                  var n = e >= 1.5 * r;
                  return Math.round(t / r) + " " + i + (n ? "s" : "");
              }
              pd.exports = function(t, e) {
                  e = e || {};
                  var r = typeof t;
                  if ("string" === r && t.length > 0) return function(t) {
                      if (t = String(t), !(t.length > 100)) {
                          var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
                          if (e) {
                              var r = parseFloat(e[1]);
                              switch ((e[2] || "ms").toLowerCase()) {
                                case "years":
                                case "year":
                                case "yrs":
                                case "yr":
                                case "y":
                                  return r * _m;

                                case "weeks":
                                case "week":
                                case "w":
                                  return r * wm;

                                case "days":
                                case "day":
                                case "d":
                                  return r * gr;

                                case "hours":
                                case "hour":
                                case "hrs":
                                case "hr":
                                case "h":
                                  return r * Kr;

                                case "minutes":
                                case "minute":
                                case "mins":
                                case "min":
                                case "m":
                                  return r * zr;

                                case "seconds":
                                case "second":
                                case "secs":
                                case "sec":
                                case "s":
                                  return r * Vr;

                                case "milliseconds":
                                case "millisecond":
                                case "msecs":
                                case "msec":
                                case "ms":
                                  return r;

                                default:
                                  return;
                              }
                          }
                      }
                  }(t);
                  if ("number" === r && isFinite(t)) return e.long ? function(t) {
                      var e = Math.abs(t);
                      return e >= gr ? Tn(t, e, gr, "day") : e >= Kr ? Tn(t, e, Kr, "hour") : e >= zr ? Tn(t, e, zr, "minute") : e >= Vr ? Tn(t, e, Vr, "second") : t + " ms";
                  }(t) : function(t) {
                      var e = Math.abs(t);
                      return e >= gr ? Math.round(t / gr) + "d" : e >= Kr ? Math.round(t / Kr) + "h" : e >= zr ? Math.round(t / zr) + "m" : e >= Vr ? Math.round(t / Vr) + "s" : t + "ms";
                  }(t);
                  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t));
              };
          })), bd = M(((bP, yd) => {
              v(), m(), _(), yd.exports = function(t) {
                  function r(h) {
                      let d, y, w, g = null;
                      function E(...S) {
                          if (!E.enabled) return;
                          let I = E, C = Number(new Date), R = C - (d || C);
                          I.diff = R, I.prev = d, I.curr = C, d = C, S[0] = r.coerce(S[0]), "string" != typeof S[0] && S.unshift("%O");
                          let U = 0;
                          S[0] = S[0].replace(/%([a-zA-Z%])/g, ((W, K) => {
                              if ("%%" === W) return "%";
                              U++;
                              let z = r.formatters[K];
                              if ("function" == typeof z) {
                                  let Q = S[U];
                                  W = z.call(I, Q), S.splice(U, 1), U--;
                              }
                              return W;
                          })), r.formatArgs.call(I, S), (I.log || r.log).apply(I, S);
                      }
                      return E.namespace = h, E.useColors = r.useColors(), E.color = r.selectColor(h), 
                      E.extend = i, E.destroy = r.destroy, Object.defineProperty(E, "enabled", {
                          enumerable: !0,
                          configurable: !1,
                          get: () => null !== g ? g : (y !== r.namespaces && (y = r.namespaces, w = r.enabled(h)), 
                          w),
                          set: S => {
                              g = S;
                          }
                      }), "function" == typeof r.init && r.init(E), E;
                  }
                  function i(h, d) {
                      let g = r(this.namespace + (typeof d > "u" ? ":" : d) + h);
                      return g.log = this.log, g;
                  }
                  function a(h) {
                      return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
                  }
                  return r.debug = r, r.default = r, r.coerce = function(h) {
                      return h instanceof Error ? h.stack || h.message : h;
                  }, r.disable = function() {
                      let h = [ ...r.names.map(a), ...r.skips.map(a).map((d => "-" + d)) ].join(",");
                      return r.enable(""), h;
                  }, r.enable = function(h) {
                      r.save(h), r.namespaces = h, r.names = [], r.skips = [];
                      let d, g = ("string" == typeof h ? h : "").split(/[\s,]+/), y = g.length;
                      for (d = 0; d < y; d++) g[d] && ("-" === (h = g[d].replace(/\*/g, ".*?"))[0] ? r.skips.push(new RegExp("^" + h.slice(1) + "$")) : r.names.push(new RegExp("^" + h + "$")));
                  }, r.enabled = function(h) {
                      if ("*" === h[h.length - 1]) return !0;
                      let d, g;
                      for (d = 0, g = r.skips.length; d < g; d++) if (r.skips[d].test(h)) return !1;
                      for (d = 0, g = r.names.length; d < g; d++) if (r.names[d].test(h)) return !0;
                      return !1;
                  }, r.humanize = gd(), r.destroy = function() {
                      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
                  }, Object.keys(t).forEach((h => {
                      r[h] = t[h];
                  })), r.names = [], r.skips = [], r.formatters = {}, r.selectColor = function(h) {
                      let d = 0;
                      for (let g = 0; g < h.length; g++) d = (d << 5) - d + h.charCodeAt(g), d |= 0;
                      return r.colors[Math.abs(d) % r.colors.length];
                  }, r.enable(r.load()), r;
              };
          })), ot = M(((xe, Rn) => {
              v(), m(), _(), xe.formatArgs = function(t) {
                  if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + Rn.exports.humanize(this.diff), 
                  !this.useColors) return;
                  let e = "color: " + this.color;
                  t.splice(1, 0, e, "color: inherit");
                  let r = 0, i = 0;
                  t[0].replace(/%[a-zA-Z%]/g, (n => {
                      "%%" !== n && (r++, "%c" === n && (i = r));
                  })), t.splice(i, 0, e);
              }, xe.save = function(t) {
                  try {
                      t ? xe.storage.setItem("debug", t) : xe.storage.removeItem("debug");
                  } catch {}
              }, xe.load = function() {
                  let t;
                  try {
                      t = xe.storage.getItem("debug");
                  } catch {}
                  return !t && typeof P < "u" && "env" in P && (t = P.env.DEBUG), t;
              }, xe.useColors = function() {
                  return !(!(typeof window < "u" && window.process) || "renderer" !== window.process.type && !window.process.__nwjs) || !(typeof B < "u" && B.userAgent && B.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && (typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof B < "u" && B.userAgent && B.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof B < "u" && B.userAgent && B.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
              }, xe.storage = function() {
                  try {
                      return localStorage;
                  } catch {}
              }(), xe.destroy = (() => {
                  let t = !1;
                  return () => {
                      t || (t = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
                  };
              })(), xe.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ], 
              xe.log = console.debug || console.log || (() => {}), Rn.exports = bd()(xe);
              var {formatters: Bm} = Rn.exports;
              Bm.j = function(t) {
                  try {
                      return JSON.stringify(t);
                  } catch (e) {
                      return "[UnexpectedJSONParseError]: " + e.message;
                  }
              };
          })), md = M(((UP, _d) => {
              v(), m(), _();
              var Pm = fd(), {EventEmitter: Om} = (ir(), X(rr)), wd = hd(), V = Wo(), D = ot()("mqtt-packet:parser");
              _d.exports = class t extends Om {
                  constructor() {
                      super(), this.parser = this.constructor.parser;
                  }
                  static parser(e) {
                      return this instanceof t ? (this.settings = e || {}, this._states = [ "_parseHeader", "_parseLength", "_parsePayload", "_newPacket" ], 
                      this._resetState(), this) : (new t).parser(e);
                  }
                  _resetState() {
                      D("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new wd, 
                      this.error = null, this._list = Pm(), this._stateCounter = 0;
                  }
                  parse(e) {
                      for (this.error && this._resetState(), this._list.append(e), D("parse: current state: %s", this._states[this._stateCounter]); (-1 !== this.packet.length || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error; ) this._stateCounter++, 
                      D("parse: state complete. _stateCounter is now: %d", this._stateCounter), D("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), 
                      this._stateCounter >= this._states.length && (this._stateCounter = 0);
                      return D("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), 
                      this._list.length;
                  }
                  _parseHeader() {
                      let e = this._list.readUInt8(0), r = e >> V.CMD_SHIFT;
                      this.packet.cmd = V.types[r];
                      let i = 15 & e, n = V.requiredHeaderFlags[r];
                      return null != n && i !== n ? this._emitError(new Error(V.requiredHeaderFlagsErrors[r])) : (this.packet.retain = 0 != (e & V.RETAIN_MASK), 
                      this.packet.qos = e >> V.QOS_SHIFT & V.QOS_MASK, this.packet.qos > 2 ? this._emitError(new Error("Packet must not have both QoS bits set to 1")) : (this.packet.dup = 0 != (e & V.DUP_MASK), 
                      D("_parseHeader: packet: %o", this.packet), this._list.consume(1), !0));
                  }
                  _parseLength() {
                      let e = this._parseVarByteNum(!0);
                      return e && (this.packet.length = e.value, this._list.consume(e.bytes)), D("_parseLength %d", e.value), 
                      !!e;
                  }
                  _parsePayload() {
                      D("_parsePayload: payload %O", this._list);
                      let e = !1;
                      if (0 === this.packet.length || this._list.length >= this.packet.length) {
                          switch (this._pos = 0, this.packet.cmd) {
                            case "connect":
                              this._parseConnect();
                              break;

                            case "connack":
                              this._parseConnack();
                              break;

                            case "publish":
                              this._parsePublish();
                              break;

                            case "puback":
                            case "pubrec":
                            case "pubrel":
                            case "pubcomp":
                              this._parseConfirmation();
                              break;

                            case "subscribe":
                              this._parseSubscribe();
                              break;

                            case "suback":
                              this._parseSuback();
                              break;

                            case "unsubscribe":
                              this._parseUnsubscribe();
                              break;

                            case "unsuback":
                              this._parseUnsuback();
                              break;

                            case "pingreq":
                            case "pingresp":
                              break;

                            case "disconnect":
                              this._parseDisconnect();
                              break;

                            case "auth":
                              this._parseAuth();
                              break;

                            default:
                              this._emitError(new Error("Not supported"));
                          }
                          e = !0;
                      }
                      return D("_parsePayload complete result: %s", e), e;
                  }
                  _parseConnect() {
                      D("_parseConnect");
                      let e, r, i, n, o = {}, s = this.packet, a = this._parseString();
                      if (null === a) return this._emitError(new Error("Cannot parse protocolId"));
                      if ("MQTT" !== a && "MQIsdp" !== a) return this._emitError(new Error("Invalid protocolId"));
                      if (s.protocolId = a, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
                      if (s.protocolVersion = this._list.readUInt8(this._pos), s.protocolVersion >= 128 && (s.bridgeMode = !0, 
                      s.protocolVersion = s.protocolVersion - 128), 3 !== s.protocolVersion && 4 !== s.protocolVersion && 5 !== s.protocolVersion) return this._emitError(new Error("Invalid protocol version"));
                      if (this._pos++, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
                      if (1 & this._list.readUInt8(this._pos)) return this._emitError(new Error("Connect flag bit 0 must be 0, but got 1"));
                      o.username = this._list.readUInt8(this._pos) & V.USERNAME_MASK, o.password = this._list.readUInt8(this._pos) & V.PASSWORD_MASK, 
                      o.will = this._list.readUInt8(this._pos) & V.WILL_FLAG_MASK;
                      let u = !!(this._list.readUInt8(this._pos) & V.WILL_RETAIN_MASK), c = (this._list.readUInt8(this._pos) & V.WILL_QOS_MASK) >> V.WILL_QOS_SHIFT;
                      if (o.will) s.will = {}, s.will.retain = u, s.will.qos = c; else {
                          if (u) return this._emitError(new Error("Will Retain Flag must be set to zero when Will Flag is set to 0"));
                          if (c) return this._emitError(new Error("Will QoS must be set to zero when Will Flag is set to 0"));
                      }
                      if (s.clean = 0 != (this._list.readUInt8(this._pos) & V.CLEAN_SESSION_MASK), this._pos++, 
                      s.keepalive = this._parseNum(), -1 === s.keepalive) return this._emitError(new Error("Packet too short"));
                      if (5 === s.protocolVersion) {
                          let d = this._parseProperties();
                          Object.getOwnPropertyNames(d).length && (s.properties = d);
                      }
                      let h = this._parseString();
                      if (null === h) return this._emitError(new Error("Packet too short"));
                      if (s.clientId = h, D("_parseConnect: packet.clientId: %s", s.clientId), o.will) {
                          if (5 === s.protocolVersion) {
                              let d = this._parseProperties();
                              Object.getOwnPropertyNames(d).length && (s.will.properties = d);
                          }
                          if (e = this._parseString(), null === e) return this._emitError(new Error("Cannot parse will topic"));
                          if (s.will.topic = e, D("_parseConnect: packet.will.topic: %s", s.will.topic), r = this._parseBuffer(), 
                          null === r) return this._emitError(new Error("Cannot parse will payload"));
                          s.will.payload = r, D("_parseConnect: packet.will.paylaod: %s", s.will.payload);
                      }
                      if (o.username) {
                          if (n = this._parseString(), null === n) return this._emitError(new Error("Cannot parse username"));
                          s.username = n, D("_parseConnect: packet.username: %s", s.username);
                      }
                      if (o.password) {
                          if (i = this._parseBuffer(), null === i) return this._emitError(new Error("Cannot parse password"));
                          s.password = i;
                      }
                      return this.settings = s, D("_parseConnect: complete"), s;
                  }
                  _parseConnack() {
                      D("_parseConnack");
                      let e = this.packet;
                      if (this._list.length < 1) return null;
                      let r = this._list.readUInt8(this._pos++);
                      if (r > 1) return this._emitError(new Error("Invalid connack flags, bits 7-1 must be set to 0"));
                      if (e.sessionPresent = !!(r & V.SESSIONPRESENT_MASK), 5 === this.settings.protocolVersion) this._list.length >= 2 ? e.reasonCode = this._list.readUInt8(this._pos++) : e.reasonCode = 0; else {
                          if (this._list.length < 2) return null;
                          e.returnCode = this._list.readUInt8(this._pos++);
                      }
                      if (-1 === e.returnCode || -1 === e.reasonCode) return this._emitError(new Error("Cannot parse return code"));
                      if (5 === this.settings.protocolVersion) {
                          let i = this._parseProperties();
                          Object.getOwnPropertyNames(i).length && (e.properties = i);
                      }
                      D("_parseConnack: complete");
                  }
                  _parsePublish() {
                      D("_parsePublish");
                      let e = this.packet;
                      if (e.topic = this._parseString(), null === e.topic) return this._emitError(new Error("Cannot parse topic"));
                      if (!(e.qos > 0) || this._parseMessageId()) {
                          if (5 === this.settings.protocolVersion) {
                              let r = this._parseProperties();
                              Object.getOwnPropertyNames(r).length && (e.properties = r);
                          }
                          e.payload = this._list.slice(this._pos, e.length), D("_parsePublish: payload from buffer list: %o", e.payload);
                      }
                  }
                  _parseSubscribe() {
                      D("_parseSubscribe");
                      let r, i, n, o, s, a, u, e = this.packet;
                      if (e.subscriptions = [], this._parseMessageId()) {
                          if (5 === this.settings.protocolVersion) {
                              let c = this._parseProperties();
                              Object.getOwnPropertyNames(c).length && (e.properties = c);
                          }
                          if (e.length <= 0) return this._emitError(new Error("Malformed subscribe, no payload specified"));
                          for (;this._pos < e.length; ) {
                              if (r = this._parseString(), null === r) return this._emitError(new Error("Cannot parse topic"));
                              if (this._pos >= e.length) return this._emitError(new Error("Malformed Subscribe Payload"));
                              if (i = this._parseByte(), 5 === this.settings.protocolVersion) {
                                  if (192 & i) return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-6 must be 0"));
                              } else if (252 & i) return this._emitError(new Error("Invalid subscribe topic flag bits, bits 7-2 must be 0"));
                              if (n = i & V.SUBSCRIBE_OPTIONS_QOS_MASK, n > 2) return this._emitError(new Error("Invalid subscribe QoS, must be <= 2"));
                              if (a = 0 != (i >> V.SUBSCRIBE_OPTIONS_NL_SHIFT & V.SUBSCRIBE_OPTIONS_NL_MASK), 
                              s = 0 != (i >> V.SUBSCRIBE_OPTIONS_RAP_SHIFT & V.SUBSCRIBE_OPTIONS_RAP_MASK), o = i >> V.SUBSCRIBE_OPTIONS_RH_SHIFT & V.SUBSCRIBE_OPTIONS_RH_MASK, 
                              o > 2) return this._emitError(new Error("Invalid retain handling, must be <= 2"));
                              u = {
                                  topic: r,
                                  qos: n
                              }, 5 === this.settings.protocolVersion ? (u.nl = a, u.rap = s, u.rh = o) : this.settings.bridgeMode && (u.rh = 0, 
                              u.rap = !0, u.nl = !0), D("_parseSubscribe: push subscription `%s` to subscription", u), 
                              e.subscriptions.push(u);
                          }
                      }
                  }
                  _parseSuback() {
                      D("_parseSuback");
                      let e = this.packet;
                      if (this.packet.granted = [], this._parseMessageId()) {
                          if (5 === this.settings.protocolVersion) {
                              let r = this._parseProperties();
                              Object.getOwnPropertyNames(r).length && (e.properties = r);
                          }
                          if (e.length <= 0) return this._emitError(new Error("Malformed suback, no payload specified"));
                          for (;this._pos < this.packet.length; ) {
                              let r = this._list.readUInt8(this._pos++);
                              if (5 === this.settings.protocolVersion) {
                                  if (!V.MQTT5_SUBACK_CODES[r]) return this._emitError(new Error("Invalid suback code"));
                              } else if (r > 2 && 128 !== r) return this._emitError(new Error("Invalid suback QoS, must be 0, 1, 2 or 128"));
                              this.packet.granted.push(r);
                          }
                      }
                  }
                  _parseUnsubscribe() {
                      D("_parseUnsubscribe");
                      let e = this.packet;
                      if (e.unsubscriptions = [], this._parseMessageId()) {
                          if (5 === this.settings.protocolVersion) {
                              let r = this._parseProperties();
                              Object.getOwnPropertyNames(r).length && (e.properties = r);
                          }
                          if (e.length <= 0) return this._emitError(new Error("Malformed unsubscribe, no payload specified"));
                          for (;this._pos < e.length; ) {
                              let r = this._parseString();
                              if (null === r) return this._emitError(new Error("Cannot parse topic"));
                              D("_parseUnsubscribe: push topic `%s` to unsubscriptions", r), e.unsubscriptions.push(r);
                          }
                      }
                  }
                  _parseUnsuback() {
                      D("_parseUnsuback");
                      let e = this.packet;
                      if (!this._parseMessageId()) return this._emitError(new Error("Cannot parse messageId"));
                      if ((3 === this.settings.protocolVersion || 4 === this.settings.protocolVersion) && 2 !== e.length) return this._emitError(new Error("Malformed unsuback, payload length must be 2"));
                      if (e.length <= 0) return this._emitError(new Error("Malformed unsuback, no payload specified"));
                      if (5 === this.settings.protocolVersion) {
                          let r = this._parseProperties();
                          for (Object.getOwnPropertyNames(r).length && (e.properties = r), e.granted = []; this._pos < this.packet.length; ) {
                              let i = this._list.readUInt8(this._pos++);
                              if (!V.MQTT5_UNSUBACK_CODES[i]) return this._emitError(new Error("Invalid unsuback code"));
                              this.packet.granted.push(i);
                          }
                      }
                  }
                  _parseConfirmation() {
                      D("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
                      let e = this.packet;
                      if (this._parseMessageId(), 5 === this.settings.protocolVersion) {
                          if (e.length > 2) {
                              switch (e.reasonCode = this._parseByte(), this.packet.cmd) {
                                case "puback":
                                case "pubrec":
                                  if (!V.MQTT5_PUBACK_PUBREC_CODES[e.reasonCode]) return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                                  break;

                                case "pubrel":
                                case "pubcomp":
                                  if (!V.MQTT5_PUBREL_PUBCOMP_CODES[e.reasonCode]) return this._emitError(new Error("Invalid " + this.packet.cmd + " reason code"));
                              }
                              D("_parseConfirmation: packet.reasonCode `%d`", e.reasonCode);
                          } else e.reasonCode = 0;
                          if (e.length > 3) {
                              let r = this._parseProperties();
                              Object.getOwnPropertyNames(r).length && (e.properties = r);
                          }
                      }
                      return !0;
                  }
                  _parseDisconnect() {
                      let e = this.packet;
                      if (D("_parseDisconnect"), 5 === this.settings.protocolVersion) {
                          this._list.length > 0 ? (e.reasonCode = this._parseByte(), V.MQTT5_DISCONNECT_CODES[e.reasonCode] || this._emitError(new Error("Invalid disconnect reason code"))) : e.reasonCode = 0;
                          let r = this._parseProperties();
                          Object.getOwnPropertyNames(r).length && (e.properties = r);
                      }
                      return D("_parseDisconnect result: true"), !0;
                  }
                  _parseAuth() {
                      D("_parseAuth");
                      let e = this.packet;
                      if (5 !== this.settings.protocolVersion) return this._emitError(new Error("Not supported auth packet for this version MQTT"));
                      if (e.reasonCode = this._parseByte(), !V.MQTT5_AUTH_CODES[e.reasonCode]) return this._emitError(new Error("Invalid auth reason code"));
                      let r = this._parseProperties();
                      return Object.getOwnPropertyNames(r).length && (e.properties = r), D("_parseAuth: result: true"), 
                      !0;
                  }
                  _parseMessageId() {
                      let e = this.packet;
                      return e.messageId = this._parseNum(), null === e.messageId ? (this._emitError(new Error("Cannot parse messageId")), 
                      !1) : (D("_parseMessageId: packet.messageId %d", e.messageId), !0);
                  }
                  _parseString(e) {
                      let r = this._parseNum(), i = r + this._pos;
                      if (-1 === r || i > this._list.length || i > this.packet.length) return null;
                      let n = this._list.toString("utf8", this._pos, i);
                      return this._pos += r, D("_parseString: result: %s", n), n;
                  }
                  _parseStringPair() {
                      return D("_parseStringPair"), {
                          name: this._parseString(),
                          value: this._parseString()
                      };
                  }
                  _parseBuffer() {
                      let e = this._parseNum(), r = e + this._pos;
                      if (-1 === e || r > this._list.length || r > this.packet.length) return null;
                      let i = this._list.slice(this._pos, r);
                      return this._pos += e, D("_parseBuffer: result: %o", i), i;
                  }
                  _parseNum() {
                      if (this._list.length - this._pos < 2) return -1;
                      let e = this._list.readUInt16BE(this._pos);
                      return this._pos += 2, D("_parseNum: result: %s", e), e;
                  }
                  _parse4ByteNum() {
                      if (this._list.length - this._pos < 4) return -1;
                      let e = this._list.readUInt32BE(this._pos);
                      return this._pos += 4, D("_parse4ByteNum: result: %s", e), e;
                  }
                  _parseVarByteNum(e) {
                      D("_parseVarByteNum");
                      let a, i = 0, n = 1, o = 0, s = !1, u = this._pos ? this._pos : 0;
                      for (;i < 4 && u + i < this._list.length; ) {
                          if (a = this._list.readUInt8(u + i++), o += n * (a & V.VARBYTEINT_MASK), n *= 128, 
                          !(a & V.VARBYTEINT_FIN_MASK)) {
                              s = !0;
                              break;
                          }
                          if (this._list.length <= i) break;
                      }
                      return !s && 4 === i && this._list.length >= i && this._emitError(new Error("Invalid variable byte integer")), 
                      u && (this._pos += i), s = !!s && (e ? {
                          bytes: i,
                          value: o
                      } : o), D("_parseVarByteNum: result: %o", s), s;
                  }
                  _parseByte() {
                      let e;
                      return this._pos < this._list.length && (e = this._list.readUInt8(this._pos), this._pos++), 
                      D("_parseByte: result: %o", e), e;
                  }
                  _parseByType(e) {
                      switch (D("_parseByType: type: %s", e), e) {
                        case "byte":
                          return 0 !== this._parseByte();

                        case "int8":
                          return this._parseByte();

                        case "int16":
                          return this._parseNum();

                        case "int32":
                          return this._parse4ByteNum();

                        case "var":
                          return this._parseVarByteNum();

                        case "string":
                          return this._parseString();

                        case "pair":
                          return this._parseStringPair();

                        case "binary":
                          return this._parseBuffer();
                      }
                  }
                  _parseProperties() {
                      D("_parseProperties");
                      let e = this._parseVarByteNum(), i = this._pos + e, n = {};
                      for (;this._pos < i; ) {
                          let o = this._parseByte();
                          if (!o) return this._emitError(new Error("Cannot parse property code type")), !1;
                          let s = V.propertiesCodes[o];
                          if (!s) return this._emitError(new Error("Unknown property")), !1;
                          if ("userProperties" !== s) n[s] ? (Array.isArray(n[s]) || (n[s] = [ n[s] ]), n[s].push(this._parseByType(V.propertiesTypes[s]))) : n[s] = this._parseByType(V.propertiesTypes[s]); else {
                              n[s] || (n[s] = Object.create(null));
                              let a = this._parseByType(V.propertiesTypes[s]);
                              if (n[s][a.name]) if (Array.isArray(n[s][a.name])) n[s][a.name].push(a.value); else {
                                  let u = n[s][a.name];
                                  n[s][a.name] = [ u ], n[s][a.name].push(a.value);
                              } else n[s][a.name] = a.value;
                          }
                      }
                      return n;
                  }
                  _newPacket() {
                      return D("_newPacket"), this.packet && (this._list.consume(this.packet.length), 
                      D("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), 
                      this.emit("packet", this.packet)), D("_newPacket: new packet"), this.packet = new wd, 
                      this._pos = 0, !0;
                  }
                  _emitError(e) {
                      D("_emitError", e), this.error = e, this.emit("error", e);
                  }
              };
          })), Ad = M(((zP, Sd) => {
              v(), m(), _();
              var {Buffer: vi} = (ye(), X(_e)), vd = {}, xm = vi.isBuffer(vi.from([ 1, 2 ]).subarray(0, 1));
              function Ed(t) {
                  let e = vi.allocUnsafe(2);
                  return e.writeUInt8(t >> 8, 0), e.writeUInt8(255 & t, 1), e;
              }
              Sd.exports = {
                  cache: vd,
                  generateCache: function() {
                      for (let t = 0; t < 65536; t++) vd[t] = Ed(t);
                  },
                  generateNumber: Ed,
                  genBufVariableByteInt: function(t) {
                      let r = 0, i = 0, n = vi.allocUnsafe(4);
                      do {
                          r = t % 128 | 0, (t = t / 128 | 0) > 0 && (r |= 128), n.writeUInt8(r, i++);
                      } while (t > 0 && i < 4);
                      return t > 0 && (i = 0), xm ? n.subarray(0, i) : n.slice(0, i);
                  },
                  generate4ByteBuffer: function(t) {
                      let e = vi.allocUnsafe(4);
                      return e.writeUInt32BE(t, 0), e;
                  }
              };
          })), Id = M(((rO, Ho) => {
              v(), m(), _(), typeof P > "u" || !P.version || 0 === P.version.indexOf("v0.") || 0 === P.version.indexOf("v1.") && 0 !== P.version.indexOf("v1.8.") ? Ho.exports = {
                  nextTick: function(t, e, r, i) {
                      if ("function" != typeof t) throw new TypeError('"callback" argument must be a function');
                      var o, s, n = arguments.length;
                      switch (n) {
                        case 0:
                        case 1:
                          return P.nextTick(t);

                        case 2:
                          return P.nextTick((function() {
                              t.call(null, e);
                          }));

                        case 3:
                          return P.nextTick((function() {
                              t.call(null, e, r);
                          }));

                        case 4:
                          return P.nextTick((function() {
                              t.call(null, e, r, i);
                          }));

                        default:
                          for (o = new Array(n - 1), s = 0; s < o.length; ) o[s++] = arguments[s];
                          return P.nextTick((function() {
                              t.apply(null, o);
                          }));
                      }
                  }
              } : Ho.exports = P;
          })), Ko = M(((hO, xd) => {
              v(), m(), _();
              var j = Wo(), {Buffer: q} = (ye(), X(_e)), qm = q.allocUnsafe(0), Dm = q.from([ 0 ]), Ei = Ad(), jm = Id().nextTick, qe = ot()("mqtt-packet:writeToStream"), Cn = Ei.cache, Fm = Ei.generateNumber, Wm = Ei.generateCache, Vo = Ei.genBufVariableByteInt, $m = Ei.generate4ByteBuffer, Ie = zo, Bn = !0;
              function Od(t, e, r) {
                  switch (qe("generate called"), e.cork && (e.cork(), jm(Hm, e)), Bn && (Bn = !1, 
                  Wm()), qe("generate: packet.cmd: %s", t.cmd), t.cmd) {
                    case "connect":
                      return function(t, e, r) {
                          let i = t || {}, n = i.protocolId || "MQTT", o = i.protocolVersion || 4, s = i.will, a = i.clean, u = i.keepalive || 0, c = i.clientId || "", h = i.username, d = i.password, g = i.properties;
                          void 0 === a && (a = !0);
                          let w, E, y = 0;
                          if (!n || "string" != typeof n && !q.isBuffer(n)) return e.destroy(new Error("Invalid protocolId")), 
                          !1;
                          if (y += n.length + 2, 3 !== o && 4 !== o && 5 !== o) return e.destroy(new Error("Invalid protocol version")), 
                          !1;
                          if (y += 1, ("string" == typeof c || q.isBuffer(c)) && (c || o >= 4) && (c || a)) y += q.byteLength(c) + 2; else {
                              if (o < 4) return e.destroy(new Error("clientId must be supplied before 3.1.1")), 
                              !1;
                              if (1 * a == 0) return e.destroy(new Error("clientId must be given if cleanSession set to 0")), 
                              !1;
                          }
                          if ("number" != typeof u || u < 0 || u > 65535 || u % 1 != 0) return e.destroy(new Error("Invalid keepalive")), 
                          !1;
                          if (y += 2, y += 1, 5 === o) {
                              if (w = Wt(e, g), !w) return !1;
                              y += w.length;
                          }
                          if (s) {
                              if ("object" != typeof s) return e.destroy(new Error("Invalid will")), !1;
                              if (!s.topic || "string" != typeof s.topic) return e.destroy(new Error("Invalid will topic")), 
                              !1;
                              if (y += q.byteLength(s.topic) + 2, y += 2, s.payload) {
                                  if (!(s.payload.length >= 0)) return e.destroy(new Error("Invalid will payload")), 
                                  !1;
                                  "string" == typeof s.payload ? y += q.byteLength(s.payload) : y += s.payload.length;
                              }
                              if (E = {}, 5 === o) {
                                  if (E = Wt(e, s.properties), !E) return !1;
                                  y += E.length;
                              }
                          }
                          let S = !1;
                          if (null != h) {
                              if (!Pd(h)) return e.destroy(new Error("Invalid username")), !1;
                              S = !0, y += q.byteLength(h) + 2;
                          }
                          if (null != d) {
                              if (!S) return e.destroy(new Error("Username is required to use password")), !1;
                              if (!Pd(d)) return e.destroy(new Error("Invalid password")), !1;
                              y += kd(d) + 2;
                          }
                          e.write(j.CONNECT_HEADER), De(e, y), Gr(e, n), i.bridgeMode && (o += 128), e.write(131 === o ? j.VERSION131 : 132 === o ? j.VERSION132 : 4 === o ? j.VERSION4 : 5 === o ? j.VERSION5 : j.VERSION3);
                          let I = 0;
                          return I |= null != h ? j.USERNAME_MASK : 0, I |= null != d ? j.PASSWORD_MASK : 0, 
                          I |= s && s.retain ? j.WILL_RETAIN_MASK : 0, I |= s && s.qos ? s.qos << j.WILL_QOS_SHIFT : 0, 
                          I |= s ? j.WILL_FLAG_MASK : 0, I |= a ? j.CLEAN_SESSION_MASK : 0, e.write(q.from([ I ])), 
                          Ie(e, u), 5 === o && w.write(), Gr(e, c), s && (5 === o && E.write(), yr(e, s.topic), 
                          Gr(e, s.payload)), null != h && Gr(e, h), null != d && Gr(e, d), !0;
                      }(t, e);

                    case "connack":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = 5 === i ? n.reasonCode : n.returnCode, s = n.properties, a = 2;
                          if ("number" != typeof o) return e.destroy(new Error("Invalid return code")), !1;
                          let u = null;
                          if (5 === i) {
                              if (u = Wt(e, s), !u) return !1;
                              a += u.length;
                          }
                          return e.write(j.CONNACK_HEADER), De(e, a), e.write(n.sessionPresent ? j.SESSIONPRESENT_HEADER : Dm), 
                          e.write(q.from([ o ])), u?.write(), !0;
                      }(t, e, r);

                    case "publish":
                      return function(t, e, r) {
                          qe("publish: packet: %o", t);
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.qos || 0, s = n.retain ? j.RETAIN_MASK : 0, a = n.topic, u = n.payload || qm, c = n.messageId, h = n.properties, d = 0;
                          if ("string" == typeof a) d += q.byteLength(a) + 2; else {
                              if (!q.isBuffer(a)) return e.destroy(new Error("Invalid topic")), !1;
                              d += a.length + 2;
                          }
                          if (q.isBuffer(u) ? d += u.length : d += q.byteLength(u), o && "number" != typeof c) return e.destroy(new Error("Invalid messageId")), 
                          !1;
                          o && (d += 2);
                          let g = null;
                          if (5 === i) {
                              if (g = Wt(e, h), !g) return !1;
                              d += g.length;
                          }
                          return e.write(j.PUBLISH_HEADER[o][n.dup ? 1 : 0][s ? 1 : 0]), De(e, d), Ie(e, kd(a)), 
                          e.write(a), o > 0 && Ie(e, c), g?.write(), qe("publish: payload: %o", u), e.write(u);
                      }(t, e, r);

                    case "puback":
                    case "pubrec":
                    case "pubrel":
                    case "pubcomp":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.cmd || "puback", s = n.messageId, a = n.dup && "pubrel" === o ? j.DUP_MASK : 0, u = 0, c = n.reasonCode, h = n.properties, d = 5 === i ? 3 : 2;
                          if ("pubrel" === o && (u = 1), "number" != typeof s) return e.destroy(new Error("Invalid messageId")), 
                          !1;
                          let g = null;
                          if (5 === i && "object" == typeof h) {
                              if (g = Si(e, h, r, d), !g) return !1;
                              d += g.length;
                          }
                          return e.write(j.ACKS[o][u][a][0]), 3 === d && (d += 0 !== c ? 1 : -1), De(e, d), 
                          Ie(e, s), 5 === i && 2 !== d && e.write(q.from([ c ])), null !== g ? g.write() : 4 === d && e.write(q.from([ 0 ])), 
                          !0;
                      }(t, e, r);

                    case "subscribe":
                      return function(t, e, r) {
                          qe("subscribe: packet: ");
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.dup ? j.DUP_MASK : 0, s = n.messageId, a = n.subscriptions, u = n.properties, c = 0;
                          if ("number" != typeof s) return e.destroy(new Error("Invalid messageId")), !1;
                          c += 2;
                          let h = null;
                          if (5 === i) {
                              if (h = Wt(e, u), !h) return !1;
                              c += h.length;
                          }
                          if ("object" != typeof a || !a.length) return e.destroy(new Error("Invalid subscriptions")), 
                          !1;
                          for (let g = 0; g < a.length; g += 1) {
                              let y = a[g].topic, w = a[g].qos;
                              if ("string" != typeof y) return e.destroy(new Error("Invalid subscriptions - invalid topic")), 
                              !1;
                              if ("number" != typeof w) return e.destroy(new Error("Invalid subscriptions - invalid qos")), 
                              !1;
                              if (5 === i) {
                                  if ("boolean" != typeof (a[g].nl || !1)) return e.destroy(new Error("Invalid subscriptions - invalid No Local")), 
                                  !1;
                                  if ("boolean" != typeof (a[g].rap || !1)) return e.destroy(new Error("Invalid subscriptions - invalid Retain as Published")), 
                                  !1;
                                  let I = a[g].rh || 0;
                                  if ("number" != typeof I || I > 2) return e.destroy(new Error("Invalid subscriptions - invalid Retain Handling")), 
                                  !1;
                              }
                              c += q.byteLength(y) + 2 + 1;
                          }
                          qe("subscribe: writing to stream: %o", j.SUBSCRIBE_HEADER), e.write(j.SUBSCRIBE_HEADER[1][o ? 1 : 0][0]), 
                          De(e, c), Ie(e, s), null !== h && h.write();
                          let d = !0;
                          for (let g of a) {
                              let C, y = g.topic, w = g.qos, E = +g.nl, S = +g.rap, I = g.rh;
                              yr(e, y), C = j.SUBSCRIBE_OPTIONS_QOS[w], 5 === i && (C |= E ? j.SUBSCRIBE_OPTIONS_NL : 0, 
                              C |= S ? j.SUBSCRIBE_OPTIONS_RAP : 0, C |= I ? j.SUBSCRIBE_OPTIONS_RH[I] : 0), d = e.write(q.from([ C ]));
                          }
                          return d;
                      }(t, e, r);

                    case "suback":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.messageId, s = n.granted, a = n.properties, u = 0;
                          if ("number" != typeof o) return e.destroy(new Error("Invalid messageId")), !1;
                          if (u += 2, "object" != typeof s || !s.length) return e.destroy(new Error("Invalid qos vector")), 
                          !1;
                          for (let h = 0; h < s.length; h += 1) {
                              if ("number" != typeof s[h]) return e.destroy(new Error("Invalid qos vector")), 
                              !1;
                              u += 1;
                          }
                          let c = null;
                          if (5 === i) {
                              if (c = Si(e, a, r, u), !c) return !1;
                              u += c.length;
                          }
                          return e.write(j.SUBACK_HEADER), De(e, u), Ie(e, o), null !== c && c.write(), e.write(q.from(s));
                      }(t, e, r);

                    case "unsubscribe":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.messageId, s = n.dup ? j.DUP_MASK : 0, a = n.unsubscriptions, u = n.properties, c = 0;
                          if ("number" != typeof o) return e.destroy(new Error("Invalid messageId")), !1;
                          if (c += 2, "object" != typeof a || !a.length) return e.destroy(new Error("Invalid unsubscriptions")), 
                          !1;
                          for (let g = 0; g < a.length; g += 1) {
                              if ("string" != typeof a[g]) return e.destroy(new Error("Invalid unsubscriptions")), 
                              !1;
                              c += q.byteLength(a[g]) + 2;
                          }
                          let h = null;
                          if (5 === i) {
                              if (h = Wt(e, u), !h) return !1;
                              c += h.length;
                          }
                          e.write(j.UNSUBSCRIBE_HEADER[1][s ? 1 : 0][0]), De(e, c), Ie(e, o), null !== h && h.write();
                          let d = !0;
                          for (let g = 0; g < a.length; g++) d = yr(e, a[g]);
                          return d;
                      }(t, e, r);

                    case "unsuback":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.messageId, s = n.dup ? j.DUP_MASK : 0, a = n.granted, u = n.properties, c = n.cmd, h = 0, d = 2;
                          if ("number" != typeof o) return e.destroy(new Error("Invalid messageId")), !1;
                          if (5 === i) {
                              if ("object" != typeof a || !a.length) return e.destroy(new Error("Invalid qos vector")), 
                              !1;
                              for (let y = 0; y < a.length; y += 1) {
                                  if ("number" != typeof a[y]) return e.destroy(new Error("Invalid qos vector")), 
                                  !1;
                                  d += 1;
                              }
                          }
                          let g = null;
                          if (5 === i) {
                              if (g = Si(e, u, r, d), !g) return !1;
                              d += g.length;
                          }
                          return e.write(j.ACKS[c][h][s][0]), De(e, d), Ie(e, o), null !== g && g.write(), 
                          5 === i && e.write(q.from(a)), !0;
                      }(t, e, r);

                    case "pingreq":
                    case "pingresp":
                      return function(t, e, r) {
                          return e.write(j.EMPTY[t.cmd]);
                      }(t, e);

                    case "disconnect":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.reasonCode, s = n.properties, a = 5 === i ? 1 : 0, u = null;
                          if (5 === i) {
                              if (u = Si(e, s, r, a), !u) return !1;
                              a += u.length;
                          }
                          return e.write(q.from([ j.codes.disconnect << 4 ])), De(e, a), 5 === i && e.write(q.from([ o ])), 
                          null !== u && u.write(), !0;
                      }(t, e, r);

                    case "auth":
                      return function(t, e, r) {
                          let i = r ? r.protocolVersion : 4, n = t || {}, o = n.reasonCode, s = n.properties, a = 5 === i ? 1 : 0;
                          5 !== i && e.destroy(new Error("Invalid mqtt version for auth packet"));
                          let u = Si(e, s, r, a);
                          return !!u && (a += u.length, e.write(q.from([ j.codes.auth << 4 ])), De(e, a), 
                          e.write(q.from([ o ])), null !== u && u.write(), !0);
                      }(t, e, r);

                    default:
                      return e.destroy(new Error("Unknown command")), !1;
                  }
              }
              function Hm(t) {
                  t.uncork();
              }
              Object.defineProperty(Od, "cacheNumbers", {
                  get: () => Ie === zo,
                  set(t) {
                      t ? ((!Cn || 0 === Object.keys(Cn).length) && (Bn = !0), Ie = zo) : (Bn = !1, Ie = r1);
                  }
              });
              var Td = {};
              function De(t, e) {
                  if (e > j.VARBYTEINT_MAX) return t.destroy(new Error(`Invalid variable byte integer: ${e}`)), 
                  !1;
                  let r = Td[e];
                  return r || (r = Vo(e), e < 16384 && (Td[e] = r)), qe("writeVarByteInt: writing to stream: %o", r), 
                  t.write(r);
              }
              function yr(t, e) {
                  let r = q.byteLength(e);
                  return Ie(t, r), qe("writeString: %s", e), t.write(e, "utf8");
              }
              function Rd(t, e, r) {
                  yr(t, e), yr(t, r);
              }
              function zo(t, e) {
                  return qe("writeNumberCached: number: %d", e), qe("writeNumberCached: %o", Cn[e]), 
                  t.write(Cn[e]);
              }
              function r1(t, e) {
                  let r = Fm(e);
                  return qe("writeNumberGenerated: %o", r), t.write(r);
              }
              function Gr(t, e) {
                  "string" == typeof e ? yr(t, e) : e ? (Ie(t, e.length), t.write(e)) : Ie(t, 0);
              }
              function Wt(t, e) {
                  if ("object" != typeof e || null != e.length) return {
                      length: 1,
                      write() {
                          Bd(t, {}, 0);
                      }
                  };
                  let r = 0;
                  function i(o, s) {
                      let u = 0;
                      switch (j.propertiesTypes[o]) {
                        case "byte":
                          if ("boolean" != typeof s) return t.destroy(new Error(`Invalid ${o}: ${s}`)), !1;
                          u += 2;
                          break;

                        case "int8":
                          if ("number" != typeof s || s < 0 || s > 255) return t.destroy(new Error(`Invalid ${o}: ${s}`)), 
                          !1;
                          u += 2;
                          break;

                        case "binary":
                          if (s && null === s) return t.destroy(new Error(`Invalid ${o}: ${s}`)), !1;
                          u += 1 + q.byteLength(s) + 2;
                          break;

                        case "int16":
                          if ("number" != typeof s || s < 0 || s > 65535) return t.destroy(new Error(`Invalid ${o}: ${s}`)), 
                          !1;
                          u += 3;
                          break;

                        case "int32":
                          if ("number" != typeof s || s < 0 || s > 4294967295) return t.destroy(new Error(`Invalid ${o}: ${s}`)), 
                          !1;
                          u += 5;
                          break;

                        case "var":
                          if ("number" != typeof s || s < 0 || s > 268435455) return t.destroy(new Error(`Invalid ${o}: ${s}`)), 
                          !1;
                          u += 1 + q.byteLength(Vo(s));
                          break;

                        case "string":
                          if ("string" != typeof s) return t.destroy(new Error(`Invalid ${o}: ${s}`)), !1;
                          u += 3 + q.byteLength(s.toString());
                          break;

                        case "pair":
                          if ("object" != typeof s) return t.destroy(new Error(`Invalid ${o}: ${s}`)), !1;
                          u += Object.getOwnPropertyNames(s).reduce(((c, h) => {
                              let d = s[h];
                              return Array.isArray(d) ? c += d.reduce(((g, y) => g += 3 + q.byteLength(h.toString()) + 2 + q.byteLength(y.toString())), 0) : c += 3 + q.byteLength(h.toString()) + 2 + q.byteLength(s[h].toString()), 
                              c;
                          }), 0);
                          break;

                        default:
                          return t.destroy(new Error(`Invalid property ${o}: ${s}`)), !1;
                      }
                      return u;
                  }
                  if (e) for (let o in e) {
                      let s = 0, a = 0, u = e[o];
                      if (Array.isArray(u)) for (let c = 0; c < u.length; c++) {
                          if (a = i(o, u[c]), !a) return !1;
                          s += a;
                      } else {
                          if (a = i(o, u), !a) return !1;
                          s = a;
                      }
                      if (!s) return !1;
                      r += s;
                  }
                  return {
                      length: q.byteLength(Vo(r)) + r,
                      write() {
                          Bd(t, e, r);
                      }
                  };
              }
              function Si(t, e, r, i) {
                  let n = [ "reasonString", "userProperties" ], o = r && r.properties && r.properties.maximumPacketSize ? r.properties.maximumPacketSize : 0, s = Wt(t, e);
                  if (o) for (;i + s.length > o; ) {
                      let a = n.shift();
                      if (!a || !e[a]) return !1;
                      delete e[a], s = Wt(t, e);
                  }
                  return s;
              }
              function Cd(t, e, r) {
                  switch (j.propertiesTypes[e]) {
                    case "byte":
                      t.write(q.from([ j.properties[e] ])), t.write(q.from([ +r ]));
                      break;

                    case "int8":
                      t.write(q.from([ j.properties[e] ])), t.write(q.from([ r ]));
                      break;

                    case "binary":
                      t.write(q.from([ j.properties[e] ])), Gr(t, r);
                      break;

                    case "int16":
                      t.write(q.from([ j.properties[e] ])), Ie(t, r);
                      break;

                    case "int32":
                      t.write(q.from([ j.properties[e] ])), function(t, e) {
                          let r = $m(e);
                          qe("write4ByteNumber: %o", r), t.write(r);
                      }(t, r);
                      break;

                    case "var":
                      t.write(q.from([ j.properties[e] ])), De(t, r);
                      break;

                    case "string":
                      t.write(q.from([ j.properties[e] ])), yr(t, r);
                      break;

                    case "pair":
                      Object.getOwnPropertyNames(r).forEach((n => {
                          let o = r[n];
                          Array.isArray(o) ? o.forEach((s => {
                              t.write(q.from([ j.properties[e] ])), Rd(t, n.toString(), s.toString());
                          })) : (t.write(q.from([ j.properties[e] ])), Rd(t, n.toString(), o.toString()));
                      }));
                      break;

                    default:
                      return t.destroy(new Error(`Invalid property ${e} value: ${r}`)), !1;
                  }
              }
              function Bd(t, e, r) {
                  De(t, r);
                  for (let i in e) if (Object.prototype.hasOwnProperty.call(e, i) && null !== e[i]) {
                      let n = e[i];
                      if (Array.isArray(n)) for (let o = 0; o < n.length; o++) Cd(t, i, n[o]); else Cd(t, i, n);
                  }
              }
              function kd(t) {
                  return t ? t instanceof q ? t.length : q.byteLength(t) : 0;
              }
              function Pd(t) {
                  return "string" == typeof t || t instanceof q;
              }
              xd.exports = Od;
          })), Ud = M(((EO, Ld) => {
              v(), m(), _();
              var n1 = Ko(), {EventEmitter: s1} = (ir(), X(rr)), {Buffer: Md} = (ye(), X(_e));
              var Go = class extends s1 {
                  constructor() {
                      super(), this._array = new Array(20), this._i = 0;
                  }
                  write(e) {
                      return this._array[this._i++] = e, !0;
                  }
                  concat() {
                      let o, e = 0, r = new Array(this._array.length), i = this._array, n = 0;
                      for (o = 0; o < i.length && void 0 !== i[o]; o++) "string" != typeof i[o] ? r[o] = i[o].length : r[o] = Md.byteLength(i[o]), 
                      e += r[o];
                      let s = Md.allocUnsafe(e);
                      for (o = 0; o < i.length && void 0 !== i[o]; o++) "string" != typeof i[o] ? (i[o].copy(s, n), 
                      n += r[o]) : (s.write(i[o], n), n += r[o]);
                      return s;
                  }
                  destroy(e) {
                      e && this.emit("error", e);
                  }
              };
              Ld.exports = function(t, e) {
                  let r = new Go;
                  return n1(t, r, e), r.concat();
              };
          })), Nd = M((Pn => {
              v(), m(), _(), Pn.parser = md().parser, Pn.generate = Ud(), Pn.writeToStream = Ko();
          })), Jo = M((Yo => {
              v(), m(), _(), Object.defineProperty(Yo, "__esModule", {
                  value: !0
              });
              Yo.default = class {
                  constructor() {
                      this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
                  }
                  allocate() {
                      let e = this.nextId++;
                      return 65536 === this.nextId && (this.nextId = 1), e;
                  }
                  getLastAllocated() {
                      return 1 === this.nextId ? 65535 : this.nextId - 1;
                  }
                  register(e) {
                      return !0;
                  }
                  deallocate(e) {}
                  clear() {}
              };
          })), Dd = M(((XO, qd) => {
              function Qr(t) {
                  return t instanceof x ? x.from(t) : new t.constructor(t.buffer.slice(), t.byteOffset, t.length);
              }
              v(), m(), _(), qd.exports = function(t) {
                  return (t = t || {}).circles ? function(t) {
                      var e = [], r = [];
                      return t.proto ? function o(s) {
                          if ("object" != typeof s || null === s) return s;
                          if (s instanceof Date) return new Date(s);
                          if (Array.isArray(s)) return i(s, o);
                          if (s instanceof Map) return new Map(i(Array.from(s), o));
                          if (s instanceof Set) return new Set(i(Array.from(s), o));
                          var a = {};
                          for (var u in e.push(s), r.push(a), s) {
                              var c = s[u];
                              if ("object" != typeof c || null === c) a[u] = c; else if (c instanceof Date) a[u] = new Date(c); else if (c instanceof Map) a[u] = new Map(i(Array.from(c), o)); else if (c instanceof Set) a[u] = new Set(i(Array.from(c), o)); else if (ArrayBuffer.isView(c)) a[u] = Qr(c); else {
                                  var h = e.indexOf(c);
                                  a[u] = -1 !== h ? r[h] : o(c);
                              }
                          }
                          return e.pop(), r.pop(), a;
                      } : function n(s) {
                          if ("object" != typeof s || null === s) return s;
                          if (s instanceof Date) return new Date(s);
                          if (Array.isArray(s)) return i(s, n);
                          if (s instanceof Map) return new Map(i(Array.from(s), n));
                          if (s instanceof Set) return new Set(i(Array.from(s), n));
                          var a = {};
                          for (var u in e.push(s), r.push(a), s) if (!1 !== Object.hasOwnProperty.call(s, u)) {
                              var c = s[u];
                              if ("object" != typeof c || null === c) a[u] = c; else if (c instanceof Date) a[u] = new Date(c); else if (c instanceof Map) a[u] = new Map(i(Array.from(c), n)); else if (c instanceof Set) a[u] = new Set(i(Array.from(c), n)); else if (ArrayBuffer.isView(c)) a[u] = Qr(c); else {
                                  var h = e.indexOf(c);
                                  a[u] = -1 !== h ? r[h] : n(c);
                              }
                          }
                          return e.pop(), r.pop(), a;
                      };
                      function i(s, a) {
                          for (var u = Object.keys(s), c = new Array(u.length), h = 0; h < u.length; h++) {
                              var d = u[h], g = s[d];
                              if ("object" != typeof g || null === g) c[d] = g; else if (g instanceof Date) c[d] = new Date(g); else if (ArrayBuffer.isView(g)) c[d] = Qr(g); else {
                                  var y = e.indexOf(g);
                                  c[d] = -1 !== y ? r[y] : a(g);
                              }
                          }
                          return c;
                      }
                  }(t) : t.proto ? i : r;
                  function e(n, o) {
                      for (var s = Object.keys(n), a = new Array(s.length), u = 0; u < s.length; u++) {
                          var c = s[u], h = n[c];
                          "object" != typeof h || null === h ? a[c] = h : h instanceof Date ? a[c] = new Date(h) : ArrayBuffer.isView(h) ? a[c] = Qr(h) : a[c] = o(h);
                      }
                      return a;
                  }
                  function r(n) {
                      if ("object" != typeof n || null === n) return n;
                      if (n instanceof Date) return new Date(n);
                      if (Array.isArray(n)) return e(n, r);
                      if (n instanceof Map) return new Map(e(Array.from(n), r));
                      if (n instanceof Set) return new Set(e(Array.from(n), r));
                      var o = {};
                      for (var s in n) if (!1 !== Object.hasOwnProperty.call(n, s)) {
                          var a = n[s];
                          "object" != typeof a || null === a ? o[s] = a : a instanceof Date ? o[s] = new Date(a) : a instanceof Map ? o[s] = new Map(e(Array.from(a), r)) : a instanceof Set ? o[s] = new Set(e(Array.from(a), r)) : ArrayBuffer.isView(a) ? o[s] = Qr(a) : o[s] = r(a);
                      }
                      return o;
                  }
                  function i(n) {
                      if ("object" != typeof n || null === n) return n;
                      if (n instanceof Date) return new Date(n);
                      if (Array.isArray(n)) return e(n, i);
                      if (n instanceof Map) return new Map(e(Array.from(n), i));
                      if (n instanceof Set) return new Set(e(Array.from(n), i));
                      var o = {};
                      for (var s in n) {
                          var a = n[s];
                          "object" != typeof a || null === a ? o[s] = a : a instanceof Date ? o[s] = new Date(a) : a instanceof Map ? o[s] = new Map(e(Array.from(a), i)) : a instanceof Set ? o[s] = new Set(e(Array.from(a), i)) : ArrayBuffer.isView(a) ? o[s] = Qr(a) : o[s] = i(a);
                      }
                      return o;
                  }
              };
          })), Fd = M(((lk, jd) => {
              v(), m(), _(), jd.exports = Dd()();
          })), $d = M((Yr => {
              function Wd(t) {
                  let e = t.split("/");
                  for (let r = 0; r < e.length; r++) if ("+" !== e[r]) {
                      if ("#" === e[r]) return r === e.length - 1;
                      if (-1 !== e[r].indexOf("+") || -1 !== e[r].indexOf("#")) return !1;
                  }
                  return !0;
              }
              v(), m(), _(), Object.defineProperty(Yr, "__esModule", {
                  value: !0
              }), Yr.validateTopics = Yr.validateTopic = void 0, Yr.validateTopic = Wd, Yr.validateTopics = function(t) {
                  if (0 === t.length) return "empty_topic_list";
                  for (let e = 0; e < t.length; e++) if (!Wd(t[e])) return t[e];
                  return null;
              };
          })), ea = M((Zo => {
              v(), m(), _(), Object.defineProperty(Zo, "__esModule", {
                  value: !0
              });
              var f1 = jt(), c1 = {
                  objectMode: !0
              }, h1 = {
                  clean: !0
              };
              Zo.default = class {
                  constructor(e) {
                      this.options = e || {}, this.options = Object.assign(Object.assign({}, h1), e), 
                      this._inflights = new Map;
                  }
                  put(e, r) {
                      return this._inflights.set(e.messageId, e), r && r(), this;
                  }
                  createStream() {
                      let e = new f1.Readable(c1), r = [], i = !1, n = 0;
                      return this._inflights.forEach(((o, s) => {
                          r.push(o);
                      })), e._read = () => {
                          !i && n < r.length ? e.push(r[n++]) : e.push(null);
                      }, e.destroy = o => {
                          if (!i) return i = !0, setTimeout((() => {
                              e.emit("close");
                          }), 0), e;
                      }, e;
                  }
                  del(e, r) {
                      let i = this._inflights.get(e.messageId);
                      return i ? (this._inflights.delete(e.messageId), r(null, i)) : r && r(new Error("missing packet")), 
                      this;
                  }
                  get(e, r) {
                      let i = this._inflights.get(e.messageId);
                      return i ? r(null, i) : r && r(new Error("missing packet")), this;
                  }
                  close(e) {
                      this.options.clean && (this._inflights = null), e && e();
                  }
              };
          })), Vd = M((ta => {
              v(), m(), _(), Object.defineProperty(ta, "__esModule", {
                  value: !0
              });
              var Hd = [ 0, 16, 128, 131, 135, 144, 145, 151, 153 ];
              ta.default = (t, e, r) => {
                  t.log("handlePublish: packet %o", e), r = typeof r < "u" ? r : t.noop;
                  let i = e.topic.toString(), n = e.payload, {qos: o} = e, {messageId: s} = e, {options: a} = t;
                  if (5 === t.options.protocolVersion) {
                      let u;
                      if (e.properties && (u = e.properties.topicAlias), typeof u < "u") if (0 === i.length) {
                          if (!(u > 0 && u <= 65535)) return t.log("handlePublish :: topic alias out of range. alias: %d", u), 
                          void t.emit("error", new Error("Received Topic Alias is out of range"));
                          {
                              let c = t.topicAliasRecv.getTopicByAlias(u);
                              if (!c) return t.log("handlePublish :: unregistered topic alias. alias: %d", u), 
                              void t.emit("error", new Error("Received unregistered Topic Alias"));
                              i = c, t.log("handlePublish :: topic complemented by alias. topic: %s - alias: %d", i, u);
                          }
                      } else {
                          if (!t.topicAliasRecv.put(i, u)) return t.log("handlePublish :: topic alias out of range. alias: %d", u), 
                          void t.emit("error", new Error("Received Topic Alias is out of range"));
                          t.log("handlePublish :: registered topic: %s - alias: %d", i, u);
                      }
                  }
                  switch (t.log("handlePublish: qos %d", o), o) {
                    case 2:
                      a.customHandleAcks(i, n, e, ((u, c) => ("number" == typeof u && (c = u, u = null), 
                      u ? t.emit("error", u) : -1 === Hd.indexOf(c) ? t.emit("error", new Error("Wrong reason code for pubrec")) : void (c ? t._sendPacket({
                          cmd: "pubrec",
                          messageId: s,
                          reasonCode: c
                      }, r) : t.incomingStore.put(e, (() => {
                          t._sendPacket({
                              cmd: "pubrec",
                              messageId: s
                          }, r);
                      }))))));
                      break;

                    case 1:
                      a.customHandleAcks(i, n, e, ((u, c) => ("number" == typeof u && (c = u, u = null), 
                      u ? t.emit("error", u) : -1 === Hd.indexOf(c) ? t.emit("error", new Error("Wrong reason code for puback")) : (c || t.emit("message", i, n, e), 
                      void t.handleMessage(e, (h => {
                          if (h) return r && r(h);
                          t._sendPacket({
                              cmd: "puback",
                              messageId: s,
                              reasonCode: c
                          }, r);
                      }))))));
                      break;

                    case 0:
                      t.emit("message", i, n, e), t.handleMessage(e, r);
                      break;

                    default:
                      t.log("handlePublish: unknown QoS. Doing nothing.");
                  }
              };
          })), zd = M(((Gk, p1) => {
              p1.exports = {
                  version: "5.5.3"
              };
          })), Jr = M((at => {
              v(), m(), _(), Object.defineProperty(at, "__esModule", {
                  value: !0
              }), at.MQTTJS_VERSION = at.nextTick = at.applyMixin = at.ErrorWithReasonCode = void 0;
              var ra = class t extends Error {
                  constructor(e, r) {
                      super(e), this.code = r, Object.setPrototypeOf(this, t.prototype), Object.getPrototypeOf(this).name = "ErrorWithReasonCode";
                  }
              };
              at.ErrorWithReasonCode = ra, at.applyMixin = function(t, e, r = !1) {
                  var i;
                  let n = [ e ];
                  for (;;) {
                      let o = n[0], s = Object.getPrototypeOf(o);
                      if (!s?.prototype) break;
                      n.unshift(s);
                  }
                  for (let o of n) for (let s of Object.getOwnPropertyNames(o.prototype)) (r || "constructor" !== s) && Object.defineProperty(t.prototype, s, null !== (i = Object.getOwnPropertyDescriptor(o.prototype, s)) && void 0 !== i ? i : Object.create(null));
              }, at.nextTick = "function" == typeof (null == P ? void 0 : P.nextTick) ? P.nextTick : t => {
                  setTimeout(t, 0);
              }, at.MQTTJS_VERSION = zd().version;
          })), Ai = M((br => {
              v(), m(), _(), Object.defineProperty(br, "__esModule", {
                  value: !0
              }), br.ReasonCodes = void 0, br.ReasonCodes = {
                  0: "",
                  1: "Unacceptable protocol version",
                  2: "Identifier rejected",
                  3: "Server unavailable",
                  4: "Bad username or password",
                  5: "Not authorized",
                  16: "No matching subscribers",
                  17: "No subscription existed",
                  128: "Unspecified error",
                  129: "Malformed Packet",
                  130: "Protocol Error",
                  131: "Implementation specific error",
                  132: "Unsupported Protocol Version",
                  133: "Client Identifier not valid",
                  134: "Bad User Name or Password",
                  135: "Not authorized",
                  136: "Server unavailable",
                  137: "Server busy",
                  138: "Banned",
                  139: "Server shutting down",
                  140: "Bad authentication method",
                  141: "Keep Alive timeout",
                  142: "Session taken over",
                  143: "Topic Filter invalid",
                  144: "Topic Name invalid",
                  145: "Packet identifier in use",
                  146: "Packet Identifier not found",
                  147: "Receive Maximum exceeded",
                  148: "Topic Alias invalid",
                  149: "Packet too large",
                  150: "Message rate too high",
                  151: "Quota exceeded",
                  152: "Administrative action",
                  153: "Payload format invalid",
                  154: "Retain not supported",
                  155: "QoS not supported",
                  156: "Use another server",
                  157: "Server moved",
                  158: "Shared Subscriptions not supported",
                  159: "Connection rate exceeded",
                  160: "Maximum connect time",
                  161: "Subscription Identifiers not supported",
                  162: "Wildcard Subscriptions not supported"
              };
              br.default = (t, e) => {
                  let s, {messageId: r} = e, i = e.cmd, n = null, o = t.outgoing[r] ? t.outgoing[r].cb : null;
                  if (o) {
                      switch (t.log("_handleAck :: packet type", i), i) {
                        case "pubcomp":
                        case "puback":
                          {
                              let a = e.reasonCode;
                              a && a > 0 && 16 !== a ? (s = new Error(`Publish error: ${br.ReasonCodes[a]}`), 
                              s.code = a, t._removeOutgoingAndStoreMessage(r, (() => {
                                  o(s, e);
                              }))) : t._removeOutgoingAndStoreMessage(r, o);
                              break;
                          }

                        case "pubrec":
                          {
                              n = {
                                  cmd: "pubrel",
                                  qos: 2,
                                  messageId: r
                              };
                              let a = e.reasonCode;
                              a && a > 0 && 16 !== a ? (s = new Error(`Publish error: ${br.ReasonCodes[a]}`), 
                              s.code = a, t._removeOutgoingAndStoreMessage(r, (() => {
                                  o(s, e);
                              }))) : t._sendPacket(n);
                              break;
                          }

                        case "suback":
                          {
                              delete t.outgoing[r], t.messageIdProvider.deallocate(r);
                              let a = e.granted;
                              for (let u = 0; u < a.length; u++) if (128 & a[u]) {
                                  let c = t.messageIdToTopic[r];
                                  c && c.forEach((h => {
                                      delete t._resubscribeTopics[h];
                                  }));
                              }
                              delete t.messageIdToTopic[r], t._invokeStoreProcessingQueue(), o(null, e);
                              break;
                          }

                        case "unsuback":
                          delete t.outgoing[r], t.messageIdProvider.deallocate(r), t._invokeStoreProcessingQueue(), 
                          o(null);
                          break;

                        default:
                          t.emit("error", new Error("unrecognized packet type"));
                      }
                      t.disconnecting && 0 === Object.keys(t.outgoing).length && t.emit("outgoingEmpty");
                  } else t.log("_handleAck :: Server sent an ack in error. Ignoring.");
              };
          })), Gd = M((ia => {
              v(), m(), _(), Object.defineProperty(ia, "__esModule", {
                  value: !0
              });
              var Kd = Jr(), b1 = Ai();
              ia.default = (t, e) => {
                  let {options: r} = t, i = r.protocolVersion, n = 5 === i ? e.reasonCode : e.returnCode;
                  if (5 === i) t.handleAuth(e, ((o, s) => {
                      if (o) t.emit("error", o); else if (24 === n) t.reconnecting = !1, t._sendPacket(s); else {
                          let a = new Kd.ErrorWithReasonCode(`Connection refused: ${b1.ReasonCodes[n]}`, n);
                          t.emit("error", a);
                      }
                  })); else {
                      let o = new Kd.ErrorWithReasonCode(`Protocol error: Auth packets are only supported in MQTT 5. Your version:${i}`, n);
                      t.emit("error", o);
                  }
              };
          })), Zd = M((kn => {
              v(), m(), _(), Object.defineProperty(kn, "__esModule", {
                  value: !0
              }), kn.LRUCache = void 0;
              var Ii = "object" == typeof performance && performance && "function" == typeof performance.now ? performance : Date, Yd = new Set, na = "object" == typeof P && P ? P : {}, Jd = (t, e, r, i) => {
                  "function" == typeof na.emitWarning ? na.emitWarning(t, e, r, i) : console.error(`[${r}] ${e}: ${t}`);
              }, On = globalThis.AbortController, Qd = globalThis.AbortSignal;
              if (typeof On > "u") {
                  Qd = class {
                      onabort;
                      _onabort=[];
                      reason;
                      aborted=!1;
                      addEventListener(i, n) {
                          this._onabort.push(n);
                      }
                  }, On = class {
                      constructor() {
                          e();
                      }
                      signal=new Qd;
                      abort(i) {
                          if (!this.signal.aborted) {
                              this.signal.reason = i, this.signal.aborted = !0;
                              for (let n of this.signal._onabort) n(i);
                              this.signal.onabort?.(i);
                          }
                      }
                  };
                  let t = "1" !== na.env?.LRU_CACHE_IGNORE_AC_WARNING, e = () => {
                      t && (t = !1, Jd("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", e));
                  };
              }
              Symbol("type");
              var $t = t => t && t === Math.floor(t) && t > 0 && isFinite(t), Xd = t => $t(t) ? t <= Math.pow(2, 8) ? Uint8Array : t <= Math.pow(2, 16) ? Uint16Array : t <= Math.pow(2, 32) ? Uint32Array : t <= Number.MAX_SAFE_INTEGER ? Xr : null : null, Xr = class extends Array {
                  constructor(e) {
                      super(e), this.fill(0);
                  }
              }, sa = class t {
                  heap;
                  length;
                  static #l=!1;
                  static create(e) {
                      let r = Xd(e);
                      if (!r) return [];
                      t.#l = !0;
                      let i = new t(e, r);
                      return t.#l = !1, i;
                  }
                  constructor(e, r) {
                      if (!t.#l) throw new TypeError("instantiate Stack using Stack.create(n)");
                      this.heap = new r(e), this.length = 0;
                  }
                  push(e) {
                      this.heap[this.length++] = e;
                  }
                  pop() {
                      return this.heap[--this.length];
                  }
              }, oa = class t {
                  #l;
                  #c;
                  #p;
                  #g;
                  #B;
                  ttl;
                  ttlResolution;
                  ttlAutopurge;
                  updateAgeOnGet;
                  updateAgeOnHas;
                  allowStale;
                  noDisposeOnSet;
                  noUpdateTTL;
                  maxEntrySize;
                  sizeCalculation;
                  noDeleteOnFetchRejection;
                  noDeleteOnStaleGet;
                  allowStaleOnFetchAbort;
                  allowStaleOnFetchRejection;
                  ignoreFetchAbort;
                  #i;
                  #y;
                  #n;
                  #r;
                  #e;
                  #u;
                  #h;
                  #a;
                  #s;
                  #b;
                  #o;
                  #E;
                  #S;
                  #w;
                  #_;
                  #I;
                  #f;
                  static unsafeExposeInternals(e) {
                      return {
                          starts: e.#S,
                          ttls: e.#w,
                          sizes: e.#E,
                          keyMap: e.#n,
                          keyList: e.#r,
                          valList: e.#e,
                          next: e.#u,
                          prev: e.#h,
                          get head() {
                              return e.#a;
                          },
                          get tail() {
                              return e.#s;
                          },
                          free: e.#b,
                          isBackgroundFetch: r => e.#t(r),
                          backgroundFetch: (r, i, n, o) => e.#k(r, i, n, o),
                          moveToTail: r => e.#C(r),
                          indexes: r => e.#m(r),
                          rindexes: r => e.#v(r),
                          isStale: r => e.#d(r)
                      };
                  }
                  get max() {
                      return this.#l;
                  }
                  get maxSize() {
                      return this.#c;
                  }
                  get calculatedSize() {
                      return this.#y;
                  }
                  get size() {
                      return this.#i;
                  }
                  get fetchMethod() {
                      return this.#B;
                  }
                  get dispose() {
                      return this.#p;
                  }
                  get disposeAfter() {
                      return this.#g;
                  }
                  constructor(e) {
                      let {max: r = 0, ttl: i, ttlResolution: n = 1, ttlAutopurge: o, updateAgeOnGet: s, updateAgeOnHas: a, allowStale: u, dispose: c, disposeAfter: h, noDisposeOnSet: d, noUpdateTTL: g, maxSize: y = 0, maxEntrySize: w = 0, sizeCalculation: E, fetchMethod: S, noDeleteOnFetchRejection: I, noDeleteOnStaleGet: C, allowStaleOnFetchRejection: R, allowStaleOnFetchAbort: U, ignoreFetchAbort: N} = e;
                      if (0 !== r && !$t(r)) throw new TypeError("max option must be a nonnegative integer");
                      let W = r ? Xd(r) : Array;
                      if (!W) throw new Error("invalid max value: " + r);
                      if (this.#l = r, this.#c = y, this.maxEntrySize = w || this.#c, this.sizeCalculation = E, 
                      this.sizeCalculation) {
                          if (!this.#c && !this.maxEntrySize) throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
                          if ("function" != typeof this.sizeCalculation) throw new TypeError("sizeCalculation set to non-function");
                      }
                      if (void 0 !== S && "function" != typeof S) throw new TypeError("fetchMethod must be a function if specified");
                      if (this.#B = S, this.#I = !!S, this.#n = new Map, this.#r = new Array(r).fill(void 0), 
                      this.#e = new Array(r).fill(void 0), this.#u = new W(r), this.#h = new W(r), this.#a = 0, 
                      this.#s = 0, this.#b = sa.create(r), this.#i = 0, this.#y = 0, "function" == typeof c && (this.#p = c), 
                      "function" == typeof h ? (this.#g = h, this.#o = []) : (this.#g = void 0, this.#o = void 0), 
                      this.#_ = !!this.#p, this.#f = !!this.#g, this.noDisposeOnSet = !!d, this.noUpdateTTL = !!g, 
                      this.noDeleteOnFetchRejection = !!I, this.allowStaleOnFetchRejection = !!R, this.allowStaleOnFetchAbort = !!U, 
                      this.ignoreFetchAbort = !!N, 0 !== this.maxEntrySize) {
                          if (0 !== this.#c && !$t(this.#c)) throw new TypeError("maxSize must be a positive integer if specified");
                          if (!$t(this.maxEntrySize)) throw new TypeError("maxEntrySize must be a positive integer if specified");
                          this.#q();
                      }
                      if (this.allowStale = !!u, this.noDeleteOnStaleGet = !!C, this.updateAgeOnGet = !!s, 
                      this.updateAgeOnHas = !!a, this.ttlResolution = $t(n) || 0 === n ? n : 1, this.ttlAutopurge = !!o, 
                      this.ttl = i || 0, this.ttl) {
                          if (!$t(this.ttl)) throw new TypeError("ttl must be a positive integer if specified");
                          this.#x();
                      }
                      if (0 === this.#l && 0 === this.ttl && 0 === this.#c) throw new TypeError("At least one of max, maxSize, or ttl is required");
                      if (!this.ttlAutopurge && !this.#l && !this.#c) {
                          let K = "LRU_CACHE_UNBOUNDED";
                          (t => !Yd.has(t))(K) && (Yd.add(K), Jd("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", K, t));
                      }
                  }
                  getRemainingTTL(e) {
                      return this.#n.has(e) ? 1 / 0 : 0;
                  }
                  #x() {
                      let e = new Xr(this.#l), r = new Xr(this.#l);
                      this.#w = e, this.#S = r, this.#M = (o, s, a = Ii.now()) => {
                          if (r[o] = 0 !== s ? a : 0, e[o] = s, 0 !== s && this.ttlAutopurge) {
                              let u = setTimeout((() => {
                                  this.#d(o) && this.delete(this.#r[o]);
                              }), s + 1);
                              u.unref && u.unref();
                          }
                      }, this.#T = o => {
                          r[o] = 0 !== e[o] ? Ii.now() : 0;
                      }, this.#A = (o, s) => {
                          if (e[s]) {
                              let a = e[s], u = r[s];
                              o.ttl = a, o.start = u, o.now = i || n();
                              let c = o.now - u;
                              o.remainingTTL = a - c;
                          }
                      };
                      let i = 0, n = () => {
                          let o = Ii.now();
                          if (this.ttlResolution > 0) {
                              i = o;
                              let s = setTimeout((() => i = 0), this.ttlResolution);
                              s.unref && s.unref();
                          }
                          return o;
                      };
                      this.getRemainingTTL = o => {
                          let s = this.#n.get(o);
                          if (void 0 === s) return 0;
                          let a = e[s], u = r[s];
                          return 0 === a || 0 === u ? 1 / 0 : a - ((i || n()) - u);
                      }, this.#d = o => 0 !== e[o] && 0 !== r[o] && (i || n()) - r[o] > e[o];
                  }
                  #T=() => {};
                  #A=() => {};
                  #M=() => {};
                  #d=() => !1;
                  #q() {
                      let e = new Xr(this.#l);
                      this.#y = 0, this.#E = e, this.#R = r => {
                          this.#y -= e[r], e[r] = 0;
                      }, this.#L = (r, i, n, o) => {
                          if (this.#t(i)) return 0;
                          if (!$t(n)) {
                              if (!o) throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
                              if ("function" != typeof o) throw new TypeError("sizeCalculation must be a function");
                              if (n = o(i, r), !$t(n)) throw new TypeError("sizeCalculation return invalid (expect positive integer)");
                          }
                          return n;
                      }, this.#P = (r, i, n) => {
                          if (e[r] = i, this.#c) {
                              let o = this.#c - e[r];
                              for (;this.#y > o; ) this.#O(!0);
                          }
                          this.#y += e[r], n && (n.entrySize = i, n.totalCalculatedSize = this.#y);
                      };
                  }
                  #R=e => {};
                  #P=(e, r, i) => {};
                  #L=(e, r, i, n) => {
                      if (i || n) throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
                      return 0;
                  };
                  * #m({allowStale: e = this.allowStale} = {}) {
                      if (this.#i) for (let r = this.#s; this.#U(r) && ((e || !this.#d(r)) && (yield r), 
                      r !== this.#a); ) r = this.#h[r];
                  }
                  * #v({allowStale: e = this.allowStale} = {}) {
                      if (this.#i) for (let r = this.#a; this.#U(r) && ((e || !this.#d(r)) && (yield r), 
                      r !== this.#s); ) r = this.#u[r];
                  }
                  #U(e) {
                      return void 0 !== e && this.#n.get(this.#r[e]) === e;
                  }
                  * entries() {
                      for (let e of this.#m()) void 0 !== this.#e[e] && void 0 !== this.#r[e] && !this.#t(this.#e[e]) && (yield [ this.#r[e], this.#e[e] ]);
                  }
                  * rentries() {
                      for (let e of this.#v()) void 0 !== this.#e[e] && void 0 !== this.#r[e] && !this.#t(this.#e[e]) && (yield [ this.#r[e], this.#e[e] ]);
                  }
                  * keys() {
                      for (let e of this.#m()) {
                          let r = this.#r[e];
                          void 0 !== r && !this.#t(this.#e[e]) && (yield r);
                      }
                  }
                  * rkeys() {
                      for (let e of this.#v()) {
                          let r = this.#r[e];
                          void 0 !== r && !this.#t(this.#e[e]) && (yield r);
                      }
                  }
                  * values() {
                      for (let e of this.#m()) void 0 !== this.#e[e] && !this.#t(this.#e[e]) && (yield this.#e[e]);
                  }
                  * rvalues() {
                      for (let e of this.#v()) void 0 !== this.#e[e] && !this.#t(this.#e[e]) && (yield this.#e[e]);
                  }
                  [Symbol.iterator]() {
                      return this.entries();
                  }
                  find(e, r = {}) {
                      for (let i of this.#m()) {
                          let n = this.#e[i], o = this.#t(n) ? n.__staleWhileFetching : n;
                          if (void 0 !== o && e(o, this.#r[i], this)) return this.get(this.#r[i], r);
                      }
                  }
                  forEach(e, r = this) {
                      for (let i of this.#m()) {
                          let n = this.#e[i], o = this.#t(n) ? n.__staleWhileFetching : n;
                          void 0 !== o && e.call(r, o, this.#r[i], this);
                      }
                  }
                  rforEach(e, r = this) {
                      for (let i of this.#v()) {
                          let n = this.#e[i], o = this.#t(n) ? n.__staleWhileFetching : n;
                          void 0 !== o && e.call(r, o, this.#r[i], this);
                      }
                  }
                  purgeStale() {
                      let e = !1;
                      for (let r of this.#v({
                          allowStale: !0
                      })) this.#d(r) && (this.delete(this.#r[r]), e = !0);
                      return e;
                  }
                  dump() {
                      let e = [];
                      for (let r of this.#m({
                          allowStale: !0
                      })) {
                          let i = this.#r[r], n = this.#e[r], o = this.#t(n) ? n.__staleWhileFetching : n;
                          if (void 0 === o || void 0 === i) continue;
                          let s = {
                              value: o
                          };
                          if (this.#w && this.#S) {
                              s.ttl = this.#w[r];
                              let a = Ii.now() - this.#S[r];
                              s.start = Math.floor(Date.now() - a);
                          }
                          this.#E && (s.size = this.#E[r]), e.unshift([ i, s ]);
                      }
                      return e;
                  }
                  load(e) {
                      this.clear();
                      for (let [r, i] of e) {
                          if (i.start) {
                              let n = Date.now() - i.start;
                              i.start = Ii.now() - n;
                          }
                          this.set(r, i.value, i);
                      }
                  }
                  set(e, r, i = {}) {
                      if (void 0 === r) return this.delete(e), this;
                      let {ttl: n = this.ttl, start: o, noDisposeOnSet: s = this.noDisposeOnSet, sizeCalculation: a = this.sizeCalculation, status: u} = i, {noUpdateTTL: c = this.noUpdateTTL} = i, h = this.#L(e, r, i.size || 0, a);
                      if (this.maxEntrySize && h > this.maxEntrySize) return u && (u.set = "miss", u.maxEntrySizeExceeded = !0), 
                      this.delete(e), this;
                      let d = 0 === this.#i ? void 0 : this.#n.get(e);
                      if (void 0 === d) d = 0 === this.#i ? this.#s : 0 !== this.#b.length ? this.#b.pop() : this.#i === this.#l ? this.#O(!1) : this.#i, 
                      this.#r[d] = e, this.#e[d] = r, this.#n.set(e, d), this.#u[this.#s] = d, this.#h[d] = this.#s, 
                      this.#s = d, this.#i++, this.#P(d, h, u), u && (u.set = "add"), c = !1; else {
                          this.#C(d);
                          let g = this.#e[d];
                          if (r !== g) {
                              if (this.#I && this.#t(g)) {
                                  g.__abortController.abort(new Error("replaced"));
                                  let {__staleWhileFetching: y} = g;
                                  void 0 !== y && !s && (this.#_ && this.#p?.(y, e, "set"), this.#f && this.#o?.push([ y, e, "set" ]));
                              } else s || (this.#_ && this.#p?.(g, e, "set"), this.#f && this.#o?.push([ g, e, "set" ]));
                              if (this.#R(d), this.#P(d, h, u), this.#e[d] = r, u) {
                                  u.set = "replace";
                                  let y = g && this.#t(g) ? g.__staleWhileFetching : g;
                                  void 0 !== y && (u.oldValue = y);
                              }
                          } else u && (u.set = "update");
                      }
                      if (0 !== n && !this.#w && this.#x(), this.#w && (c || this.#M(d, n, o), u && this.#A(u, d)), 
                      !s && this.#f && this.#o) {
                          let y, g = this.#o;
                          for (;y = g?.shift(); ) this.#g?.(...y);
                      }
                      return this;
                  }
                  pop() {
                      try {
                          for (;this.#i; ) {
                              let e = this.#e[this.#a];
                              if (this.#O(!0), this.#t(e)) {
                                  if (e.__staleWhileFetching) return e.__staleWhileFetching;
                              } else if (void 0 !== e) return e;
                          }
                      } finally {
                          if (this.#f && this.#o) {
                              let r, e = this.#o;
                              for (;r = e?.shift(); ) this.#g?.(...r);
                          }
                      }
                  }
                  #O(e) {
                      let r = this.#a, i = this.#r[r], n = this.#e[r];
                      return this.#I && this.#t(n) ? n.__abortController.abort(new Error("evicted")) : (this.#_ || this.#f) && (this.#_ && this.#p?.(n, i, "evict"), 
                      this.#f && this.#o?.push([ n, i, "evict" ])), this.#R(r), e && (this.#r[r] = void 0, 
                      this.#e[r] = void 0, this.#b.push(r)), 1 === this.#i ? (this.#a = this.#s = 0, this.#b.length = 0) : this.#a = this.#u[r], 
                      this.#n.delete(i), this.#i--, r;
                  }
                  has(e, r = {}) {
                      let {updateAgeOnHas: i = this.updateAgeOnHas, status: n} = r, o = this.#n.get(e);
                      if (void 0 !== o) {
                          let s = this.#e[o];
                          if (this.#t(s) && void 0 === s.__staleWhileFetching) return !1;
                          if (!this.#d(o)) return i && this.#T(o), n && (n.has = "hit", this.#A(n, o)), !0;
                          n && (n.has = "stale", this.#A(n, o));
                      } else n && (n.has = "miss");
                      return !1;
                  }
                  peek(e, r = {}) {
                      let {allowStale: i = this.allowStale} = r, n = this.#n.get(e);
                      if (void 0 !== n && (i || !this.#d(n))) {
                          let o = this.#e[n];
                          return this.#t(o) ? o.__staleWhileFetching : o;
                      }
                  }
                  #k(e, r, i, n) {
                      let o = void 0 === r ? void 0 : this.#e[r];
                      if (this.#t(o)) return o;
                      let s = new On, {signal: a} = i;
                      a?.addEventListener("abort", (() => s.abort(a.reason)), {
                          signal: s.signal
                      });
                      let u = {
                          signal: s.signal,
                          options: i,
                          context: n
                      }, c = (E, S = !1) => {
                          let {aborted: I} = s.signal, C = i.ignoreFetchAbort && void 0 !== E;
                          if (i.status && (I && !S ? (i.status.fetchAborted = !0, i.status.fetchError = s.signal.reason, 
                          C && (i.status.fetchAbortIgnored = !0)) : i.status.fetchResolved = !0), I && !C && !S) return d(s.signal.reason);
                          let R = y;
                          return this.#e[r] === y && (void 0 === E ? R.__staleWhileFetching ? this.#e[r] = R.__staleWhileFetching : this.delete(e) : (i.status && (i.status.fetchUpdated = !0), 
                          this.set(e, E, u.options))), E;
                      }, d = E => {
                          let {aborted: S} = s.signal, I = S && i.allowStaleOnFetchAbort, C = I || i.allowStaleOnFetchRejection, R = C || i.noDeleteOnFetchRejection, U = y;
                          if (this.#e[r] === y && (R && void 0 !== U.__staleWhileFetching ? I || (this.#e[r] = U.__staleWhileFetching) : this.delete(e)), 
                          C) return i.status && void 0 !== U.__staleWhileFetching && (i.status.returnedStale = !0), 
                          U.__staleWhileFetching;
                          if (U.__returned === U) throw E;
                      };
                      i.status && (i.status.fetchDispatched = !0);
                      let y = new Promise(((E, S) => {
                          let I = this.#B?.(e, o, u);
                          I && I instanceof Promise && I.then((C => E(void 0 === C ? void 0 : C)), S), s.signal.addEventListener("abort", (() => {
                              (!i.ignoreFetchAbort || i.allowStaleOnFetchAbort) && (E(void 0), i.allowStaleOnFetchAbort && (E = C => c(C, !0)));
                          }));
                      })).then(c, (E => (i.status && (i.status.fetchRejected = !0, i.status.fetchError = E), 
                      d(E)))), w = Object.assign(y, {
                          __abortController: s,
                          __staleWhileFetching: o,
                          __returned: void 0
                      });
                      return void 0 === r ? (this.set(e, w, {
                          ...u.options,
                          status: void 0
                      }), r = this.#n.get(e)) : this.#e[r] = w, w;
                  }
                  #t(e) {
                      if (!this.#I) return !1;
                      let r = e;
                      return !!r && r instanceof Promise && r.hasOwnProperty("__staleWhileFetching") && r.__abortController instanceof On;
                  }
                  async fetch(e, r = {}) {
                      let {allowStale: i = this.allowStale, updateAgeOnGet: n = this.updateAgeOnGet, noDeleteOnStaleGet: o = this.noDeleteOnStaleGet, ttl: s = this.ttl, noDisposeOnSet: a = this.noDisposeOnSet, size: u = 0, sizeCalculation: c = this.sizeCalculation, noUpdateTTL: h = this.noUpdateTTL, noDeleteOnFetchRejection: d = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: g = this.allowStaleOnFetchRejection, ignoreFetchAbort: y = this.ignoreFetchAbort, allowStaleOnFetchAbort: w = this.allowStaleOnFetchAbort, context: E, forceRefresh: S = !1, status: I, signal: C} = r;
                      if (!this.#I) return I && (I.fetch = "get"), this.get(e, {
                          allowStale: i,
                          updateAgeOnGet: n,
                          noDeleteOnStaleGet: o,
                          status: I
                      });
                      let R = {
                          allowStale: i,
                          updateAgeOnGet: n,
                          noDeleteOnStaleGet: o,
                          ttl: s,
                          noDisposeOnSet: a,
                          size: u,
                          sizeCalculation: c,
                          noUpdateTTL: h,
                          noDeleteOnFetchRejection: d,
                          allowStaleOnFetchRejection: g,
                          allowStaleOnFetchAbort: w,
                          ignoreFetchAbort: y,
                          status: I,
                          signal: C
                      }, U = this.#n.get(e);
                      if (void 0 === U) {
                          I && (I.fetch = "miss");
                          let N = this.#k(e, U, R, E);
                          return N.__returned = N;
                      }
                      {
                          let N = this.#e[U];
                          if (this.#t(N)) {
                              let de = i && void 0 !== N.__staleWhileFetching;
                              return I && (I.fetch = "inflight", de && (I.returnedStale = !0)), de ? N.__staleWhileFetching : N.__returned = N;
                          }
                          let W = this.#d(U);
                          if (!S && !W) return I && (I.fetch = "hit"), this.#C(U), n && this.#T(U), I && this.#A(I, U), 
                          N;
                          let K = this.#k(e, U, R, E), Q = void 0 !== K.__staleWhileFetching && i;
                          return I && (I.fetch = W ? "stale" : "refresh", Q && W && (I.returnedStale = !0)), 
                          Q ? K.__staleWhileFetching : K.__returned = K;
                      }
                  }
                  get(e, r = {}) {
                      let {allowStale: i = this.allowStale, updateAgeOnGet: n = this.updateAgeOnGet, noDeleteOnStaleGet: o = this.noDeleteOnStaleGet, status: s} = r, a = this.#n.get(e);
                      if (void 0 !== a) {
                          let u = this.#e[a], c = this.#t(u);
                          return s && this.#A(s, a), this.#d(a) ? (s && (s.get = "stale"), c ? (s && i && void 0 !== u.__staleWhileFetching && (s.returnedStale = !0), 
                          i ? u.__staleWhileFetching : void 0) : (o || this.delete(e), s && i && (s.returnedStale = !0), 
                          i ? u : void 0)) : (s && (s.get = "hit"), c ? u.__staleWhileFetching : (this.#C(a), 
                          n && this.#T(a), u));
                      }
                      s && (s.get = "miss");
                  }
                  #N(e, r) {
                      this.#h[r] = e, this.#u[e] = r;
                  }
                  #C(e) {
                      e !== this.#s && (e === this.#a ? this.#a = this.#u[e] : this.#N(this.#h[e], this.#u[e]), 
                      this.#N(this.#s, e), this.#s = e);
                  }
                  delete(e) {
                      let r = !1;
                      if (0 !== this.#i) {
                          let i = this.#n.get(e);
                          if (void 0 !== i) if (r = !0, 1 === this.#i) this.clear(); else {
                              this.#R(i);
                              let n = this.#e[i];
                              this.#t(n) ? n.__abortController.abort(new Error("deleted")) : (this.#_ || this.#f) && (this.#_ && this.#p?.(n, e, "delete"), 
                              this.#f && this.#o?.push([ n, e, "delete" ])), this.#n.delete(e), this.#r[i] = void 0, 
                              this.#e[i] = void 0, i === this.#s ? this.#s = this.#h[i] : i === this.#a ? this.#a = this.#u[i] : (this.#u[this.#h[i]] = this.#u[i], 
                              this.#h[this.#u[i]] = this.#h[i]), this.#i--, this.#b.push(i);
                          }
                      }
                      if (this.#f && this.#o?.length) {
                          let n, i = this.#o;
                          for (;n = i?.shift(); ) this.#g?.(...n);
                      }
                      return r;
                  }
                  clear() {
                      for (let e of this.#v({
                          allowStale: !0
                      })) {
                          let r = this.#e[e];
                          if (this.#t(r)) r.__abortController.abort(new Error("deleted")); else {
                              let i = this.#r[e];
                              this.#_ && this.#p?.(r, i, "delete"), this.#f && this.#o?.push([ r, i, "delete" ]);
                          }
                      }
                      if (this.#n.clear(), this.#e.fill(void 0), this.#r.fill(void 0), this.#w && this.#S && (this.#w.fill(0), 
                      this.#S.fill(0)), this.#E && this.#E.fill(0), this.#a = 0, this.#s = 0, this.#b.length = 0, 
                      this.#y = 0, this.#i = 0, this.#f && this.#o) {
                          let r, e = this.#o;
                          for (;r = e?.shift(); ) this.#g?.(...r);
                      }
                  }
              };
              kn.LRUCache = oa;
          })), lt = M((Ht => {
              v(), m(), _(), Object.defineProperty(Ht, "t", {
                  value: !0
              }), Ht.ContainerIterator = Ht.Container = Ht.Base = void 0;
              Ht.ContainerIterator = class {
                  constructor(e = 0) {
                      this.iteratorType = e;
                  }
                  equals(e) {
                      return this.o === e.o;
                  }
              };
              var xn = class {
                  constructor() {
                      this.i = 0;
                  }
                  get length() {
                      return this.i;
                  }
                  size() {
                      return this.i;
                  }
                  empty() {
                      return 0 === this.i;
                  }
              };
              Ht.Base = xn;
              Ht.Container = class extends xn {};
          })), ep = M((Mn => {
              v(), m(), _(), Object.defineProperty(Mn, "t", {
                  value: !0
              }), Mn.default = void 0;
              var m1 = lt(), ua = class extends m1.Base {
                  constructor(e = []) {
                      super(), this.S = [];
                      let r = this;
                      e.forEach((function(i) {
                          r.push(i);
                      }));
                  }
                  clear() {
                      this.i = 0, this.S = [];
                  }
                  push(e) {
                      return this.S.push(e), this.i += 1, this.i;
                  }
                  pop() {
                      if (0 !== this.i) return this.i -= 1, this.S.pop();
                  }
                  top() {
                      return this.S[this.i - 1];
                  }
              }, v1 = ua;
              Mn.default = v1;
          })), tp = M((Ln => {
              v(), m(), _(), Object.defineProperty(Ln, "t", {
                  value: !0
              }), Ln.default = void 0;
              var E1 = lt(), fa = class extends E1.Base {
                  constructor(e = []) {
                      super(), this.j = 0, this.q = [];
                      let r = this;
                      e.forEach((function(i) {
                          r.push(i);
                      }));
                  }
                  clear() {
                      this.q = [], this.i = this.j = 0;
                  }
                  push(e) {
                      let r = this.q.length;
                      if (this.j / r > .5 && this.j + this.i >= r && r > 4096) {
                          let i = this.i;
                          for (let n = 0; n < i; ++n) this.q[n] = this.q[this.j + n];
                          this.j = 0, this.q[this.i] = e;
                      } else this.q[this.j + this.i] = e;
                      return ++this.i;
                  }
                  pop() {
                      if (0 === this.i) return;
                      let e = this.q[this.j++];
                      return this.i -= 1, e;
                  }
                  front() {
                      if (0 !== this.i) return this.q[this.j];
                  }
              }, S1 = fa;
              Ln.default = S1;
          })), rp = M((Un => {
              v(), m(), _(), Object.defineProperty(Un, "t", {
                  value: !0
              }), Un.default = void 0;
              var A1 = lt(), ca = class extends A1.Base {
                  constructor(e = [], r = function(n, o) {
                      return n > o ? -1 : n < o ? 1 : 0;
                  }, i = !0) {
                      if (super(), this.v = r, Array.isArray(e)) this.C = i ? [ ...e ] : e; else {
                          this.C = [];
                          let o = this;
                          e.forEach((function(s) {
                              o.C.push(s);
                          }));
                      }
                      this.i = this.C.length;
                      let n = this.i >> 1;
                      for (let o = this.i - 1 >> 1; o >= 0; --o) this.k(o, n);
                  }
                  m(e) {
                      let r = this.C[e];
                      for (;e > 0; ) {
                          let i = e - 1 >> 1, n = this.C[i];
                          if (this.v(n, r) <= 0) break;
                          this.C[e] = n, e = i;
                      }
                      this.C[e] = r;
                  }
                  k(e, r) {
                      let i = this.C[e];
                      for (;e < r; ) {
                          let n = e << 1 | 1, o = n + 1, s = this.C[n];
                          if (o < this.i && this.v(s, this.C[o]) > 0 && (n = o, s = this.C[o]), this.v(s, i) >= 0) break;
                          this.C[e] = s, e = n;
                      }
                      this.C[e] = i;
                  }
                  clear() {
                      this.i = 0, this.C.length = 0;
                  }
                  push(e) {
                      this.C.push(e), this.m(this.i), this.i += 1;
                  }
                  pop() {
                      if (0 === this.i) return;
                      let e = this.C[0], r = this.C.pop();
                      return this.i -= 1, this.i && (this.C[0] = r, this.k(0, this.i >> 1)), e;
                  }
                  top() {
                      return this.C[0];
                  }
                  find(e) {
                      return this.C.indexOf(e) >= 0;
                  }
                  remove(e) {
                      let r = this.C.indexOf(e);
                      return !(r < 0) && (0 === r ? this.pop() : r === this.i - 1 ? (this.C.pop(), this.i -= 1) : (this.C.splice(r, 1, this.C.pop()), 
                      this.i -= 1, this.m(r), this.k(r, this.i >> 1)), !0);
                  }
                  updateItem(e) {
                      let r = this.C.indexOf(e);
                      return !(r < 0) && (this.m(r), this.k(r, this.i >> 1), !0);
                  }
                  toArray() {
                      return [ ...this.C ];
                  }
              }, I1 = ca;
              Un.default = I1;
          })), qn = M((Nn => {
              v(), m(), _(), Object.defineProperty(Nn, "t", {
                  value: !0
              }), Nn.default = void 0;
              var T1 = lt(), R1 = class extends T1.Container {};
              Nn.default = R1;
          })), ut = M((da => {
              v(), m(), _(), Object.defineProperty(da, "t", {
                  value: !0
              }), da.throwIteratorAccessError = function() {
                  throw new RangeError("Iterator access denied!");
              };
          })), ga = M((jn => {
              v(), m(), _(), Object.defineProperty(jn, "t", {
                  value: !0
              }), jn.RandomIterator = void 0;
              var B1 = lt(), Dn = ut(), pa = class extends B1.ContainerIterator {
                  constructor(e, r) {
                      super(r), this.o = e, 0 === this.iteratorType ? (this.pre = function() {
                          return 0 === this.o && (0, Dn.throwIteratorAccessError)(), this.o -= 1, this;
                      }, this.next = function() {
                          return this.o === this.container.size() && (0, Dn.throwIteratorAccessError)(), this.o += 1, 
                          this;
                      }) : (this.pre = function() {
                          return this.o === this.container.size() - 1 && (0, Dn.throwIteratorAccessError)(), 
                          this.o += 1, this;
                      }, this.next = function() {
                          return -1 === this.o && (0, Dn.throwIteratorAccessError)(), this.o -= 1, this;
                      });
                  }
                  get pointer() {
                      return this.container.getElementByPos(this.o);
                  }
                  set pointer(e) {
                      this.container.setElementByPos(this.o, e);
                  }
              };
              jn.RandomIterator = pa;
          })), ip = M((Fn => {
              v(), m(), _(), Object.defineProperty(Fn, "t", {
                  value: !0
              }), Fn.default = void 0;
              var t, P1 = (t = qn()) && t.t ? t : {
                  default: t
              }, O1 = ga();
              var wr = class t extends O1.RandomIterator {
                  constructor(e, r, i) {
                      super(e, i), this.container = r;
                  }
                  copy() {
                      return new t(this.o, this.container, this.iteratorType);
                  }
              }, ya = class extends P1.default {
                  constructor(e = [], r = !0) {
                      if (super(), Array.isArray(e)) this.J = r ? [ ...e ] : e, this.i = e.length; else {
                          this.J = [];
                          let i = this;
                          e.forEach((function(n) {
                              i.pushBack(n);
                          }));
                      }
                  }
                  clear() {
                      this.i = 0, this.J.length = 0;
                  }
                  begin() {
                      return new wr(0, this);
                  }
                  end() {
                      return new wr(this.i, this);
                  }
                  rBegin() {
                      return new wr(this.i - 1, this, 1);
                  }
                  rEnd() {
                      return new wr(-1, this, 1);
                  }
                  front() {
                      return this.J[0];
                  }
                  back() {
                      return this.J[this.i - 1];
                  }
                  getElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      return this.J[e];
                  }
                  eraseElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      return this.J.splice(e, 1), this.i -= 1, this.i;
                  }
                  eraseElementByValue(e) {
                      let r = 0;
                      for (let i = 0; i < this.i; ++i) this.J[i] !== e && (this.J[r++] = this.J[i]);
                      return this.i = this.J.length = r, this.i;
                  }
                  eraseElementByIterator(e) {
                      let r = e.o;
                      return e = e.next(), this.eraseElementByPos(r), e;
                  }
                  pushBack(e) {
                      return this.J.push(e), this.i += 1, this.i;
                  }
                  popBack() {
                      if (0 !== this.i) return this.i -= 1, this.J.pop();
                  }
                  setElementByPos(e, r) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      this.J[e] = r;
                  }
                  insert(e, r, i = 1) {
                      if (e < 0 || e > this.i) throw new RangeError;
                      return this.J.splice(e, 0, ...new Array(i).fill(r)), this.i += i, this.i;
                  }
                  find(e) {
                      for (let r = 0; r < this.i; ++r) if (this.J[r] === e) return new wr(r, this);
                      return this.end();
                  }
                  reverse() {
                      this.J.reverse();
                  }
                  unique() {
                      let e = 1;
                      for (let r = 1; r < this.i; ++r) this.J[r] !== this.J[r - 1] && (this.J[e++] = this.J[r]);
                      return this.i = this.J.length = e, this.i;
                  }
                  sort(e) {
                      this.J.sort(e);
                  }
                  forEach(e) {
                      for (let r = 0; r < this.i; ++r) e(this.J[r], r, this);
                  }
                  [Symbol.iterator]() {
                      return function*() {
                          yield* this.J;
                      }.bind(this)();
                  }
              }, x1 = ya;
              Fn.default = x1;
          })), np = M((Wn => {
              v(), m(), _(), Object.defineProperty(Wn, "t", {
                  value: !0
              }), Wn.default = void 0;
              var t, M1 = (t = qn()) && t.t ? t : {
                  default: t
              }, L1 = lt(), _r = ut();
              var mr = class t extends L1.ContainerIterator {
                  constructor(e, r, i, n) {
                      super(n), this.o = e, this.h = r, this.container = i, 0 === this.iteratorType ? (this.pre = function() {
                          return this.o.L === this.h && (0, _r.throwIteratorAccessError)(), this.o = this.o.L, 
                          this;
                      }, this.next = function() {
                          return this.o === this.h && (0, _r.throwIteratorAccessError)(), this.o = this.o.B, 
                          this;
                      }) : (this.pre = function() {
                          return this.o.B === this.h && (0, _r.throwIteratorAccessError)(), this.o = this.o.B, 
                          this;
                      }, this.next = function() {
                          return this.o === this.h && (0, _r.throwIteratorAccessError)(), this.o = this.o.L, 
                          this;
                      });
                  }
                  get pointer() {
                      return this.o === this.h && (0, _r.throwIteratorAccessError)(), this.o.l;
                  }
                  set pointer(e) {
                      this.o === this.h && (0, _r.throwIteratorAccessError)(), this.o.l = e;
                  }
                  copy() {
                      return new t(this.o, this.h, this.container, this.iteratorType);
                  }
              }, ba = class extends M1.default {
                  constructor(e = []) {
                      super(), this.h = {}, this.p = this._ = this.h.L = this.h.B = this.h;
                      let r = this;
                      e.forEach((function(i) {
                          r.pushBack(i);
                      }));
                  }
                  V(e) {
                      let {L: r, B: i} = e;
                      r.B = i, i.L = r, e === this.p && (this.p = i), e === this._ && (this._ = r), this.i -= 1;
                  }
                  G(e, r) {
                      let i = r.B, n = {
                          l: e,
                          L: r,
                          B: i
                      };
                      r.B = n, i.L = n, r === this.h && (this.p = n), i === this.h && (this._ = n), this.i += 1;
                  }
                  clear() {
                      this.i = 0, this.p = this._ = this.h.L = this.h.B = this.h;
                  }
                  begin() {
                      return new mr(this.p, this.h, this);
                  }
                  end() {
                      return new mr(this.h, this.h, this);
                  }
                  rBegin() {
                      return new mr(this._, this.h, this, 1);
                  }
                  rEnd() {
                      return new mr(this.h, this.h, this, 1);
                  }
                  front() {
                      return this.p.l;
                  }
                  back() {
                      return this._.l;
                  }
                  getElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r = this.p;
                      for (;e--; ) r = r.B;
                      return r.l;
                  }
                  eraseElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r = this.p;
                      for (;e--; ) r = r.B;
                      return this.V(r), this.i;
                  }
                  eraseElementByValue(e) {
                      let r = this.p;
                      for (;r !== this.h; ) r.l === e && this.V(r), r = r.B;
                      return this.i;
                  }
                  eraseElementByIterator(e) {
                      let r = e.o;
                      return r === this.h && (0, _r.throwIteratorAccessError)(), e = e.next(), this.V(r), 
                      e;
                  }
                  pushBack(e) {
                      return this.G(e, this._), this.i;
                  }
                  popBack() {
                      if (0 === this.i) return;
                      let e = this._.l;
                      return this.V(this._), e;
                  }
                  pushFront(e) {
                      return this.G(e, this.h), this.i;
                  }
                  popFront() {
                      if (0 === this.i) return;
                      let e = this.p.l;
                      return this.V(this.p), e;
                  }
                  setElementByPos(e, r) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let i = this.p;
                      for (;e--; ) i = i.B;
                      i.l = r;
                  }
                  insert(e, r, i = 1) {
                      if (e < 0 || e > this.i) throw new RangeError;
                      if (i <= 0) return this.i;
                      if (0 === e) for (;i--; ) this.pushFront(r); else if (e === this.i) for (;i--; ) this.pushBack(r); else {
                          let n = this.p;
                          for (let s = 1; s < e; ++s) n = n.B;
                          let o = n.B;
                          for (this.i += i; i--; ) n.B = {
                              l: r,
                              L: n
                          }, n.B.L = n, n = n.B;
                          n.B = o, o.L = n;
                      }
                      return this.i;
                  }
                  find(e) {
                      let r = this.p;
                      for (;r !== this.h; ) {
                          if (r.l === e) return new mr(r, this.h, this);
                          r = r.B;
                      }
                      return this.end();
                  }
                  reverse() {
                      if (this.i <= 1) return;
                      let e = this.p, r = this._, i = 0;
                      for (;i << 1 < this.i; ) {
                          let n = e.l;
                          e.l = r.l, r.l = n, e = e.B, r = r.L, i += 1;
                      }
                  }
                  unique() {
                      if (this.i <= 1) return this.i;
                      let e = this.p;
                      for (;e !== this.h; ) {
                          let r = e;
                          for (;r.B !== this.h && r.l === r.B.l; ) r = r.B, this.i -= 1;
                          e.B = r.B, e.B.L = e, e = e.B;
                      }
                      return this.i;
                  }
                  sort(e) {
                      if (this.i <= 1) return;
                      let r = [];
                      this.forEach((function(n) {
                          r.push(n);
                      })), r.sort(e);
                      let i = this.p;
                      r.forEach((function(n) {
                          i.l = n, i = i.B;
                      }));
                  }
                  merge(e) {
                      let r = this;
                      if (0 === this.i) e.forEach((function(i) {
                          r.pushBack(i);
                      })); else {
                          let i = this.p;
                          e.forEach((function(n) {
                              for (;i !== r.h && i.l <= n; ) i = i.B;
                              r.G(n, i.L);
                          }));
                      }
                      return this.i;
                  }
                  forEach(e) {
                      let r = this.p, i = 0;
                      for (;r !== this.h; ) e(r.l, i++, this), r = r.B;
                  }
                  [Symbol.iterator]() {
                      return function*() {
                          if (0 === this.i) return;
                          let e = this.p;
                          for (;e !== this.h; ) yield e.l, e = e.B;
                      }.bind(this)();
                  }
              }, N1 = ba;
              Wn.default = N1;
          })), sp = M(($n => {
              v(), m(), _(), Object.defineProperty($n, "t", {
                  value: !0
              }), $n.default = void 0;
              var t, q1 = (t = qn()) && t.t ? t : {
                  default: t
              }, D1 = ga();
              var vr = class t extends D1.RandomIterator {
                  constructor(e, r, i) {
                      super(e, i), this.container = r;
                  }
                  copy() {
                      return new t(this.o, this.container, this.iteratorType);
                  }
              }, wa = class extends q1.default {
                  constructor(e = [], r = 4096) {
                      super(), this.j = 0, this.D = 0, this.R = 0, this.N = 0, this.P = 0, this.A = [];
                      let i = (() => {
                          if ("number" == typeof e.length) return e.length;
                          if ("number" == typeof e.size) return e.size;
                          if ("function" == typeof e.size) return e.size();
                          throw new TypeError("Cannot get the length or size of the container");
                      })();
                      this.F = r, this.P = Math.max(Math.ceil(i / this.F), 1);
                      for (let s = 0; s < this.P; ++s) this.A.push(new Array(this.F));
                      let n = Math.ceil(i / this.F);
                      this.j = this.R = (this.P >> 1) - (n >> 1), this.D = this.N = this.F - i % this.F >> 1;
                      let o = this;
                      e.forEach((function(s) {
                          o.pushBack(s);
                      }));
                  }
                  T() {
                      let e = [], r = Math.max(this.P >> 1, 1);
                      for (let i = 0; i < r; ++i) e[i] = new Array(this.F);
                      for (let i = this.j; i < this.P; ++i) e[e.length] = this.A[i];
                      for (let i = 0; i < this.R; ++i) e[e.length] = this.A[i];
                      e[e.length] = [ ...this.A[this.R] ], this.j = r, this.R = e.length - 1;
                      for (let i = 0; i < r; ++i) e[e.length] = new Array(this.F);
                      this.A = e, this.P = e.length;
                  }
                  O(e) {
                      let r = this.D + e + 1, i = r % this.F, n = i - 1, o = this.j + (r - i) / this.F;
                      return 0 === i && (o -= 1), o %= this.P, n < 0 && (n += this.F), {
                          curNodeBucketIndex: o,
                          curNodePointerIndex: n
                      };
                  }
                  clear() {
                      this.A = [ new Array(this.F) ], this.P = 1, this.j = this.R = this.i = 0, this.D = this.N = this.F >> 1;
                  }
                  begin() {
                      return new vr(0, this);
                  }
                  end() {
                      return new vr(this.i, this);
                  }
                  rBegin() {
                      return new vr(this.i - 1, this, 1);
                  }
                  rEnd() {
                      return new vr(-1, this, 1);
                  }
                  front() {
                      if (0 !== this.i) return this.A[this.j][this.D];
                  }
                  back() {
                      if (0 !== this.i) return this.A[this.R][this.N];
                  }
                  pushBack(e) {
                      return this.i && (this.N < this.F - 1 ? this.N += 1 : this.R < this.P - 1 ? (this.R += 1, 
                      this.N = 0) : (this.R = 0, this.N = 0), this.R === this.j && this.N === this.D && this.T()), 
                      this.i += 1, this.A[this.R][this.N] = e, this.i;
                  }
                  popBack() {
                      if (0 === this.i) return;
                      let e = this.A[this.R][this.N];
                      return 1 !== this.i && (this.N > 0 ? this.N -= 1 : this.R > 0 ? (this.R -= 1, this.N = this.F - 1) : (this.R = this.P - 1, 
                      this.N = this.F - 1)), this.i -= 1, e;
                  }
                  pushFront(e) {
                      return this.i && (this.D > 0 ? this.D -= 1 : this.j > 0 ? (this.j -= 1, this.D = this.F - 1) : (this.j = this.P - 1, 
                      this.D = this.F - 1), this.j === this.R && this.D === this.N && this.T()), this.i += 1, 
                      this.A[this.j][this.D] = e, this.i;
                  }
                  popFront() {
                      if (0 === this.i) return;
                      let e = this.A[this.j][this.D];
                      return 1 !== this.i && (this.D < this.F - 1 ? this.D += 1 : this.j < this.P - 1 ? (this.j += 1, 
                      this.D = 0) : (this.j = 0, this.D = 0)), this.i -= 1, e;
                  }
                  getElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let {curNodeBucketIndex: r, curNodePointerIndex: i} = this.O(e);
                      return this.A[r][i];
                  }
                  setElementByPos(e, r) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let {curNodeBucketIndex: i, curNodePointerIndex: n} = this.O(e);
                      this.A[i][n] = r;
                  }
                  insert(e, r, i = 1) {
                      if (e < 0 || e > this.i) throw new RangeError;
                      if (0 === e) for (;i--; ) this.pushFront(r); else if (e === this.i) for (;i--; ) this.pushBack(r); else {
                          let n = [];
                          for (let o = e; o < this.i; ++o) n.push(this.getElementByPos(o));
                          this.cut(e - 1);
                          for (let o = 0; o < i; ++o) this.pushBack(r);
                          for (let o = 0; o < n.length; ++o) this.pushBack(n[o]);
                      }
                      return this.i;
                  }
                  cut(e) {
                      if (e < 0) return this.clear(), 0;
                      let {curNodeBucketIndex: r, curNodePointerIndex: i} = this.O(e);
                      return this.R = r, this.N = i, this.i = e + 1, this.i;
                  }
                  eraseElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      if (0 === e) this.popFront(); else if (e === this.i - 1) this.popBack(); else {
                          let r = [];
                          for (let n = e + 1; n < this.i; ++n) r.push(this.getElementByPos(n));
                          this.cut(e), this.popBack();
                          let i = this;
                          r.forEach((function(n) {
                              i.pushBack(n);
                          }));
                      }
                      return this.i;
                  }
                  eraseElementByValue(e) {
                      if (0 === this.i) return 0;
                      let r = [];
                      for (let n = 0; n < this.i; ++n) {
                          let o = this.getElementByPos(n);
                          o !== e && r.push(o);
                      }
                      let i = r.length;
                      for (let n = 0; n < i; ++n) this.setElementByPos(n, r[n]);
                      return this.cut(i - 1);
                  }
                  eraseElementByIterator(e) {
                      let r = e.o;
                      return this.eraseElementByPos(r), e = e.next();
                  }
                  find(e) {
                      for (let r = 0; r < this.i; ++r) if (this.getElementByPos(r) === e) return new vr(r, this);
                      return this.end();
                  }
                  reverse() {
                      let e = 0, r = this.i - 1;
                      for (;e < r; ) {
                          let i = this.getElementByPos(e);
                          this.setElementByPos(e, this.getElementByPos(r)), this.setElementByPos(r, i), e += 1, 
                          r -= 1;
                      }
                  }
                  unique() {
                      if (this.i <= 1) return this.i;
                      let e = 1, r = this.getElementByPos(0);
                      for (let i = 1; i < this.i; ++i) {
                          let n = this.getElementByPos(i);
                          n !== r && (r = n, this.setElementByPos(e++, n));
                      }
                      for (;this.i > e; ) this.popBack();
                      return this.i;
                  }
                  sort(e) {
                      let r = [];
                      for (let i = 0; i < this.i; ++i) r.push(this.getElementByPos(i));
                      r.sort(e);
                      for (let i = 0; i < this.i; ++i) this.setElementByPos(i, r[i]);
                  }
                  shrinkToFit() {
                      if (0 === this.i) return;
                      let e = [];
                      this.forEach((function(r) {
                          e.push(r);
                      })), this.P = Math.max(Math.ceil(this.i / this.F), 1), this.i = this.j = this.R = this.D = this.N = 0, 
                      this.A = [];
                      for (let r = 0; r < this.P; ++r) this.A.push(new Array(this.F));
                      for (let r = 0; r < e.length; ++r) this.pushBack(e[r]);
                  }
                  forEach(e) {
                      for (let r = 0; r < this.i; ++r) e(this.getElementByPos(r), r, this);
                  }
                  [Symbol.iterator]() {
                      return function*() {
                          for (let e = 0; e < this.i; ++e) yield this.getElementByPos(e);
                      }.bind(this)();
                  }
              }, F1 = wa;
              $n.default = F1;
          })), op = M((Zr => {
              v(), m(), _(), Object.defineProperty(Zr, "t", {
                  value: !0
              }), Zr.TreeNodeEnableIndex = Zr.TreeNode = void 0;
              var Hn = class {
                  constructor(e, r) {
                      this.ee = 1, this.u = void 0, this.l = void 0, this.U = void 0, this.W = void 0, 
                      this.tt = void 0, this.u = e, this.l = r;
                  }
                  L() {
                      let e = this;
                      if (1 === e.ee && e.tt.tt === e) e = e.W; else if (e.U) for (e = e.U; e.W; ) e = e.W; else {
                          let r = e.tt;
                          for (;r.U === e; ) e = r, r = e.tt;
                          e = r;
                      }
                      return e;
                  }
                  B() {
                      let e = this;
                      if (e.W) {
                          for (e = e.W; e.U; ) e = e.U;
                          return e;
                      }
                      {
                          let r = e.tt;
                          for (;r.W === e; ) e = r, r = e.tt;
                          return e.W !== r ? r : e;
                      }
                  }
                  te() {
                      let e = this.tt, r = this.W, i = r.U;
                      return e.tt === this ? e.tt = r : e.U === this ? e.U = r : e.W = r, r.tt = e, r.U = this, 
                      this.tt = r, this.W = i, i && (i.tt = this), r;
                  }
                  se() {
                      let e = this.tt, r = this.U, i = r.W;
                      return e.tt === this ? e.tt = r : e.U === this ? e.U = r : e.W = r, r.tt = e, r.W = this, 
                      this.tt = r, this.U = i, i && (i.tt = this), r;
                  }
              };
              Zr.TreeNode = Hn;
              Zr.TreeNodeEnableIndex = class extends Hn {
                  constructor() {
                      super(...arguments), this.rt = 1;
                  }
                  te() {
                      let e = super.te();
                      return this.ie(), e.ie(), e;
                  }
                  se() {
                      let e = super.se();
                      return this.ie(), e.ie(), e;
                  }
                  ie() {
                      this.rt = 1, this.U && (this.rt += this.U.rt), this.W && (this.rt += this.W.rt);
                  }
              };
          })), va = M((Vn => {
              v(), m(), _(), Object.defineProperty(Vn, "t", {
                  value: !0
              }), Vn.default = void 0;
              var ap = op(), W1 = lt(), lp = ut(), ma = class extends W1.Container {
                  constructor(e = function(i, n) {
                      return i < n ? -1 : i > n ? 1 : 0;
                  }, r = !1) {
                      super(), this.Y = void 0, this.v = e, r ? (this.re = ap.TreeNodeEnableIndex, this.M = function(i, n, o) {
                          let s = this.ne(i, n, o);
                          if (s) {
                              let a = s.tt;
                              for (;a !== this.h; ) a.rt += 1, a = a.tt;
                              let u = this.he(s);
                              if (u) {
                                  let {parentNode: c, grandParent: h, curNode: d} = u;
                                  c.ie(), h.ie(), d.ie();
                              }
                          }
                          return this.i;
                      }, this.V = function(i) {
                          let n = this.fe(i);
                          for (;n !== this.h; ) n.rt -= 1, n = n.tt;
                      }) : (this.re = ap.TreeNode, this.M = function(i, n, o) {
                          let s = this.ne(i, n, o);
                          return s && this.he(s), this.i;
                      }, this.V = this.fe), this.h = new this.re;
                  }
                  X(e, r) {
                      let i = this.h;
                      for (;e; ) {
                          let n = this.v(e.u, r);
                          if (n < 0) e = e.W; else {
                              if (!(n > 0)) return e;
                              i = e, e = e.U;
                          }
                      }
                      return i;
                  }
                  Z(e, r) {
                      let i = this.h;
                      for (;e; ) this.v(e.u, r) <= 0 ? e = e.W : (i = e, e = e.U);
                      return i;
                  }
                  $(e, r) {
                      let i = this.h;
                      for (;e; ) {
                          let n = this.v(e.u, r);
                          if (n < 0) i = e, e = e.W; else {
                              if (!(n > 0)) return e;
                              e = e.U;
                          }
                      }
                      return i;
                  }
                  rr(e, r) {
                      let i = this.h;
                      for (;e; ) this.v(e.u, r) < 0 ? (i = e, e = e.W) : e = e.U;
                      return i;
                  }
                  ue(e) {
                      for (;;) {
                          let r = e.tt;
                          if (r === this.h) return;
                          if (1 === e.ee) return void (e.ee = 0);
                          if (e === r.U) {
                              let i = r.W;
                              if (1 === i.ee) i.ee = 0, r.ee = 1, r === this.Y ? this.Y = r.te() : r.te(); else {
                                  if (i.W && 1 === i.W.ee) return i.ee = r.ee, r.ee = 0, i.W.ee = 0, void (r === this.Y ? this.Y = r.te() : r.te());
                                  i.U && 1 === i.U.ee ? (i.ee = 1, i.U.ee = 0, i.se()) : (i.ee = 1, e = r);
                              }
                          } else {
                              let i = r.U;
                              if (1 === i.ee) i.ee = 0, r.ee = 1, r === this.Y ? this.Y = r.se() : r.se(); else {
                                  if (i.U && 1 === i.U.ee) return i.ee = r.ee, r.ee = 0, i.U.ee = 0, void (r === this.Y ? this.Y = r.se() : r.se());
                                  i.W && 1 === i.W.ee ? (i.ee = 1, i.W.ee = 0, i.te()) : (i.ee = 1, e = r);
                              }
                          }
                      }
                  }
                  fe(e) {
                      if (1 === this.i) return this.clear(), this.h;
                      let r = e;
                      for (;r.U || r.W; ) {
                          if (r.W) for (r = r.W; r.U; ) r = r.U; else r = r.U;
                          [e.u, r.u] = [ r.u, e.u ], [e.l, r.l] = [ r.l, e.l ], e = r;
                      }
                      this.h.U === r ? this.h.U = r.tt : this.h.W === r && (this.h.W = r.tt), this.ue(r);
                      let i = r.tt;
                      return r === i.U ? i.U = void 0 : i.W = void 0, this.i -= 1, this.Y.ee = 0, i;
                  }
                  oe(e, r) {
                      return void 0 !== e && (!(!this.oe(e.U, r) && !r(e)) || this.oe(e.W, r));
                  }
                  he(e) {
                      for (;;) {
                          let r = e.tt;
                          if (0 === r.ee) return;
                          let i = r.tt;
                          if (r === i.U) {
                              let n = i.W;
                              if (n && 1 === n.ee) {
                                  if (n.ee = r.ee = 0, i === this.Y) return;
                                  i.ee = 1, e = i;
                                  continue;
                              }
                              if (e === r.W) {
                                  if (e.ee = 0, e.U && (e.U.tt = r), e.W && (e.W.tt = i), r.W = e.U, i.U = e.W, e.U = r, 
                                  e.W = i, i === this.Y) this.Y = e, this.h.tt = e; else {
                                      let o = i.tt;
                                      o.U === i ? o.U = e : o.W = e;
                                  }
                                  return e.tt = i.tt, r.tt = e, i.tt = e, i.ee = 1, {
                                      parentNode: r,
                                      grandParent: i,
                                      curNode: e
                                  };
                              }
                              r.ee = 0, i === this.Y ? this.Y = i.se() : i.se(), i.ee = 1;
                          } else {
                              let n = i.U;
                              if (n && 1 === n.ee) {
                                  if (n.ee = r.ee = 0, i === this.Y) return;
                                  i.ee = 1, e = i;
                                  continue;
                              }
                              if (e === r.U) {
                                  if (e.ee = 0, e.U && (e.U.tt = i), e.W && (e.W.tt = r), i.W = e.U, r.U = e.W, e.U = i, 
                                  e.W = r, i === this.Y) this.Y = e, this.h.tt = e; else {
                                      let o = i.tt;
                                      o.U === i ? o.U = e : o.W = e;
                                  }
                                  return e.tt = i.tt, r.tt = e, i.tt = e, i.ee = 1, {
                                      parentNode: r,
                                      grandParent: i,
                                      curNode: e
                                  };
                              }
                              r.ee = 0, i === this.Y ? this.Y = i.te() : i.te(), i.ee = 1;
                          }
                          return;
                      }
                  }
                  ne(e, r, i) {
                      if (void 0 === this.Y) return this.i += 1, this.Y = new this.re(e, r), this.Y.ee = 0, 
                      this.Y.tt = this.h, this.h.tt = this.Y, this.h.U = this.Y, void (this.h.W = this.Y);
                      let n, o = this.h.U, s = this.v(o.u, e);
                      if (0 !== s) {
                          if (s > 0) o.U = new this.re(e, r), o.U.tt = o, n = o.U, this.h.U = n; else {
                              let a = this.h.W, u = this.v(a.u, e);
                              if (0 === u) return void (a.l = r);
                              if (u < 0) a.W = new this.re(e, r), a.W.tt = a, n = a.W, this.h.W = n; else {
                                  if (void 0 !== i) {
                                      let c = i.o;
                                      if (c !== this.h) {
                                          let h = this.v(c.u, e);
                                          if (0 === h) return void (c.l = r);
                                          if (h > 0) {
                                              let d = c.L(), g = this.v(d.u, e);
                                              if (0 === g) return void (d.l = r);
                                              g < 0 && (n = new this.re(e, r), void 0 === d.W ? (d.W = n, n.tt = d) : (c.U = n, 
                                              n.tt = c));
                                          }
                                      }
                                  }
                                  if (void 0 === n) for (n = this.Y; ;) {
                                      let c = this.v(n.u, e);
                                      if (c > 0) {
                                          if (void 0 === n.U) {
                                              n.U = new this.re(e, r), n.U.tt = n, n = n.U;
                                              break;
                                          }
                                          n = n.U;
                                      } else {
                                          if (!(c < 0)) return void (n.l = r);
                                          if (void 0 === n.W) {
                                              n.W = new this.re(e, r), n.W.tt = n, n = n.W;
                                              break;
                                          }
                                          n = n.W;
                                      }
                                  }
                              }
                          }
                          return this.i += 1, n;
                      }
                      o.l = r;
                  }
                  I(e, r) {
                      for (;e; ) {
                          let i = this.v(e.u, r);
                          if (i < 0) e = e.W; else {
                              if (!(i > 0)) return e;
                              e = e.U;
                          }
                      }
                      return e || this.h;
                  }
                  clear() {
                      this.i = 0, this.Y = void 0, this.h.tt = void 0, this.h.U = this.h.W = void 0;
                  }
                  updateKeyByIterator(e, r) {
                      let i = e.o;
                      if (i === this.h && (0, lp.throwIteratorAccessError)(), 1 === this.i) return i.u = r, 
                      !0;
                      if (i === this.h.U) return this.v(i.B().u, r) > 0 && (i.u = r, !0);
                      if (i === this.h.W) return this.v(i.L().u, r) < 0 && (i.u = r, !0);
                      let n = i.L().u;
                      if (this.v(n, r) >= 0) return !1;
                      let o = i.B().u;
                      return !(this.v(o, r) <= 0) && (i.u = r, !0);
                  }
                  eraseElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r = 0, i = this;
                      return this.oe(this.Y, (function(n) {
                          return e === r ? (i.V(n), !0) : (r += 1, !1);
                      })), this.i;
                  }
                  eraseElementByKey(e) {
                      if (0 === this.i) return !1;
                      let r = this.I(this.Y, e);
                      return r !== this.h && (this.V(r), !0);
                  }
                  eraseElementByIterator(e) {
                      let r = e.o;
                      r === this.h && (0, lp.throwIteratorAccessError)();
                      let i = void 0 === r.W;
                      return 0 === e.iteratorType ? i && e.next() : (!i || void 0 === r.U) && e.next(), 
                      this.V(r), e;
                  }
                  forEach(e) {
                      let r = 0;
                      for (let i of this) e(i, r++, this);
                  }
                  getElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r, i = 0;
                      for (let n of this) {
                          if (i === e) {
                              r = n;
                              break;
                          }
                          i += 1;
                      }
                      return r;
                  }
                  getHeight() {
                      if (0 === this.i) return 0;
                      let e = function(r) {
                          return r ? Math.max(e(r.U), e(r.W)) + 1 : 0;
                      };
                      return e(this.Y);
                  }
              }, $1 = ma;
              Vn.default = $1;
          })), Sa = M((Kn => {
              v(), m(), _(), Object.defineProperty(Kn, "t", {
                  value: !0
              }), Kn.default = void 0;
              var H1 = lt(), zn = ut(), Ea = class extends H1.ContainerIterator {
                  constructor(e, r, i) {
                      super(i), this.o = e, this.h = r, 0 === this.iteratorType ? (this.pre = function() {
                          return this.o === this.h.U && (0, zn.throwIteratorAccessError)(), this.o = this.o.L(), 
                          this;
                      }, this.next = function() {
                          return this.o === this.h && (0, zn.throwIteratorAccessError)(), this.o = this.o.B(), 
                          this;
                      }) : (this.pre = function() {
                          return this.o === this.h.W && (0, zn.throwIteratorAccessError)(), this.o = this.o.B(), 
                          this;
                      }, this.next = function() {
                          return this.o === this.h && (0, zn.throwIteratorAccessError)(), this.o = this.o.L(), 
                          this;
                      });
                  }
                  get index() {
                      let e = this.o, r = this.h.tt;
                      if (e === this.h) return r ? r.rt - 1 : 0;
                      let i = 0;
                      for (e.U && (i += e.U.rt); e !== r; ) {
                          let n = e.tt;
                          e === n.W && (i += 1, n.U && (i += n.U.rt)), e = n;
                      }
                      return i;
                  }
              }, V1 = Ea;
              Kn.default = V1;
          })), fp = M((Gn => {
              v(), m(), _(), Object.defineProperty(Gn, "t", {
                  value: !0
              }), Gn.default = void 0;
              var z1 = up(va()), K1 = up(Sa()), G1 = ut();
              function up(t) {
                  return t && t.t ? t : {
                      default: t
                  };
              }
              var Ke = class t extends K1.default {
                  constructor(e, r, i, n) {
                      super(e, r, n), this.container = i;
                  }
                  get pointer() {
                      return this.o === this.h && (0, G1.throwIteratorAccessError)(), this.o.u;
                  }
                  copy() {
                      return new t(this.o, this.h, this.container, this.iteratorType);
                  }
              }, Aa = class extends z1.default {
                  constructor(e = [], r, i) {
                      super(r, i);
                      let n = this;
                      e.forEach((function(o) {
                          n.insert(o);
                      }));
                  }
                  * K(e) {
                      void 0 !== e && (yield* this.K(e.U), yield e.u, yield* this.K(e.W));
                  }
                  begin() {
                      return new Ke(this.h.U || this.h, this.h, this);
                  }
                  end() {
                      return new Ke(this.h, this.h, this);
                  }
                  rBegin() {
                      return new Ke(this.h.W || this.h, this.h, this, 1);
                  }
                  rEnd() {
                      return new Ke(this.h, this.h, this, 1);
                  }
                  front() {
                      return this.h.U ? this.h.U.u : void 0;
                  }
                  back() {
                      return this.h.W ? this.h.W.u : void 0;
                  }
                  insert(e, r) {
                      return this.M(e, void 0, r);
                  }
                  find(e) {
                      let r = this.I(this.Y, e);
                      return new Ke(r, this.h, this);
                  }
                  lowerBound(e) {
                      let r = this.X(this.Y, e);
                      return new Ke(r, this.h, this);
                  }
                  upperBound(e) {
                      let r = this.Z(this.Y, e);
                      return new Ke(r, this.h, this);
                  }
                  reverseLowerBound(e) {
                      let r = this.$(this.Y, e);
                      return new Ke(r, this.h, this);
                  }
                  reverseUpperBound(e) {
                      let r = this.rr(this.Y, e);
                      return new Ke(r, this.h, this);
                  }
                  union(e) {
                      let r = this;
                      return e.forEach((function(i) {
                          r.insert(i);
                      })), this.i;
                  }
                  [Symbol.iterator]() {
                      return this.K(this.Y);
                  }
              }, Q1 = Aa;
              Gn.default = Q1;
          })), hp = M((Qn => {
              v(), m(), _(), Object.defineProperty(Qn, "t", {
                  value: !0
              }), Qn.default = void 0;
              var Y1 = cp(va()), J1 = cp(Sa()), X1 = ut();
              function cp(t) {
                  return t && t.t ? t : {
                      default: t
                  };
              }
              var Ge = class t extends J1.default {
                  constructor(e, r, i, n) {
                      super(e, r, n), this.container = i;
                  }
                  get pointer() {
                      this.o === this.h && (0, X1.throwIteratorAccessError)();
                      let e = this;
                      return new Proxy([], {
                          get: (r, i) => "0" === i ? e.o.u : "1" === i ? e.o.l : void 0,
                          set(r, i, n) {
                              if ("1" !== i) throw new TypeError("props must be 1");
                              return e.o.l = n, !0;
                          }
                      });
                  }
                  copy() {
                      return new t(this.o, this.h, this.container, this.iteratorType);
                  }
              }, Ia = class extends Y1.default {
                  constructor(e = [], r, i) {
                      super(r, i);
                      let n = this;
                      e.forEach((function(o) {
                          n.setElement(o[0], o[1]);
                      }));
                  }
                  * K(e) {
                      void 0 !== e && (yield* this.K(e.U), yield [ e.u, e.l ], yield* this.K(e.W));
                  }
                  begin() {
                      return new Ge(this.h.U || this.h, this.h, this);
                  }
                  end() {
                      return new Ge(this.h, this.h, this);
                  }
                  rBegin() {
                      return new Ge(this.h.W || this.h, this.h, this, 1);
                  }
                  rEnd() {
                      return new Ge(this.h, this.h, this, 1);
                  }
                  front() {
                      if (0 === this.i) return;
                      let e = this.h.U;
                      return [ e.u, e.l ];
                  }
                  back() {
                      if (0 === this.i) return;
                      let e = this.h.W;
                      return [ e.u, e.l ];
                  }
                  lowerBound(e) {
                      let r = this.X(this.Y, e);
                      return new Ge(r, this.h, this);
                  }
                  upperBound(e) {
                      let r = this.Z(this.Y, e);
                      return new Ge(r, this.h, this);
                  }
                  reverseLowerBound(e) {
                      let r = this.$(this.Y, e);
                      return new Ge(r, this.h, this);
                  }
                  reverseUpperBound(e) {
                      let r = this.rr(this.Y, e);
                      return new Ge(r, this.h, this);
                  }
                  setElement(e, r, i) {
                      return this.M(e, r, i);
                  }
                  find(e) {
                      let r = this.I(this.Y, e);
                      return new Ge(r, this.h, this);
                  }
                  getElementByKey(e) {
                      return this.I(this.Y, e).l;
                  }
                  union(e) {
                      let r = this;
                      return e.forEach((function(i) {
                          r.setElement(i[0], i[1]);
                      })), this.i;
                  }
                  [Symbol.iterator]() {
                      return this.K(this.Y);
                  }
              }, Z1 = Ia;
              Qn.default = Z1;
          })), Ra = M((Ta => {
              v(), m(), _(), Object.defineProperty(Ta, "t", {
                  value: !0
              }), Ta.default = function(t) {
                  let e = typeof t;
                  return "object" === e && null !== t || "function" === e;
              };
          })), Oa = M((ei => {
              v(), m(), _(), Object.defineProperty(ei, "t", {
                  value: !0
              }), ei.HashContainerIterator = ei.HashContainer = void 0;
              var t, dp = lt(), Ca = (t = Ra()) && t.t ? t : {
                  default: t
              }, Ti = ut();
              var Ba = class extends dp.ContainerIterator {
                  constructor(e, r, i) {
                      super(i), this.o = e, this.h = r, 0 === this.iteratorType ? (this.pre = function() {
                          return this.o.L === this.h && (0, Ti.throwIteratorAccessError)(), this.o = this.o.L, 
                          this;
                      }, this.next = function() {
                          return this.o === this.h && (0, Ti.throwIteratorAccessError)(), this.o = this.o.B, 
                          this;
                      }) : (this.pre = function() {
                          return this.o.B === this.h && (0, Ti.throwIteratorAccessError)(), this.o = this.o.B, 
                          this;
                      }, this.next = function() {
                          return this.o === this.h && (0, Ti.throwIteratorAccessError)(), this.o = this.o.L, 
                          this;
                      });
                  }
              };
              ei.HashContainerIterator = Ba;
              var Pa = class extends dp.Container {
                  constructor() {
                      super(), this.H = [], this.g = {}, this.HASH_TAG = Symbol("@@HASH_TAG"), Object.setPrototypeOf(this.g, null), 
                      this.h = {}, this.h.L = this.h.B = this.p = this._ = this.h;
                  }
                  V(e) {
                      let {L: r, B: i} = e;
                      r.B = i, i.L = r, e === this.p && (this.p = i), e === this._ && (this._ = r), this.i -= 1;
                  }
                  M(e, r, i) {
                      let n;
                      if (void 0 === i && (i = (0, Ca.default)(e)), i) {
                          let o = e[this.HASH_TAG];
                          if (void 0 !== o) return this.H[o].l = r, this.i;
                          Object.defineProperty(e, this.HASH_TAG, {
                              value: this.H.length,
                              configurable: !0
                          }), n = {
                              u: e,
                              l: r,
                              L: this._,
                              B: this.h
                          }, this.H.push(n);
                      } else {
                          let o = this.g[e];
                          if (o) return o.l = r, this.i;
                          n = {
                              u: e,
                              l: r,
                              L: this._,
                              B: this.h
                          }, this.g[e] = n;
                      }
                      return 0 === this.i ? (this.p = n, this.h.B = n) : this._.B = n, this._ = n, this.h.L = n, 
                      ++this.i;
                  }
                  I(e, r) {
                      if (void 0 === r && (r = (0, Ca.default)(e)), r) {
                          let i = e[this.HASH_TAG];
                          return void 0 === i ? this.h : this.H[i];
                      }
                      return this.g[e] || this.h;
                  }
                  clear() {
                      let e = this.HASH_TAG;
                      this.H.forEach((function(r) {
                          delete r.u[e];
                      })), this.H = [], this.g = {}, Object.setPrototypeOf(this.g, null), this.i = 0, 
                      this.p = this._ = this.h.L = this.h.B = this.h;
                  }
                  eraseElementByKey(e, r) {
                      let i;
                      if (void 0 === r && (r = (0, Ca.default)(e)), r) {
                          let n = e[this.HASH_TAG];
                          if (void 0 === n) return !1;
                          delete e[this.HASH_TAG], i = this.H[n], delete this.H[n];
                      } else {
                          if (i = this.g[e], void 0 === i) return !1;
                          delete this.g[e];
                      }
                      return this.V(i), !0;
                  }
                  eraseElementByIterator(e) {
                      let r = e.o;
                      return r === this.h && (0, Ti.throwIteratorAccessError)(), this.V(r), e.next();
                  }
                  eraseElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r = this.p;
                      for (;e--; ) r = r.B;
                      return this.V(r), this.i;
                  }
              };
              ei.HashContainer = Pa;
          })), gp = M((Yn => {
              v(), m(), _(), Object.defineProperty(Yn, "t", {
                  value: !0
              }), Yn.default = void 0;
              var pp = Oa(), rv = ut(), Er = class t extends pp.HashContainerIterator {
                  constructor(e, r, i, n) {
                      super(e, r, n), this.container = i;
                  }
                  get pointer() {
                      return this.o === this.h && (0, rv.throwIteratorAccessError)(), this.o.u;
                  }
                  copy() {
                      return new t(this.o, this.h, this.container, this.iteratorType);
                  }
              }, ka = class extends pp.HashContainer {
                  constructor(e = []) {
                      super();
                      let r = this;
                      e.forEach((function(i) {
                          r.insert(i);
                      }));
                  }
                  begin() {
                      return new Er(this.p, this.h, this);
                  }
                  end() {
                      return new Er(this.h, this.h, this);
                  }
                  rBegin() {
                      return new Er(this._, this.h, this, 1);
                  }
                  rEnd() {
                      return new Er(this.h, this.h, this, 1);
                  }
                  front() {
                      return this.p.u;
                  }
                  back() {
                      return this._.u;
                  }
                  insert(e, r) {
                      return this.M(e, void 0, r);
                  }
                  getElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r = this.p;
                      for (;e--; ) r = r.B;
                      return r.u;
                  }
                  find(e, r) {
                      let i = this.I(e, r);
                      return new Er(i, this.h, this);
                  }
                  forEach(e) {
                      let r = 0, i = this.p;
                      for (;i !== this.h; ) e(i.u, r++, this), i = i.B;
                  }
                  [Symbol.iterator]() {
                      return function*() {
                          let e = this.p;
                          for (;e !== this.h; ) yield e.u, e = e.B;
                      }.bind(this)();
                  }
              }, iv = ka;
              Yn.default = iv;
          })), bp = M((Jn => {
              v(), m(), _(), Object.defineProperty(Jn, "t", {
                  value: !0
              }), Jn.default = void 0;
              var t, yp = Oa(), nv = (t = Ra()) && t.t ? t : {
                  default: t
              }, sv = ut();
              var Sr = class t extends yp.HashContainerIterator {
                  constructor(e, r, i, n) {
                      super(e, r, n), this.container = i;
                  }
                  get pointer() {
                      this.o === this.h && (0, sv.throwIteratorAccessError)();
                      let e = this;
                      return new Proxy([], {
                          get: (r, i) => "0" === i ? e.o.u : "1" === i ? e.o.l : void 0,
                          set(r, i, n) {
                              if ("1" !== i) throw new TypeError("props must be 1");
                              return e.o.l = n, !0;
                          }
                      });
                  }
                  copy() {
                      return new t(this.o, this.h, this.container, this.iteratorType);
                  }
              }, xa = class extends yp.HashContainer {
                  constructor(e = []) {
                      super();
                      let r = this;
                      e.forEach((function(i) {
                          r.setElement(i[0], i[1]);
                      }));
                  }
                  begin() {
                      return new Sr(this.p, this.h, this);
                  }
                  end() {
                      return new Sr(this.h, this.h, this);
                  }
                  rBegin() {
                      return new Sr(this._, this.h, this, 1);
                  }
                  rEnd() {
                      return new Sr(this.h, this.h, this, 1);
                  }
                  front() {
                      if (0 !== this.i) return [ this.p.u, this.p.l ];
                  }
                  back() {
                      if (0 !== this.i) return [ this._.u, this._.l ];
                  }
                  setElement(e, r, i) {
                      return this.M(e, r, i);
                  }
                  getElementByKey(e, r) {
                      if (void 0 === r && (r = (0, nv.default)(e)), r) {
                          let n = e[this.HASH_TAG];
                          return void 0 !== n ? this.H[n].l : void 0;
                      }
                      let i = this.g[e];
                      return i ? i.l : void 0;
                  }
                  getElementByPos(e) {
                      if (e < 0 || e > this.i - 1) throw new RangeError;
                      let r = this.p;
                      for (;e--; ) r = r.B;
                      return [ r.u, r.l ];
                  }
                  find(e, r) {
                      let i = this.I(e, r);
                      return new Sr(i, this.h, this);
                  }
                  forEach(e) {
                      let r = 0, i = this.p;
                      for (;i !== this.h; ) e([ i.u, i.l ], r++, this), i = i.B;
                  }
                  [Symbol.iterator]() {
                      return function*() {
                          let e = this.p;
                          for (;e !== this.h; ) yield [ e.u, e.l ], e = e.B;
                      }.bind(this)();
                  }
              }, av = xa;
              Jn.default = av;
          })), wp = M((je => {
              v(), m(), _(), Object.defineProperty(je, "t", {
                  value: !0
              }), Object.defineProperty(je, "Deque", {
                  enumerable: !0,
                  get: function() {
                      return dv.default;
                  }
              }), Object.defineProperty(je, "HashMap", {
                  enumerable: !0,
                  get: function() {
                      return bv.default;
                  }
              }), Object.defineProperty(je, "HashSet", {
                  enumerable: !0,
                  get: function() {
                      return yv.default;
                  }
              }), Object.defineProperty(je, "LinkList", {
                  enumerable: !0,
                  get: function() {
                      return hv.default;
                  }
              }), Object.defineProperty(je, "OrderedMap", {
                  enumerable: !0,
                  get: function() {
                      return gv.default;
                  }
              }), Object.defineProperty(je, "OrderedSet", {
                  enumerable: !0,
                  get: function() {
                      return pv.default;
                  }
              }), Object.defineProperty(je, "PriorityQueue", {
                  enumerable: !0,
                  get: function() {
                      return fv.default;
                  }
              }), Object.defineProperty(je, "Queue", {
                  enumerable: !0,
                  get: function() {
                      return uv.default;
                  }
              }), Object.defineProperty(je, "Stack", {
                  enumerable: !0,
                  get: function() {
                      return lv.default;
                  }
              }), Object.defineProperty(je, "Vector", {
                  enumerable: !0,
                  get: function() {
                      return cv.default;
                  }
              });
              var lv = ft(ep()), uv = ft(tp()), fv = ft(rp()), cv = ft(ip()), hv = ft(np()), dv = ft(sp()), pv = ft(fp()), gv = ft(hp()), yv = ft(gp()), bv = ft(bp());
              function ft(t) {
                  return t && t.t ? t : {
                      default: t
                  };
              }
          })), mp = M(((SN, _p) => {
              v(), m(), _();
              var wv = wp().OrderedSet, ct = ot()("number-allocator:trace"), _v = ot()("number-allocator:error");
              function Te(t, e) {
                  this.low = t, this.high = e;
              }
              function ht(t, e) {
                  if (!(this instanceof ht)) return new ht(t, e);
                  this.min = t, this.max = e, this.ss = new wv([], ((r, i) => r.compare(i))), ct("Create"), 
                  this.clear();
              }
              Te.prototype.equals = function(t) {
                  return this.low === t.low && this.high === t.high;
              }, Te.prototype.compare = function(t) {
                  return this.low < t.low && this.high < t.low ? -1 : t.low < this.low && t.high < this.low ? 1 : 0;
              }, ht.prototype.firstVacant = function() {
                  return 0 === this.ss.size() ? null : this.ss.front().low;
              }, ht.prototype.alloc = function() {
                  if (0 === this.ss.size()) return ct("alloc():empty"), null;
                  let t = this.ss.begin(), e = t.pointer.low, r = t.pointer.high, i = e;
                  return i + 1 <= r ? this.ss.updateKeyByIterator(t, new Te(e + 1, r)) : this.ss.eraseElementByPos(0), 
                  ct("alloc():" + i), i;
              }, ht.prototype.use = function(t) {
                  let e = new Te(t, t), r = this.ss.lowerBound(e);
                  if (!r.equals(this.ss.end())) {
                      let i = r.pointer.low, n = r.pointer.high;
                      return r.pointer.equals(e) ? (this.ss.eraseElementByIterator(r), ct("use():" + t), 
                      !0) : !(i > t) && (i === t ? (this.ss.updateKeyByIterator(r, new Te(i + 1, n)), 
                      ct("use():" + t), !0) : n === t ? (this.ss.updateKeyByIterator(r, new Te(i, n - 1)), 
                      ct("use():" + t), !0) : (this.ss.updateKeyByIterator(r, new Te(t + 1, n)), this.ss.insert(new Te(i, t - 1)), 
                      ct("use():" + t), !0));
                  }
                  return ct("use():failed"), !1;
              }, ht.prototype.free = function(t) {
                  if (t < this.min || t > this.max) return void _v("free():" + t + " is out of range");
                  let e = new Te(t, t), r = this.ss.upperBound(e);
                  if (r.equals(this.ss.end())) {
                      if (r.equals(this.ss.begin())) return void this.ss.insert(e);
                      r.pre();
                      let i = r.pointer.high;
                      r.pointer.high + 1 === t ? this.ss.updateKeyByIterator(r, new Te(i, t)) : this.ss.insert(e);
                  } else if (r.equals(this.ss.begin())) if (t + 1 === r.pointer.low) {
                      let i = r.pointer.high;
                      this.ss.updateKeyByIterator(r, new Te(t, i));
                  } else this.ss.insert(e); else {
                      let i = r.pointer.low, n = r.pointer.high;
                      r.pre();
                      let o = r.pointer.low;
                      r.pointer.high + 1 === t ? t + 1 === i ? (this.ss.eraseElementByIterator(r), this.ss.updateKeyByIterator(r, new Te(o, n))) : this.ss.updateKeyByIterator(r, new Te(o, t)) : t + 1 === i ? (this.ss.eraseElementByIterator(r.next()), 
                      this.ss.insert(new Te(t, n))) : this.ss.insert(e);
                  }
                  ct("free():" + t);
              }, ht.prototype.clear = function() {
                  ct("clear()"), this.ss.clear(), this.ss.insert(new Te(this.min, this.max));
              }, ht.prototype.intervalCount = function() {
                  return this.ss.size();
              }, ht.prototype.dump = function() {
                  console.log("length:" + this.ss.size());
                  for (let t of this.ss) console.log(t);
              }, _p.exports = ht;
          })), Ma = M(((xN, vp) => {
              v(), m(), _();
              var mv = mp();
              vp.exports.NumberAllocator = mv;
          })), Ep = M((Ua => {
              v(), m(), _(), Object.defineProperty(Ua, "__esModule", {
                  value: !0
              });
              var vv = Zd(), Ev = Ma();
              Ua.default = class {
                  constructor(e) {
                      e > 0 && (this.aliasToTopic = new vv.LRUCache({
                          max: e
                      }), this.topicToAlias = {}, this.numberAllocator = new Ev.NumberAllocator(1, e), 
                      this.max = e, this.length = 0);
                  }
                  put(e, r) {
                      if (0 === r || r > this.max) return !1;
                      let i = this.aliasToTopic.get(r);
                      return i && delete this.topicToAlias[i], this.aliasToTopic.set(r, e), this.topicToAlias[e] = r, 
                      this.numberAllocator.use(r), this.length = this.aliasToTopic.size, !0;
                  }
                  getTopicByAlias(e) {
                      return this.aliasToTopic.get(e);
                  }
                  getAliasByTopic(e) {
                      let r = this.topicToAlias[e];
                      return typeof r < "u" && this.aliasToTopic.get(r), r;
                  }
                  clear() {
                      this.aliasToTopic.clear(), this.topicToAlias = {}, this.numberAllocator.clear(), 
                      this.length = 0;
                  }
                  getLruAlias() {
                      return this.numberAllocator.firstVacant() || [ ...this.aliasToTopic.keys() ][this.aliasToTopic.size - 1];
                  }
              };
          })), Sp = M((Ri => {
              v(), m(), _();
              var Sv = Ri && Ri.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Ri, "__esModule", {
                  value: !0
              });
              var Av = Ai(), Iv = Sv(Ep()), Tv = Jr();
              Ri.default = (t, e) => {
                  t.log("_handleConnack");
                  let {options: r} = t, n = 5 === r.protocolVersion ? e.reasonCode : e.returnCode;
                  if (clearTimeout(t.connackTimer), delete t.topicAliasSend, e.properties) {
                      if (e.properties.topicAliasMaximum) {
                          if (e.properties.topicAliasMaximum > 65535) return void t.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                          e.properties.topicAliasMaximum > 0 && (t.topicAliasSend = new Iv.default(e.properties.topicAliasMaximum));
                      }
                      e.properties.serverKeepAlive && r.keepalive && (r.keepalive = e.properties.serverKeepAlive, 
                      t._shiftPingInterval()), e.properties.maximumPacketSize && (r.properties || (r.properties = {}), 
                      r.properties.maximumPacketSize = e.properties.maximumPacketSize);
                  }
                  if (0 === n) t.reconnecting = !1, t._onConnect(e); else if (n > 0) {
                      let o = new Tv.ErrorWithReasonCode(`Connection refused: ${Av.ReasonCodes[n]}`, n);
                      t.emit("error", o);
                  }
              };
          })), Ap = M((Na => {
              v(), m(), _(), Object.defineProperty(Na, "__esModule", {
                  value: !0
              });
              Na.default = (t, e, r) => {
                  t.log("handling pubrel packet");
                  let i = typeof r < "u" ? r : t.noop, {messageId: n} = e, o = {
                      cmd: "pubcomp",
                      messageId: n
                  };
                  t.incomingStore.get(e, ((s, a) => {
                      s ? t._sendPacket(o, i) : (t.emit("message", a.topic, a.payload, a), t.handleMessage(a, (u => {
                          if (u) return i(u);
                          t.incomingStore.del(a, t.noop), t._sendPacket(o, i);
                      })));
                  }));
              };
          })), Ip = M((Ci => {
              v(), m(), _();
              var Bi = Ci && Ci.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Ci, "__esModule", {
                  value: !0
              });
              var Bv = Bi(Vd()), Pv = Bi(Gd()), Ov = Bi(Sp()), kv = Bi(Ai()), xv = Bi(Ap());
              Ci.default = (t, e, r) => {
                  let {options: i} = t;
                  if (5 === i.protocolVersion && i.properties && i.properties.maximumPacketSize && i.properties.maximumPacketSize < e.length) return t.emit("error", new Error(`exceeding packets size ${e.cmd}`)), 
                  t.end({
                      reasonCode: 149,
                      properties: {
                          reasonString: "Maximum packet size was exceeded"
                      }
                  }), t;
                  switch (t.log("_handlePacket :: emitting packetreceive"), t.emit("packetreceive", e), 
                  e.cmd) {
                    case "publish":
                      (0, Bv.default)(t, e, r);
                      break;

                    case "puback":
                    case "pubrec":
                    case "pubcomp":
                    case "suback":
                    case "unsuback":
                      (0, kv.default)(t, e), r();
                      break;

                    case "pubrel":
                      (0, xv.default)(t, e, r);
                      break;

                    case "connack":
                      (0, Ov.default)(t, e), r();
                      break;

                    case "auth":
                      (0, Pv.default)(t, e), r();
                      break;

                    case "pingresp":
                      t.pingResp = !0, r();
                      break;

                    case "disconnect":
                      t.emit("disconnect", e), r();
                      break;

                    default:
                      t.log("_handlePacket :: unknown command"), r();
                  }
              };
          })), Tp = M((ti => {
              v(), m(), _();
              var Lv = ti && ti.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(ti, "__esModule", {
                  value: !0
              }), ti.TypedEventEmitter = void 0;
              var Uv = Lv((ir(), X(rr))), Nv = Jr(), Xn = class {};
              ti.TypedEventEmitter = Xn, (0, Nv.applyMixin)(Xn, Uv.default);
          })), Pi = M((Ar => {
              v(), m(), _(), Object.defineProperty(Ar, "__esModule", {
                  value: !0
              }), Ar.isReactNativeBrowser = Ar.isWebWorker = void 0;
              var Rp = () => {
                  var t, e;
                  return !("object" != typeof self || null === (e = null === (t = self?.constructor) || void 0 === t ? void 0 : t.name) || void 0 === e || !e.includes("WorkerGlobalScope"));
              }, Cp = () => typeof B < "u" && "ReactNative" === B.product, Dv = typeof window < "u" && typeof window.document < "u" || Rp() || Cp();
              Ar.isWebWorker = Rp(), Ar.isReactNativeBrowser = Cp(), Ar.default = Dv;
          })), Pp = M(((Zn, Bp) => {
              var t, e;
              v(), m(), _(), t = Zn, e = function(t) {
                  var g, i = void 0 === Number.MAX_SAFE_INTEGER ? 9007199254740991 : Number.MAX_SAFE_INTEGER, n = 536870912, o = 2 * n, a = new WeakMap, c = function(g, y) {
                      return function(w) {
                          var E = y.get(w), S = void 0 === E ? w.size : E < o ? E + 1 : 0;
                          if (!w.has(S)) return g(w, S);
                          if (w.size < n) {
                              for (;w.has(S); ) S = Math.floor(Math.random() * o);
                              return g(w, S);
                          }
                          if (w.size > i) throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
                          for (;w.has(S); ) S = Math.floor(Math.random() * i);
                          return g(w, S);
                      };
                  }((g = a, function(y, w) {
                      return g.set(y, w), w;
                  }), a), h = function(g) {
                      return function(y) {
                          var w = g(y);
                          return y.add(w), w;
                      };
                  }(c);
                  t.addUniqueNumber = h, t.generateUniqueNumber = c;
              }, "object" == typeof Zn && typeof Bp < "u" ? e(Zn) : "function" == typeof define && __webpack_require__.amdO ? define([ "exports" ], e) : e((t = typeof globalThis < "u" ? globalThis : t || self).fastUniqueNumbers = {});
          })), kp = M(((es, Op) => {
              var t, e;
              v(), m(), _(), t = es, e = function(t, e) {
                  t.load = function(s) {
                      var a = new Map([ [ 0, function() {} ] ]), u = new Map([ [ 0, function() {} ] ]), c = new Map, h = new Worker(s);
                      return h.addEventListener("message", (function(E) {
                          var S = E.data;
                          if (function(s) {
                              return void 0 !== s.method && "call" === s.method;
                          }(S)) {
                              var I = S.params, C = I.timerId, R = I.timerType;
                              if ("interval" === R) {
                                  var U = a.get(C);
                                  if ("number" == typeof U) {
                                      var N = c.get(U);
                                      if (void 0 === N || N.timerId !== C || N.timerType !== R) throw new Error("The timer is in an undefined state.");
                                  } else {
                                      if (!(typeof U < "u")) throw new Error("The timer is in an undefined state.");
                                      U();
                                  }
                              } else if ("timeout" === R) {
                                  var W = u.get(C);
                                  if ("number" == typeof W) {
                                      var K = c.get(W);
                                      if (void 0 === K || K.timerId !== C || K.timerType !== R) throw new Error("The timer is in an undefined state.");
                                  } else {
                                      if (!(typeof W < "u")) throw new Error("The timer is in an undefined state.");
                                      W(), u.delete(C);
                                  }
                              }
                          } else {
                              if (!function(s) {
                                  return null === s.error && "number" == typeof s.id;
                              }(S)) {
                                  var pe = S.error.message;
                                  throw new Error(pe);
                              }
                              var z = S.id, Q = c.get(z);
                              if (void 0 === Q) throw new Error("The timer is in an undefined state.");
                              var de = Q.timerId, Gt = Q.timerType;
                              c.delete(z), "interval" === Gt ? a.delete(de) : u.delete(de);
                          }
                      })), {
                          clearInterval: function(S) {
                              var I = e.generateUniqueNumber(c);
                              c.set(I, {
                                  timerId: S,
                                  timerType: "interval"
                              }), a.set(S, I), h.postMessage({
                                  id: I,
                                  method: "clear",
                                  params: {
                                      timerId: S,
                                      timerType: "interval"
                                  }
                              });
                          },
                          clearTimeout: function(S) {
                              var I = e.generateUniqueNumber(c);
                              c.set(I, {
                                  timerId: S,
                                  timerType: "timeout"
                              }), u.set(S, I), h.postMessage({
                                  id: I,
                                  method: "clear",
                                  params: {
                                      timerId: S,
                                      timerType: "timeout"
                                  }
                              });
                          },
                          setInterval: function(S) {
                              var I = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, C = e.generateUniqueNumber(a);
                              return a.set(C, (function() {
                                  S(), "function" == typeof a.get(C) && h.postMessage({
                                      id: null,
                                      method: "set",
                                      params: {
                                          delay: I,
                                          now: performance.now(),
                                          timerId: C,
                                          timerType: "interval"
                                      }
                                  });
                              })), h.postMessage({
                                  id: null,
                                  method: "set",
                                  params: {
                                      delay: I,
                                      now: performance.now(),
                                      timerId: C,
                                      timerType: "interval"
                                  }
                              }), C;
                          },
                          setTimeout: function(S) {
                              var I = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, C = e.generateUniqueNumber(u);
                              return u.set(C, S), h.postMessage({
                                  id: null,
                                  method: "set",
                                  params: {
                                      delay: I,
                                      now: performance.now(),
                                      timerId: C,
                                      timerType: "timeout"
                                  }
                              }), C;
                          }
                      };
                  };
              }, "object" == typeof es && typeof Op < "u" ? e(es, Pp()) : "function" == typeof define && __webpack_require__.amdO ? define([ "exports", "fast-unique-numbers" ], e) : e((t = typeof globalThis < "u" ? globalThis : t || self).workerTimersBroker = {}, t.fastUniqueNumbers);
          })), Mp = M(((ts, xp) => {
              var t, e;
              v(), m(), _(), t = ts, e = function(t, e) {
                  var h, d, g, n = (h = e.load, d = '(()=>{var e={472:(e,t,r)=>{var o,i;void 0===(i="function"==typeof(o=function(){"use strict";var e=new Map,t=new Map,r=function(t){var r=e.get(t);if(void 0===r)throw new Error(\'There is no interval scheduled with the given id "\'.concat(t,\'".\'));clearTimeout(r),e.delete(t)},o=function(e){var r=t.get(e);if(void 0===r)throw new Error(\'There is no timeout scheduled with the given id "\'.concat(e,\'".\'));clearTimeout(r),t.delete(e)},i=function(e,t){var r,o=performance.now();return{expected:o+(r=e-Math.max(0,o-t)),remainingDelay:r}},n=function e(t,r,o,i){var n=performance.now();n>o?postMessage({id:null,method:"call",params:{timerId:r,timerType:i}}):t.set(r,setTimeout(e,o-n,t,r,o,i))},a=function(t,r,o){var a=i(t,o),s=a.expected,d=a.remainingDelay;e.set(r,setTimeout(n,d,e,r,s,"interval"))},s=function(e,r,o){var a=i(e,o),s=a.expected,d=a.remainingDelay;t.set(r,setTimeout(n,d,t,r,s,"timeout"))};addEventListener("message",(function(e){var t=e.data;try{if("clear"===t.method){var i=t.id,n=t.params,d=n.timerId,c=n.timerType;if("interval"===c)r(d),postMessage({error:null,id:i});else{if("timeout"!==c)throw new Error(\'The given type "\'.concat(c,\'" is not supported\'));o(d),postMessage({error:null,id:i})}}else{if("set"!==t.method)throw new Error(\'The given method "\'.concat(t.method,\'" is not supported\'));var u=t.params,l=u.delay,p=u.now,m=u.timerId,v=u.timerType;if("interval"===v)a(l,m,p);else{if("timeout"!==v)throw new Error(\'The given type "\'.concat(v,\'" is not supported\'));s(l,m,p)}}}catch(e){postMessage({error:{message:e.message},id:t.id,result:null})}}))})?o.call(t,r,t,e):o)||(e.exports=i)}},t={};function r(o){var i=t[o];if(void 0!==i)return i.exports;var n=t[o]={exports:{}};return e[o](n,n.exports,r),n.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var o in t)r.o(t,o)&&!r.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();', 
                  g = null, function() {
                      if (null !== g) return g;
                      var y = new Blob([ d ], {
                          type: "application/javascript; charset=utf-8"
                      }), w = URL.createObjectURL(y);
                      return g = h(w), setTimeout((function() {
                          return URL.revokeObjectURL(w);
                      })), g;
                  });
                  t.clearInterval = function(h) {
                      return n().clearInterval(h);
                  }, t.clearTimeout = function(h) {
                      return n().clearTimeout(h);
                  }, t.setInterval = function() {
                      var h;
                      return (h = n()).setInterval.apply(h, arguments);
                  }, t.setTimeout = function() {
                      var h;
                      return (h = n()).setTimeout.apply(h, arguments);
                  };
              }, "object" == typeof ts && typeof xp < "u" ? e(ts, kp()) : "function" == typeof define && __webpack_require__.amdO ? define([ "exports", "worker-timers-broker" ], e) : e((t = typeof globalThis < "u" ? globalThis : t || self).workerTimers = {}, t.workerTimersBroker);
          })), qp = M((Ct => {
              v(), m(), _();
              var jv = Ct && Ct.__createBinding || (Object.create ? function(t, e, r, i) {
                  void 0 === i && (i = r);
                  var n = Object.getOwnPropertyDescriptor(e, r);
                  (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) && (n = {
                      enumerable: !0,
                      get: function() {
                          return e[r];
                      }
                  }), Object.defineProperty(t, i, n);
              } : function(t, e, r, i) {
                  void 0 === i && (i = r), t[i] = e[r];
              }), Fv = Ct && Ct.__setModuleDefault || (Object.create ? function(t, e) {
                  Object.defineProperty(t, "default", {
                      enumerable: !0,
                      value: e
                  });
              } : function(t, e) {
                  t.default = e;
              }), Wv = Ct && Ct.__importStar || function(t) {
                  if (t && t.__esModule) return t;
                  var e = {};
                  if (null != t) for (var r in t) "default" !== r && Object.prototype.hasOwnProperty.call(t, r) && jv(e, t, r);
                  return Fv(e, t), e;
              };
              Object.defineProperty(Ct, "__esModule", {
                  value: !0
              });
              var qa = Wv(Pi()), Lp = Mp(), Up = {
                  set: Lp.setTimeout,
                  clear: Lp.clearTimeout
              }, Np = {
                  set: (t, e) => setTimeout(t, e),
                  clear: t => clearTimeout(t)
              };
              Ct.default = t => {
                  switch (t) {
                    case "native":
                      return Np;

                    case "worker":
                      return Up;

                    default:
                      return !qa.default || qa.isWebWorker || qa.isReactNativeBrowser ? Np : Up;
                  }
              };
          })), ja = M((Oi => {
              v(), m(), _();
              var Hv = Oi && Oi.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Oi, "__esModule", {
                  value: !0
              });
              var Vv = Hv(qp());
              Oi.default = class {
                  constructor(e, r, i) {
                      this.destroyed = !1, this.keepalive = 1e3 * e, this.checkPing = r, this.timer = (0, 
                      Vv.default)(i), this.reschedule();
                  }
                  clear() {
                      this.timerId && (this.timer.clear(this.timerId), this.timerId = null);
                  }
                  destroy() {
                      this.clear(), this.destroyed = !0;
                  }
                  reschedule() {
                      this.destroyed || (this.clear(), this.timerId = this.timer.set((() => {
                          this.destroyed || (this.checkPing(), this.reschedule());
                      }), this.keepalive));
                  }
              };
          })), ss = M((Qe => {
              v(), m(), _();
              var zv = Qe && Qe.__createBinding || (Object.create ? function(t, e, r, i) {
                  void 0 === i && (i = r);
                  var n = Object.getOwnPropertyDescriptor(e, r);
                  (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) && (n = {
                      enumerable: !0,
                      get: function() {
                          return e[r];
                      }
                  }), Object.defineProperty(t, i, n);
              } : function(t, e, r, i) {
                  void 0 === i && (i = r), t[i] = e[r];
              }), Kv = Qe && Qe.__setModuleDefault || (Object.create ? function(t, e) {
                  Object.defineProperty(t, "default", {
                      enumerable: !0,
                      value: e
                  });
              } : function(t, e) {
                  t.default = e;
              }), $p = Qe && Qe.__importStar || function(t) {
                  if (t && t.__esModule) return t;
                  var e = {};
                  if (null != t) for (var r in t) "default" !== r && Object.prototype.hasOwnProperty.call(t, r) && zv(e, t, r);
                  return Kv(e, t), e;
              }, Vt = Qe && Qe.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Qe, "__esModule", {
                  value: !0
              });
              var Gv = Vt(Gu()), Fa = Vt(Nd()), Qv = Vt(Jo()), Yv = jt(), Dp = Vt(Fd()), jp = $p($d()), Jv = Vt(ot()), rs = Vt(ea()), Xv = Vt(Ip()), is = Jr(), Zv = Tp(), eE = Vt(ja()), Fp = $p(Pi()), Wa = globalThis.setImmediate || ((...t) => {
                  let e = t.shift();
                  (0, is.nextTick)((() => {
                      e(...t);
                  }));
              }), Wp = {
                  keepalive: 60,
                  reschedulePings: !0,
                  protocolId: "MQTT",
                  protocolVersion: 4,
                  reconnectPeriod: 1e3,
                  connectTimeout: 3e4,
                  clean: !0,
                  resubscribe: !0,
                  writeCache: !0,
                  timerVariant: "auto"
              }, ns = class t extends Zv.TypedEventEmitter {
                  static defaultId() {
                      return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
                  }
                  constructor(e, r) {
                      super(), this.options = r || {};
                      for (let i in Wp) typeof this.options[i] > "u" ? this.options[i] = Wp[i] : this.options[i] = r[i];
                      this.log = this.options.log || (0, Jv.default)("mqttjs:client"), this.noop = this._noop.bind(this), 
                      this.log("MqttClient :: version:", t.VERSION), Fp.isWebWorker ? this.log("MqttClient :: environment", "webworker") : this.log("MqttClient :: environment", Fp.default ? "browser" : "node"), 
                      this.log("MqttClient :: options.protocol", r.protocol), this.log("MqttClient :: options.protocolVersion", r.protocolVersion), 
                      this.log("MqttClient :: options.username", r.username), this.log("MqttClient :: options.keepalive", r.keepalive), 
                      this.log("MqttClient :: options.reconnectPeriod", r.reconnectPeriod), this.log("MqttClient :: options.rejectUnauthorized", r.rejectUnauthorized), 
                      this.log("MqttClient :: options.properties.topicAliasMaximum", r.properties ? r.properties.topicAliasMaximum : void 0), 
                      this.options.clientId = "string" == typeof r.clientId ? r.clientId : t.defaultId(), 
                      this.log("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = 5 === r.protocolVersion && r.customHandleAcks ? r.customHandleAcks : (...i) => {
                          i[3](null, 0);
                      }, this.options.writeCache || (Fa.default.writeToStream.cacheNumbers = !1), this.streamBuilder = e, 
                      this.messageIdProvider = typeof this.options.messageIdProvider > "u" ? new Qv.default : this.options.messageIdProvider, 
                      this.outgoingStore = r.outgoingStore || new rs.default, this.incomingStore = r.incomingStore || new rs.default, 
                      this.queueQoSZero = void 0 === r.queueQoSZero || r.queueQoSZero, this._resubscribeTopics = {}, 
                      this.messageIdToTopic = {}, this.pingTimer = null, this.connected = !1, this.disconnecting = !1, 
                      this.reconnecting = !1, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, 
                      this._storeProcessing = !1, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], 
                      this.outgoing = {}, this._firstConnection = !0, r.properties && r.properties.topicAliasMaximum > 0 && (r.properties.topicAliasMaximum > 65535 ? this.log("MqttClient :: options.properties.topicAliasMaximum is out of range") : this.topicAliasRecv = new Gv.default(r.properties.topicAliasMaximum)), 
                      this.on("connect", (() => {
                          let {queue: i} = this, n = () => {
                              let o = i.shift();
                              this.log("deliver :: entry %o", o);
                              let s = null;
                              if (!o) return void this._resubscribe();
                              s = o.packet, this.log("deliver :: call _sendPacket for %o", s);
                              let a = !0;
                              s.messageId && 0 !== s.messageId && (this.messageIdProvider.register(s.messageId) || (a = !1)), 
                              a ? this._sendPacket(s, (u => {
                                  o.cb && o.cb(u), n();
                              })) : (this.log("messageId: %d has already used. The message is skipped and removed.", s.messageId), 
                              n());
                          };
                          this.log("connect :: sending queued packets"), n();
                      })), this.on("close", (() => {
                          this.log("close :: connected set to `false`"), this.connected = !1, this.log("close :: clearing connackTimer"), 
                          clearTimeout(this.connackTimer), this.log("close :: destroy ping timer"), this.pingTimer && (this.pingTimer.destroy(), 
                          this.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), this.log("close :: calling _setupReconnect"), 
                          this._setupReconnect();
                      })), this.options.manualConnect || (this.log("MqttClient :: setting up stream"), 
                      this.connect());
                  }
                  handleAuth(e, r) {
                      r();
                  }
                  handleMessage(e, r) {
                      r();
                  }
                  _nextId() {
                      return this.messageIdProvider.allocate();
                  }
                  getLastMessageId() {
                      return this.messageIdProvider.getLastAllocated();
                  }
                  connect() {
                      var e;
                      let r = new Yv.Writable, i = Fa.default.parser(this.options), n = null, o = [];
                      this.log("connect :: calling method to clear reconnect"), this._clearReconnect(), 
                      this.log("connect :: using streamBuilder provided to client to create stream"), 
                      this.stream = this.streamBuilder(this), i.on("packet", (h => {
                          this.log("parser :: on packet push to packets array."), o.push(h);
                      }));
                      let s = () => {
                          this.log("work :: getting next packet in queue");
                          let h = o.shift();
                          if (h) this.log("work :: packet pulled from queue"), (0, Xv.default)(this, h, a); else {
                              this.log("work :: no packets in queue");
                              let d = n;
                              n = null, this.log("work :: done flag is %s", !!d), d && d();
                          }
                      }, a = () => {
                          if (o.length) (0, is.nextTick)(s); else {
                              let h = n;
                              n = null, h();
                          }
                      };
                      r._write = (h, d, g) => {
                          n = g, this.log("writable stream :: parsing buffer"), i.parse(h), s();
                      };
                      this.log("connect :: pipe stream to writable stream"), this.stream.pipe(r), this.stream.on("error", (h => {
                          this.log("streamErrorHandler :: error", h.message), h.code ? (this.log("streamErrorHandler :: emitting error"), 
                          this.emit("error", h)) : this.noop(h);
                      })), this.stream.on("close", (() => {
                          this.log("(%s)stream :: on close", this.options.clientId), this._flushVolatile(), 
                          this.log("stream: emit close to MqttClient"), this.emit("close");
                      })), this.log("connect: sending packet `connect`");
                      let c = {
                          cmd: "connect",
                          protocolId: this.options.protocolId,
                          protocolVersion: this.options.protocolVersion,
                          clean: this.options.clean,
                          clientId: this.options.clientId,
                          keepalive: this.options.keepalive,
                          username: this.options.username,
                          password: this.options.password,
                          properties: this.options.properties
                      };
                      if (this.options.will && (c.will = Object.assign(Object.assign({}, this.options.will), {
                          payload: null === (e = this.options.will) || void 0 === e ? void 0 : e.payload
                      })), this.topicAliasRecv && (c.properties || (c.properties = {}), this.topicAliasRecv && (c.properties.topicAliasMaximum = this.topicAliasRecv.max)), 
                      this._writePacket(c), i.on("error", this.emit.bind(this, "error")), this.options.properties) {
                          if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) return this.end((() => this.emit("error", new Error("Packet has no Authentication Method")))), 
                          this;
                          if (this.options.properties.authenticationMethod && this.options.authPacket && "object" == typeof this.options.authPacket) {
                              let h = Object.assign({
                                  cmd: "auth",
                                  reasonCode: 0
                              }, this.options.authPacket);
                              this._writePacket(h);
                          }
                      }
                      return this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout((() => {
                          this.log("!!connectTimeout hit!! Calling _cleanUp with force `true`"), this.emit("error", new Error("connack timeout")), 
                          this._cleanUp(!0);
                      }), this.options.connectTimeout), this;
                  }
                  publish(e, r, i, n) {
                      this.log("publish :: message `%s` to topic `%s`", r, e);
                      let {options: o} = this;
                      "function" == typeof i && (n = i, i = null), i = i || {}, i = Object.assign(Object.assign({}, {
                          qos: 0,
                          retain: !1,
                          dup: !1
                      }), i);
                      let {qos: a, retain: u, dup: c, properties: h, cbStorePut: d} = i;
                      if (this._checkDisconnecting(n)) return this;
                      let g = () => {
                          let y = 0;
                          if ((1 === a || 2 === a) && (y = this._nextId(), null === y)) return this.log("No messageId left"), 
                          !1;
                          let w = {
                              cmd: "publish",
                              topic: e,
                              payload: r,
                              qos: a,
                              retain: u,
                              messageId: y,
                              dup: c
                          };
                          switch (5 === o.protocolVersion && (w.properties = h), this.log("publish :: qos", a), 
                          a) {
                            case 1:
                            case 2:
                              this.outgoing[w.messageId] = {
                                  volatile: !1,
                                  cb: n || this.noop
                              }, this.log("MqttClient:publish: packet cmd: %s", w.cmd), this._sendPacket(w, void 0, d);
                              break;

                            default:
                              this.log("MqttClient:publish: packet cmd: %s", w.cmd), this._sendPacket(w, n, d);
                          }
                          return !0;
                      };
                      return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !g()) && this._storeProcessingQueue.push({
                          invoke: g,
                          cbStorePut: i.cbStorePut,
                          callback: n
                      }), this;
                  }
                  publishAsync(e, r, i) {
                      return new Promise(((n, o) => {
                          this.publish(e, r, i, ((s, a) => {
                              s ? o(s) : n(a);
                          }));
                      }));
                  }
                  subscribe(e, r, i) {
                      let n = this.options.protocolVersion;
                      "function" == typeof r && (i = r), i = i || this.noop;
                      let o = !1, s = [];
                      "string" == typeof e ? s = e = [ e ] : Array.isArray(e) ? s = e : "object" == typeof e && (o = e.resubscribe, 
                      delete e.resubscribe, s = Object.keys(e));
                      let a = jp.validateTopics(s);
                      if (null !== a) return Wa(i, new Error(`Invalid topic ${a}`)), this;
                      if (this._checkDisconnecting(i)) return this.log("subscribe: discconecting true"), 
                      this;
                      let u = {
                          qos: 0
                      };
                      5 === n && (u.nl = !1, u.rap = !1, u.rh = 0);
                      let c = (r = Object.assign(Object.assign({}, u), r)).properties, h = [], d = (y, w) => {
                          if (w = w || r, !Object.prototype.hasOwnProperty.call(this._resubscribeTopics, y) || this._resubscribeTopics[y].qos < w.qos || o) {
                              let E = {
                                  topic: y,
                                  qos: w.qos
                              };
                              5 === n && (E.nl = w.nl, E.rap = w.rap, E.rh = w.rh, E.properties = c), this.log("subscribe: pushing topic `%s` and qos `%s` to subs list", E.topic, E.qos), 
                              h.push(E);
                          }
                      };
                      if (Array.isArray(e) ? e.forEach((y => {
                          this.log("subscribe: array topic %s", y), d(y);
                      })) : Object.keys(e).forEach((y => {
                          this.log("subscribe: object topic %s, %o", y, e[y]), d(y, e[y]);
                      })), !h.length) return i(null, []), this;
                      let g = () => {
                          let y = this._nextId();
                          if (null === y) return this.log("No messageId left"), !1;
                          let w = {
                              cmd: "subscribe",
                              subscriptions: h,
                              messageId: y
                          };
                          if (c && (w.properties = c), this.options.resubscribe) {
                              this.log("subscribe :: resubscribe true");
                              let E = [];
                              h.forEach((S => {
                                  if (this.options.reconnectPeriod > 0) {
                                      let I = {
                                          qos: S.qos
                                      };
                                      5 === n && (I.nl = S.nl || !1, I.rap = S.rap || !1, I.rh = S.rh || 0, I.properties = S.properties), 
                                      this._resubscribeTopics[S.topic] = I, E.push(S.topic);
                                  }
                              })), this.messageIdToTopic[w.messageId] = E;
                          }
                          return this.outgoing[w.messageId] = {
                              volatile: !0,
                              cb(E, S) {
                                  if (!E) {
                                      let {granted: I} = S;
                                      for (let C = 0; C < I.length; C += 1) h[C].qos = I[C];
                                  }
                                  i(E, h);
                              }
                          }, this.log("subscribe :: call _sendPacket"), this._sendPacket(w), !0;
                      };
                      return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !g()) && this._storeProcessingQueue.push({
                          invoke: g,
                          callback: i
                      }), this;
                  }
                  subscribeAsync(e, r) {
                      return new Promise(((i, n) => {
                          this.subscribe(e, r, ((o, s) => {
                              o ? n(o) : i(s);
                          }));
                      }));
                  }
                  unsubscribe(e, r, i) {
                      "string" == typeof e && (e = [ e ]), "function" == typeof r && (i = r), i = i || this.noop;
                      let n = jp.validateTopics(e);
                      if (null !== n) return Wa(i, new Error(`Invalid topic ${n}`)), this;
                      if (this._checkDisconnecting(i)) return this;
                      let o = () => {
                          let s = this._nextId();
                          if (null === s) return this.log("No messageId left"), !1;
                          let a = {
                              cmd: "unsubscribe",
                              messageId: s,
                              unsubscriptions: []
                          };
                          return "string" == typeof e ? a.unsubscriptions = [ e ] : Array.isArray(e) && (a.unsubscriptions = e), 
                          this.options.resubscribe && a.unsubscriptions.forEach((u => {
                              delete this._resubscribeTopics[u];
                          })), "object" == typeof r && r.properties && (a.properties = r.properties), this.outgoing[a.messageId] = {
                              volatile: !0,
                              cb: i
                          }, this.log("unsubscribe: call _sendPacket"), this._sendPacket(a), !0;
                      };
                      return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !o()) && this._storeProcessingQueue.push({
                          invoke: o,
                          callback: i
                      }), this;
                  }
                  unsubscribeAsync(e, r) {
                      return new Promise(((i, n) => {
                          this.unsubscribe(e, r, ((o, s) => {
                              o ? n(o) : i(s);
                          }));
                      }));
                  }
                  end(e, r, i) {
                      this.log("end :: (%s)", this.options.clientId), (null == e || "boolean" != typeof e) && (i = i || r, 
                      r = e, e = !1), "object" != typeof r && (i = i || r, r = null), this.log("end :: cb? %s", !!i), 
                      (!i || "function" != typeof i) && (i = this.noop);
                      let n = () => {
                          this.log("end :: closeStores: closing incoming and outgoing stores"), this.disconnected = !0, 
                          this.incomingStore.close((s => {
                              this.outgoingStore.close((a => {
                                  if (this.log("end :: closeStores: emitting end"), this.emit("end"), i) {
                                      let u = s || a;
                                      this.log("end :: closeStores: invoking callback with args"), i(u);
                                  }
                              }));
                          })), this._deferredReconnect && this._deferredReconnect();
                      }, o = () => {
                          this.log("end :: (%s) :: finish :: calling _cleanUp with force %s", this.options.clientId, e), 
                          this._cleanUp(e, (() => {
                              this.log("end :: finish :: calling process.nextTick on closeStores"), (0, is.nextTick)(n);
                          }), r);
                      };
                      return this.disconnecting ? (i(), this) : (this._clearReconnect(), this.disconnecting = !0, 
                      !e && Object.keys(this.outgoing).length > 0 ? (this.log("end :: (%s) :: calling finish in 10ms once outgoing is empty", this.options.clientId), 
                      this.once("outgoingEmpty", setTimeout.bind(null, o, 10))) : (this.log("end :: (%s) :: immediately calling finish", this.options.clientId), 
                      o()), this);
                  }
                  endAsync(e, r) {
                      return new Promise(((i, n) => {
                          this.end(e, r, (o => {
                              o ? n(o) : i();
                          }));
                      }));
                  }
                  removeOutgoingMessage(e) {
                      if (this.outgoing[e]) {
                          let {cb: r} = this.outgoing[e];
                          this._removeOutgoingAndStoreMessage(e, (() => {
                              r(new Error("Message removed"));
                          }));
                      }
                      return this;
                  }
                  reconnect(e) {
                      this.log("client reconnect");
                      let r = () => {
                          e ? (this.options.incomingStore = e.incomingStore, this.options.outgoingStore = e.outgoingStore) : (this.options.incomingStore = null, 
                          this.options.outgoingStore = null), this.incomingStore = this.options.incomingStore || new rs.default, 
                          this.outgoingStore = this.options.outgoingStore || new rs.default, this.disconnecting = !1, 
                          this.disconnected = !1, this._deferredReconnect = null, this._reconnect();
                      };
                      return this.disconnecting && !this.disconnected ? this._deferredReconnect = r : r(), 
                      this;
                  }
                  _flushVolatile() {
                      this.outgoing && (this.log("_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), 
                      Object.keys(this.outgoing).forEach((e => {
                          this.outgoing[e].volatile && "function" == typeof this.outgoing[e].cb && (this.outgoing[e].cb(new Error("Connection closed")), 
                          delete this.outgoing[e]);
                      })));
                  }
                  _flush() {
                      this.outgoing && (this.log("_flush: queue exists? %b", !!this.outgoing), Object.keys(this.outgoing).forEach((e => {
                          "function" == typeof this.outgoing[e].cb && (this.outgoing[e].cb(new Error("Connection closed")), 
                          delete this.outgoing[e]);
                      })));
                  }
                  _removeTopicAliasAndRecoverTopicName(e) {
                      let r;
                      e.properties && (r = e.properties.topicAlias);
                      let i = e.topic.toString();
                      if (this.log("_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o", r, i), 
                      0 === i.length) {
                          if (typeof r > "u") return new Error("Unregistered Topic Alias");
                          if (i = this.topicAliasSend.getTopicByAlias(r), typeof i > "u") return new Error("Unregistered Topic Alias");
                          e.topic = i;
                      }
                      r && delete e.properties.topicAlias;
                  }
                  _checkDisconnecting(e) {
                      return this.disconnecting && (e && e !== this.noop ? e(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), 
                      this.disconnecting;
                  }
                  _reconnect() {
                      this.log("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end((() => {
                          this.connect();
                      })), this.log("client already connected. disconnecting first.")) : (this.log("_reconnect: calling connect"), 
                      this.connect());
                  }
                  _setupReconnect() {
                      !this.disconnecting && !this.reconnectTimer && this.options.reconnectPeriod > 0 ? (this.reconnecting || (this.log("_setupReconnect :: emit `offline` state"), 
                      this.emit("offline"), this.log("_setupReconnect :: set `reconnecting` to `true`"), 
                      this.reconnecting = !0), this.log("_setupReconnect :: setting reconnectTimer for %d ms", this.options.reconnectPeriod), 
                      this.reconnectTimer = setInterval((() => {
                          this.log("reconnectTimer :: reconnect triggered!"), this._reconnect();
                      }), this.options.reconnectPeriod)) : this.log("_setupReconnect :: doing nothing...");
                  }
                  _clearReconnect() {
                      this.log("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), 
                      this.reconnectTimer = null);
                  }
                  _cleanUp(e, r, i = {}) {
                      if (r && (this.log("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", r)), 
                      this.log("_cleanUp :: forced? %s", e), e) 0 === this.options.reconnectPeriod && this.options.clean && this._flush(), 
                      this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy(); else {
                          let n = Object.assign({
                              cmd: "disconnect"
                          }, i);
                          this.log("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), 
                          this._sendPacket(n, (() => {
                              this.log("_cleanUp :: (%s) :: destroying stream", this.options.clientId), Wa((() => {
                                  this.stream.end((() => {
                                      this.log("_cleanUp :: (%s) :: stream destroyed", this.options.clientId);
                                  }));
                              }));
                          }));
                      }
                      !this.disconnecting && !this.reconnecting && (this.log("_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect."), 
                      this._clearReconnect(), this._setupReconnect()), this.pingTimer && (this.log("_cleanUp :: destroy pingTimer"), 
                      this.pingTimer.destroy(), this.pingTimer = null), r && !this.connected && (this.log("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), 
                      this.stream.removeListener("close", r), r());
                  }
                  _storeAndSend(e, r, i) {
                      this.log("storeAndSend :: store packet with cmd %s to outgoingStore", e.cmd);
                      let o, n = e;
                      if ("publish" === n.cmd && (n = (0, Dp.default)(e), o = this._removeTopicAliasAndRecoverTopicName(n), 
                      o)) return r && r(o);
                      this.outgoingStore.put(n, (s => {
                          if (s) return r && r(s);
                          i(), this._writePacket(e, r);
                      }));
                  }
                  _applyTopicAlias(e) {
                      if (5 === this.options.protocolVersion && "publish" === e.cmd) {
                          let r;
                          e.properties && (r = e.properties.topicAlias);
                          let i = e.topic.toString();
                          if (this.topicAliasSend) if (r) {
                              if (0 !== i.length && (this.log("applyTopicAlias :: register topic: %s - alias: %d", i, r), 
                              !this.topicAliasSend.put(i, r))) return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", i, r), 
                              new Error("Sending Topic Alias out of range");
                          } else 0 !== i.length && (this.options.autoAssignTopicAlias ? (r = this.topicAliasSend.getAliasByTopic(i), 
                          r ? (e.topic = "", e.properties = Object.assign(Object.assign({}, e.properties), {
                              topicAlias: r
                          }), this.log("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", i, r)) : (r = this.topicAliasSend.getLruAlias(), 
                          this.topicAliasSend.put(i, r), e.properties = Object.assign(Object.assign({}, e.properties), {
                              topicAlias: r
                          }), this.log("applyTopicAlias :: auto assign topic: %s - alias: %d", i, r))) : this.options.autoUseTopicAlias && (r = this.topicAliasSend.getAliasByTopic(i), 
                          r && (e.topic = "", e.properties = Object.assign(Object.assign({}, e.properties), {
                              topicAlias: r
                          }), this.log("applyTopicAlias :: auto use topic: %s - alias: %d", i, r)))); else if (r) return this.log("applyTopicAlias :: error out of range. topic: %s - alias: %d", i, r), 
                          new Error("Sending Topic Alias out of range");
                      }
                  }
                  _noop(e) {
                      this.log("noop ::", e);
                  }
                  _writePacket(e, r) {
                      this.log("_writePacket :: packet: %O", e), this.log("_writePacket :: emitting `packetsend`"), 
                      this.emit("packetsend", e), this._shiftPingInterval(), this.log("_writePacket :: writing to stream");
                      let i = Fa.default.writeToStream(e, this.stream, this.options);
                      this.log("_writePacket :: writeToStream result %s", i), !i && r && r !== this.noop ? (this.log("_writePacket :: handle events on `drain` once through callback."), 
                      this.stream.once("drain", r)) : r && (this.log("_writePacket :: invoking cb"), r());
                  }
                  _sendPacket(e, r, i, n) {
                      this.log("_sendPacket :: (%s) ::  start", this.options.clientId), i = i || this.noop, 
                      r = r || this.noop;
                      let o = this._applyTopicAlias(e);
                      if (o) r(o); else {
                          if (!this.connected) return "auth" === e.cmd ? void this._writePacket(e, r) : (this.log("_sendPacket :: client not connected. Storing packet offline."), 
                          void this._storePacket(e, r, i));
                          if (n) this._writePacket(e, r); else {
                              switch (e.cmd) {
                                case "publish":
                                  break;

                                case "pubrel":
                                  return void this._storeAndSend(e, r, i);

                                default:
                                  return void this._writePacket(e, r);
                              }
                              switch (e.qos) {
                                case 2:
                                case 1:
                                  this._storeAndSend(e, r, i);
                                  break;

                                default:
                                  this._writePacket(e, r);
                              }
                              this.log("_sendPacket :: (%s) ::  end", this.options.clientId);
                          }
                      }
                  }
                  _storePacket(e, r, i) {
                      this.log("_storePacket :: packet: %o", e), this.log("_storePacket :: cb? %s", !!r), 
                      i = i || this.noop;
                      let n = e;
                      if ("publish" === n.cmd) {
                          n = (0, Dp.default)(e);
                          let s = this._removeTopicAliasAndRecoverTopicName(n);
                          if (s) return r && r(s);
                      }
                      let o = n.qos || 0;
                      0 === o && this.queueQoSZero || "publish" !== n.cmd ? this.queue.push({
                          packet: n,
                          cb: r
                      }) : o > 0 ? (r = this.outgoing[n.messageId] ? this.outgoing[n.messageId].cb : null, 
                      this.outgoingStore.put(n, (s => {
                          if (s) return r && r(s);
                          i();
                      }))) : r && r(new Error("No connection to broker"));
                  }
                  _setupPingTimer() {
                      this.log("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive), !this.pingTimer && this.options.keepalive && (this.pingResp = !0, 
                      this.pingTimer = new eE.default(this.options.keepalive, (() => {
                          this._checkPing();
                      }), this.options.timerVariant));
                  }
                  _shiftPingInterval() {
                      this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule();
                  }
                  _checkPing() {
                      this.log("_checkPing :: checking ping..."), this.pingResp ? (this.log("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), 
                      this.pingResp = !1, this._sendPacket({
                          cmd: "pingreq"
                      })) : (this.emit("error", new Error("Keepalive timeout")), this.log("_checkPing :: calling _cleanUp with force true"), 
                      this._cleanUp(!0));
                  }
                  _resubscribe() {
                      this.log("_resubscribe");
                      let e = Object.keys(this._resubscribeTopics);
                      if (!this._firstConnection && (this.options.clean || this.options.protocolVersion >= 4 && !this.connackPacket.sessionPresent) && e.length > 0) if (this.options.resubscribe) if (5 === this.options.protocolVersion) {
                          this.log("_resubscribe: protocolVersion 5");
                          for (let r = 0; r < e.length; r++) {
                              let i = {};
                              i[e[r]] = this._resubscribeTopics[e[r]], i.resubscribe = !0, this.subscribe(i, {
                                  properties: i[e[r]].properties
                              });
                          }
                      } else this._resubscribeTopics.resubscribe = !0, this.subscribe(this._resubscribeTopics); else this._resubscribeTopics = {};
                      this._firstConnection = !1;
                  }
                  _onConnect(e) {
                      if (this.disconnected) return void this.emit("connect", e);
                      this.connackPacket = e, this.messageIdProvider.clear(), this._setupPingTimer(), 
                      this.connected = !0;
                      let r = () => {
                          let i = this.outgoingStore.createStream(), n = () => {
                              i.destroy(), i = null, this._flushStoreProcessingQueue(), o();
                          }, o = () => {
                              this._storeProcessing = !1, this._packetIdsDuringStoreProcessing = {};
                          };
                          this.once("close", n), i.on("error", (a => {
                              o(), this._flushStoreProcessingQueue(), this.removeListener("close", n), this.emit("error", a);
                          }));
                          let s = () => {
                              if (!i) return;
                              let u, a = i.read(1);
                              a ? (this._storeProcessing = !0, this._packetIdsDuringStoreProcessing[a.messageId] ? s() : this.disconnecting || this.reconnectTimer ? i.destroy && i.destroy() : (u = this.outgoing[a.messageId] ? this.outgoing[a.messageId].cb : null, 
                              this.outgoing[a.messageId] = {
                                  volatile: !1,
                                  cb(c, h) {
                                      u && u(c, h), s();
                                  }
                              }, this._packetIdsDuringStoreProcessing[a.messageId] = !0, this.messageIdProvider.register(a.messageId) ? this._sendPacket(a, void 0, void 0, !0) : this.log("messageId: %d has already used.", a.messageId))) : i.once("readable", s);
                          };
                          i.on("end", (() => {
                              let a = !0;
                              for (let u in this._packetIdsDuringStoreProcessing) if (!this._packetIdsDuringStoreProcessing[u]) {
                                  a = !1;
                                  break;
                              }
                              this.removeListener("close", n), a ? (o(), this._invokeAllStoreProcessingQueue(), 
                              this.emit("connect", e)) : r();
                          })), s();
                      };
                      r();
                  }
                  _invokeStoreProcessingQueue() {
                      if (!this._storeProcessing && this._storeProcessingQueue.length > 0) {
                          let e = this._storeProcessingQueue[0];
                          if (e && e.invoke()) return this._storeProcessingQueue.shift(), !0;
                      }
                      return !1;
                  }
                  _invokeAllStoreProcessingQueue() {
                      for (;this._invokeStoreProcessingQueue(); ) ;
                  }
                  _flushStoreProcessingQueue() {
                      for (let e of this._storeProcessingQueue) e.cbStorePut && e.cbStorePut(new Error("Connection closed")), 
                      e.callback && e.callback(new Error("Connection closed"));
                      this._storeProcessingQueue.splice(0);
                  }
                  _removeOutgoingAndStoreMessage(e, r) {
                      delete this.outgoing[e], this.outgoingStore.del({
                          messageId: e
                      }, ((i, n) => {
                          r(i, n), this.messageIdProvider.deallocate(e), this._invokeStoreProcessingQueue();
                      }));
                  }
              };
              ns.VERSION = is.MQTTJS_VERSION, Qe.default = ns;
          })), Hp = M((Ha => {
              v(), m(), _(), Object.defineProperty(Ha, "__esModule", {
                  value: !0
              });
              var tE = Ma();
              Ha.default = class {
                  constructor() {
                      this.numberAllocator = new tE.NumberAllocator(1, 65535);
                  }
                  allocate() {
                      return this.lastId = this.numberAllocator.alloc(), this.lastId;
                  }
                  getLastAllocated() {
                      return this.lastId;
                  }
                  register(e) {
                      return this.numberAllocator.use(e);
                  }
                  deallocate(e) {
                      this.numberAllocator.free(e);
                  }
                  clear() {
                      this.numberAllocator.clear();
                  }
              };
          }));
          function Ir(t) {
              throw new RangeError(sE[t]);
          }
          function Vp(t, e) {
              let r = t.split("@"), i = "";
              return r.length > 1 && (i = r[0] + "@", t = r[1]), i + function(o, s) {
                  let a = [], u = o.length;
                  for (;u--; ) a[u] = s(o[u]);
                  return a;
              }((t = t.replace(nE, ".")).split("."), e).join(".");
          }
          function Qp(t) {
              let e = [], r = 0, i = t.length;
              for (;r < i; ) {
                  let n = t.charCodeAt(r++);
                  if (n >= 55296 && n <= 56319 && r < i) {
                      let o = t.charCodeAt(r++);
                      56320 == (64512 & o) ? e.push(((1023 & n) << 10) + (1023 & o) + 65536) : (e.push(n), 
                      r--);
                  } else e.push(n);
              }
              return e;
          }
          var rE, iE, nE, sE, dt, Va, zp, Yp, Kp, Gp, zt, Jp = we((() => {
              v(), m(), _(), rE = /^xn--/, iE = /[^\0-\x7E]/, nE = /[\x2E\u3002\uFF0E\uFF61]/g, 
              sE = {
                  overflow: "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input"
              }, dt = Math.floor, Va = String.fromCharCode, zp = function(t, e) {
                  return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
              }, Yp = function(t, e, r) {
                  let i = 0;
                  for (t = r ? dt(t / 700) : t >> 1, t += dt(t / e); t > 455; i += 36) t = dt(t / 35);
                  return dt(i + 36 * t / (t + 38));
              }, Kp = function(t) {
                  let e = [], r = t.length, i = 0, n = 128, o = 72, s = t.lastIndexOf("-");
                  s < 0 && (s = 0);
                  for (let u = 0; u < s; ++u) t.charCodeAt(u) >= 128 && Ir("not-basic"), e.push(t.charCodeAt(u));
                  for (let u = s > 0 ? s + 1 : 0; u < r; ) {
                      let c = i;
                      for (let d = 1, g = 36; ;g += 36) {
                          u >= r && Ir("invalid-input");
                          let y = (a = t.charCodeAt(u++)) - 48 < 10 ? a - 22 : a - 65 < 26 ? a - 65 : a - 97 < 26 ? a - 97 : 36;
                          (y >= 36 || y > dt((2147483647 - i) / d)) && Ir("overflow"), i += y * d;
                          let w = g <= o ? 1 : g >= o + 26 ? 26 : g - o;
                          if (y < w) break;
                          let E = 36 - w;
                          d > dt(2147483647 / E) && Ir("overflow"), d *= E;
                      }
                      let h = e.length + 1;
                      o = Yp(i - c, h, 0 == c), dt(i / h) > 2147483647 - n && Ir("overflow"), n += dt(i / h), 
                      i %= h, e.splice(i++, 0, n);
                  }
                  var a;
                  return String.fromCodePoint(...e);
              }, Gp = function(t) {
                  let e = [], r = (t = Qp(t)).length, i = 128, n = 0, o = 72;
                  for (let u of t) u < 128 && e.push(Va(u));
                  let s = e.length, a = s;
                  for (s && e.push("-"); a < r; ) {
                      let u = 2147483647;
                      for (let h of t) h >= i && h < u && (u = h);
                      let c = a + 1;
                      u - i > dt((2147483647 - n) / c) && Ir("overflow"), n += (u - i) * c, i = u;
                      for (let h of t) if (h < i && ++n > 2147483647 && Ir("overflow"), h == i) {
                          let d = n;
                          for (let g = 36; ;g += 36) {
                              let y = g <= o ? 1 : g >= o + 26 ? 26 : g - o;
                              if (d < y) break;
                              let w = d - y, E = 36 - y;
                              e.push(Va(zp(y + w % E, 0))), d = dt(w / E);
                          }
                          e.push(Va(zp(d, 0))), o = Yp(n, c, a == s), n = 0, ++a;
                      }
                      ++n, ++i;
                  }
                  return e.join("");
              }, zt = {
                  version: "2.1.0",
                  ucs2: {
                      decode: Qp,
                      encode: t => String.fromCodePoint(...t)
                  },
                  decode: Kp,
                  encode: Gp,
                  toASCII: function(t) {
                      return Vp(t, (function(e) {
                          return iE.test(e) ? "xn--" + Gp(e) : e;
                      }));
                  },
                  toUnicode: function(t) {
                      return Vp(t, (function(e) {
                          return rE.test(e) ? Kp(e.slice(4).toLowerCase()) : e;
                      }));
                  }
              }, zt.encode, zt.toASCII, zt.toUnicode, zt.ucs2, zt.version;
          }));
          function oE(t, e) {
              return Object.prototype.hasOwnProperty.call(t, e);
          }
          var aE, ki, lE, pt, Xp = we((() => {
              v(), m(), _(), aE = function(t, e, r, i) {
                  e = e || "&", r = r || "=";
                  var n = {};
                  if ("string" != typeof t || 0 === t.length) return n;
                  var o = /\+/g;
                  t = t.split(e);
                  var s = 1e3;
                  i && "number" == typeof i.maxKeys && (s = i.maxKeys);
                  var a = t.length;
                  s > 0 && a > s && (a = s);
                  for (var u = 0; u < a; ++u) {
                      var c, h, d, g, y = t[u].replace(o, "%20"), w = y.indexOf(r);
                      w >= 0 ? (c = y.substr(0, w), h = y.substr(w + 1)) : (c = y, h = ""), d = decodeURIComponent(c), 
                      g = decodeURIComponent(h), oE(n, d) ? Array.isArray(n[d]) ? n[d].push(g) : n[d] = [ n[d], g ] : n[d] = g;
                  }
                  return n;
              }, ki = function(t) {
                  switch (typeof t) {
                    case "string":
                      return t;

                    case "boolean":
                      return t ? "true" : "false";

                    case "number":
                      return isFinite(t) ? t : "";

                    default:
                      return "";
                  }
              }, lE = function(t, e, r, i) {
                  return e = e || "&", r = r || "=", null === t && (t = void 0), "object" == typeof t ? Object.keys(t).map((function(n) {
                      var o = encodeURIComponent(ki(n)) + r;
                      return Array.isArray(t[n]) ? t[n].map((function(s) {
                          return o + encodeURIComponent(ki(s));
                      })).join(e) : o + encodeURIComponent(ki(t[n]));
                  })).join(e) : i ? encodeURIComponent(ki(i)) + r + encodeURIComponent(ki(t)) : "";
              }, (pt = {}).decode = pt.parse = aE, pt.encode = pt.stringify = lE, pt.decode, pt.encode, 
              pt.parse, pt.stringify;
          }));
          function za() {
              throw new Error("setTimeout has not been defined");
          }
          function Ka() {
              throw new Error("clearTimeout has not been defined");
          }
          function tg(t) {
              if (Pt === setTimeout) return setTimeout(t, 0);
              if ((Pt === za || !Pt) && setTimeout) return Pt = setTimeout, setTimeout(t, 0);
              try {
                  return Pt(t, 0);
              } catch {
                  try {
                      return Pt.call(null, t, 0);
                  } catch {
                      return Pt.call(this || ii, t, 0);
                  }
              }
          }
          function uE() {
              ri && Tr && (ri = !1, Tr.length ? kt = Tr.concat(kt) : os = -1, kt.length && rg());
          }
          function rg() {
              if (!ri) {
                  var t = tg(uE);
                  ri = !0;
                  for (var e = kt.length; e; ) {
                      for (Tr = kt, kt = []; ++os < e; ) Tr && Tr[os].run();
                      os = -1, e = kt.length;
                  }
                  Tr = null, ri = !1, function(r) {
                      if (Ot === clearTimeout) return clearTimeout(r);
                      if ((Ot === Ka || !Ot) && clearTimeout) return Ot = clearTimeout, clearTimeout(r);
                      try {
                          Ot(r);
                      } catch {
                          try {
                              return Ot.call(null, r);
                          } catch {
                              return Ot.call(this || ii, r);
                          }
                      }
                  }(t);
              }
          }
          function Zp(t, e) {
              (this || ii).fun = t, (this || ii).array = e;
          }
          function Bt() {}
          var eg, Pt, Ot, ii, fe, Tr, kt, ri, os, ne, ig = we((() => {
              v(), m(), _(), ii = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : __webpack_require__.g, 
              fe = eg = {}, function() {
                  try {
                      Pt = "function" == typeof setTimeout ? setTimeout : za;
                  } catch {
                      Pt = za;
                  }
                  try {
                      Ot = "function" == typeof clearTimeout ? clearTimeout : Ka;
                  } catch {
                      Ot = Ka;
                  }
              }(), kt = [], ri = !1, os = -1, fe.nextTick = function(t) {
                  var e = new Array(arguments.length - 1);
                  if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) e[r - 1] = arguments[r];
                  kt.push(new Zp(t, e)), 1 !== kt.length || ri || tg(rg);
              }, Zp.prototype.run = function() {
                  (this || ii).fun.apply(null, (this || ii).array);
              }, fe.title = "browser", fe.browser = !0, fe.env = {}, fe.argv = [], fe.version = "", 
              fe.versions = {}, fe.on = Bt, fe.addListener = Bt, fe.once = Bt, fe.off = Bt, fe.removeListener = Bt, 
              fe.removeAllListeners = Bt, fe.emit = Bt, fe.prependListener = Bt, fe.prependOnceListener = Bt, 
              fe.listeners = function(t) {
                  return [];
              }, fe.binding = function(t) {
                  throw new Error("process.binding is not supported");
              }, fe.cwd = function() {
                  return "/";
              }, fe.chdir = function(t) {
                  throw new Error("process.chdir is not supported");
              }, fe.umask = function() {
                  return 0;
              }, ne = eg, ne.argv, ne.binding, ne.browser, ne.chdir, ne.cwd, ne.emit, ne.env, 
              ne.listeners, ne.nextTick, ne.off, ne.on, ne.once, ne.prependListener, ne.prependOnceListener, 
              ne.removeAllListeners, ne.removeListener, ne.title, ne.umask, ne.version, ne.versions;
          }));
          function fE() {
              if (ng) return Ga;
              ng = !0;
              var e, r, t = Ga = {};
              function i() {
                  throw new Error("setTimeout has not been defined");
              }
              function n() {
                  throw new Error("clearTimeout has not been defined");
              }
              function o(E) {
                  if (e === setTimeout) return setTimeout(E, 0);
                  if ((e === i || !e) && setTimeout) return e = setTimeout, setTimeout(E, 0);
                  try {
                      return e(E, 0);
                  } catch {
                      try {
                          return e.call(null, E, 0);
                      } catch {
                          return e.call(this || ni, E, 0);
                      }
                  }
              }
              !function() {
                  try {
                      e = "function" == typeof setTimeout ? setTimeout : i;
                  } catch {
                      e = i;
                  }
                  try {
                      r = "function" == typeof clearTimeout ? clearTimeout : n;
                  } catch {
                      r = n;
                  }
              }();
              var c, a = [], u = !1, h = -1;
              function d() {
                  !u || !c || (u = !1, c.length ? a = c.concat(a) : h = -1, a.length && g());
              }
              function g() {
                  if (!u) {
                      var E = o(d);
                      u = !0;
                      for (var S = a.length; S; ) {
                          for (c = a, a = []; ++h < S; ) c && c[h].run();
                          h = -1, S = a.length;
                      }
                      c = null, u = !1, function(E) {
                          if (r === clearTimeout) return clearTimeout(E);
                          if ((r === n || !r) && clearTimeout) return r = clearTimeout, clearTimeout(E);
                          try {
                              return r(E);
                          } catch {
                              try {
                                  return r.call(null, E);
                              } catch {
                                  return r.call(this || ni, E);
                              }
                          }
                      }(E);
                  }
              }
              function y(E, S) {
                  (this || ni).fun = E, (this || ni).array = S;
              }
              function w() {}
              return t.nextTick = function(E) {
                  var S = new Array(arguments.length - 1);
                  if (arguments.length > 1) for (var I = 1; I < arguments.length; I++) S[I - 1] = arguments[I];
                  a.push(new y(E, S)), 1 === a.length && !u && o(g);
              }, y.prototype.run = function() {
                  (this || ni).fun.apply(null, (this || ni).array);
              }, t.title = "browser", t.browser = !0, t.env = {}, t.argv = [], t.version = "", 
              t.versions = {}, t.on = w, t.addListener = w, t.once = w, t.off = w, t.removeListener = w, 
              t.removeAllListeners = w, t.emit = w, t.prependListener = w, t.prependOnceListener = w, 
              t.listeners = function(E) {
                  return [];
              }, t.binding = function(E) {
                  throw new Error("process.binding is not supported");
              }, t.cwd = function() {
                  return "/";
              }, t.chdir = function(E) {
                  throw new Error("process.chdir is not supported");
              }, t.umask = function() {
                  return 0;
              }, Ga;
          }
          var Ga, ng, ni, re, Qa = we((() => {
              v(), m(), _(), Ga = {}, ng = !1, ni = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : __webpack_require__.g, 
              (re = fE()).platform = "browser", re.addListener, re.argv, re.binding, re.browser, 
              re.chdir, re.cwd, re.emit, re.env, re.listeners, re.nextTick, re.off, re.on, re.once, 
              re.prependListener, re.prependOnceListener, re.removeAllListeners, re.removeListener, 
              re.title, re.umask, re.version, re.versions;
          }));
          var Ya, sg, Ja, og = we((() => {
              v(), m(), _(), Qa(), Ya = {}, sg = !1, Ja = function() {
                  if (sg) return Ya;
                  sg = !0;
                  var t = re;
                  function e(o) {
                      if ("string" != typeof o) throw new TypeError("Path must be a string. Received " + JSON.stringify(o));
                  }
                  function r(o, s) {
                      for (var d, a = "", u = 0, c = -1, h = 0, g = 0; g <= o.length; ++g) {
                          if (g < o.length) d = o.charCodeAt(g); else {
                              if (47 === d) break;
                              d = 47;
                          }
                          if (47 === d) {
                              if (c !== g - 1 && 1 !== h) if (c !== g - 1 && 2 === h) {
                                  if (a.length < 2 || 2 !== u || 46 !== a.charCodeAt(a.length - 1) || 46 !== a.charCodeAt(a.length - 2)) if (a.length > 2) {
                                      var y = a.lastIndexOf("/");
                                      if (y !== a.length - 1) {
                                          -1 === y ? (a = "", u = 0) : u = (a = a.slice(0, y)).length - 1 - a.lastIndexOf("/"), 
                                          c = g, h = 0;
                                          continue;
                                      }
                                  } else if (2 === a.length || 1 === a.length) {
                                      a = "", u = 0, c = g, h = 0;
                                      continue;
                                  }
                                  s && (a.length > 0 ? a += "/.." : a = "..", u = 2);
                              } else a.length > 0 ? a += "/" + o.slice(c + 1, g) : a = o.slice(c + 1, g), u = g - c - 1;
                              c = g, h = 0;
                          } else 46 === d && -1 !== h ? ++h : h = -1;
                      }
                      return a;
                  }
                  var n = {
                      resolve: function() {
                          for (var u, s = "", a = !1, c = arguments.length - 1; c >= -1 && !a; c--) {
                              var h;
                              c >= 0 ? h = arguments[c] : (void 0 === u && (u = t.cwd()), h = u), e(h), 0 !== h.length && (s = h + "/" + s, 
                              a = 47 === h.charCodeAt(0));
                          }
                          return s = r(s, !a), a ? s.length > 0 ? "/" + s : "/" : s.length > 0 ? s : ".";
                      },
                      normalize: function(s) {
                          if (e(s), 0 === s.length) return ".";
                          var a = 47 === s.charCodeAt(0), u = 47 === s.charCodeAt(s.length - 1);
                          return 0 === (s = r(s, !a)).length && !a && (s = "."), s.length > 0 && u && (s += "/"), 
                          a ? "/" + s : s;
                      },
                      isAbsolute: function(s) {
                          return e(s), s.length > 0 && 47 === s.charCodeAt(0);
                      },
                      join: function() {
                          if (0 === arguments.length) return ".";
                          for (var s, a = 0; a < arguments.length; ++a) {
                              var u = arguments[a];
                              e(u), u.length > 0 && (void 0 === s ? s = u : s += "/" + u);
                          }
                          return void 0 === s ? "." : n.normalize(s);
                      },
                      relative: function(s, a) {
                          if (e(s), e(a), s === a || (s = n.resolve(s)) === (a = n.resolve(a))) return "";
                          for (var u = 1; u < s.length && 47 === s.charCodeAt(u); ++u) ;
                          for (var c = s.length, h = c - u, d = 1; d < a.length && 47 === a.charCodeAt(d); ++d) ;
                          for (var y = a.length - d, w = h < y ? h : y, E = -1, S = 0; S <= w; ++S) {
                              if (S === w) {
                                  if (y > w) {
                                      if (47 === a.charCodeAt(d + S)) return a.slice(d + S + 1);
                                      if (0 === S) return a.slice(d + S);
                                  } else h > w && (47 === s.charCodeAt(u + S) ? E = S : 0 === S && (E = 0));
                                  break;
                              }
                              var I = s.charCodeAt(u + S);
                              if (I !== a.charCodeAt(d + S)) break;
                              47 === I && (E = S);
                          }
                          var R = "";
                          for (S = u + E + 1; S <= c; ++S) (S === c || 47 === s.charCodeAt(S)) && (0 === R.length ? R += ".." : R += "/..");
                          return R.length > 0 ? R + a.slice(d + E) : (d += E, 47 === a.charCodeAt(d) && ++d, 
                          a.slice(d));
                      },
                      _makeLong: function(s) {
                          return s;
                      },
                      dirname: function(s) {
                          if (e(s), 0 === s.length) return ".";
                          for (var a = s.charCodeAt(0), u = 47 === a, c = -1, h = !0, d = s.length - 1; d >= 1; --d) if (47 === (a = s.charCodeAt(d))) {
                              if (!h) {
                                  c = d;
                                  break;
                              }
                          } else h = !1;
                          return -1 === c ? u ? "/" : "." : u && 1 === c ? "//" : s.slice(0, c);
                      },
                      basename: function(s, a) {
                          if (void 0 !== a && "string" != typeof a) throw new TypeError('"ext" argument must be a string');
                          e(s);
                          var d, u = 0, c = -1, h = !0;
                          if (void 0 !== a && a.length > 0 && a.length <= s.length) {
                              if (a.length === s.length && a === s) return "";
                              var g = a.length - 1, y = -1;
                              for (d = s.length - 1; d >= 0; --d) {
                                  var w = s.charCodeAt(d);
                                  if (47 === w) {
                                      if (!h) {
                                          u = d + 1;
                                          break;
                                      }
                                  } else -1 === y && (h = !1, y = d + 1), g >= 0 && (w === a.charCodeAt(g) ? -1 == --g && (c = d) : (g = -1, 
                                  c = y));
                              }
                              return u === c ? c = y : -1 === c && (c = s.length), s.slice(u, c);
                          }
                          for (d = s.length - 1; d >= 0; --d) if (47 === s.charCodeAt(d)) {
                              if (!h) {
                                  u = d + 1;
                                  break;
                              }
                          } else -1 === c && (h = !1, c = d + 1);
                          return -1 === c ? "" : s.slice(u, c);
                      },
                      extname: function(s) {
                          e(s);
                          for (var a = -1, u = 0, c = -1, h = !0, d = 0, g = s.length - 1; g >= 0; --g) {
                              var y = s.charCodeAt(g);
                              if (47 !== y) -1 === c && (h = !1, c = g + 1), 46 === y ? -1 === a ? a = g : 1 !== d && (d = 1) : -1 !== a && (d = -1); else if (!h) {
                                  u = g + 1;
                                  break;
                              }
                          }
                          return -1 === a || -1 === c || 0 === d || 1 === d && a === c - 1 && a === u + 1 ? "" : s.slice(a, c);
                      },
                      format: function(s) {
                          if (null === s || "object" != typeof s) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof s);
                          return function(o, s) {
                              var a = s.dir || s.root, u = s.base || (s.name || "") + (s.ext || "");
                              return a ? a === s.root ? a + u : a + o + u : u;
                          }("/", s);
                      },
                      parse: function(s) {
                          e(s);
                          var a = {
                              root: "",
                              dir: "",
                              base: "",
                              ext: "",
                              name: ""
                          };
                          if (0 === s.length) return a;
                          var h, u = s.charCodeAt(0), c = 47 === u;
                          c ? (a.root = "/", h = 1) : h = 0;
                          for (var d = -1, g = 0, y = -1, w = !0, E = s.length - 1, S = 0; E >= h; --E) if (47 !== (u = s.charCodeAt(E))) -1 === y && (w = !1, 
                          y = E + 1), 46 === u ? -1 === d ? d = E : 1 !== S && (S = 1) : -1 !== d && (S = -1); else if (!w) {
                              g = E + 1;
                              break;
                          }
                          return -1 === d || -1 === y || 0 === S || 1 === S && d === y - 1 && d === g + 1 ? -1 !== y && (a.base = a.name = 0 === g && c ? s.slice(1, y) : s.slice(g, y)) : (0 === g && c ? (a.name = s.slice(1, d), 
                          a.base = s.slice(1, y)) : (a.name = s.slice(g, d), a.base = s.slice(g, y)), a.ext = s.slice(d, y)), 
                          g > 0 ? a.dir = s.slice(0, g - 1) : c && (a.dir = "/"), a;
                      },
                      sep: "/",
                      delimiter: ":",
                      win32: null,
                      posix: null
                  };
                  return n.posix = n, Ya = n;
              }();
          })), pg = {};
          function Fe() {
              this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, 
              this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, 
              this.path = null, this.href = null;
          }
          function xi(t, e, r) {
              if (t && gt.isObject(t) && t instanceof Fe) return t;
              var i = new Fe;
              return i.parse(t, e, r), i;
          }
          function OE(t) {
              if ("string" == typeof t) t = new URL(t); else if (!(t instanceof URL)) throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
              if ("file:" !== t.protocol) throw new Deno.errors.InvalidData("invalid url scheme");
              return rl ? function(t) {
                  let e = t.hostname, r = t.pathname;
                  for (let i = 0; i < r.length; i++) if ("%" === r[i]) {
                      let n = r.codePointAt(i + 2) || 32;
                      if ("2" === r[i + 1] && 102 === n || "5" === r[i + 1] && 99 === n) throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
                  }
                  if (r = r.replace(IE, "\\"), r = decodeURIComponent(r), "" !== e) return `\\\\${e}${r}`;
                  {
                      let i = 32 | r.codePointAt(1), n = r[2];
                      if (i < SE || i > AE || ":" !== n) throw new Deno.errors.InvalidData("file url path must be absolute");
                      return r.slice(1);
                  }
              }(t) : function(t) {
                  if ("" !== t.hostname) throw new Deno.errors.InvalidData("invalid file url hostname");
                  let e = t.pathname;
                  for (let r = 0; r < e.length; r++) if ("%" === e[r]) {
                      let i = e.codePointAt(r + 2) || 32;
                      if ("2" === e[r + 1] && 102 === i) throw new Deno.errors.InvalidData("must not include encoded / characters");
                  }
                  return decodeURIComponent(e);
              }(t);
          }
          function ME(t) {
              let e = cg.resolve(t), r = t.charCodeAt(t.length - 1);
              (r === EE || rl && r === vE) && e[e.length - 1] !== cg.sep && (e += "/");
              let i = new URL("file://");
              return e.includes("%") && (e = e.replace(TE, "%25")), !rl && e.includes("\\") && (e = e.replace(RE, "%5C")), 
              e.includes("\n") && (e = e.replace(CE, "%0A")), e.includes("\r") && (e = e.replace(BE, "%0D")), 
              e.includes("\t") && (e = e.replace(PE, "%09")), i.pathname = e, i;
          }
          function hg(t) {
              if ("string" == typeof t) t = new URL(t); else if (!(t instanceof URL)) throw new Deno.errors.InvalidData("invalid argument path , must be a string or URL");
              if ("file:" !== t.protocol) throw new Deno.errors.InvalidData("invalid url scheme");
              return il ? function(t) {
                  let e = t.hostname, r = t.pathname;
                  for (let i = 0; i < r.length; i++) if ("%" === r[i]) {
                      let n = r.codePointAt(i + 2) || 32;
                      if ("2" === r[i + 1] && 102 === n || "5" === r[i + 1] && 99 === n) throw new Deno.errors.InvalidData("must not include encoded \\ or / characters");
                  }
                  if (r = r.replace(zE, "\\"), r = decodeURIComponent(r), "" !== e) return `\\\\${e}${r}`;
                  {
                      let i = 32 | r.codePointAt(1), n = r[2];
                      if (i < HE || i > VE || ":" !== n) throw new Deno.errors.InvalidData("file url path must be absolute");
                      return r.slice(1);
                  }
              }(t) : function(t) {
                  if ("" !== t.hostname) throw new Deno.errors.InvalidData("invalid file url hostname");
                  let e = t.pathname;
                  for (let r = 0; r < e.length; r++) if ("%" === e[r]) {
                      let i = e.codePointAt(r + 2) || 32;
                      if ("2" === e[r + 1] && 102 === i) throw new Deno.errors.InvalidData("must not include encoded / characters");
                  }
                  return decodeURIComponent(e);
              }(t);
          }
          function dg(t) {
              let e = Ja.resolve(t), r = t.charCodeAt(t.length - 1);
              (r === $E || il && r === WE) && e[e.length - 1] !== Ja.sep && (e += "/");
              let i = new URL("file://");
              return e.includes("%") && (e = e.replace(KE, "%25")), !il && e.includes("\\") && (e = e.replace(GE, "%5C")), 
              e.includes("\n") && (e = e.replace(QE, "%0A")), e.includes("\r") && (e = e.replace(YE, "%0D")), 
              e.includes("\t") && (e = e.replace(JE, "%09")), i.pathname = e, i;
          }
          Qt(pg, {
              URL: () => FE,
              Url: () => UE,
              default: () => Z,
              fileURLToPath: () => hg,
              format: () => NE,
              parse: () => jE,
              pathToFileURL: () => dg,
              resolve: () => qE,
              resolveObject: () => DE
          });
          var Z, hE, gt, dE, pE, gE, yE, tl, ag, lg, ug, bE, wE, Xa, si, Za, el, fg, cg, mE, vE, EE, SE, AE, rl, IE, TE, RE, CE, BE, PE, LE, UE, NE, qE, DE, jE, FE, WE, $E, HE, VE, il, zE, KE, GE, QE, YE, JE, gg = we((() => {
              v(), m(), _(), Jp(), Xp(), ig(), og(), Qa(), hE = zt, gt = {
                  isString: function(t) {
                      return "string" == typeof t;
                  },
                  isObject: function(t) {
                      return "object" == typeof t && null !== t;
                  },
                  isNull: function(t) {
                      return null === t;
                  },
                  isNullOrUndefined: function(t) {
                      return null == t;
                  }
              }, (Z = {}).parse = xi, Z.resolve = function(t, e) {
                  return xi(t, !1, !0).resolve(e);
              }, Z.resolveObject = function(t, e) {
                  return t ? xi(t, !1, !0).resolveObject(e) : e;
              }, Z.format = function(t) {
                  return gt.isString(t) && (t = xi(t)), t instanceof Fe ? t.format() : Fe.prototype.format.call(t);
              }, Z.Url = Fe, dE = /^([a-z0-9.+-]+:)/i, pE = /:[0-9]*$/, gE = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, 
              yE = [ "{", "}", "|", "\\", "^", "`" ].concat([ "<", ">", '"', "`", " ", "\r", "\n", "\t" ]), 
              tl = [ "'" ].concat(yE), ag = [ "%", "/", "?", ";", "#" ].concat(tl), lg = [ "/", "?", "#" ], 
              ug = /^[+a-z0-9A-Z_-]{0,63}$/, bE = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, wE = {
                  javascript: !0,
                  "javascript:": !0
              }, Xa = {
                  javascript: !0,
                  "javascript:": !0
              }, si = {
                  http: !0,
                  https: !0,
                  ftp: !0,
                  gopher: !0,
                  file: !0,
                  "http:": !0,
                  "https:": !0,
                  "ftp:": !0,
                  "gopher:": !0,
                  "file:": !0
              }, Za = pt, Fe.prototype.parse = function(t, e, r) {
                  if (!gt.isString(t)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
                  var i = t.indexOf("?"), n = -1 !== i && i < t.indexOf("#") ? "?" : "#", o = t.split(n);
                  o[0] = o[0].replace(/\\/g, "/");
                  var s = t = o.join(n);
                  if (s = s.trim(), !r && 1 === t.split("#").length) {
                      var a = gE.exec(s);
                      if (a) return this.path = s, this.href = s, this.pathname = a[1], a[2] ? (this.search = a[2], 
                      this.query = e ? Za.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", 
                      this.query = {}), this;
                  }
                  var u = dE.exec(s);
                  if (u) {
                      var c = (u = u[0]).toLowerCase();
                      this.protocol = c, s = s.substr(u.length);
                  }
                  if (r || u || s.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                      var h = "//" === s.substr(0, 2);
                      !h || u && Xa[u] || (s = s.substr(2), this.slashes = !0);
                  }
                  if (!Xa[u] && (h || u && !si[u])) {
                      for (var d, g, y = -1, w = 0; w < lg.length; w++) -1 !== (E = s.indexOf(lg[w])) && (-1 === y || E < y) && (y = E);
                      for (-1 !== (g = -1 === y ? s.lastIndexOf("@") : s.lastIndexOf("@", y)) && (d = s.slice(0, g), 
                      s = s.slice(g + 1), this.auth = decodeURIComponent(d)), y = -1, w = 0; w < ag.length; w++) {
                          var E;
                          -1 !== (E = s.indexOf(ag[w])) && (-1 === y || E < y) && (y = E);
                      }
                      -1 === y && (y = s.length), this.host = s.slice(0, y), s = s.slice(y), this.parseHost(), 
                      this.hostname = this.hostname || "";
                      var S = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                      if (!S) for (var I = this.hostname.split(/\./), C = (w = 0, I.length); w < C; w++) {
                          var R = I[w];
                          if (R && !R.match(ug)) {
                              for (var U = "", N = 0, W = R.length; N < W; N++) R.charCodeAt(N) > 127 ? U += "x" : U += R[N];
                              if (!U.match(ug)) {
                                  var K = I.slice(0, w), z = I.slice(w + 1), Q = R.match(bE);
                                  Q && (K.push(Q[1]), z.unshift(Q[2])), z.length && (s = "/" + z.join(".") + s), this.hostname = K.join(".");
                                  break;
                              }
                          }
                      }
                      this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), 
                      S || (this.hostname = hE.toASCII(this.hostname));
                      var de = this.port ? ":" + this.port : "", Gt = this.hostname || "";
                      this.host = Gt + de, this.href += this.host, S && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), 
                      "/" !== s[0] && (s = "/" + s));
                  }
                  if (!wE[c]) for (w = 0, C = tl.length; w < C; w++) {
                      var pe = tl[w];
                      if (-1 !== s.indexOf(pe)) {
                          var Cr = encodeURIComponent(pe);
                          Cr === pe && (Cr = escape(pe)), s = s.split(pe).join(Cr);
                      }
                  }
                  var Br = s.indexOf("#");
                  -1 !== Br && (this.hash = s.substr(Br), s = s.slice(0, Br));
                  var Pr = s.indexOf("?");
                  if (-1 !== Pr ? (this.search = s.substr(Pr), this.query = s.substr(Pr + 1), e && (this.query = Za.parse(this.query)), 
                  s = s.slice(0, Pr)) : e && (this.search = "", this.query = {}), s && (this.pathname = s), 
                  si[c] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                      de = this.pathname || "";
                      var fs = this.search || "";
                      this.path = de + fs;
                  }
                  return this.href = this.format(), this;
              }, Fe.prototype.format = function() {
                  var t = this.auth || "";
                  t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
                  var e = this.protocol || "", r = this.pathname || "", i = this.hash || "", n = !1, o = "";
                  this.host ? n = t + this.host : this.hostname && (n = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), 
                  this.port && (n += ":" + this.port)), this.query && gt.isObject(this.query) && Object.keys(this.query).length && (o = Za.stringify(this.query));
                  var s = this.search || o && "?" + o || "";
                  return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || si[e]) && !1 !== n ? (n = "//" + (n || ""), 
                  r && "/" !== r.charAt(0) && (r = "/" + r)) : n || (n = ""), i && "#" !== i.charAt(0) && (i = "#" + i), 
                  s && "?" !== s.charAt(0) && (s = "?" + s), e + n + (r = r.replace(/[?#]/g, (function(a) {
                      return encodeURIComponent(a);
                  }))) + (s = s.replace("#", "%23")) + i;
              }, Fe.prototype.resolve = function(t) {
                  return this.resolveObject(xi(t, !1, !0)).format();
              }, Fe.prototype.resolveObject = function(t) {
                  if (gt.isString(t)) {
                      var e = new Fe;
                      e.parse(t, !1, !0), t = e;
                  }
                  for (var r = new Fe, i = Object.keys(this), n = 0; n < i.length; n++) {
                      var o = i[n];
                      r[o] = this[o];
                  }
                  if (r.hash = t.hash, "" === t.href) return r.href = r.format(), r;
                  if (t.slashes && !t.protocol) {
                      for (var s = Object.keys(t), a = 0; a < s.length; a++) {
                          var u = s[a];
                          "protocol" !== u && (r[u] = t[u]);
                      }
                      return si[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), 
                      r.href = r.format(), r;
                  }
                  if (t.protocol && t.protocol !== r.protocol) {
                      if (!si[t.protocol]) {
                          for (var c = Object.keys(t), h = 0; h < c.length; h++) {
                              var d = c[h];
                              r[d] = t[d];
                          }
                          return r.href = r.format(), r;
                      }
                      if (r.protocol = t.protocol, t.host || Xa[t.protocol]) r.pathname = t.pathname; else {
                          for (var g = (t.pathname || "").split("/"); g.length && !(t.host = g.shift()); ) ;
                          t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== g[0] && g.unshift(""), 
                          g.length < 2 && g.unshift(""), r.pathname = g.join("/");
                      }
                      if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, 
                      r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
                          var y = r.pathname || "", w = r.search || "";
                          r.path = y + w;
                      }
                      return r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
                  }
                  var E = r.pathname && "/" === r.pathname.charAt(0), S = t.host || t.pathname && "/" === t.pathname.charAt(0), I = S || E || r.host && t.pathname, C = I, R = r.pathname && r.pathname.split("/") || [], U = (g = t.pathname && t.pathname.split("/") || [], 
                  r.protocol && !si[r.protocol]);
                  if (U && (r.hostname = "", r.port = null, r.host && ("" === R[0] ? R[0] = r.host : R.unshift(r.host)), 
                  r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === g[0] ? g[0] = t.host : g.unshift(t.host)), 
                  t.host = null), I = I && ("" === g[0] || "" === R[0])), S) r.host = t.host || "" === t.host ? t.host : r.host, 
                  r.hostname = t.hostname || "" === t.hostname ? t.hostname : r.hostname, r.search = t.search, 
                  r.query = t.query, R = g; else if (g.length) R || (R = []), R.pop(), R = R.concat(g), 
                  r.search = t.search, r.query = t.query; else if (!gt.isNullOrUndefined(t.search)) return U && (r.hostname = r.host = R.shift(), 
                  (Q = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = Q.shift(), 
                  r.host = r.hostname = Q.shift())), r.search = t.search, r.query = t.query, gt.isNull(r.pathname) && gt.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), 
                  r.href = r.format(), r;
                  if (!R.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, 
                  r.href = r.format(), r;
                  for (var N = R.slice(-1)[0], W = (r.host || t.host || R.length > 1) && ("." === N || ".." === N) || "" === N, K = 0, z = R.length; z >= 0; z--) "." === (N = R[z]) ? R.splice(z, 1) : ".." === N ? (R.splice(z, 1), 
                  K++) : K && (R.splice(z, 1), K--);
                  if (!I && !C) for (;K--; K) R.unshift("..");
                  !I || "" === R[0] || R[0] && "/" === R[0].charAt(0) || R.unshift(""), W && "/" !== R.join("/").substr(-1) && R.push("");
                  var Q, de = "" === R[0] || R[0] && "/" === R[0].charAt(0);
                  return U && (r.hostname = r.host = de ? "" : R.length ? R.shift() : "", (Q = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = Q.shift(), 
                  r.host = r.hostname = Q.shift())), (I = I || r.host && R.length) && !de && R.unshift(""), 
                  R.length ? r.pathname = R.join("/") : (r.pathname = null, r.path = null), gt.isNull(r.pathname) && gt.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), 
                  r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), 
                  r;
              }, Fe.prototype.parseHost = function() {
                  var t = this.host, e = pE.exec(t);
                  e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), 
                  t && (this.hostname = t);
              }, Z.Url, Z.format, Z.resolve, Z.resolveObject, el = {}, fg = !1, cg = function() {
                  if (fg) return el;
                  fg = !0;
                  var t = ne;
                  function e(o) {
                      if ("string" != typeof o) throw new TypeError("Path must be a string. Received " + JSON.stringify(o));
                  }
                  function r(o, s) {
                      for (var d, a = "", u = 0, c = -1, h = 0, g = 0; g <= o.length; ++g) {
                          if (g < o.length) d = o.charCodeAt(g); else {
                              if (47 === d) break;
                              d = 47;
                          }
                          if (47 === d) {
                              if (c !== g - 1 && 1 !== h) if (c !== g - 1 && 2 === h) {
                                  if (a.length < 2 || 2 !== u || 46 !== a.charCodeAt(a.length - 1) || 46 !== a.charCodeAt(a.length - 2)) if (a.length > 2) {
                                      var y = a.lastIndexOf("/");
                                      if (y !== a.length - 1) {
                                          -1 === y ? (a = "", u = 0) : u = (a = a.slice(0, y)).length - 1 - a.lastIndexOf("/"), 
                                          c = g, h = 0;
                                          continue;
                                      }
                                  } else if (2 === a.length || 1 === a.length) {
                                      a = "", u = 0, c = g, h = 0;
                                      continue;
                                  }
                                  s && (a.length > 0 ? a += "/.." : a = "..", u = 2);
                              } else a.length > 0 ? a += "/" + o.slice(c + 1, g) : a = o.slice(c + 1, g), u = g - c - 1;
                              c = g, h = 0;
                          } else 46 === d && -1 !== h ? ++h : h = -1;
                      }
                      return a;
                  }
                  var n = {
                      resolve: function() {
                          for (var u, s = "", a = !1, c = arguments.length - 1; c >= -1 && !a; c--) {
                              var h;
                              c >= 0 ? h = arguments[c] : (void 0 === u && (u = t.cwd()), h = u), e(h), 0 !== h.length && (s = h + "/" + s, 
                              a = 47 === h.charCodeAt(0));
                          }
                          return s = r(s, !a), a ? s.length > 0 ? "/" + s : "/" : s.length > 0 ? s : ".";
                      },
                      normalize: function(s) {
                          if (e(s), 0 === s.length) return ".";
                          var a = 47 === s.charCodeAt(0), u = 47 === s.charCodeAt(s.length - 1);
                          return 0 === (s = r(s, !a)).length && !a && (s = "."), s.length > 0 && u && (s += "/"), 
                          a ? "/" + s : s;
                      },
                      isAbsolute: function(s) {
                          return e(s), s.length > 0 && 47 === s.charCodeAt(0);
                      },
                      join: function() {
                          if (0 === arguments.length) return ".";
                          for (var s, a = 0; a < arguments.length; ++a) {
                              var u = arguments[a];
                              e(u), u.length > 0 && (void 0 === s ? s = u : s += "/" + u);
                          }
                          return void 0 === s ? "." : n.normalize(s);
                      },
                      relative: function(s, a) {
                          if (e(s), e(a), s === a || (s = n.resolve(s)) === (a = n.resolve(a))) return "";
                          for (var u = 1; u < s.length && 47 === s.charCodeAt(u); ++u) ;
                          for (var c = s.length, h = c - u, d = 1; d < a.length && 47 === a.charCodeAt(d); ++d) ;
                          for (var y = a.length - d, w = h < y ? h : y, E = -1, S = 0; S <= w; ++S) {
                              if (S === w) {
                                  if (y > w) {
                                      if (47 === a.charCodeAt(d + S)) return a.slice(d + S + 1);
                                      if (0 === S) return a.slice(d + S);
                                  } else h > w && (47 === s.charCodeAt(u + S) ? E = S : 0 === S && (E = 0));
                                  break;
                              }
                              var I = s.charCodeAt(u + S);
                              if (I !== a.charCodeAt(d + S)) break;
                              47 === I && (E = S);
                          }
                          var R = "";
                          for (S = u + E + 1; S <= c; ++S) (S === c || 47 === s.charCodeAt(S)) && (0 === R.length ? R += ".." : R += "/..");
                          return R.length > 0 ? R + a.slice(d + E) : (d += E, 47 === a.charCodeAt(d) && ++d, 
                          a.slice(d));
                      },
                      _makeLong: function(s) {
                          return s;
                      },
                      dirname: function(s) {
                          if (e(s), 0 === s.length) return ".";
                          for (var a = s.charCodeAt(0), u = 47 === a, c = -1, h = !0, d = s.length - 1; d >= 1; --d) if (47 === (a = s.charCodeAt(d))) {
                              if (!h) {
                                  c = d;
                                  break;
                              }
                          } else h = !1;
                          return -1 === c ? u ? "/" : "." : u && 1 === c ? "//" : s.slice(0, c);
                      },
                      basename: function(s, a) {
                          if (void 0 !== a && "string" != typeof a) throw new TypeError('"ext" argument must be a string');
                          e(s);
                          var d, u = 0, c = -1, h = !0;
                          if (void 0 !== a && a.length > 0 && a.length <= s.length) {
                              if (a.length === s.length && a === s) return "";
                              var g = a.length - 1, y = -1;
                              for (d = s.length - 1; d >= 0; --d) {
                                  var w = s.charCodeAt(d);
                                  if (47 === w) {
                                      if (!h) {
                                          u = d + 1;
                                          break;
                                      }
                                  } else -1 === y && (h = !1, y = d + 1), g >= 0 && (w === a.charCodeAt(g) ? -1 == --g && (c = d) : (g = -1, 
                                  c = y));
                              }
                              return u === c ? c = y : -1 === c && (c = s.length), s.slice(u, c);
                          }
                          for (d = s.length - 1; d >= 0; --d) if (47 === s.charCodeAt(d)) {
                              if (!h) {
                                  u = d + 1;
                                  break;
                              }
                          } else -1 === c && (h = !1, c = d + 1);
                          return -1 === c ? "" : s.slice(u, c);
                      },
                      extname: function(s) {
                          e(s);
                          for (var a = -1, u = 0, c = -1, h = !0, d = 0, g = s.length - 1; g >= 0; --g) {
                              var y = s.charCodeAt(g);
                              if (47 !== y) -1 === c && (h = !1, c = g + 1), 46 === y ? -1 === a ? a = g : 1 !== d && (d = 1) : -1 !== a && (d = -1); else if (!h) {
                                  u = g + 1;
                                  break;
                              }
                          }
                          return -1 === a || -1 === c || 0 === d || 1 === d && a === c - 1 && a === u + 1 ? "" : s.slice(a, c);
                      },
                      format: function(s) {
                          if (null === s || "object" != typeof s) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof s);
                          return function(o, s) {
                              var a = s.dir || s.root, u = s.base || (s.name || "") + (s.ext || "");
                              return a ? a === s.root ? a + u : a + o + u : u;
                          }("/", s);
                      },
                      parse: function(s) {
                          e(s);
                          var a = {
                              root: "",
                              dir: "",
                              base: "",
                              ext: "",
                              name: ""
                          };
                          if (0 === s.length) return a;
                          var h, u = s.charCodeAt(0), c = 47 === u;
                          c ? (a.root = "/", h = 1) : h = 0;
                          for (var d = -1, g = 0, y = -1, w = !0, E = s.length - 1, S = 0; E >= h; --E) if (47 !== (u = s.charCodeAt(E))) -1 === y && (w = !1, 
                          y = E + 1), 46 === u ? -1 === d ? d = E : 1 !== S && (S = 1) : -1 !== d && (S = -1); else if (!w) {
                              g = E + 1;
                              break;
                          }
                          return -1 === d || -1 === y || 0 === S || 1 === S && d === y - 1 && d === g + 1 ? -1 !== y && (a.base = a.name = 0 === g && c ? s.slice(1, y) : s.slice(g, y)) : (0 === g && c ? (a.name = s.slice(1, d), 
                          a.base = s.slice(1, y)) : (a.name = s.slice(g, d), a.base = s.slice(g, y)), a.ext = s.slice(d, y)), 
                          g > 0 ? a.dir = s.slice(0, g - 1) : c && (a.dir = "/"), a;
                      },
                      sep: "/",
                      delimiter: ":",
                      win32: null,
                      posix: null
                  };
                  return n.posix = n, el = n;
              }(), mE = typeof Deno < "u" ? "windows" === Deno.build.os ? "win32" : Deno.build.os : void 0, 
              Z.URL = typeof URL < "u" ? URL : null, Z.pathToFileURL = ME, Z.fileURLToPath = OE, 
              Z.Url, Z.format, Z.resolve, Z.resolveObject, Z.URL, vE = 92, EE = 47, SE = 97, AE = 122, 
              rl = "win32" === mE, IE = /\//g, TE = /%/g, RE = /\\/g, CE = /\n/g, BE = /\r/g, 
              PE = /\t/g, LE = typeof Deno < "u" ? "windows" === Deno.build.os ? "win32" : Deno.build.os : void 0, 
              Z.URL = typeof URL < "u" ? URL : null, Z.pathToFileURL = dg, Z.fileURLToPath = hg, 
              UE = Z.Url, NE = Z.format, qE = Z.resolve, DE = Z.resolveObject, jE = Z.parse, FE = Z.URL, 
              WE = 92, $E = 47, HE = 97, VE = 122, il = "win32" === LE, zE = /\//g, KE = /%/g, 
              GE = /\\/g, QE = /\n/g, YE = /\r/g, JE = /\t/g;
          })), nl = {};
          function Me() {
              throw new Error("Node.js net module is not supported by JSPM core outside of Node.js");
          }
          Qt(nl, {
              Server: () => Me,
              Socket: () => Me,
              Stream: () => Me,
              _createServerHandle: () => Me,
              _normalizeArgs: () => Me,
              _setSimultaneousAccepts: () => Me,
              connect: () => Me,
              createConnection: () => Me,
              createServer: () => Me,
              default: () => eS,
              isIP: () => Me,
              isIPv4: () => Me,
              isIPv6: () => Me
          });
          var eS, sl = we((() => {
              v(), m(), _(), eS = {
                  _createServerHandle: Me,
                  _normalizeArgs: Me,
                  _setSimultaneousAccepts: Me,
                  connect: Me,
                  createConnection: Me,
                  createServer: Me,
                  isIP: Me,
                  isIPv4: Me,
                  isIPv6: Me,
                  Server: Me,
                  Socket: Me,
                  Stream: Me
              };
          })), ol = M((Mi => {
              v(), m(), _();
              var yg = Mi && Mi.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Mi, "__esModule", {
                  value: !0
              });
              var tS = yg((sl(), X(nl))), iS = (0, yg(ot()).default)("mqttjs:tcp");
              Mi.default = (t, e) => {
                  e.port = e.port || 1883, e.hostname = e.hostname || e.host || "localhost";
                  let {port: r} = e, i = e.hostname;
                  return iS("port %d and host %s", r, i), tS.default.createConnection(r, i);
              };
          })), bg = {};
          Qt(bg, {
              default: () => sS
          });
          var sS, wg = we((() => {
              v(), m(), _(), sS = {};
          })), ll = M((Li => {
              v(), m(), _();
              var al = Li && Li.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Li, "__esModule", {
                  value: !0
              });
              var oS = al((wg(), X(bg))), aS = al((sl(), X(nl))), uS = (0, al(ot()).default)("mqttjs:tls");
              Li.default = (t, e) => {
                  e.port = e.port || 8883, e.host = e.hostname || e.host || "localhost", 0 === aS.default.isIP(e.host) && (e.servername = e.host), 
                  e.rejectUnauthorized = !1 !== e.rejectUnauthorized, delete e.path, uS("port %d host %s rejectUnauthorized %b", e.port, e.host, e.rejectUnauthorized);
                  let r = oS.default.connect(e);
                  function i(n) {
                      e.rejectUnauthorized && t.emit("error", n), r.end();
                  }
                  return r.on("secureConnect", (() => {
                      e.rejectUnauthorized && !r.authorized ? r.emit("error", new Error("TLS not authorized")) : r.removeListener("error", i);
                  })), r.on("error", i), r;
              };
          })), as = M((oi => {
              v(), m(), _(), Object.defineProperty(oi, "__esModule", {
                  value: !0
              }), oi.BufferedDuplex = oi.writev = void 0;
              var cS = jt(), _g = (ye(), X(_e));
              function mg(t, e) {
                  let r = new Array(t.length);
                  for (let i = 0; i < t.length; i++) "string" == typeof t[i].chunk ? r[i] = _g.Buffer.from(t[i].chunk, "utf8") : r[i] = t[i].chunk;
                  this._write(_g.Buffer.concat(r), "binary", e);
              }
              oi.writev = mg;
              var ul = class extends cS.Duplex {
                  constructor(e, r, i) {
                      super({
                          objectMode: !0
                      }), this.proxy = r, this.socket = i, this.writeQueue = [], e.objectMode || (this._writev = mg.bind(this)), 
                      this.isSocketOpen = !1, this.proxy.on("data", (n => {
                          this.push(n);
                      }));
                  }
                  _read(e) {
                      this.proxy.read(e);
                  }
                  _write(e, r, i) {
                      this.isSocketOpen ? this.writeToProxy(e, r, i) : this.writeQueue.push({
                          chunk: e,
                          encoding: r,
                          cb: i
                      });
                  }
                  _final(e) {
                      this.writeQueue = [], this.proxy.end(e);
                  }
                  _destroy(e, r) {
                      this.writeQueue = [], this.proxy.destroy(), r(e);
                  }
                  socketReady() {
                      this.emit("connect"), this.isSocketOpen = !0, this.processWriteQueue();
                  }
                  writeToProxy(e, r, i) {
                      !1 === this.proxy.write(e, r) ? this.proxy.once("drain", i) : i();
                  }
                  processWriteQueue() {
                      for (;this.writeQueue.length > 0; ) {
                          let {chunk: e, encoding: r, cb: i} = this.writeQueue.shift();
                          this.writeToProxy(e, r, i);
                      }
                  }
              };
              oi.BufferedDuplex = ul;
          })), hl = M((cl => {
              v(), m(), _(), Object.defineProperty(cl, "__esModule", {
                  value: !0
              });
              var yt, fl, Le, vg = (ye(), X(_e)), hS = jt(), dS = as();
              cl.default = (t, e) => {
                  if (e.hostname = e.hostname || e.host, !e.hostname) throw new Error("Could not determine host. Specify host manually.");
                  let r = "MQIsdp" === e.protocolId && 3 === e.protocolVersion ? "mqttv3.1" : "mqtt";
                  !function(t) {
                      t.hostname || (t.hostname = "localhost"), t.path || (t.path = "/"), t.wsOptions || (t.wsOptions = {});
                  }(e);
                  let i = function(t, e) {
                      let r = "wxs" === t.protocol ? "wss" : "ws", i = `${r}://${t.hostname}${t.path}`;
                      return t.port && 80 !== t.port && 443 !== t.port && (i = `${r}://${t.hostname}:${t.port}${t.path}`), 
                      "function" == typeof t.transformWsUrl && (i = t.transformWsUrl(i, t, e)), i;
                  }(e, t);
                  yt = wx.connectSocket({
                      url: i,
                      protocols: [ r ]
                  }), fl = function() {
                      let t = new hS.Transform;
                      return t._write = (e, r, i) => {
                          yt.send({
                              data: e.buffer,
                              success() {
                                  i();
                              },
                              fail(n) {
                                  i(new Error(n));
                              }
                          });
                      }, t._flush = e => {
                          yt.close({
                              success() {
                                  e();
                              }
                          });
                      }, t;
                  }(), (Le = new dS.BufferedDuplex(e, fl, yt))._destroy = (o, s) => {
                      yt.close({
                          success() {
                              s && s(o);
                          }
                      });
                  };
                  let n = Le.destroy;
                  return Le.destroy = (o, s) => (Le.destroy = n, setTimeout((() => {
                      yt.close({
                          fail() {
                              Le._destroy(o, s);
                          }
                      });
                  }), 0), Le), yt.onOpen((() => {
                      Le.socketReady();
                  })), yt.onMessage((t => {
                      let {data: e} = t;
                      e = e instanceof ArrayBuffer ? vg.Buffer.from(e) : vg.Buffer.from(e, "utf8"), fl.push(e);
                  })), yt.onClose((() => {
                      Le.emit("close"), Le.end(), Le.destroy();
                  })), yt.onError((t => {
                      let e = new Error(t.errMsg);
                      Le.destroy(e);
                  })), Le;
              };
          })), gl = M((pl => {
              v(), m(), _(), Object.defineProperty(pl, "__esModule", {
                  value: !0
              });
              var xt, ls, ai, dl = (ye(), X(_e)), _S = jt(), mS = as(), Eg = !1;
              pl.default = (t, e) => {
                  if (e.hostname = e.hostname || e.host, !e.hostname) throw new Error("Could not determine host. Specify host manually.");
                  let r = "MQIsdp" === e.protocolId && 3 === e.protocolVersion ? "mqttv3.1" : "mqtt";
                  !function(t) {
                      t.hostname || (t.hostname = "localhost"), t.path || (t.path = "/"), t.wsOptions || (t.wsOptions = {});
                  }(e);
                  let i = function(t, e) {
                      let r = "alis" === t.protocol ? "wss" : "ws", i = `${r}://${t.hostname}${t.path}`;
                      return t.port && 80 !== t.port && 443 !== t.port && (i = `${r}://${t.hostname}:${t.port}${t.path}`), 
                      "function" == typeof t.transformWsUrl && (i = t.transformWsUrl(i, t, e)), i;
                  }(e, t);
                  return (xt = e.my).connectSocket({
                      url: i,
                      protocols: r
                  }), ls = function() {
                      let t = new _S.Transform;
                      return t._write = (e, r, i) => {
                          xt.sendSocketMessage({
                              data: e.buffer,
                              success() {
                                  i();
                              },
                              fail() {
                                  i(new Error);
                              }
                          });
                      }, t._flush = e => {
                          xt.closeSocket({
                              success() {
                                  e();
                              }
                          });
                      }, t;
                  }(), ai = new mS.BufferedDuplex(e, ls, xt), Eg || (Eg = !0, xt.onSocketOpen((() => {
                      ai.socketReady();
                  })), xt.onSocketMessage((t => {
                      if ("string" == typeof t.data) {
                          let e = dl.Buffer.from(t.data, "base64");
                          ls.push(e);
                      } else {
                          let e = new FileReader;
                          e.addEventListener("load", (() => {
                              let r = e.result;
                              r = r instanceof ArrayBuffer ? dl.Buffer.from(r) : dl.Buffer.from(r, "utf8"), ls.push(r);
                          })), e.readAsArrayBuffer(t.data);
                      }
                  })), xt.onSocketClose((() => {
                      ai.end(), ai.destroy();
                  })), xt.onSocketError((t => {
                      ai.destroy(t);
                  }))), ai;
              };
          })), Ag = M(((xD, Sg) => {
              v(), m(), _(), Sg.exports = function() {
                  throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
              };
          })), _l = M((Ui => {
              v(), m(), _();
              var wl = Ui && Ui.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Ui, "__esModule", {
                  value: !0
              });
              var yl = (ye(), X(_e)), Ig = wl(Ag()), TS = wl(ot()), RS = jt(), Tg = wl(Pi()), bl = as(), Kt = (0, 
              TS.default)("mqttjs:ws"), CS = [ "rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase" ];
              function Rg(t, e) {
                  let r = `${t.protocol}://${t.hostname}:${t.port}${t.path}`;
                  return "function" == typeof t.transformWsUrl && (r = t.transformWsUrl(r, t, e)), 
                  r;
              }
              function Cg(t) {
                  let e = t;
                  return t.hostname || (e.hostname = "localhost"), t.port || ("wss" === t.protocol ? e.port = 443 : e.port = 80), 
                  t.path || (e.path = "/"), t.wsOptions || (e.wsOptions = {}), !Tg.default && "wss" === t.protocol && CS.forEach((r => {
                      Object.prototype.hasOwnProperty.call(t, r) && !Object.prototype.hasOwnProperty.call(t.wsOptions, r) && (e.wsOptions[r] = t[r]);
                  })), e;
              }
              Ui.default = Tg.default ? (t, e) => {
                  Kt("browserStreamBuilder");
                  let r, n = function(t) {
                      let e = Cg(t);
                      if (e.hostname || (e.hostname = e.host), !e.hostname) {
                          if (typeof document > "u") throw new Error("Could not determine host. Specify host manually.");
                          let r = new URL(document.URL);
                          e.hostname = r.hostname, e.port || (e.port = Number(r.port));
                      }
                      return void 0 === e.objectMode && (e.objectMode = !(!0 === e.binary || void 0 === e.binary)), 
                      e;
                  }(e).browserBufferSize || 524288, o = e.browserBufferTimeout || 1e3, s = !e.objectMode, a = function(t, e) {
                      let n, r = "MQIsdp" === e.protocolId && 3 === e.protocolVersion ? "mqttv3.1" : "mqtt", i = Rg(e, t);
                      return n = e.createWebsocket ? e.createWebsocket(i, [ r ], e) : new WebSocket(i, [ r ]), 
                      n.binaryType = "arraybuffer", n;
                  }(t, e), u = function(I, C, R) {
                      let U = new RS.Transform({
                          objectMode: I.objectMode
                      });
                      return U._write = C, U._flush = R, U;
                  }(e, (function E(I, C, R) {
                      if (a.bufferedAmount > n) return void setTimeout(E, o, I, C, R);
                      s && "string" == typeof I && (I = yl.Buffer.from(I, "utf8"));
                      try {
                          a.send(I);
                      } catch (U) {
                          return R(U);
                      }
                      R();
                  }), (function(I) {
                      a.close(), I();
                  }));
                  e.objectMode || (u._writev = bl.writev.bind(u)), u.on("close", (() => {
                      a.close();
                  }));
                  let c = typeof a.addEventListener < "u";
                  function d() {
                      Kt("WebSocket onOpen"), r instanceof bl.BufferedDuplex && r.socketReady();
                  }
                  function g(I) {
                      Kt("WebSocket onClose", I), r.end(), r.destroy();
                  }
                  function y(I) {
                      Kt("WebSocket onError", I);
                      let C = new Error("WebSocket error");
                      C.event = I, r.destroy(C);
                  }
                  function w(I) {
                      let {data: C} = I;
                      C = C instanceof ArrayBuffer ? yl.Buffer.from(C) : yl.Buffer.from(C, "utf8"), u.push(C);
                  }
                  return a.readyState === a.OPEN ? (r = u, r.socket = a) : (r = new bl.BufferedDuplex(e, u, a), 
                  c ? a.addEventListener("open", d) : a.onopen = d), c ? (a.addEventListener("close", g), 
                  a.addEventListener("error", y), a.addEventListener("message", w)) : (a.onclose = g, 
                  a.onerror = y, a.onmessage = w), r;
              } : (t, e) => {
                  Kt("streamBuilder");
                  let r = Cg(e), i = Rg(r, t), n = function(t, e, r) {
                      Kt("createWebSocket"), Kt(`protocol: ${r.protocolId} ${r.protocolVersion}`);
                      let n, i = "MQIsdp" === r.protocolId && 3 === r.protocolVersion ? "mqttv3.1" : "mqtt";
                      return Kt(`creating new Websocket for url: ${e} and protocol: ${i}`), n = r.createWebsocket ? r.createWebsocket(e, [ i ], r) : new Ig.default(e, [ i ], r.wsOptions), 
                      n;
                  }(0, i, r), o = Ig.default.createWebSocketStream(n, r.wsOptions);
                  return o.url = i, n.on("close", (() => {
                      o.destroy();
                  })), o;
              };
          })), Og = M((Rr => {
              v(), m(), _();
              var us = Rr && Rr.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(Rr, "__esModule", {
                  value: !0
              }), Rr.connectAsync = void 0;
              var MS = us(ot()), LS = us((gg(), X(pg))), US = us(ss()), NS = us(Pi()), Bg = (0, 
              MS.default)("mqttjs"), Re = {};
              function Pg(t, e) {
                  if (Bg("connecting to an MQTT broker..."), "object" == typeof t && !e && (e = t, 
                  t = ""), e = e || {}, t && "string" == typeof t) {
                      let n = LS.default.parse(t, !0);
                      if (null != n.port && (n.port = Number(n.port)), null === (e = Object.assign(Object.assign({}, n), e)).protocol) throw new Error("Missing protocol");
                      e.protocol = e.protocol.replace(/:$/, "");
                  }
                  if (function(t) {
                      let e;
                      t.auth && (e = t.auth.match(/^(.+):(.+)$/), e ? (t.username = e[1], t.password = e[2]) : t.username = t.auth);
                  }(e), e.query && "string" == typeof e.query.clientId && (e.clientId = e.query.clientId), 
                  e.cert && e.key) {
                      if (!e.protocol) throw new Error("Missing secure protocol key");
                      if (-1 === [ "mqtts", "wss", "wxs", "alis" ].indexOf(e.protocol)) switch (e.protocol) {
                        case "mqtt":
                          e.protocol = "mqtts";
                          break;

                        case "ws":
                          e.protocol = "wss";
                          break;

                        case "wx":
                          e.protocol = "wxs";
                          break;

                        case "ali":
                          e.protocol = "alis";
                          break;

                        default:
                          throw new Error(`Unknown protocol for secure connection: "${e.protocol}"!`);
                      }
                  }
                  if (!Re[e.protocol]) {
                      let n = -1 !== [ "mqtts", "wss" ].indexOf(e.protocol);
                      e.protocol = [ "mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis" ].filter(((o, s) => (!n || s % 2 != 0) && "function" == typeof Re[o]))[0];
                  }
                  if (!1 === e.clean && !e.clientId) throw new Error("Missing clientId for unclean clients");
                  e.protocol && (e.defaultProtocol = e.protocol);
                  let i = new US.default((function(n) {
                      return e.servers && ((!n._reconnectCount || n._reconnectCount === e.servers.length) && (n._reconnectCount = 0), 
                      e.host = e.servers[n._reconnectCount].host, e.port = e.servers[n._reconnectCount].port, 
                      e.protocol = e.servers[n._reconnectCount].protocol ? e.servers[n._reconnectCount].protocol : e.defaultProtocol, 
                      e.hostname = e.host, n._reconnectCount++), Bg("calling streambuilder for", e.protocol), 
                      Re[e.protocol](n, e);
                  }), e);
                  return i.on("error", (() => {})), i;
              }
              NS.default ? (Re.wx = hl().default, Re.wxs = hl().default, Re.ali = gl().default, 
              Re.alis = gl().default) : (Re.mqtt = ol().default, Re.tcp = ol().default, Re.ssl = ll().default, 
              Re.tls = Re.ssl, Re.mqtts = ll().default), Re.ws = _l().default, Re.wss = _l().default, 
              Rr.connectAsync = function(t, e, r = !0) {
                  return new Promise(((i, n) => {
                      let o = Pg(t, e), s = {
                          connect: u => {
                              a(), i(o);
                          },
                          end: () => {
                              a(), i(o);
                          },
                          error: u => {
                              a(), o.end(), n(u);
                          }
                      };
                      function a() {
                          Object.keys(s).forEach((u => {
                              o.off(u, s[u]);
                          }));
                      }
                      !1 === r && (s.close = () => {
                          s.error(new Error("Couldn't connect to server"));
                      }), Object.keys(s).forEach((u => {
                          o.on(u, s[u]);
                      }));
                  }));
              }, Rr.default = Pg;
          })), ml = M((G => {
              v(), m(), _();
              var kg = G && G.__createBinding || (Object.create ? function(t, e, r, i) {
                  void 0 === i && (i = r);
                  var n = Object.getOwnPropertyDescriptor(e, r);
                  (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) && (n = {
                      enumerable: !0,
                      get: function() {
                          return e[r];
                      }
                  }), Object.defineProperty(t, i, n);
              } : function(t, e, r, i) {
                  void 0 === i && (i = r), t[i] = e[r];
              }), jS = G && G.__setModuleDefault || (Object.create ? function(t, e) {
                  Object.defineProperty(t, "default", {
                      enumerable: !0,
                      value: e
                  });
              } : function(t, e) {
                  t.default = e;
              }), FS = G && G.__importStar || function(t) {
                  if (t && t.__esModule) return t;
                  var e = {};
                  if (null != t) for (var r in t) "default" !== r && Object.prototype.hasOwnProperty.call(t, r) && kg(e, t, r);
                  return jS(e, t), e;
              }, xg = G && G.__exportStar || function(t, e) {
                  for (var r in t) "default" !== r && !Object.prototype.hasOwnProperty.call(e, r) && kg(e, t, r);
              }, Ni = G && G.__importDefault || function(t) {
                  return t && t.__esModule ? t : {
                      default: t
                  };
              };
              Object.defineProperty(G, "__esModule", {
                  value: !0
              }), G.ReasonCodes = G.PingTimer = G.UniqueMessageIdProvider = G.DefaultMessageIdProvider = G.Store = G.MqttClient = G.connectAsync = G.connect = G.Client = void 0;
              var Mg = Ni(ss());
              G.MqttClient = Mg.default;
              var WS = Ni(Jo());
              G.DefaultMessageIdProvider = WS.default;
              var $S = Ni(Hp());
              G.UniqueMessageIdProvider = $S.default;
              var HS = Ni(ea());
              G.Store = HS.default;
              var Lg = FS(Og());
              G.connect = Lg.default, Object.defineProperty(G, "connectAsync", {
                  enumerable: !0,
                  get: function() {
                      return Lg.connectAsync;
                  }
              });
              var VS = Ni(ja());
              G.PingTimer = VS.default, G.Client = Mg.default, xg(ss(), G), xg(Jr(), G);
              var zS = Ai();
              Object.defineProperty(G, "ReasonCodes", {
                  enumerable: !0,
                  get: function() {
                      return zS.ReasonCodes;
                  }
              });
          })), JS = M((We => {
              v(), m(), _();
              var Ug = We && We.__createBinding || (Object.create ? function(t, e, r, i) {
                  void 0 === i && (i = r);
                  var n = Object.getOwnPropertyDescriptor(e, r);
                  (!n || ("get" in n ? !e.__esModule : n.writable || n.configurable)) && (n = {
                      enumerable: !0,
                      get: function() {
                          return e[r];
                      }
                  }), Object.defineProperty(t, i, n);
              } : function(t, e, r, i) {
                  void 0 === i && (i = r), t[i] = e[r];
              }), KS = We && We.__setModuleDefault || (Object.create ? function(t, e) {
                  Object.defineProperty(t, "default", {
                      enumerable: !0,
                      value: e
                  });
              } : function(t, e) {
                  t.default = e;
              }), GS = We && We.__importStar || function(t) {
                  if (t && t.__esModule) return t;
                  var e = {};
                  if (null != t) for (var r in t) "default" !== r && Object.prototype.hasOwnProperty.call(t, r) && Ug(e, t, r);
                  return KS(e, t), e;
              }, QS = We && We.__exportStar || function(t, e) {
                  for (var r in t) "default" !== r && !Object.prototype.hasOwnProperty.call(e, r) && Ug(e, t, r);
              };
              Object.defineProperty(We, "__esModule", {
                  value: !0
              });
              var YS = GS(ml());
              We.default = YS, QS(ml(), We);
          }));
          const mqtt_esm = JS(), {connect} = mqtt_esm, Log = console.log, makeOptions = (roomId, res) => {
              const {client_id, username, password, status_topic} = res;
              return {
                  clientId: client_id,
                  username,
                  password,
                  clean: !0,
                  reconnectPeriod: 3e3,
                  connectTimeout: 3e4,
                  keepalive: 10,
                  will: {
                      retain: !0,
                      topic: status_topic,
                      payload: JSON.stringify({
                          type: "END",
                          userId: username,
                          roomId,
                          clientId: client_id,
                          timestamp: Date.now(),
                          connectionType: "GOOGLE_MEET_SUBTITLE"
                      }),
                      qos: 1
                  },
                  timerVariant: "native"
              };
          };
          const mqtt = class {
              constructor(options) {
                  defineProperty_defineProperty(this, "client", void 0), defineProperty_defineProperty(this, "params", void 0), 
                  defineProperty_defineProperty(this, "options", void 0), defineProperty_defineProperty(this, "tokenExpireTime", void 0), 
                  defineProperty_defineProperty(this, "status", !1), defineProperty_defineProperty(this, "checkToken", (async () => {
                      if (dayjs_min_default()().unix() > this.tokenExpireTime) {
                          const info = await this.params.getToken();
                          this.options = makeOptions(this.params.roomId, info), this.tokenExpireTime = dayjs_min_default()().add(1, "hour").unix();
                      }
                      return this.options;
                  })), defineProperty_defineProperty(this, "initAsync", (() => new Promise(this.init))), 
                  defineProperty_defineProperty(this, "init", (async resolve => {
                      this.options = await this.checkToken();
                      const client = connect(this.params.info.ws_url, this.options);
                      client.on("error", (err => {
                          if (Log("Subtitle MQTT error", err.message), err.message.includes("Bad username or password")) return this.tokenExpireTime = 0, 
                          void this.destroyAndInit();
                          throw this.onStatusChange(!1), new Error(`SubtitleModule: Mqtt ${err.message}`);
                      })), client.on("close", (() => {
                          this.onStatusChange(!1), Log("Subtitle MQTT close");
                      })), client.on("reconnect", (() => {
                          this.onStatusChange(!1), Log("Subtitle MQTT reconnect");
                      })), client.on("offline", (() => {
                          this.onStatusChange(!1), Log("Subtitle MQTT offline");
                      })), client.on("connect", (() => {
                          this.onStatusChange(!0), Log("Subtitle MQTT connect"), this.startPublish(), resolve?.();
                      })), client.on("message", ((_, msg) => {
                          this.params.onMessage?.(JSON.parse(msg.toString()));
                      })), this.client = client, this.subscribe(this.params.topics);
                  })), this.params = options, this.options = makeOptions(options.roomId, options.info), 
                  this.tokenExpireTime = dayjs_min_default()().add(1, "hour").unix(), this.initAsync().then((() => {
                      this.params.onLoaded();
                  }));
              }
              destroyAndInit() {
                  Log("Subtitle MQTT Force Reconnect"), this.destroy(), this.init();
              }
              startPublish() {
                  if (!this.client) return;
                  const {roomId, info: {client_id, username, status_topic}} = this.params, msg = JSON.stringify({
                      type: "START",
                      userId: username,
                      roomId,
                      clientId: client_id,
                      timestamp: Date.now(),
                      connectionType: "GOOGLE_MEET_SUBTITLE"
                  });
                  this.client.publish(status_topic, msg);
              }
              sendMessage(topic, msg, qos = 0) {
                  return this.client.publishAsync(topic, msg, {
                      qos
                  });
              }
              onStatusChange(newStatus) {
                  newStatus !== this.status && (this.status = newStatus, this.params.onStatusChange?.(this.status));
              }
              subscribe(topic) {
                  return Log("Subtitle MQTT Subscribe", topic, this.client), new Promise(((resolve, reject) => {
                      this.client ? this.client.subscribe(topic, {
                          qos: 1
                      }, (err => {
                          err ? reject(err) : (Log({
                              type: "EVENT",
                              msg: {
                                  action: "subscribe topic",
                                  topic,
                                  status: "succ"
                              },
                              name: "SUB-MQTT"
                          }), resolve(0));
                      })) : reject(new Error("Subscribe no client"));
                  }));
              }
              unsubscribe() {
                  this.client && (Log("Subtitle MQTT Unsubscribe", this.params.topics), this.client.unsubscribe(this.params.topics));
              }
              destroy() {
                  this.onStatusChange(!1), this.client.end(!0);
              }
          };
          let onMachineTranslationCallback = _msg => {};
          const timeMap = {}, translateTimeMap = {};
          let googleNetError = 0;
          const modifiedGetMqttInfo = roomId => getMQTTInfo("", roomId).catch((() => {
              throw new Error("TOKEN_EMPTY");
          })), useMqttStore = create(((set, get) => ({
              client: void 0,
              status: void 0,
              errorMsg: "",
              info: void 0,
              translateAdapter: "MS",
              init: stillConnect => {
                  const {status} = get(), {roomId, translateAdapter} = stores_info.getState();
                  if (!roomId) throw new Error("NO_ROOMID");
                  if (!status) return trackEvent({
                      event_type: "TranslationMethod",
                      trigger_type: "Automatic",
                      trigger_control: translateAdapter
                  }), set({
                      errorMsg: "",
                      translateAdapter
                  }), modifiedGetMqttInfo(roomId).then((res => {
                      if (res.status && !stillConnect) throw uiConfig.setState({
                          connectBlocked: !0
                      }), new Error("STILL_USING");
                      return set({
                          info: res
                      }), res;
                  })).then((res => {
                      const client = new mqtt({
                          roomId,
                          info: res,
                          getToken: () => modifiedGetMqttInfo(roomId),
                          onMessage: msg => {
                              "MEET_SUBTITLE_STATUS" !== msg.type || msg.subtitle || (trackEvent({
                                  event_type: "SubtitleClick",
                                  trigger_type: "Automatic",
                                  trigger_control: "CloseSubtitle"
                              }), window.postMessage({
                                  type: "subtitle:close"
                              }, "*")), "MEET_SUBTITLE_BALANCE_CHANGED_EXPIRE" === msg.type && limit.getState().checkData(), 
                              "MEET_SUBTITLE_BALANCE_CHANGED_PURCHASE" === msg.type && limit.getState().updateData(), 
                              "MEET_SUBTITLE_BALANCE_CHANGED_REWARD" === msg.type && limit.getState().updateData();
                          },
                          topics: [ res.notice_topic, res.translate_topic ],
                          onStatusChange: status => {
                              status && limit.getState().getData(), set({
                                  status
                              });
                          },
                          onLoaded: () => {}
                      });
                      console.log("paul mqtt set client"), set({
                          client
                      });
                  })).catch((error => {
                      window.postMessage({
                          type: "subtitle:pause"
                      }), set({
                          errorMsg: error.message
                      });
                  }));
              },
              sendSubtitle: async (json, sourceLang, targetLang, name, channel, resultId) => {
                  const {client, info, translateAdapter} = get();
                  if (!client || !info?.transcribe_topic) return void console.log("no client or transcribeTopic");
                  trackEvent({
                      event_type: "SubtitleTranscribed",
                      trigger_type: "Automatic",
                      trigger_control: "Youtube-Local" === name ? "Youtube-Local" : "MS-Recognized"
                  });
                  const {roomId} = stores_info.getState(), {status, msg} = await ((translateAdapter, info, resultId) => new Promise(((resolove, _reject) => {
                      const {dataJson, roomId, timestamp, sourceLang, targetLang, displayName} = info, json = JSON.parse(dataJson), tm = resultId || timeMap[json.Offset] || String(timestamp);
                      if (timeMap[json.Offset] = tm, translateTimeMap[json.Offset] = translateTimeMap[json.Offset] || 0, 
                      json.Id = tm, info.dataJson = JSON.stringify(json), "MS" === translateAdapter || "Success" === json.RecognitionStatus) resolove({
                          msg: JSON.stringify(info),
                          status: ""
                      }); else {
                          const gTimeStamp = Date.now();
                          onMachineTranslationCallback({
                              data: {
                                  isComplete: !1,
                                  displayName,
                                  originalLang: sourceLang,
                                  originalText: json.Text,
                                  resultId: tm,
                                  roomId
                              },
                              timestamp: gTimeStamp,
                              type: "MEET_SUBTITLE_TEXT"
                          }), sourceLang !== targetLang[0] && (new (createTranslate(translateAdapter))).query(json.Text, targetLang[0]).then((rst => {
                              trackEvent({
                                  event_type: "GoogleTranslation",
                                  trigger_type: "Automatic",
                                  trigger_control: "GoogleTranslateSucc"
                              }), gTimeStamp >= translateTimeMap[json.Offset] && (onMachineTranslationCallback({
                                  data: {
                                      isComplete: !1,
                                      displayName,
                                      translateLang: targetLang[0],
                                      translateText: rst,
                                      resultId: tm,
                                      roomId
                                  },
                                  timestamp: gTimeStamp,
                                  type: "MEET_SUBTITLE_TRANSLATE_TEXT"
                              }), translateTimeMap[json.Offset] = gTimeStamp), resolove({
                                  status: "succ",
                                  msg: ""
                              });
                          })).catch((() => {
                              trackEvent({
                                  event_type: "GoogleTranslation",
                                  trigger_type: "Automatic",
                                  trigger_control: "GoogleTranslateFail"
                              }), resolove({
                                  msg: "",
                                  status: "fail"
                              });
                          }));
                      }
                  })))(translateAdapter, {
                      channel: "GOOGLE_MEET_PLUGIN_SUBTITLE",
                      dataJson: json,
                      displayName: name,
                      model: channel ? "TRANSCRIBED" : "TRANSCRIBING",
                      sourceLang: langFormator[sourceLang],
                      roomId,
                      targetLang: [ targetLang ],
                      timestamp: Date.now(),
                      transcribeChannel: channel || "MS",
                      speaker: "local voice" === name ? "you" : "other"
                  }, resultId ? String(resultId) : void 0);
                  msg.length > 0 && client.sendMessage(info.transcribe_topic, msg), "fail" === status ? googleNetError++ : "succ" === status && (googleNetError = 0), 
                  googleNetError > 2 && (trackEvent({
                      event_type: "GoogleTranslationSwitch",
                      trigger_type: "Automatic",
                      trigger_control: "TranslationSwitchGPT"
                  }), set({
                      translateAdapter: "MS"
                  }));
              },
              sendSubtitleAsync: (json, sourceLang, targetLang, name) => {
                  const {client, info} = get();
                  if (!client || !info?.transcribe_topic) return void console.log("no client or transcribeTopic");
                  const {roomId} = stores_info.getState(), msg = {
                      channel: "GOOGLE_MEET_PLUGIN_SUBTITLE",
                      dataJson: json,
                      displayName: name,
                      model: "TRANSCRIBING",
                      sourceLang: langFormator[sourceLang],
                      roomId,
                      targetLang: [ targetLang ],
                      timestamp: Date.now(),
                      transcribeChannel: "MS",
                      speaker: "local voice" === name ? "you" : "other"
                  };
                  return client.sendMessage(info.transcribe_topic, JSON.stringify(msg), 1);
              },
              destroy: () => {
                  const {client} = get();
                  client?.destroy(), set({
                      client: void 0,
                      status: void 0,
                      info: void 0
                  });
              }
          }))), useMqttStatus = () => useMqttStore((({status}) => status)), stores_mqtt = useMqttStore, useSubtitleStore = create(((set, get) => {
              const updateMessage = (message, index, disableCheckEscape = !1) => {
                  const prevMessages = get().messages, nextItem = {
                      ...prevMessages[index],
                      ...message,
                      endTime: Date.now(),
                      isComplete: message.isComplete || !1
                  };
                  if (nextItem.isComplete && nextItem.translateText && nextItem.translateLang) if (disableCheckEscape) {
                      const nextMessages = [ ...prevMessages ];
                      nextMessages[index] = nextItem, set({
                          messages: nextMessages
                      });
                  } else (async info => {
                      if (!info.translateText || !info.translateLang) return info;
                      if (!isCheckEscape) return info;
                      const Trans = createTranslate(transMethod), [machineTranslationText, mtErr] = await (new Trans).query(info.text, info.translateLang).then((rst => [ rst, null ]), (error => [ null, error ])), [isLanguageEscaped, checkError] = await (new Trans).query(info.translateText, info.translateLang).then((rst => [ info.translateText?.replaceAll(/[!,.?]/g, "") !== rst.replaceAll(/[!,.?]/g, ""), null ]), (error => [ null, error ]));
                      if (checkError) return trackEvent({
                          event_type: "CheckEscape",
                          trigger_type: "Automatic",
                          trigger_control: "CheckEscapeFailNoEscape",
                          Data: {
                              info,
                              transMethod
                          }
                      }), info;
                      const {roomId} = stores_info.getState();
                      if (isLanguageEscaped) return machineTranslationText ? (trackEvent({
                          event_type: "CheckEscape",
                          trigger_type: "Automatic",
                          trigger_control: "CheckEscapeSuccEscape",
                          Data: {
                              info,
                              machineTranslationText,
                              transMethod,
                              type: "Language Escape"
                          }
                      }), console.log(">>>>  \n", info.st, "\n", info.text, "\n", info.translateText, "\n", machineTranslationText), 
                      updateTranslateMessage({
                          targetLang: info.translateLang,
                          text: machineTranslationText,
                          subtitleId: info.subtitleId,
                          roomId
                      }), {
                          ...info,
                          translateText: machineTranslationText
                      }) : (trackEvent({
                          event_type: "CheckEscape",
                          trigger_type: "Automatic",
                          trigger_control: "CheckEscapeFailEscape",
                          Data: {
                              info,
                              transMethod
                          }
                      }), info);
                      if (mtErr) return trackEvent({
                          event_type: "CheckEscape",
                          trigger_type: "Automatic",
                          trigger_control: "CheckEscapeSuccNoEscape",
                          Data: {
                              info,
                              transMethod
                          }
                      }), info;
                      const len = info.translateText.length, mtLen = machineTranslationText.length;
                      return Math.floor(0 * mtLen) > len || Math.round(2 * mtLen) < len ? (trackEvent({
                          event_type: "CheckEscape",
                          trigger_type: "Automatic",
                          trigger_control: "CheckEscapeSuccEscape",
                          Data: {
                              info,
                              machineTranslationText,
                              transMethod,
                              type: "Length Escape"
                          }
                      }), console.log(">>>>  \n", info.st, "\n", info.text, "\n", info.translateText, "\n", machineTranslationText), 
                      updateTranslateMessage({
                          targetLang: info.translateLang,
                          text: machineTranslationText,
                          subtitleId: info.subtitleId,
                          roomId
                      }), {
                          ...info,
                          translateText: machineTranslationText
                      }) : (trackEvent({
                          event_type: "CheckEscape",
                          trigger_type: "Automatic",
                          trigger_control: "CheckEscapeSuccNoEscape",
                          Data: {
                              info,
                              transMethod
                          }
                      }), info);
                  })(nextItem).then((rst => {
                      const nextMessages = [ ...get().messages ];
                      nextMessages[index] = rst, set({
                          messages: nextMessages
                      });
                  })); else {
                      const nextMessages = [ ...prevMessages ];
                      nextMessages[index] = nextItem, set({
                          messages: nextMessages
                      });
                  }
              };
              return window.addEventListener("message", (({data}) => {
                  "getstore" === data.type && console.log(useSubtitleStore.getState());
              })), {
                  messages: [],
                  addMessage: message => {
                      set({
                          messages: [ ...get().messages, {
                              ...message,
                              startTime: Date.now()
                          } ]
                      }), (index => {
                          setTimeout((() => {
                              const message = get().messages[index];
                              message && "" === message.translateText && trackEvent({
                                  event_type: "Translate",
                                  trigger_type: "Automatic",
                                  trigger_control: "TranslateFail",
                                  event_id: message.st
                              });
                          }), 1e5);
                      })(get().messages.length - 1);
                  },
                  updateMessage,
                  retranslation: subtitle => {
                      const {translateLang} = userConfig.getState().config, index = get().messages.findIndex((item => item.st === subtitle.st));
                      if (subtitle.lang === translateLang) updateMessage({
                          translateText: void 0,
                          translateLang,
                          isComplete: !0
                      }, index); else {
                          updateMessage({
                              isComplete: !1
                          }, index);
                          const {info} = stores_mqtt.getState();
                          if (info) {
                              const {translate_topic, username} = info;
                              (async (data, targetLang, resultId, displayName, translate_topic) => {
                                  await content_script_sendMessage("retranslation-text", {
                                      bizId: subtitleToken_bizId,
                                      targetLang,
                                      text: data.text,
                                      original_lang: langFormator[data.lang] || "zh_hans",
                                      translate_topic,
                                      resultId,
                                      displayName
                                  }, "background");
                              })(subtitle, subtitle.translateLang, subtitle.st, username, translate_topic);
                          }
                      }
                  },
                  fixLastMessage: async () => {
                      const messages = [ ...get().messages ], lastMessage = messages.at(-1);
                      if (!1 === lastMessage?.isComplete) {
                          const json = JSON.stringify({
                              Id: lastMessage.st,
                              RecognitionStatus: "Success",
                              DisplayText: lastMessage.text,
                              Offset: 0,
                              Duration: 0,
                              PrimaryLanguage: {
                                  Language: lastMessage.lang,
                                  Confidence: "Unknown"
                              },
                              Channel: 0
                          });
                          await stores_mqtt.getState().sendSubtitleAsync(json, lastMessage.lang, lastMessage.translateLang || userConfig.getState().config.translateLang, lastMessage.user || ""), 
                          lastMessage.isComplete = !0, lastMessage.st = `${lastMessage.st}_LOSTED`, set({
                              messages
                          });
                      }
                  },
                  uploadMessages: () => {
                      const {source, url, title, roomId} = stores_info.getState();
                      roomId && (async data => {
                          await chrome.runtime.sendMessage({
                              type: "create-subtitle-segment",
                              data
                          });
                      })({
                          content: get().messages.map((item => ({
                              end_time: item.endTime,
                              gmt_generate: item.startTime,
                              speaker: item.user || "",
                              start_time: item.startTime,
                              text: item.text,
                              translations: item.translateLang && item.translateText ? [ {
                                  lang: item.translateLang,
                                  text: item.translateText
                              } ] : void 0
                          }))),
                          title,
                          source,
                          source_url: url,
                          room_id: roomId
                      });
                  },
                  resetMessage: () => set({
                      messages: []
                  })
              };
          })), subtitle = useSubtitleStore;
          class Contracts {
              static throwIfNullOrUndefined(param, name) {
                  if (null == param) throw new Error("throwIfNullOrUndefined:" + name);
              }
              static throwIfNull(param, name) {
                  if (null === param) throw new Error("throwIfNull:" + name);
              }
              static throwIfNullOrWhitespace(param, name) {
                  if (Contracts.throwIfNullOrUndefined(param, name), ("" + param).trim().length < 1) throw new Error("throwIfNullOrWhitespace:" + name);
              }
              static throwIfDisposed(isDisposed) {
                  if (isDisposed) throw new Error("the object is already disposed");
              }
              static throwIfArrayEmptyOrWhitespace(array, name) {
                  if (Contracts.throwIfNullOrUndefined(array, name), 0 === array.length) throw new Error("throwIfArrayEmptyOrWhitespace:" + name);
                  for (const item of array) Contracts.throwIfNullOrWhitespace(item, name);
              }
              static throwIfFileDoesNotExist(param, name) {
                  Contracts.throwIfNullOrWhitespace(param, name);
              }
              static throwIfNotUndefined(param, name) {
                  if (void 0 !== param) throw new Error("throwIfNotUndefined:" + name);
              }
          }
          var PropertyId, OutputFormat, ProfanityOption, SpeechSynthesisOutputFormat, LanguageIdMode, LanguageIdPriority, RecognitionMode, SpeechResultFormat, connectivity, type, getRandomValues;
          !function(PropertyId) {
              PropertyId[PropertyId.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", 
              PropertyId[PropertyId.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", 
              PropertyId[PropertyId.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", 
              PropertyId[PropertyId.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", 
              PropertyId[PropertyId.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", 
              PropertyId[PropertyId.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", 
              PropertyId[PropertyId.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", 
              PropertyId[PropertyId.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", 
              PropertyId[PropertyId.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", 
              PropertyId[PropertyId.SpeechServiceConnection_IntentRegion = 9] = "SpeechServiceConnection_IntentRegion", 
              PropertyId[PropertyId.SpeechServiceConnection_ProxyHostName = 10] = "SpeechServiceConnection_ProxyHostName", 
              PropertyId[PropertyId.SpeechServiceConnection_ProxyPort = 11] = "SpeechServiceConnection_ProxyPort", 
              PropertyId[PropertyId.SpeechServiceConnection_ProxyUserName = 12] = "SpeechServiceConnection_ProxyUserName", 
              PropertyId[PropertyId.SpeechServiceConnection_ProxyPassword = 13] = "SpeechServiceConnection_ProxyPassword", 
              PropertyId[PropertyId.SpeechServiceConnection_RecoMode = 14] = "SpeechServiceConnection_RecoMode", 
              PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage = 15] = "SpeechServiceConnection_RecoLanguage", 
              PropertyId[PropertyId.Speech_SessionId = 16] = "Speech_SessionId", PropertyId[PropertyId.SpeechServiceConnection_SynthLanguage = 17] = "SpeechServiceConnection_SynthLanguage", 
              PropertyId[PropertyId.SpeechServiceConnection_SynthVoice = 18] = "SpeechServiceConnection_SynthVoice", 
              PropertyId[PropertyId.SpeechServiceConnection_SynthOutputFormat = 19] = "SpeechServiceConnection_SynthOutputFormat", 
              PropertyId[PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages = 20] = "SpeechServiceConnection_AutoDetectSourceLanguages", 
              PropertyId[PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse = 21] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", 
              PropertyId[PropertyId.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 22] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", 
              PropertyId[PropertyId.SpeechServiceResponse_JsonResult = 23] = "SpeechServiceResponse_JsonResult", 
              PropertyId[PropertyId.SpeechServiceResponse_JsonErrorDetails = 24] = "SpeechServiceResponse_JsonErrorDetails", 
              PropertyId[PropertyId.CancellationDetails_Reason = 25] = "CancellationDetails_Reason", 
              PropertyId[PropertyId.CancellationDetails_ReasonText = 26] = "CancellationDetails_ReasonText", 
              PropertyId[PropertyId.CancellationDetails_ReasonDetailedText = 27] = "CancellationDetails_ReasonDetailedText", 
              PropertyId[PropertyId.LanguageUnderstandingServiceResponse_JsonResult = 28] = "LanguageUnderstandingServiceResponse_JsonResult", 
              PropertyId[PropertyId.SpeechServiceConnection_Url = 29] = "SpeechServiceConnection_Url", 
              PropertyId[PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs = 30] = "SpeechServiceConnection_InitialSilenceTimeoutMs", 
              PropertyId[PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs = 31] = "SpeechServiceConnection_EndSilenceTimeoutMs", 
              PropertyId[PropertyId.Speech_SegmentationSilenceTimeoutMs = 32] = "Speech_SegmentationSilenceTimeoutMs", 
              PropertyId[PropertyId.SpeechServiceConnection_EnableAudioLogging = 33] = "SpeechServiceConnection_EnableAudioLogging", 
              PropertyId[PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority = 34] = "SpeechServiceConnection_AtStartLanguageIdPriority", 
              PropertyId[PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority = 35] = "SpeechServiceConnection_ContinuousLanguageIdPriority", 
              PropertyId[PropertyId.SpeechServiceConnection_RecognitionEndpointVersion = 36] = "SpeechServiceConnection_RecognitionEndpointVersion", 
              PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption = 37] = "SpeechServiceResponse_ProfanityOption", 
              PropertyId[PropertyId.SpeechServiceResponse_PostProcessingOption = 38] = "SpeechServiceResponse_PostProcessingOption", 
              PropertyId[PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps = 39] = "SpeechServiceResponse_RequestWordLevelTimestamps", 
              PropertyId[PropertyId.SpeechServiceResponse_StablePartialResultThreshold = 40] = "SpeechServiceResponse_StablePartialResultThreshold", 
              PropertyId[PropertyId.SpeechServiceResponse_OutputFormatOption = 41] = "SpeechServiceResponse_OutputFormatOption", 
              PropertyId[PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult = 42] = "SpeechServiceResponse_TranslationRequestStablePartialResult", 
              PropertyId[PropertyId.SpeechServiceResponse_RequestWordBoundary = 43] = "SpeechServiceResponse_RequestWordBoundary", 
              PropertyId[PropertyId.SpeechServiceResponse_RequestPunctuationBoundary = 44] = "SpeechServiceResponse_RequestPunctuationBoundary", 
              PropertyId[PropertyId.SpeechServiceResponse_RequestSentenceBoundary = 45] = "SpeechServiceResponse_RequestSentenceBoundary", 
              PropertyId[PropertyId.Conversation_ApplicationId = 46] = "Conversation_ApplicationId", 
              PropertyId[PropertyId.Conversation_DialogType = 47] = "Conversation_DialogType", 
              PropertyId[PropertyId.Conversation_Initial_Silence_Timeout = 48] = "Conversation_Initial_Silence_Timeout", 
              PropertyId[PropertyId.Conversation_From_Id = 49] = "Conversation_From_Id", PropertyId[PropertyId.Conversation_Conversation_Id = 50] = "Conversation_Conversation_Id", 
              PropertyId[PropertyId.Conversation_Custom_Voice_Deployment_Ids = 51] = "Conversation_Custom_Voice_Deployment_Ids", 
              PropertyId[PropertyId.Conversation_Speech_Activity_Template = 52] = "Conversation_Speech_Activity_Template", 
              PropertyId[PropertyId.Conversation_Request_Bot_Status_Messages = 53] = "Conversation_Request_Bot_Status_Messages", 
              PropertyId[PropertyId.Conversation_Agent_Connection_Id = 54] = "Conversation_Agent_Connection_Id", 
              PropertyId[PropertyId.SpeechServiceConnection_Host = 55] = "SpeechServiceConnection_Host", 
              PropertyId[PropertyId.ConversationTranslator_Host = 56] = "ConversationTranslator_Host", 
              PropertyId[PropertyId.ConversationTranslator_Name = 57] = "ConversationTranslator_Name", 
              PropertyId[PropertyId.ConversationTranslator_CorrelationId = 58] = "ConversationTranslator_CorrelationId", 
              PropertyId[PropertyId.ConversationTranslator_Token = 59] = "ConversationTranslator_Token", 
              PropertyId[PropertyId.PronunciationAssessment_ReferenceText = 60] = "PronunciationAssessment_ReferenceText", 
              PropertyId[PropertyId.PronunciationAssessment_GradingSystem = 61] = "PronunciationAssessment_GradingSystem", 
              PropertyId[PropertyId.PronunciationAssessment_Granularity = 62] = "PronunciationAssessment_Granularity", 
              PropertyId[PropertyId.PronunciationAssessment_EnableMiscue = 63] = "PronunciationAssessment_EnableMiscue", 
              PropertyId[PropertyId.PronunciationAssessment_Json = 64] = "PronunciationAssessment_Json", 
              PropertyId[PropertyId.PronunciationAssessment_Params = 65] = "PronunciationAssessment_Params", 
              PropertyId[PropertyId.SpeakerRecognition_Api_Version = 66] = "SpeakerRecognition_Api_Version";
          }(PropertyId || (PropertyId = {}));
          class PropertyCollection {
              constructor() {
                  this.privKeys = [], this.privValues = [];
              }
              getProperty(key, def) {
                  let keyToUse;
                  keyToUse = "string" == typeof key ? key : PropertyId[key];
                  for (let n = 0; n < this.privKeys.length; n++) if (this.privKeys[n] === keyToUse) return this.privValues[n];
                  if (void 0 !== def) return String(def);
              }
              setProperty(key, value) {
                  let keyToUse;
                  keyToUse = "string" == typeof key ? key : PropertyId[key];
                  for (let n = 0; n < this.privKeys.length; n++) if (this.privKeys[n] === keyToUse) return void (this.privValues[n] = value);
                  this.privKeys.push(keyToUse), this.privValues.push(value);
              }
              clone() {
                  const clonedMap = new PropertyCollection;
                  for (let n = 0; n < this.privKeys.length; n++) clonedMap.privKeys.push(this.privKeys[n]), 
                  clonedMap.privValues.push(this.privValues[n]);
                  return clonedMap;
              }
              mergeTo(destinationCollection) {
                  this.privKeys.forEach((key => {
                      if (void 0 === destinationCollection.getProperty(key, void 0)) {
                          const value = this.getProperty(key);
                          destinationCollection.setProperty(key, value);
                      }
                  }));
              }
              get keys() {
                  return this.privKeys;
              }
          }
          !function(OutputFormat) {
              OutputFormat[OutputFormat.Simple = 0] = "Simple", OutputFormat[OutputFormat.Detailed = 1] = "Detailed";
          }(OutputFormat || (OutputFormat = {})), function(ProfanityOption) {
              ProfanityOption[ProfanityOption.Masked = 0] = "Masked", ProfanityOption[ProfanityOption.Removed = 1] = "Removed", 
              ProfanityOption[ProfanityOption.Raw = 2] = "Raw";
          }(ProfanityOption || (ProfanityOption = {})), function(SpeechSynthesisOutputFormat) {
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", 
              SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm";
          }(SpeechSynthesisOutputFormat || (SpeechSynthesisOutputFormat = {}));
          class SpeechConfig {
              constructor() {}
              static fromSubscription(subscriptionKey, region) {
                  Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey"), Contracts.throwIfNullOrWhitespace(region, "region");
                  const speechImpl = new SpeechConfigImpl;
                  return speechImpl.setProperty(PropertyId.SpeechServiceConnection_Region, region), 
                  speechImpl.setProperty(PropertyId.SpeechServiceConnection_IntentRegion, region), 
                  speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey), 
                  speechImpl;
              }
              static fromEndpoint(endpoint, subscriptionKey) {
                  Contracts.throwIfNull(endpoint, "endpoint");
                  const speechImpl = new SpeechConfigImpl;
                  return speechImpl.setProperty(PropertyId.SpeechServiceConnection_Endpoint, endpoint.href), 
                  void 0 !== subscriptionKey && speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey), 
                  speechImpl;
              }
              static fromHost(hostName, subscriptionKey) {
                  Contracts.throwIfNull(hostName, "hostName");
                  const speechImpl = new SpeechConfigImpl;
                  return speechImpl.setProperty(PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + ("" === hostName.port ? "" : ":" + hostName.port)), 
                  void 0 !== subscriptionKey && speechImpl.setProperty(PropertyId.SpeechServiceConnection_Key, subscriptionKey), 
                  speechImpl;
              }
              static fromAuthorizationToken(authorizationToken, region) {
                  Contracts.throwIfNull(authorizationToken, "authorizationToken"), Contracts.throwIfNullOrWhitespace(region, "region");
                  const speechImpl = new SpeechConfigImpl;
                  return speechImpl.setProperty(PropertyId.SpeechServiceConnection_Region, region), 
                  speechImpl.setProperty(PropertyId.SpeechServiceConnection_IntentRegion, region), 
                  speechImpl.authorizationToken = authorizationToken, speechImpl;
              }
              close() {}
          }
          class SpeechConfigImpl extends SpeechConfig {
              constructor() {
                  super(), this.privProperties = new PropertyCollection, this.speechRecognitionLanguage = "en-US", 
                  this.outputFormat = OutputFormat.Simple;
              }
              get properties() {
                  return this.privProperties;
              }
              get endPoint() {
                  return new URL(this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Endpoint));
              }
              get subscriptionKey() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Key);
              }
              get region() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Region);
              }
              get authorizationToken() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceAuthorization_Token);
              }
              set authorizationToken(value) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);
              }
              get speechRecognitionLanguage() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);
              }
              set speechRecognitionLanguage(value) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecoLanguage, value);
              }
              get autoDetectSourceLanguages() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
              }
              set autoDetectSourceLanguages(value) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, value);
              }
              get outputFormat() {
                  return OutputFormat[this.privProperties.getProperty("OutputFormat", void 0)];
              }
              set outputFormat(value) {
                  this.privProperties.setProperty("OutputFormat", OutputFormat[value]);
              }
              get endpointId() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_EndpointId);
              }
              set endpointId(value) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_EndpointId, value);
              }
              setProperty(name, value) {
                  Contracts.throwIfNull(value, "value"), this.privProperties.setProperty(name, value);
              }
              getProperty(name, def) {
                  return this.privProperties.getProperty(name, def);
              }
              setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
                  this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName), 
                  this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPort], proxyPort), 
                  this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName), 
                  this.setProperty(PropertyId[PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
              }
              setServiceProperty(name, value) {
                  const currentProperties = JSON.parse(this.privProperties.getProperty("ServiceProperties", "{}"));
                  currentProperties[name] = value, this.privProperties.setProperty("ServiceProperties", JSON.stringify(currentProperties));
              }
              setProfanity(profanity) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceResponse_ProfanityOption, ProfanityOption[profanity]);
              }
              enableAudioLogging() {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
              }
              requestWordLevelTimestamps() {
                  this.privProperties.setProperty(PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
              }
              enableDictation() {
                  this.privProperties.setProperty("ForceDictation", "true");
              }
              clone() {
                  const ret = new SpeechConfigImpl;
                  return ret.privProperties = this.privProperties.clone(), ret;
              }
              get speechSynthesisLanguage() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthLanguage);
              }
              set speechSynthesisLanguage(language) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthLanguage, language);
              }
              get speechSynthesisVoiceName() {
                  return this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthVoice);
              }
              set speechSynthesisVoiceName(voice) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthVoice, voice);
              }
              get speechSynthesisOutputFormat() {
                  return SpeechSynthesisOutputFormat[this.privProperties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
              }
              set speechSynthesisOutputFormat(format) {
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, SpeechSynthesisOutputFormat[format]);
              }
          }
          !function(LanguageIdMode) {
              LanguageIdMode[LanguageIdMode.AtStart = 0] = "AtStart", LanguageIdMode[LanguageIdMode.Continuous = 1] = "Continuous";
          }(LanguageIdMode || (LanguageIdMode = {})), function(LanguageIdPriority) {
              LanguageIdPriority[LanguageIdPriority.Accuracy = 0] = "Accuracy", LanguageIdPriority[LanguageIdPriority.Latency = 1] = "Latency";
          }(LanguageIdPriority || (LanguageIdPriority = {}));
          class AutoDetectSourceLanguageConfig {
              constructor() {
                  this.privProperties = new PropertyCollection, this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, "Latency"), 
                  this.privLanguageIdMode = LanguageIdMode.AtStart;
              }
              static fromOpenRange() {
                  const config = new AutoDetectSourceLanguageConfig;
                  return config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, "OpenRange"), 
                  config;
              }
              static fromLanguages(languages) {
                  Contracts.throwIfArrayEmptyOrWhitespace(languages, "languages");
                  const config = new AutoDetectSourceLanguageConfig;
                  return config.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join()), 
                  config;
              }
              static fromSourceLanguageConfigs(configs) {
                  if (configs.length < 1) throw new Error("Expected non-empty SourceLanguageConfig array.");
                  const autoConfig = new AutoDetectSourceLanguageConfig, langs = [];
                  return configs.forEach((config => {
                      if (langs.push(config.language), void 0 !== config.endpointId && "" !== config.endpointId) {
                          const customProperty = config.language + PropertyId.SpeechServiceConnection_EndpointId.toString();
                          autoConfig.properties.setProperty(customProperty, config.endpointId);
                      }
                  })), autoConfig.properties.setProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join()), 
                  autoConfig;
              }
              get properties() {
                  return this.privProperties;
              }
              set mode(mode) {
                  mode === LanguageIdMode.Continuous ? (this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), 
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, "Latency")) : (this.privProperties.setProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), 
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, void 0)), 
                  this.privLanguageIdMode = mode;
              }
              set priority(priority) {
                  priority === LanguageIdPriority.Accuracy ? this.privLanguageIdMode !== LanguageIdMode.Continuous && this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, "Accuracy") : (this.privProperties.setProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, "Latency"), 
                  this.privProperties.setProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, "Latency"));
              }
          }
          class SourceLanguageConfig {
              constructor(language, endpointId) {
                  Contracts.throwIfNullOrUndefined(language, "language"), this.privLanguage = language, 
                  this.privEndpointId = endpointId;
              }
              static fromLanguage(language, endpointId) {
                  return new SourceLanguageConfig(language, endpointId);
              }
              get language() {
                  return this.privLanguage;
              }
              get endpointId() {
                  return this.privEndpointId;
              }
          }
          class RiffPcmEncoder {
              constructor(actualSampleRate, desiredSampleRate) {
                  this.privActualSampleRate = actualSampleRate, this.privDesiredSampleRate = desiredSampleRate;
              }
              encode(actualAudioFrame) {
                  const audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);
                  if (!audioFrame) return null;
                  const audioLength = 2 * audioFrame.length, buffer = new ArrayBuffer(audioLength), view = new DataView(buffer);
                  return this.floatTo16BitPCM(view, 0, audioFrame), buffer;
              }
              setString(view, offset, str) {
                  for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
              }
              floatTo16BitPCM(view, offset, input) {
                  for (let i = 0; i < input.length; i++, offset += 2) {
                      const s = Math.max(-1, Math.min(1, input[i]));
                      view.setInt16(offset, s < 0 ? 32768 * s : 32767 * s, !0);
                  }
              }
              downSampleAudioFrame(srcFrame, srcRate, dstRate) {
                  if (!srcFrame) return null;
                  if (dstRate === srcRate || dstRate > srcRate) return srcFrame;
                  const ratio = srcRate / dstRate, dstLength = Math.round(srcFrame.length / ratio), dstFrame = new Float32Array(dstLength);
                  let srcOffset = 0, dstOffset = 0;
                  for (;dstOffset < dstLength; ) {
                      const nextSrcOffset = Math.round((dstOffset + 1) * ratio);
                      let accum = 0, count = 0;
                      for (;srcOffset < nextSrcOffset && srcOffset < srcFrame.length; ) accum += srcFrame[srcOffset++], 
                      count++;
                      dstFrame[dstOffset++] = accum / count;
                  }
                  return dstFrame;
              }
          }
          class PcmRecorder {
              constructor(stopInputOnRelease) {
                  this.privStopInputOnRelease = stopInputOnRelease;
              }
              record(context, mediaStream, outputStream) {
                  const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, 16e3), micInput = context.createMediaStreamSource(mediaStream);
                  if (!this.privSpeechProcessorScript) {
                      const blob = new Blob([ "class SP extends AudioWorkletProcessor {\n                constructor(options) {\n                  super(options);\n                }\n                process(inputs, outputs) {\n                  const input = inputs[0];\n                  const output = [];\n                  for (let channel = 0; channel < input.length; channel += 1) {\n                    output[channel] = input[channel];\n                  }\n                  this.port.postMessage(output[0]);\n                  return true;\n                }\n              }\n              registerProcessor('speech-processor', SP);" ], {
                          type: "application/javascript; charset=utf-8"
                      });
                      this.privSpeechProcessorScript = URL.createObjectURL(blob);
                  }
                  const attachScriptProcessor = () => {
                      const scriptNode = (() => {
                          let bufferSize = 0;
                          try {
                              return context.createScriptProcessor(bufferSize, 1, 1);
                          } catch (error) {
                              bufferSize = 2048;
                              let audioSampleRate = context.sampleRate;
                              for (;bufferSize < 16384 && audioSampleRate >= 32e3; ) bufferSize <<= 1, audioSampleRate >>= 1;
                              return context.createScriptProcessor(bufferSize, 1, 1);
                          }
                      })();
                      scriptNode.onaudioprocess = event => {
                          const inputFrame = event.inputBuffer.getChannelData(0);
                          if (outputStream && !outputStream.isClosed) {
                              const waveFrame = waveStreamEncoder.encode(inputFrame);
                              waveFrame && outputStream.writeStreamChunk({
                                  buffer: waveFrame,
                                  isEnd: !1,
                                  timeReceived: Date.now()
                              });
                          }
                      }, micInput.connect(scriptNode), scriptNode.connect(context.destination), this.privMediaResources = {
                          scriptProcessorNode: scriptNode,
                          source: micInput,
                          stream: mediaStream
                      };
                  };
                  if (this.privSpeechProcessorScript && context.audioWorklet) context.audioWorklet.addModule(this.privSpeechProcessorScript).then((() => {
                      const workletNode = new AudioWorkletNode(context, "speech-processor");
                      workletNode.port.onmessage = ev => {
                          const inputFrame = ev.data;
                          if (outputStream && !outputStream.isClosed) {
                              const waveFrame = waveStreamEncoder.encode(inputFrame);
                              waveFrame && outputStream.writeStreamChunk({
                                  buffer: waveFrame,
                                  isEnd: !1,
                                  timeReceived: Date.now()
                              });
                          }
                      }, micInput.connect(workletNode), workletNode.connect(context.destination), this.privMediaResources = {
                          scriptProcessorNode: workletNode,
                          source: micInput,
                          stream: mediaStream
                      };
                  })).catch((() => {
                      attachScriptProcessor();
                  })); else try {
                      attachScriptProcessor();
                  } catch (err) {
                      throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);
                  }
              }
              releaseMediaResources(context) {
                  this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(context.destination), 
                  this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), 
                  this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((track => track.stop())), 
                  this.privMediaResources.source = null));
              }
              setWorkletUrl(url) {
                  this.privSpeechProcessorScript = url;
              }
          }
          !function(RecognitionMode) {
              RecognitionMode[RecognitionMode.Interactive = 0] = "Interactive", RecognitionMode[RecognitionMode.Conversation = 1] = "Conversation", 
              RecognitionMode[RecognitionMode.Dictation = 2] = "Dictation";
          }(RecognitionMode || (RecognitionMode = {})), function(SpeechResultFormat) {
              SpeechResultFormat[SpeechResultFormat.Simple = 0] = "Simple", SpeechResultFormat[SpeechResultFormat.Detailed = 1] = "Detailed";
          }(SpeechResultFormat || (SpeechResultFormat = {}));
          class RecognizerConfig {
              constructor(speechServiceConfig, parameters) {
                  this.privSpeechServiceConfig = speechServiceConfig || new SpeechServiceConfig(new RecognizerConfig_Context(null)), 
                  this.privParameters = parameters, this.privMaxRetryCount = parseInt(parameters.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), 
                  this.privLanguageIdPriority = parameters.getProperty(PropertyId.SpeechServiceConnection_ContinuousLanguageIdPriority, void 0), 
                  this.privLanguageIdMode = "Latency" === this.privLanguageIdPriority ? "DetectContinuous" : "DetectAtAudioStart", 
                  "DetectAtAudioStart" === this.privLanguageIdMode && (this.privLanguageIdPriority = parameters.getProperty(PropertyId.SpeechServiceConnection_AtStartLanguageIdPriority, void 0));
              }
              get parameters() {
                  return this.privParameters;
              }
              get recognitionMode() {
                  return this.privRecognitionMode;
              }
              set recognitionMode(value) {
                  this.privRecognitionMode = value, this.privRecognitionActivityTimeout = value === RecognitionMode.Interactive ? 8e3 : 25e3, 
                  this.privSpeechServiceConfig.Recognition = RecognitionMode[value];
              }
              get SpeechServiceConfig() {
                  return this.privSpeechServiceConfig;
              }
              get recognitionActivityTimeout() {
                  return this.privRecognitionActivityTimeout;
              }
              get isContinuousRecognition() {
                  return this.privRecognitionMode !== RecognitionMode.Interactive;
              }
              get languageIdPriority() {
                  return this.privLanguageIdPriority ? `Prioritize${this.privLanguageIdPriority}` : "";
              }
              get languageIdMode() {
                  return this.privLanguageIdMode;
              }
              get autoDetectSourceLanguages() {
                  return this.parameters.getProperty(PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
              }
              get recognitionEndpointVersion() {
                  return this.parameters.getProperty(PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, void 0);
              }
              get sourceLanguageModels() {
                  const models = [];
                  let modelsExist = !1;
                  if (void 0 !== this.autoDetectSourceLanguages) for (const language of this.autoDetectSourceLanguages.split(",")) {
                      const customProperty = language + PropertyId.SpeechServiceConnection_EndpointId.toString(), modelId = this.parameters.getProperty(customProperty, void 0);
                      void 0 !== modelId ? (models.push({
                          language,
                          endpoint: modelId
                      }), modelsExist = !0) : models.push({
                          language,
                          endpoint: ""
                      });
                  }
                  return modelsExist ? models : void 0;
              }
              get maxRetryCount() {
                  return this.privMaxRetryCount;
              }
          }
          class SpeechServiceConfig {
              constructor(context) {
                  this.context = context;
              }
              serialize() {
                  return JSON.stringify(this, ((key, value) => {
                      if (value && "object" == typeof value) {
                          const replacement = {};
                          for (const k in value) Object.hasOwnProperty.call(value, k) && (replacement[k && k.charAt(0).toLowerCase() + k.substring(1)] = value[k]);
                          return replacement;
                      }
                      return value;
                  }));
              }
              get Context() {
                  return this.context;
              }
              get Recognition() {
                  return this.recognition;
              }
              set Recognition(value) {
                  this.recognition = value.toLowerCase();
              }
          }
          class RecognizerConfig_Context {
              constructor(os) {
                  this.system = new System, this.os = os;
              }
          }
          class System {
              constructor() {
                  this.name = "SpeechSDK", this.version = "1.23.0", this.build = "JavaScript", this.lang = "JavaScript";
              }
          }
          class OS {
              constructor(platform, name, version) {
                  this.platform = platform, this.name = name, this.version = version;
              }
          }
          !function(connectivity) {
              connectivity.Bluetooth = "Bluetooth", connectivity.Wired = "Wired", connectivity.WiFi = "WiFi", 
              connectivity.Cellular = "Cellular", connectivity.InBuilt = "InBuilt", connectivity.Unknown = "Unknown";
          }(connectivity || (connectivity = {})), function(type) {
              type.Phone = "Phone", type.Speaker = "Speaker", type.Car = "Car", type.Headset = "Headset", 
              type.Thermostat = "Thermostat", type.Microphones = "Microphones", type.Deskphone = "Deskphone", 
              type.RemoteControl = "RemoteControl", type.Unknown = "Unknown", type.File = "File", 
              type.Stream = "Stream";
          }(type || (type = {}));
          var rnds8 = new Uint8Array(16);
          function rng() {
              if (!getRandomValues && !(getRandomValues = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
              return getRandomValues(rnds8);
          }
          const regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
          const esm_browser_validate = function(uuid) {
              return "string" == typeof uuid && regex.test(uuid);
          };
          for (var byteToHex = [], i = 0; i < 256; ++i) byteToHex.push((i + 256).toString(16).substr(1));
          const esm_browser_stringify = function(arr) {
              var offset = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
              if (!esm_browser_validate(uuid)) throw TypeError("Stringified UUID is invalid");
              return uuid;
          };
          const esm_browser_v4 = function(options, buf, offset) {
              var rnds = (options = options || {}).random || (options.rng || rng)();
              if (rnds[6] = 15 & rnds[6] | 64, rnds[8] = 63 & rnds[8] | 128, buf) {
                  offset = offset || 0;
                  for (var i = 0; i < 16; ++i) buf[offset + i] = rnds[i];
                  return buf;
              }
              return esm_browser_stringify(rnds);
          }, createNoDashGuid = () => esm_browser_v4().replace(new RegExp("-", "g"), "").toUpperCase();
          class ArgumentNullError extends Error {
              constructor(argumentName) {
                  super(argumentName), this.name = "ArgumentNull", this.message = argumentName;
              }
          }
          class InvalidOperationError extends Error {
              constructor(error) {
                  super(error), this.name = "InvalidOperation", this.message = error;
              }
          }
          class ObjectDisposedError extends Error {
              constructor(objectName, error) {
                  super(error), this.name = objectName + "ObjectDisposed", this.message = error;
              }
          }
          class EventSource {
              constructor(metadata) {
                  this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, 
                  this.privMetadata = metadata;
              }
              onEvent(event) {
                  if (this.isDisposed()) throw new ObjectDisposedError("EventSource");
                  if (this.metadata) for (const paramName in this.metadata) paramName && event.metadata && (event.metadata[paramName] || (event.metadata[paramName] = this.metadata[paramName]));
                  for (const eventId in this.privEventListeners) eventId && this.privEventListeners[eventId] && this.privEventListeners[eventId](event);
              }
              attach(onEventCallback) {
                  const id = createNoDashGuid();
                  return this.privEventListeners[id] = onEventCallback, {
                      detach: () => (delete this.privEventListeners[id], Promise.resolve())
                  };
              }
              attachListener(listener) {
                  return this.attach((e => listener.onEvent(e)));
              }
              attachConsoleListener(listener) {
                  return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((e => listener.onEvent(e))), 
                  this.privConsoleListener;
              }
              isDisposed() {
                  return this.privIsDisposed;
              }
              dispose() {
                  this.privEventListeners = null, this.privIsDisposed = !0;
              }
              get metadata() {
                  return this.privMetadata;
              }
          }
          var PromiseState, PlatformEvent_EventType;
          !function(PromiseState) {
              PromiseState[PromiseState.None = 0] = "None", PromiseState[PromiseState.Resolved = 1] = "Resolved", 
              PromiseState[PromiseState.Rejected = 2] = "Rejected";
          }(PromiseState || (PromiseState = {}));
          class Deferred {
              constructor() {
                  this.resolve = result => (this.privResolve(result), this), this.reject = error => (this.privReject(error), 
                  this), this.privPromise = new Promise(((resolve, reject) => {
                      this.privResolve = resolve, this.privReject = reject;
                  }));
              }
              get promise() {
                  return this.privPromise;
              }
          }
          function marshalPromiseToCallbacks(promise, cb, err) {
              promise.then((val => {
                  try {
                      cb && cb(val);
                  } catch (error) {
                      if (err) try {
                          if (error instanceof Error) {
                              const typedError = error;
                              err(typedError.name + ": " + typedError.message);
                          } else err(error);
                      } catch (error) {}
                  }
              }), (error => {
                  if (err) try {
                      if (error instanceof Error) {
                          const typedError = error;
                          err(typedError.name + ": " + typedError.message);
                      } else err(error);
                  } catch (error) {}
              }));
          }
          !function(EventType) {
              EventType[EventType.Debug = 0] = "Debug", EventType[EventType.Info = 1] = "Info", 
              EventType[EventType.Warning = 2] = "Warning", EventType[EventType.Error = 3] = "Error", 
              EventType[EventType.None = 4] = "None";
          }(PlatformEvent_EventType || (PlatformEvent_EventType = {}));
          class PlatformEvent {
              constructor(eventName, eventType) {
                  this.privName = eventName, this.privEventId = createNoDashGuid(), this.privEventTime = (new Date).toISOString(), 
                  this.privEventType = eventType, this.privMetadata = {};
              }
              get name() {
                  return this.privName;
              }
              get eventId() {
                  return this.privEventId;
              }
              get eventTime() {
                  return this.privEventTime;
              }
              get eventType() {
                  return this.privEventType;
              }
              get metadata() {
                  return this.privMetadata;
              }
          }
          class AudioSourceEvent extends PlatformEvent {
              constructor(eventName, audioSourceId, eventType = PlatformEvent_EventType.Info) {
                  super(eventName, eventType), this.privAudioSourceId = audioSourceId;
              }
              get audioSourceId() {
                  return this.privAudioSourceId;
              }
          }
          class AudioSourceInitializingEvent extends AudioSourceEvent {
              constructor(audioSourceId) {
                  super("AudioSourceInitializingEvent", audioSourceId);
              }
          }
          class AudioSourceReadyEvent extends AudioSourceEvent {
              constructor(audioSourceId) {
                  super("AudioSourceReadyEvent", audioSourceId);
              }
          }
          class AudioSourceOffEvent extends AudioSourceEvent {
              constructor(audioSourceId) {
                  super("AudioSourceOffEvent", audioSourceId);
              }
          }
          class AudioSourceErrorEvent extends AudioSourceEvent {
              constructor(audioSourceId, error) {
                  super("AudioSourceErrorEvent", audioSourceId, PlatformEvent_EventType.Error), this.privError = error;
              }
              get error() {
                  return this.privError;
              }
          }
          class AudioStreamNodeEvent extends AudioSourceEvent {
              constructor(eventName, audioSourceId, audioNodeId) {
                  super(eventName, audioSourceId), this.privAudioNodeId = audioNodeId;
              }
              get audioNodeId() {
                  return this.privAudioNodeId;
              }
          }
          class AudioStreamNodeAttachingEvent extends AudioStreamNodeEvent {
              constructor(audioSourceId, audioNodeId) {
                  super("AudioStreamNodeAttachingEvent", audioSourceId, audioNodeId);
              }
          }
          class AudioStreamNodeAttachedEvent extends AudioStreamNodeEvent {
              constructor(audioSourceId, audioNodeId) {
                  super("AudioStreamNodeAttachedEvent", audioSourceId, audioNodeId);
              }
          }
          class AudioStreamNodeDetachedEvent extends AudioStreamNodeEvent {
              constructor(audioSourceId, audioNodeId) {
                  super("AudioStreamNodeDetachedEvent", audioSourceId, audioNodeId);
              }
          }
          class AudioStreamNodeErrorEvent extends AudioStreamNodeEvent {
              constructor(audioSourceId, audioNodeId, error) {
                  super("AudioStreamNodeErrorEvent", audioSourceId, audioNodeId), this.privError = error;
              }
              get error() {
                  return this.privError;
              }
          }
          class List {
              constructor(list) {
                  if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, 
                  this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], 
                  list) for (const item of list) this.privList.push(item);
              }
              get(itemIndex) {
                  return this.throwIfDisposed(), this.privList[itemIndex];
              }
              first() {
                  return this.get(0);
              }
              last() {
                  return this.get(this.length() - 1);
              }
              add(item) {
                  this.throwIfDisposed(), this.insertAt(this.privList.length, item);
              }
              insertAt(index, item) {
                  this.throwIfDisposed(), 0 === index ? this.privList.unshift(item) : index === this.privList.length ? this.privList.push(item) : this.privList.splice(index, 0, item), 
                  this.triggerSubscriptions(this.privAddSubscriptions);
              }
              removeFirst() {
                  return this.throwIfDisposed(), this.removeAt(0);
              }
              removeLast() {
                  return this.throwIfDisposed(), this.removeAt(this.length() - 1);
              }
              removeAt(index) {
                  return this.throwIfDisposed(), this.remove(index, 1)[0];
              }
              remove(index, count) {
                  this.throwIfDisposed();
                  const removedElements = this.privList.splice(index, count);
                  return this.triggerSubscriptions(this.privRemoveSubscriptions), removedElements;
              }
              clear() {
                  this.throwIfDisposed(), this.remove(0, this.length());
              }
              length() {
                  return this.throwIfDisposed(), this.privList.length;
              }
              onAdded(addedCallback) {
                  this.throwIfDisposed();
                  const subscriptionId = this.privSubscriptionIdCounter++;
                  return this.privAddSubscriptions[subscriptionId] = addedCallback, {
                      detach: () => (delete this.privAddSubscriptions[subscriptionId], Promise.resolve())
                  };
              }
              onRemoved(removedCallback) {
                  this.throwIfDisposed();
                  const subscriptionId = this.privSubscriptionIdCounter++;
                  return this.privRemoveSubscriptions[subscriptionId] = removedCallback, {
                      detach: () => (delete this.privRemoveSubscriptions[subscriptionId], Promise.resolve())
                  };
              }
              onDisposed(disposedCallback) {
                  this.throwIfDisposed();
                  const subscriptionId = this.privSubscriptionIdCounter++;
                  return this.privDisposedSubscriptions[subscriptionId] = disposedCallback, {
                      detach: () => (delete this.privDisposedSubscriptions[subscriptionId], Promise.resolve())
                  };
              }
              join(seperator) {
                  return this.throwIfDisposed(), this.privList.join(seperator);
              }
              toArray() {
                  const cloneCopy = Array();
                  return this.privList.forEach((val => {
                      cloneCopy.push(val);
                  })), cloneCopy;
              }
              any(callback) {
                  return this.throwIfDisposed(), callback ? this.where(callback).length() > 0 : this.length() > 0;
              }
              all(callback) {
                  return this.throwIfDisposed(), this.where(callback).length() === this.length();
              }
              forEach(callback) {
                  this.throwIfDisposed();
                  for (let i = 0; i < this.length(); i++) callback(this.privList[i], i);
              }
              select(callback) {
                  this.throwIfDisposed();
                  const selectList = [];
                  for (let i = 0; i < this.privList.length; i++) selectList.push(callback(this.privList[i], i));
                  return new List(selectList);
              }
              where(callback) {
                  this.throwIfDisposed();
                  const filteredList = new List;
                  for (let i = 0; i < this.privList.length; i++) callback(this.privList[i], i) && filteredList.add(this.privList[i]);
                  return filteredList;
              }
              orderBy(compareFn) {
                  this.throwIfDisposed();
                  const orderedArray = this.toArray().sort(compareFn);
                  return new List(orderedArray);
              }
              orderByDesc(compareFn) {
                  return this.throwIfDisposed(), this.orderBy(((a, b) => compareFn(b, a)));
              }
              clone() {
                  return this.throwIfDisposed(), new List(this.toArray());
              }
              concat(list) {
                  return this.throwIfDisposed(), new List(this.privList.concat(list.toArray()));
              }
              concatArray(array) {
                  return this.throwIfDisposed(), new List(this.privList.concat(array));
              }
              isDisposed() {
                  return null == this.privList;
              }
              dispose(reason) {
                  this.isDisposed() || (this.privDisposeReason = reason, this.privList = null, this.privAddSubscriptions = null, 
                  this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
              }
              throwIfDisposed() {
                  if (this.isDisposed()) throw new ObjectDisposedError("List", this.privDisposeReason);
              }
              triggerSubscriptions(subscriptions) {
                  if (subscriptions) for (const subscriptionId in subscriptions) subscriptionId && subscriptions[subscriptionId]();
              }
          }
          var SubscriberType, __awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          !function(SubscriberType) {
              SubscriberType[SubscriberType.Dequeue = 0] = "Dequeue", SubscriberType[SubscriberType.Peek = 1] = "Peek";
          }(SubscriberType || (SubscriberType = {}));
          class Queue {
              constructor(list) {
                  this.privPromiseStore = new List, this.privIsDrainInProgress = !1, this.privIsDisposing = !1, 
                  this.privDisposeReason = null, this.privList = list || new List, this.privDetachables = [], 
                  this.privSubscribers = new List, this.privDetachables.push(this.privList.onAdded((() => this.drain())));
              }
              enqueue(item) {
                  this.throwIfDispose(), this.enqueueFromPromise(new Promise((resolve => resolve(item))));
              }
              enqueueFromPromise(promise) {
                  this.throwIfDispose(), promise.then((val => {
                      this.privList.add(val);
                  }), (() => {}));
              }
              dequeue() {
                  this.throwIfDispose();
                  const deferredSubscriber = new Deferred;
                  return this.privSubscribers && (this.privSubscribers.add({
                      deferral: deferredSubscriber,
                      type: SubscriberType.Dequeue
                  }), this.drain()), deferredSubscriber.promise;
              }
              peek() {
                  this.throwIfDispose();
                  const deferredSubscriber = new Deferred;
                  return this.privSubscribers && (this.privSubscribers.add({
                      deferral: deferredSubscriber,
                      type: SubscriberType.Peek
                  }), this.drain()), deferredSubscriber.promise;
              }
              length() {
                  return this.throwIfDispose(), this.privList.length();
              }
              isDisposed() {
                  return null == this.privSubscribers;
              }
              drainAndDispose(pendingItemProcessor, reason) {
                  return __awaiter(this, void 0, void 0, (function*() {
                      if (!this.isDisposed() && !this.privIsDisposing) {
                          this.privDisposeReason = reason, this.privIsDisposing = !0;
                          const subs = this.privSubscribers;
                          if (subs) {
                              for (;subs.length() > 0; ) {
                                  subs.removeFirst().deferral.resolve(void 0);
                              }
                              this.privSubscribers === subs && (this.privSubscribers = subs);
                          }
                          for (const detachable of this.privDetachables) yield detachable.detach();
                          if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {
                              const promiseArray = [];
                              return this.privPromiseStore.toArray().forEach((wrapper => {
                                  promiseArray.push(wrapper);
                              })), Promise.all(promiseArray).finally((() => {
                                  this.privSubscribers = null, this.privList.forEach((item => {
                                      pendingItemProcessor(item);
                                  })), this.privList = null;
                              })).then();
                          }
                          this.privSubscribers = null, this.privList = null;
                      }
                  }));
              }
              dispose(reason) {
                  return __awaiter(this, void 0, void 0, (function*() {
                      yield this.drainAndDispose(null, reason);
                  }));
              }
              drain() {
                  if (!this.privIsDrainInProgress && !this.privIsDisposing) {
                      this.privIsDrainInProgress = !0;
                      const subs = this.privSubscribers, lists = this.privList;
                      if (subs && lists) {
                          for (;lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing; ) {
                              const subscriber = subs.removeFirst();
                              if (subscriber.type === SubscriberType.Peek) subscriber.deferral.resolve(lists.first()); else {
                                  const dequeuedItem = lists.removeFirst();
                                  subscriber.deferral.resolve(dequeuedItem);
                              }
                          }
                          this.privSubscribers === subs && (this.privSubscribers = subs), this.privList === lists && (this.privList = lists);
                      }
                      this.privIsDrainInProgress = !1;
                  }
              }
              throwIfDispose() {
                  if (this.isDisposed()) {
                      if (this.privDisposeReason) throw new InvalidOperationError(this.privDisposeReason);
                      throw new ObjectDisposedError("Queue");
                  }
                  if (this.privIsDisposing) throw new InvalidOperationError("Queue disposing");
              }
          }
          var AudioFormatTag, Stream_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class Stream_Stream {
              constructor(streamId) {
                  this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = streamId || createNoDashGuid(), 
                  this.privReaderQueue = new Queue;
              }
              get isClosed() {
                  return this.privIsWriteEnded;
              }
              get isReadEnded() {
                  return this.privIsReadEnded;
              }
              get id() {
                  return this.privId;
              }
              close() {
                  this.privIsWriteEnded || (this.writeStreamChunk({
                      buffer: null,
                      isEnd: !0,
                      timeReceived: Date.now()
                  }), this.privIsWriteEnded = !0);
              }
              writeStreamChunk(streamChunk) {
                  if (this.throwIfClosed(), !this.privReaderQueue.isDisposed()) try {
                      this.privReaderQueue.enqueue(streamChunk);
                  } catch (e) {}
              }
              read() {
                  if (this.privIsReadEnded) throw new InvalidOperationError("Stream read has already finished");
                  return this.privReaderQueue.dequeue().then((streamChunk => Stream_awaiter(this, void 0, void 0, (function*() {
                      return (void 0 === streamChunk || streamChunk.isEnd) && (yield this.privReaderQueue.dispose("End of stream reached")), 
                      streamChunk;
                  }))));
              }
              readEnded() {
                  this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new Queue);
              }
              throwIfClosed() {
                  if (this.privIsWriteEnded) throw new InvalidOperationError("Stream closed");
              }
          }
          class ChunkedArrayBufferStream extends Stream_Stream {
              constructor(targetChunkSize, streamId) {
                  super(streamId), this.privTargetChunkSize = targetChunkSize, this.privNextBufferReadyBytes = 0;
              }
              writeStreamChunk(chunk) {
                  if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) return void super.writeStreamChunk(chunk);
                  let bytesCopiedFromBuffer = 0;
                  for (;bytesCopiedFromBuffer < chunk.buffer.byteLength; ) {
                      void 0 === this.privNextBufferToWrite && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), 
                      this.privNextBufferStartTime = chunk.timeReceived);
                      const bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes), targetView = new Uint8Array(this.privNextBufferToWrite), sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));
                      targetView.set(sourceView, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += bytesToCopy, 
                      bytesCopiedFromBuffer += bytesToCopy, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
                          buffer: this.privNextBufferToWrite,
                          isEnd: !1,
                          timeReceived: this.privNextBufferStartTime
                      }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
                  }
              }
              close() {
                  0 === this.privNextBufferReadyBytes || this.isClosed || super.writeStreamChunk({
                      buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
                      isEnd: !1,
                      timeReceived: this.privNextBufferStartTime
                  }), super.close();
              }
          }
          class Events {
              static setEventSource(eventSource) {
                  if (!eventSource) throw new ArgumentNullError("eventSource");
                  Events.privInstance = eventSource;
              }
              static get instance() {
                  return Events.privInstance;
              }
          }
          Events.privInstance = new EventSource, function(AudioFormatTag) {
              AudioFormatTag[AudioFormatTag.PCM = 1] = "PCM", AudioFormatTag[AudioFormatTag.MuLaw = 2] = "MuLaw", 
              AudioFormatTag[AudioFormatTag.Siren = 3] = "Siren", AudioFormatTag[AudioFormatTag.MP3 = 4] = "MP3", 
              AudioFormatTag[AudioFormatTag.SILKSkype = 5] = "SILKSkype", AudioFormatTag[AudioFormatTag.OGG_OPUS = 6] = "OGG_OPUS", 
              AudioFormatTag[AudioFormatTag.WEBM_OPUS = 7] = "WEBM_OPUS", AudioFormatTag[AudioFormatTag.ALaw = 8] = "ALaw", 
              AudioFormatTag[AudioFormatTag.FLAC = 9] = "FLAC", AudioFormatTag[AudioFormatTag.OPUS = 10] = "OPUS";
          }(AudioFormatTag || (AudioFormatTag = {}));
          class AudioStreamFormat {
              static getDefaultInputFormat() {
                  return AudioStreamFormatImpl.getDefaultInputFormat();
              }
              static getWaveFormat(samplesPerSecond, bitsPerSample, channels, format) {
                  return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels, format);
              }
              static getWaveFormatPCM(samplesPerSecond, bitsPerSample, channels) {
                  return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels);
              }
          }
          class AudioStreamFormatImpl extends AudioStreamFormat {
              constructor(samplesPerSec = 16e3, bitsPerSample = 16, channels = 1, format = AudioFormatTag.PCM) {
                  super();
                  let isWavFormat = !0;
                  switch (format) {
                    case AudioFormatTag.PCM:
                      this.formatTag = 1;
                      break;

                    case AudioFormatTag.ALaw:
                      this.formatTag = 6;
                      break;

                    case AudioFormatTag.MuLaw:
                      this.formatTag = 7;
                      break;

                    default:
                      isWavFormat = !1;
                  }
                  if (this.bitsPerSample = bitsPerSample, this.samplesPerSec = samplesPerSec, this.channels = channels, 
                  this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), 
                  this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), isWavFormat) {
                      this.privHeader = new ArrayBuffer(44);
                      const view = new DataView(this.privHeader);
                      this.setString(view, 0, "RIFF"), view.setUint32(4, 0, !0), this.setString(view, 8, "WAVEfmt "), 
                      view.setUint32(16, 16, !0), view.setUint16(20, this.formatTag, !0), view.setUint16(22, this.channels, !0), 
                      view.setUint32(24, this.samplesPerSec, !0), view.setUint32(28, this.avgBytesPerSec, !0), 
                      view.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), view.setUint16(34, this.bitsPerSample, !0), 
                      this.setString(view, 36, "data"), view.setUint32(40, 0, !0);
                  }
              }
              static getDefaultInputFormat() {
                  return new AudioStreamFormatImpl;
              }
              static getAudioContext(sampleRate) {
                  const AudioContext = window.AudioContext || window.webkitAudioContext || !1;
                  if (AudioContext) return void 0 !== sampleRate && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new AudioContext({
                      sampleRate
                  }) : new AudioContext;
                  throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
              }
              close() {}
              get header() {
                  return this.privHeader;
              }
              setString(view, offset, str) {
                  for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
              }
          }
          var MicAudioSource_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class MicAudioSource {
              constructor(privRecorder, deviceId, audioSourceId, mediaStream) {
                  this.privRecorder = privRecorder, this.deviceId = deviceId, this.privStreams = {}, 
                  this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = audioSourceId || createNoDashGuid(), 
                  this.privEvents = new EventSource, this.privMediaStream = mediaStream || null, this.privIsClosing = !1;
              }
              get format() {
                  return Promise.resolve(MicAudioSource.AUDIOFORMAT);
              }
              get blob() {
                  return Promise.reject("Not implemented for Mic input");
              }
              turnOn() {
                  if (this.privInitializeDeferral) return this.privInitializeDeferral.promise;
                  this.privInitializeDeferral = new Deferred;
                  try {
                      this.createAudioContext();
                  } catch (error) {
                      if (error instanceof Error) {
                          const typedError = error;
                          this.privInitializeDeferral.reject(typedError.name + ": " + typedError.message);
                      } else this.privInitializeDeferral.reject(error);
                      return this.privInitializeDeferral.promise;
                  }
                  const nav = window.navigator;
                  let getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;
                  if (nav.mediaDevices && (getUserMedia = (constraints, successCallback, errorCallback) => {
                      nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);
                  }), getUserMedia) {
                      const next = () => {
                          this.onEvent(new AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new AudioSourceReadyEvent(this.privId)), 
                          this.privInitializeDeferral.resolve()) : getUserMedia({
                              audio: !this.deviceId || {
                                  deviceId: this.deviceId
                              },
                              video: !1
                          }, (mediaStream => {
                              this.privMediaStream = mediaStream, this.onEvent(new AudioSourceReadyEvent(this.privId)), 
                              this.privInitializeDeferral.resolve();
                          }), (error => {
                              const errorMsg = `Error occurred during microphone initialization: ${error}`;
                              this.privInitializeDeferral.reject(errorMsg), this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));
                          }));
                      };
                      "suspended" === this.privContext.state ? this.privContext.resume().then(next).catch((reason => {
                          this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);
                      })) : next();
                  } else {
                      const errorMsg = "Browser does not support getUserMedia.";
                      this.privInitializeDeferral.reject(errorMsg), this.onEvent(new AudioSourceErrorEvent(errorMsg, ""));
                  }
                  return this.privInitializeDeferral.promise;
              }
              id() {
                  return this.privId;
              }
              attach(audioNodeId) {
                  return this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId)), 
                  this.listen(audioNodeId).then((stream => (this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId)), 
                  {
                      detach: () => MicAudioSource_awaiter(this, void 0, void 0, (function*() {
                          return stream.readEnded(), delete this.privStreams[audioNodeId], this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId)), 
                          this.turnOff();
                      })),
                      id: () => audioNodeId,
                      read: () => stream.read()
                  })));
              }
              detach(audioNodeId) {
                  audioNodeId && this.privStreams[audioNodeId] && (this.privStreams[audioNodeId].close(), 
                  delete this.privStreams[audioNodeId], this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId)));
              }
              turnOff() {
                  return MicAudioSource_awaiter(this, void 0, void 0, (function*() {
                      for (const streamId in this.privStreams) if (streamId) {
                          const stream = this.privStreams[streamId];
                          stream && stream.close();
                      }
                      this.onEvent(new AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (yield this.privInitializeDeferral, 
                      this.privInitializeDeferral = null), yield this.destroyAudioContext();
                  }));
              }
              get events() {
                  return this.privEvents;
              }
              get deviceInfo() {
                  return this.getMicrophoneLabel().then((label => ({
                      bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,
                      channelcount: MicAudioSource.AUDIOFORMAT.channels,
                      connectivity: connectivity.Unknown,
                      manufacturer: "Speech SDK",
                      model: label,
                      samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,
                      type: type.Microphones
                  })));
              }
              setProperty(name, value) {
                  if ("MICROPHONE-WorkletSourceUrl" !== name) throw new Error("Property '" + name + "' is not supported on Microphone.");
                  this.privRecorder.setWorkletUrl(value);
              }
              getMicrophoneLabel() {
                  if (void 0 !== this.privMicrophoneLabel) return Promise.resolve(this.privMicrophoneLabel);
                  if (void 0 === this.privMediaStream || !this.privMediaStream.active) return Promise.resolve("microphone");
                  this.privMicrophoneLabel = "microphone";
                  const microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId;
                  if (void 0 === microphoneDeviceId) return Promise.resolve(this.privMicrophoneLabel);
                  const deferred = new Deferred;
                  return navigator.mediaDevices.enumerateDevices().then((devices => {
                      for (const device of devices) if (device.deviceId === microphoneDeviceId) {
                          this.privMicrophoneLabel = device.label;
                          break;
                      }
                      deferred.resolve(this.privMicrophoneLabel);
                  }), (() => deferred.resolve(this.privMicrophoneLabel))), deferred.promise;
              }
              listen(audioNodeId) {
                  return MicAudioSource_awaiter(this, void 0, void 0, (function*() {
                      yield this.turnOn();
                      const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);
                      this.privStreams[audioNodeId] = stream;
                      try {
                          this.privRecorder.record(this.privContext, this.privMediaStream, stream);
                      } catch (error) {
                          throw this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error)), 
                          error;
                      }
                      return stream;
                  }));
              }
              onEvent(event) {
                  this.privEvents.onEvent(event), Events.instance.onEvent(event);
              }
              createAudioContext() {
                  this.privContext || (this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec));
              }
              destroyAudioContext() {
                  return MicAudioSource_awaiter(this, void 0, void 0, (function*() {
                      if (!this.privContext) return;
                      this.privRecorder.releaseMediaResources(this.privContext);
                      let hasClose = !1;
                      "close" in this.privContext && (hasClose = !0), hasClose ? this.privIsClosing || (this.privIsClosing = !0, 
                      yield this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : null !== this.privContext && "running" === this.privContext.state && (yield this.privContext.suspend());
                  }));
              }
          }
          MicAudioSource.AUDIOFORMAT = AudioStreamFormat.getDefaultInputFormat();
          var FileAudioSource_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class FileAudioSource {
              constructor(file, filename, audioSourceId) {
                  this.privStreams = {}, this.privHeaderEnd = 44, this.privId = audioSourceId || createNoDashGuid(), 
                  this.privEvents = new EventSource, this.privSource = file, "undefined" != typeof window && "undefined" != typeof Blob && this.privSource instanceof Blob ? this.privFilename = file.name : this.privFilename = filename || "unknown.wav", 
                  this.privAudioFormatPromise = this.readHeader();
              }
              get format() {
                  return this.privAudioFormatPromise;
              }
              get blob() {
                  return Promise.resolve(this.privSource);
              }
              turnOn() {
                  if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
                      const errorMsg = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
                      return this.onEvent(new AudioSourceErrorEvent(errorMsg, "")), Promise.reject(errorMsg);
                  }
                  this.onEvent(new AudioSourceInitializingEvent(this.privId)), this.onEvent(new AudioSourceReadyEvent(this.privId));
              }
              id() {
                  return this.privId;
              }
              attach(audioNodeId) {
                  return FileAudioSource_awaiter(this, void 0, void 0, (function*() {
                      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
                      const stream = yield this.upload(audioNodeId);
                      return this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId)), 
                      Promise.resolve({
                          detach: () => FileAudioSource_awaiter(this, void 0, void 0, (function*() {
                              stream.readEnded(), delete this.privStreams[audioNodeId], this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId)), 
                              yield this.turnOff();
                          })),
                          id: () => audioNodeId,
                          read: () => stream.read()
                      });
                  }));
              }
              detach(audioNodeId) {
                  audioNodeId && this.privStreams[audioNodeId] && (this.privStreams[audioNodeId].close(), 
                  delete this.privStreams[audioNodeId], this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId)));
              }
              turnOff() {
                  for (const streamId in this.privStreams) if (streamId) {
                      const stream = this.privStreams[streamId];
                      stream && !stream.isClosed && stream.close();
                  }
                  return this.onEvent(new AudioSourceOffEvent(this.privId)), Promise.resolve();
              }
              get events() {
                  return this.privEvents;
              }
              get deviceInfo() {
                  return this.privAudioFormatPromise.then((result => Promise.resolve({
                      bitspersample: result.bitsPerSample,
                      channelcount: result.channels,
                      connectivity: connectivity.Unknown,
                      manufacturer: "Speech SDK",
                      model: "File",
                      samplerate: result.samplesPerSec,
                      type: type.File
                  })));
              }
              readHeader() {
                  const header = this.privSource.slice(0, 512), headerResult = new Deferred, processHeader = header => {
                      const view = new DataView(header), getWord = index => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));
                      if ("RIFF" !== getWord(0)) return void headerResult.reject("Invalid WAV header in file, RIFF was not found");
                      if ("WAVE" !== getWord(8) || "fmt " !== getWord(12)) return void headerResult.reject("Invalid WAV header in file, WAVEfmt was not found");
                      const formatSize = view.getInt32(16, !0), channelCount = view.getUint16(22, !0), sampleRate = view.getUint32(24, !0), bitsPerSample = view.getUint16(34, !0);
                      let pos = 36 + Math.max(formatSize - 16, 0);
                      for (;"data" !== getWord(pos); pos += 2) if (pos > 504) return void headerResult.reject("Invalid WAV header in file, data block was not found");
                      this.privHeaderEnd = pos + 8, headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));
                  };
                  if ("undefined" != typeof window && "undefined" != typeof Blob && header instanceof Blob) {
                      const reader = new FileReader;
                      reader.onload = event => {
                          const header = event.target.result;
                          processHeader(header);
                      }, reader.readAsArrayBuffer(header);
                  } else {
                      const h = header;
                      processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));
                  }
                  return headerResult.promise;
              }
              upload(audioNodeId) {
                  return FileAudioSource_awaiter(this, void 0, void 0, (function*() {
                      const onerror = error => {
                          const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;
                          throw this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg)), 
                          new Error(errorMsg);
                      };
                      try {
                          yield this.turnOn();
                          const format = yield this.privAudioFormatPromise, stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);
                          this.privStreams[audioNodeId] = stream;
                          const chunk = this.privSource.slice(this.privHeaderEnd), processFile = buff => {
                              stream.isClosed || (stream.writeStreamChunk({
                                  buffer: buff,
                                  isEnd: !1,
                                  timeReceived: Date.now()
                              }), stream.close());
                          };
                          if ("undefined" != typeof window && "undefined" != typeof Blob && chunk instanceof Blob) {
                              const reader = new FileReader;
                              reader.onerror = ev => onerror(ev.toString()), reader.onload = event => {
                                  const fileBuffer = event.target.result;
                                  processFile(fileBuffer);
                              }, reader.readAsArrayBuffer(chunk);
                          } else {
                              const c = chunk;
                              processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));
                          }
                          return stream;
                      } catch (e) {
                          onerror(e);
                      }
                  }));
              }
              onEvent(event) {
                  this.privEvents.onEvent(event), Events.instance.onEvent(event);
              }
          }
          class PullAudioInputStreamCallback {}
          var MessageType, ConnectionState, CancellationReason, CancellationErrorCode, ResultReason, AudioInputStream_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class AudioInputStream {
              constructor() {}
              static createPushStream(format) {
                  return PushAudioInputStream.create(format);
              }
              static createPullStream(callback, format) {
                  return PullAudioInputStream.create(callback, format);
              }
          }
          class PushAudioInputStream extends AudioInputStream {
              static create(format) {
                  return new PushAudioInputStreamImpl(format);
              }
          }
          class PushAudioInputStreamImpl extends PushAudioInputStream {
              constructor(format) {
                  super(), this.privFormat = void 0 === format ? AudioStreamFormatImpl.getDefaultInputFormat() : format, 
                  this.privEvents = new EventSource, this.privId = createNoDashGuid(), this.privStream = new ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
              }
              get format() {
                  return Promise.resolve(this.privFormat);
              }
              write(dataBuffer) {
                  this.privStream.writeStreamChunk({
                      buffer: dataBuffer,
                      isEnd: !1,
                      timeReceived: Date.now()
                  });
              }
              close() {
                  this.privStream.close();
              }
              id() {
                  return this.privId;
              }
              get blob() {
                  return this.attach("id").then((audioNode => {
                      const data = [];
                      let bufferData = Buffer.from("");
                      const readCycle = () => audioNode.read().then((audioStreamChunk => !audioStreamChunk || audioStreamChunk.isEnd ? "undefined" != typeof XMLHttpRequest && "undefined" != typeof Blob ? Promise.resolve(new Blob(data)) : Promise.resolve(Buffer.from(bufferData)) : ("undefined" != typeof Blob ? data.push(audioStreamChunk.buffer) : bufferData = Buffer.concat([ bufferData, this.toBuffer(audioStreamChunk.buffer) ]), 
                      readCycle())));
                      return readCycle();
                  }));
              }
              turnOn() {
                  this.onEvent(new AudioSourceInitializingEvent(this.privId)), this.onEvent(new AudioSourceReadyEvent(this.privId));
              }
              attach(audioNodeId) {
                  return AudioInputStream_awaiter(this, void 0, void 0, (function*() {
                      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId)), yield this.turnOn();
                      const stream = this.privStream;
                      return this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId)), 
                      {
                          detach: () => AudioInputStream_awaiter(this, void 0, void 0, (function*() {
                              return this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId)), 
                              this.turnOff();
                          })),
                          id: () => audioNodeId,
                          read: () => stream.read()
                      };
                  }));
              }
              detach(audioNodeId) {
                  this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
              }
              turnOff() {}
              get events() {
                  return this.privEvents;
              }
              get deviceInfo() {
                  return Promise.resolve({
                      bitspersample: this.privFormat.bitsPerSample,
                      channelcount: this.privFormat.channels,
                      connectivity: connectivity.Unknown,
                      manufacturer: "Speech SDK",
                      model: "PushStream",
                      samplerate: this.privFormat.samplesPerSec,
                      type: type.Stream
                  });
              }
              onEvent(event) {
                  this.privEvents.onEvent(event), Events.instance.onEvent(event);
              }
              toBuffer(arrayBuffer) {
                  const buf = Buffer.alloc(arrayBuffer.byteLength), view = new Uint8Array(arrayBuffer);
                  for (let i = 0; i < buf.length; ++i) buf[i] = view[i];
                  return buf;
              }
          }
          class PullAudioInputStream extends AudioInputStream {
              constructor() {
                  super();
              }
              static create(callback, format) {
                  return new PullAudioInputStreamImpl(callback, format);
              }
          }
          class PullAudioInputStreamImpl extends PullAudioInputStream {
              constructor(callback, format) {
                  super(), this.privFormat = void 0 === format ? AudioStreamFormat.getDefaultInputFormat() : format, 
                  this.privEvents = new EventSource, this.privId = createNoDashGuid(), this.privCallback = callback, 
                  this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
              }
              get format() {
                  return Promise.resolve(this.privFormat);
              }
              close() {
                  this.privIsClosed = !0, this.privCallback.close();
              }
              id() {
                  return this.privId;
              }
              get blob() {
                  return Promise.reject("Not implemented");
              }
              turnOn() {
                  this.onEvent(new AudioSourceInitializingEvent(this.privId)), this.onEvent(new AudioSourceReadyEvent(this.privId));
              }
              attach(audioNodeId) {
                  return AudioInputStream_awaiter(this, void 0, void 0, (function*() {
                      return this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId)), 
                      yield this.turnOn(), this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId)), 
                      {
                          detach: () => (this.privCallback.close(), this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId)), 
                          this.turnOff()),
                          id: () => audioNodeId,
                          read: () => {
                              let transmitBuff, totalBytes = 0;
                              for (;totalBytes < this.privBufferSize; ) {
                                  const readBuff = new ArrayBuffer(this.privBufferSize - totalBytes), pulledBytes = this.privCallback.read(readBuff);
                                  if (void 0 === transmitBuff) transmitBuff = readBuff; else {
                                      new Int8Array(transmitBuff).set(new Int8Array(readBuff), totalBytes);
                                  }
                                  if (0 === pulledBytes) break;
                                  totalBytes += pulledBytes;
                              }
                              return Promise.resolve({
                                  buffer: transmitBuff.slice(0, totalBytes),
                                  isEnd: this.privIsClosed || 0 === totalBytes,
                                  timeReceived: Date.now()
                              });
                          }
                      };
                  }));
              }
              detach(audioNodeId) {
                  this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
              }
              turnOff() {}
              get events() {
                  return this.privEvents;
              }
              get deviceInfo() {
                  return Promise.resolve({
                      bitspersample: this.privFormat.bitsPerSample,
                      channelcount: this.privFormat.channels,
                      connectivity: connectivity.Unknown,
                      manufacturer: "Speech SDK",
                      model: "PullStream",
                      samplerate: this.privFormat.samplesPerSec,
                      type: type.Stream
                  });
              }
              onEvent(event) {
                  this.privEvents.onEvent(event), Events.instance.onEvent(event);
              }
          }
          !function(MessageType) {
              MessageType[MessageType.Text = 0] = "Text", MessageType[MessageType.Binary = 1] = "Binary";
          }(MessageType || (MessageType = {}));
          class ConnectionMessage {
              constructor(messageType, body, headers, id) {
                  if (this.privBody = null, messageType === MessageType.Text && body && "string" != typeof body) throw new InvalidOperationError("Payload must be a string");
                  if (messageType === MessageType.Binary && body && !(body instanceof ArrayBuffer)) throw new InvalidOperationError("Payload must be ArrayBuffer");
                  switch (this.privMessageType = messageType, this.privBody = body, this.privHeaders = headers || {}, 
                  this.privId = id || createNoDashGuid(), this.messageType) {
                    case MessageType.Binary:
                      this.privSize = null !== this.binaryBody ? this.binaryBody.byteLength : 0;
                      break;

                    case MessageType.Text:
                      this.privSize = this.textBody.length;
                  }
              }
              get messageType() {
                  return this.privMessageType;
              }
              get headers() {
                  return this.privHeaders;
              }
              get body() {
                  return this.privBody;
              }
              get textBody() {
                  if (this.privMessageType === MessageType.Binary) throw new InvalidOperationError("Not supported for binary message");
                  return this.privBody;
              }
              get binaryBody() {
                  if (this.privMessageType === MessageType.Text) throw new InvalidOperationError("Not supported for text message");
                  return this.privBody;
              }
              get id() {
                  return this.privId;
              }
          }
          class ServiceEvent extends PlatformEvent {
              constructor(eventName, jsonstring, eventType = PlatformEvent_EventType.Info) {
                  super(eventName, eventType), this.privJsonResult = jsonstring;
              }
              get jsonString() {
                  return this.privJsonResult;
              }
          }
          class ConnectionEvent extends PlatformEvent {
              constructor(eventName, connectionId, eventType = PlatformEvent_EventType.Info) {
                  super(eventName, eventType), this.privConnectionId = connectionId;
              }
              get connectionId() {
                  return this.privConnectionId;
              }
          }
          class ConnectionStartEvent extends ConnectionEvent {
              constructor(connectionId, uri, headers) {
                  super("ConnectionStartEvent", connectionId), this.privUri = uri, this.privHeaders = headers;
              }
              get uri() {
                  return this.privUri;
              }
              get headers() {
                  return this.privHeaders;
              }
          }
          class ConnectionEstablishedEvent extends ConnectionEvent {
              constructor(connectionId) {
                  super("ConnectionEstablishedEvent", connectionId);
              }
          }
          class ConnectionClosedEvent extends ConnectionEvent {
              constructor(connectionId, statusCode, reason) {
                  super("ConnectionClosedEvent", connectionId, PlatformEvent_EventType.Debug), this.privReason = reason, 
                  this.privStatusCode = statusCode;
              }
              get reason() {
                  return this.privReason;
              }
              get statusCode() {
                  return this.privStatusCode;
              }
          }
          class ConnectionErrorEvent extends ConnectionEvent {
              constructor(connectionId, message, type) {
                  super("ConnectionErrorEvent", connectionId, PlatformEvent_EventType.Debug), this.privMessage = message, 
                  this.privType = type;
              }
              get message() {
                  return this.privMessage;
              }
              get type() {
                  return this.privType;
              }
          }
          class ConnectionEstablishErrorEvent extends ConnectionEvent {
              constructor(connectionId, statuscode, reason) {
                  super("ConnectionEstablishErrorEvent", connectionId, PlatformEvent_EventType.Error), 
                  this.privStatusCode = statuscode, this.privReason = reason;
              }
              get reason() {
                  return this.privReason;
              }
              get statusCode() {
                  return this.privStatusCode;
              }
          }
          class ConnectionMessageReceivedEvent extends ConnectionEvent {
              constructor(connectionId, networkReceivedTimeISO, message) {
                  super("ConnectionMessageReceivedEvent", connectionId), this.privNetworkReceivedTime = networkReceivedTimeISO, 
                  this.privMessage = message;
              }
              get networkReceivedTime() {
                  return this.privNetworkReceivedTime;
              }
              get message() {
                  return this.privMessage;
              }
          }
          class ConnectionMessageSentEvent extends ConnectionEvent {
              constructor(connectionId, networkSentTimeISO, message) {
                  super("ConnectionMessageSentEvent", connectionId), this.privNetworkSentTime = networkSentTimeISO, 
                  this.privMessage = message;
              }
              get networkSentTime() {
                  return this.privNetworkSentTime;
              }
              get message() {
                  return this.privMessage;
              }
          }
          !function(ConnectionState) {
              ConnectionState[ConnectionState.None = 0] = "None", ConnectionState[ConnectionState.Connected = 1] = "Connected", 
              ConnectionState[ConnectionState.Connecting = 2] = "Connecting", ConnectionState[ConnectionState.Disconnected = 3] = "Disconnected";
          }(ConnectionState || (ConnectionState = {})), function(CancellationReason) {
              CancellationReason[CancellationReason.Error = 0] = "Error", CancellationReason[CancellationReason.EndOfStream = 1] = "EndOfStream";
          }(CancellationReason || (CancellationReason = {})), function(CancellationErrorCode) {
              CancellationErrorCode[CancellationErrorCode.NoError = 0] = "NoError", CancellationErrorCode[CancellationErrorCode.AuthenticationFailure = 1] = "AuthenticationFailure", 
              CancellationErrorCode[CancellationErrorCode.BadRequestParameters = 2] = "BadRequestParameters", 
              CancellationErrorCode[CancellationErrorCode.TooManyRequests = 3] = "TooManyRequests", 
              CancellationErrorCode[CancellationErrorCode.ConnectionFailure = 4] = "ConnectionFailure", 
              CancellationErrorCode[CancellationErrorCode.ServiceTimeout = 5] = "ServiceTimeout", 
              CancellationErrorCode[CancellationErrorCode.ServiceError = 6] = "ServiceError", 
              CancellationErrorCode[CancellationErrorCode.RuntimeError = 7] = "RuntimeError", 
              CancellationErrorCode[CancellationErrorCode.Forbidden = 8] = "Forbidden";
          }(CancellationErrorCode || (CancellationErrorCode = {}));
          class SpeechSynthesisEventArgs {
              constructor(result) {
                  this.privResult = result;
              }
              get result() {
                  return this.privResult;
              }
          }
          class SynthesisResult {
              constructor(resultId, reason, errorDetails, properties) {
                  this.privResultId = resultId, this.privReason = reason, this.privErrorDetails = errorDetails, 
                  this.privProperties = properties;
              }
              get resultId() {
                  return this.privResultId;
              }
              get reason() {
                  return this.privReason;
              }
              get errorDetails() {
                  return this.privErrorDetails;
              }
              get properties() {
                  return this.privProperties;
              }
          }
          class SpeechSynthesisResult extends SynthesisResult {
              constructor(resultId, reason, audioData, errorDetails, properties, audioDuration) {
                  super(resultId, reason, errorDetails, properties), this.privAudioData = audioData, 
                  this.privAudioDuration = audioDuration;
              }
              get audioData() {
                  return this.privAudioData;
              }
              get audioDuration() {
                  return this.privAudioDuration;
              }
          }
          !function(ResultReason) {
              ResultReason[ResultReason.NoMatch = 0] = "NoMatch", ResultReason[ResultReason.Canceled = 1] = "Canceled", 
              ResultReason[ResultReason.RecognizingSpeech = 2] = "RecognizingSpeech", ResultReason[ResultReason.RecognizedSpeech = 3] = "RecognizedSpeech", 
              ResultReason[ResultReason.RecognizedKeyword = 4] = "RecognizedKeyword", ResultReason[ResultReason.RecognizingIntent = 5] = "RecognizingIntent", 
              ResultReason[ResultReason.RecognizedIntent = 6] = "RecognizedIntent", ResultReason[ResultReason.TranslatingSpeech = 7] = "TranslatingSpeech", 
              ResultReason[ResultReason.TranslatedSpeech = 8] = "TranslatedSpeech", ResultReason[ResultReason.SynthesizingAudio = 9] = "SynthesizingAudio", 
              ResultReason[ResultReason.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", 
              ResultReason[ResultReason.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", 
              ResultReason[ResultReason.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", 
              ResultReason[ResultReason.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", ResultReason[ResultReason.RecognizedSpeakers = 14] = "RecognizedSpeakers", 
              ResultReason[ResultReason.RecognizedSpeaker = 15] = "RecognizedSpeaker", ResultReason[ResultReason.ResetVoiceProfile = 16] = "ResetVoiceProfile", 
              ResultReason[ResultReason.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", ResultReason[ResultReason.VoicesListRetrieved = 18] = "VoicesListRetrieved";
          }(ResultReason || (ResultReason = {}));
          class SpeechSynthesisWordBoundaryEventArgs {
              constructor(audioOffset, duration, text, wordLength, textOffset, boundaryType) {
                  this.privAudioOffset = audioOffset, this.privDuration = duration, this.privText = text, 
                  this.privWordLength = wordLength, this.privTextOffset = textOffset, this.privBoundaryType = boundaryType;
              }
              get audioOffset() {
                  return this.privAudioOffset;
              }
              get duration() {
                  return this.privDuration;
              }
              get text() {
                  return this.privText;
              }
              get wordLength() {
                  return this.privWordLength;
              }
              get textOffset() {
                  return this.privTextOffset;
              }
              get boundaryType() {
                  return this.privBoundaryType;
              }
          }
          class SpeechSynthesisBookmarkEventArgs {
              constructor(audioOffset, text) {
                  this.privAudioOffset = audioOffset, this.privText = text;
              }
              get audioOffset() {
                  return this.privAudioOffset;
              }
              get text() {
                  return this.privText;
              }
          }
          class SpeechSynthesisVisemeEventArgs {
              constructor(audioOffset, visemeId, animation) {
                  this.privAudioOffset = audioOffset, this.privVisemeId = visemeId, this.privAnimation = animation;
              }
              get audioOffset() {
                  return this.privAudioOffset;
              }
              get visemeId() {
                  return this.privVisemeId;
              }
              get animation() {
                  return this.privAnimation;
              }
          }
          class AudioOutputFormatImpl extends AudioStreamFormatImpl {
              constructor(formatTag, channels, samplesPerSec, avgBytesPerSec, blockAlign, bitsPerSample, audioFormatString, requestAudioFormatString, hasHeader) {
                  super(samplesPerSec, bitsPerSample, channels, formatTag), this.formatTag = formatTag, 
                  this.avgBytesPerSec = avgBytesPerSec, this.blockAlign = blockAlign, this.priAudioFormatString = audioFormatString, 
                  this.priRequestAudioFormatString = requestAudioFormatString, this.priHasHeader = hasHeader;
              }
              static fromSpeechSynthesisOutputFormat(speechSynthesisOutputFormat) {
                  return void 0 === speechSynthesisOutputFormat ? AudioOutputFormatImpl.getDefaultOutputFormat() : AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString[speechSynthesisOutputFormat]);
              }
              static fromSpeechSynthesisOutputFormatString(speechSynthesisOutputFormatString) {
                  switch (speechSynthesisOutputFormatString) {
                    case "raw-8khz-8bit-mono-mulaw":
                      return new AudioOutputFormatImpl(AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "riff-16khz-16kbps-mono-siren":
                      return new AudioOutputFormatImpl(AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, speechSynthesisOutputFormatString, "audio-16khz-16kbps-mono-siren", !0);

                    case "audio-16khz-16kbps-mono-siren":
                      return new AudioOutputFormatImpl(AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-16khz-32kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-16khz-128kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-16khz-64kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-24khz-48kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-24khz-96kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-24khz-160kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "raw-16khz-16bit-mono-truesilk":
                      return new AudioOutputFormatImpl(AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "riff-8khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", !0);

                    case "riff-24khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", !0);

                    case "riff-8khz-8bit-mono-mulaw":
                      return new AudioOutputFormatImpl(AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-mulaw", !0);

                    case "raw-16khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, speechSynthesisOutputFormatString, "raw-16khz-16bit-mono-pcm", !1);

                    case "raw-24khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", !1);

                    case "raw-8khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", !1);

                    case "ogg-16khz-16bit-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "ogg-24khz-16bit-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "raw-48khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", !1);

                    case "riff-48khz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", !0);

                    case "audio-48khz-96kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-48khz-192kbitrate-mono-mp3":
                      return new AudioOutputFormatImpl(AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "ogg-48khz-16bit-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "webm-16khz-16bit-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "webm-24khz-16bit-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "webm-24khz-16bit-24kbps-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-16khz-16bit-32kbps-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-24khz-16bit-48kbps-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-24khz-16bit-24kbps-mono-opus":
                      return new AudioOutputFormatImpl(AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-24khz-16bit-mono-flac":
                      return new AudioOutputFormatImpl(AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "audio-48khz-16bit-mono-flac":
                      return new AudioOutputFormatImpl(AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "raw-24khz-16bit-mono-truesilk":
                      return new AudioOutputFormatImpl(AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "raw-8khz-8bit-mono-alaw":
                      return new AudioOutputFormatImpl(AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "riff-8khz-8bit-mono-alaw":
                      return new AudioOutputFormatImpl(AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-alaw", !0);

                    case "raw-22050hz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "riff-22050hz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, "raw-22050hz-16bit-mono-pcm", !0);

                    case "raw-44100hz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, !1);

                    case "riff-44100hz-16bit-mono-pcm":
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, "raw-44100hz-16bit-mono-pcm", !0);

                    default:
                      return new AudioOutputFormatImpl(AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
                  }
              }
              static getDefaultOutputFormat() {
                  return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString("undefined" != typeof window ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
              }
              get hasHeader() {
                  return this.priHasHeader;
              }
              get header() {
                  if (this.hasHeader) return this.privHeader;
              }
              updateHeader(audioLength) {
                  if (this.priHasHeader) {
                      const view = new DataView(this.privHeader);
                      view.setUint32(4, audioLength + this.privHeader.byteLength - 8, !0), view.setUint32(40, audioLength, !0);
                  }
              }
              get requestAudioFormatString() {
                  return this.priRequestAudioFormatString;
              }
          }
          AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString = {
              [SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
              [SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
              [SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
              [SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
              [SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
              [SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
              [SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
              [SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
              [SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
              [SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
              [SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
              [SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
              [SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
              [SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
              [SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
              [SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
              [SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
              [SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
              [SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
              [SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm"
          };
          var MetadataType, AudioOutputStream_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class AudioOutputStream {
              constructor() {}
              static createPullStream() {
                  return PullAudioOutputStream.create();
              }
          }
          class PullAudioOutputStream extends AudioOutputStream {
              static create() {
                  return new PullAudioOutputStreamImpl;
              }
          }
          class PullAudioOutputStreamImpl extends PullAudioOutputStream {
              constructor() {
                  super(), this.privId = createNoDashGuid(), this.privStream = new Stream_Stream;
              }
              set format(format) {
                  null == format && (this.privFormat = AudioOutputFormatImpl.getDefaultOutputFormat()), 
                  this.privFormat = format;
              }
              get format() {
                  return this.privFormat;
              }
              get isClosed() {
                  return this.privStream.isClosed;
              }
              id() {
                  return this.privId;
              }
              read(dataBuffer) {
                  return AudioOutputStream_awaiter(this, void 0, void 0, (function*() {
                      const intView = new Int8Array(dataBuffer);
                      let totalBytes = 0;
                      if (void 0 !== this.privLastChunkView) {
                          if (this.privLastChunkView.length > dataBuffer.byteLength) return intView.set(this.privLastChunkView.slice(0, dataBuffer.byteLength)), 
                          this.privLastChunkView = this.privLastChunkView.slice(dataBuffer.byteLength), Promise.resolve(dataBuffer.byteLength);
                          intView.set(this.privLastChunkView), totalBytes = this.privLastChunkView.length, 
                          this.privLastChunkView = void 0;
                      }
                      for (;totalBytes < dataBuffer.byteLength && !this.privStream.isReadEnded; ) {
                          const chunk = yield this.privStream.read();
                          if (void 0 === chunk || chunk.isEnd) this.privStream.readEnded(); else {
                              let tmpBuffer;
                              chunk.buffer.byteLength > dataBuffer.byteLength - totalBytes ? (tmpBuffer = chunk.buffer.slice(0, dataBuffer.byteLength - totalBytes), 
                              this.privLastChunkView = new Int8Array(chunk.buffer.slice(dataBuffer.byteLength - totalBytes))) : tmpBuffer = chunk.buffer, 
                              intView.set(new Int8Array(tmpBuffer), totalBytes), totalBytes += tmpBuffer.byteLength;
                          }
                      }
                      return totalBytes;
                  }));
              }
              write(dataBuffer) {
                  Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), 
                  this.privStream.writeStreamChunk({
                      buffer: dataBuffer,
                      isEnd: !1,
                      timeReceived: Date.now()
                  });
              }
              close() {
                  this.privStream.close();
              }
          }
          class PushAudioOutputStream extends AudioOutputStream {
              constructor() {
                  super();
              }
              static create(callback) {
                  return new PushAudioOutputStreamImpl(callback);
              }
          }
          class PushAudioOutputStreamImpl extends PushAudioOutputStream {
              constructor(callback) {
                  super(), this.privId = createNoDashGuid(), this.privCallback = callback;
              }
              set format(format) {}
              write(buffer) {
                  this.privCallback.write && this.privCallback.write(buffer);
              }
              close() {
                  this.privCallback.close && this.privCallback.close();
              }
              id() {
                  return this.privId;
              }
          }
          !function(MetadataType) {
              MetadataType.WordBoundary = "WordBoundary", MetadataType.Bookmark = "Bookmark", 
              MetadataType.Viseme = "Viseme", MetadataType.SentenceBoundary = "SentenceBoundary", 
              MetadataType.SessionEnd = "SessionEnd";
          }(MetadataType || (MetadataType = {}));
          class SynthesisAudioMetadata {
              constructor(json) {
                  this.privSynthesisAudioMetadata = JSON.parse(json);
              }
              static fromJSON(json) {
                  return new SynthesisAudioMetadata(json);
              }
              get Metadata() {
                  return this.privSynthesisAudioMetadata.Metadata;
              }
          }
          class SpeechSynthesisEvent extends PlatformEvent {
              constructor(eventName, requestId, eventType = PlatformEvent_EventType.Info) {
                  super(eventName, eventType), this.privRequestId = requestId;
              }
              get requestId() {
                  return this.privRequestId;
              }
          }
          class SynthesisTriggeredEvent extends SpeechSynthesisEvent {
              constructor(requestId, sessionAudioDestinationId, turnAudioDestinationId) {
                  super("SynthesisTriggeredEvent", requestId), this.privSessionAudioDestinationId = sessionAudioDestinationId, 
                  this.privTurnAudioDestinationId = turnAudioDestinationId;
              }
              get audioSessionDestinationId() {
                  return this.privSessionAudioDestinationId;
              }
              get audioTurnDestinationId() {
                  return this.privTurnAudioDestinationId;
              }
          }
          class ConnectingToSynthesisServiceEvent extends SpeechSynthesisEvent {
              constructor(requestId, authFetchEventId) {
                  super("ConnectingToSynthesisServiceEvent", requestId), this.privAuthFetchEventId = authFetchEventId;
              }
              get authFetchEventId() {
                  return this.privAuthFetchEventId;
              }
          }
          class SynthesisStartedEvent extends SpeechSynthesisEvent {
              constructor(requestId, authFetchEventId) {
                  super("SynthesisStartedEvent", requestId), this.privAuthFetchEventId = authFetchEventId;
              }
              get authFetchEventId() {
                  return this.privAuthFetchEventId;
              }
          }
          var SynthesisTurn_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class SynthesisTurn {
              constructor() {
                  this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, 
                  this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, 
                  this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = createNoDashGuid(), 
                  this.privTurnDeferral = new Deferred, this.privTurnDeferral.resolve();
              }
              get requestId() {
                  return this.privRequestId;
              }
              get streamId() {
                  return this.privStreamId;
              }
              set streamId(value) {
                  this.privStreamId = value;
              }
              get audioOutputFormat() {
                  return this.privAudioOutputFormat;
              }
              set audioOutputFormat(format) {
                  this.privAudioOutputFormat = format;
              }
              get turnCompletionPromise() {
                  return this.privTurnDeferral.promise;
              }
              get isSynthesisEnded() {
                  return this.privIsSynthesisEnded;
              }
              get isSynthesizing() {
                  return this.privIsSynthesizing;
              }
              get currentTextOffset() {
                  return this.privTextOffset;
              }
              get currentSentenceOffset() {
                  return this.privSentenceOffset;
              }
              get bytesReceived() {
                  return this.privBytesReceived;
              }
              get audioDuration() {
                  return this.privAudioDuration;
              }
              getAllReceivedAudio() {
                  return SynthesisTurn_awaiter(this, void 0, void 0, (function*() {
                      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (yield this.readAllAudioFromStream(), 
                      Promise.resolve(this.privReceivedAudio)) : null;
                  }));
              }
              getAllReceivedAudioWithHeader() {
                  return SynthesisTurn_awaiter(this, void 0, void 0, (function*() {
                      if (this.privReceivedAudioWithHeader) return this.privReceivedAudioWithHeader;
                      if (!this.privIsSynthesisEnded) return null;
                      if (this.audioOutputFormat.hasHeader) {
                          const audio = yield this.getAllReceivedAudio();
                          return this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat), 
                          this.privReceivedAudioWithHeader;
                      }
                      return this.getAllReceivedAudio();
                  }));
              }
              startNewSynthesis(requestId, rawText, isSSML, audioDestination) {
                  this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = requestId, 
                  this.privRawText = rawText, this.privIsSSML = isSSML, this.privAudioOutputStream = new PullAudioOutputStreamImpl, 
                  this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, 
                  this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, 
                  this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, 
                  this.privPartialVisemeAnimation = "", void 0 !== audioDestination && (this.privTurnAudioDestination = audioDestination, 
                  this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new SynthesisTriggeredEvent(this.requestId, void 0, void 0 === audioDestination ? void 0 : audioDestination.id()));
              }
              onPreConnectionStart(authFetchEventId) {
                  this.privAuthFetchEventId = authFetchEventId, this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
              }
              onAuthCompleted(isError) {
                  isError && this.onComplete();
              }
              onConnectionEstablishCompleted(statusCode) {
                  if (200 === statusCode) return this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), 
                  void (this.privBytesReceived = 0);
                  403 === statusCode && this.onComplete();
              }
              onServiceResponseMessage(responseJson) {
                  const response = JSON.parse(responseJson);
                  this.streamId = response.audio.streamId;
              }
              onServiceTurnEndResponse() {
                  this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
              }
              onServiceTurnStartResponse() {
                  this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), 
                  this.privTurnDeferral.promise.then().catch((() => {}))), this.privInTurn = !0, this.privTurnDeferral = new Deferred;
              }
              onAudioChunkReceived(data) {
                  this.isSynthesizing && (this.privAudioOutputStream.write(data), this.privBytesReceived += data.byteLength, 
                  void 0 !== this.privTurnAudioDestination && this.privTurnAudioDestination.write(data));
              }
              onTextBoundaryEvent(metadata) {
                  this.updateTextOffset(metadata.Data.text.Text, metadata.Type);
              }
              onVisemeMetadataReceived(metadata) {
                  void 0 !== metadata.Data.AnimationChunk && (this.privPartialVisemeAnimation += metadata.Data.AnimationChunk);
              }
              onSessionEnd(metadata) {
                  this.privAudioDuration = metadata.Data.Offset;
              }
              dispose() {
                  this.privIsDisposed || (this.privIsDisposed = !0);
              }
              onStopSynthesizing() {
                  this.onComplete();
              }
              getAndClearVisemeAnimation() {
                  const animation = this.privPartialVisemeAnimation;
                  return this.privPartialVisemeAnimation = "", animation;
              }
              onEvent(event) {
                  Events.instance.onEvent(event);
              }
              static isXmlTag(text) {
                  return text.length >= 2 && "<" === text[0] && ">" === text[text.length - 1];
              }
              updateTextOffset(text, type) {
                  type === MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex), 
                  this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + text.length, 
                  this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text) && this.updateTextOffset(text, type))) : (this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex), 
                  this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length, 
                  this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text) && this.updateTextOffset(text, type)));
              }
              onComplete() {
                  this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, 
                  this.privAudioOutputStream.close(), this.privInTurn = !1, void 0 !== this.privTurnAudioDestination && (this.privTurnAudioDestination.close(), 
                  this.privTurnAudioDestination = void 0));
              }
              readAllAudioFromStream() {
                  return SynthesisTurn_awaiter(this, void 0, void 0, (function*() {
                      if (this.privIsSynthesisEnded) {
                          this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
                          try {
                              yield this.privAudioOutputStream.read(this.privReceivedAudio);
                          } catch (e) {
                              this.privReceivedAudio = new ArrayBuffer(0);
                          }
                      }
                  }));
              }
              withinXmlTag(idx) {
                  return this.privRawText.indexOf("<", idx + 1) > this.privRawText.indexOf(">", idx + 1);
              }
          }
          class SynthesisContext {
              constructor(speechSynthesizer) {
                  this.privContext = {}, this.privSpeechSynthesizer = speechSynthesizer;
              }
              setSection(sectionName, value) {
                  this.privContext[sectionName] = value;
              }
              set audioOutputFormat(format) {
                  this.privAudioOutputFormat = format;
              }
              toJSON() {
                  const synthesisSection = this.buildSynthesisContext();
                  return this.setSection("synthesis", synthesisSection), JSON.stringify(this.privContext);
              }
              buildSynthesisContext() {
                  return {
                      audio: {
                          metadataOptions: {
                              bookmarkEnabled: !!this.privSpeechSynthesizer.bookmarkReached,
                              punctuationBoundaryEnabled: this.privSpeechSynthesizer.properties.getProperty(PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!this.privSpeechSynthesizer.wordBoundary),
                              sentenceBoundaryEnabled: this.privSpeechSynthesizer.properties.getProperty(PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
                              sessionEndEnabled: !0,
                              visemeEnabled: !!this.privSpeechSynthesizer.visemeReceived,
                              wordBoundaryEnabled: this.privSpeechSynthesizer.properties.getProperty(PropertyId.SpeechServiceResponse_RequestWordBoundary, !!this.privSpeechSynthesizer.wordBoundary)
                          },
                          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
                      },
                      language: {
                          autoDetection: this.privSpeechSynthesizer.autoDetectSourceLanguage
                      }
                  };
              }
          }
          class AgentConfig {
              toJsonString() {
                  return JSON.stringify(this.iPrivConfig);
              }
              get() {
                  return this.iPrivConfig;
              }
              set(value) {
                  this.iPrivConfig = value;
              }
          }
          class HeaderNames {}
          HeaderNames.AuthKey = "Ocp-Apim-Subscription-Key", HeaderNames.ConnectionId = "X-ConnectionId", 
          HeaderNames.ContentType = "Content-Type", HeaderNames.CustomCommandsAppId = "X-CommandsAppId", 
          HeaderNames.Path = "Path", HeaderNames.RequestId = "X-RequestId", HeaderNames.RequestStreamId = "X-StreamId", 
          HeaderNames.RequestTimestamp = "X-Timestamp";
          class SpeechConnectionMessage extends ConnectionMessage {
              constructor(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id) {
                  if (!path) throw new ArgumentNullError("path");
                  if (!requestId) throw new ArgumentNullError("requestId");
                  const headers = {};
                  if (headers[HeaderNames.Path] = path, headers[HeaderNames.RequestId] = requestId, 
                  headers[HeaderNames.RequestTimestamp] = (new Date).toISOString(), contentType && (headers[HeaderNames.ContentType] = contentType), 
                  streamId && (headers[HeaderNames.RequestStreamId] = streamId), additionalHeaders) for (const headerName in additionalHeaders) headerName && (headers[headerName] = additionalHeaders[headerName]);
                  id ? super(messageType, body, headers, id) : super(messageType, body, headers), 
                  this.privPath = path, this.privRequestId = requestId, this.privContentType = contentType, 
                  this.privStreamId = streamId, this.privAdditionalHeaders = additionalHeaders;
              }
              get path() {
                  return this.privPath;
              }
              get requestId() {
                  return this.privRequestId;
              }
              get contentType() {
                  return this.privContentType;
              }
              get streamId() {
                  return this.privStreamId;
              }
              get additionalHeaders() {
                  return this.privAdditionalHeaders;
              }
              static fromConnectionMessage(message) {
                  let path = null, requestId = null, contentType = null, streamId = null;
                  const additionalHeaders = {};
                  if (message.headers) for (const headerName in message.headers) headerName && (headerName.toLowerCase() === HeaderNames.Path.toLowerCase() ? path = message.headers[headerName] : headerName.toLowerCase() === HeaderNames.RequestId.toLowerCase() ? requestId = message.headers[headerName] : headerName.toLowerCase() === HeaderNames.ContentType.toLowerCase() ? contentType = message.headers[headerName] : headerName.toLowerCase() === HeaderNames.RequestStreamId.toLowerCase() ? streamId = message.headers[headerName] : additionalHeaders[headerName] = message.headers[headerName]);
                  return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);
              }
          }
          var SynthesisAdapterBase_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class SynthesisAdapterBase {
              constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {
                  if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, 
                  this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, 
                  !authentication) throw new ArgumentNullError("authentication");
                  if (!connectionFactory) throw new ArgumentNullError("connectionFactory");
                  if (!synthesizerConfig) throw new ArgumentNullError("synthesizerConfig");
                  this.privAuthentication = authentication, this.privConnectionFactory = connectionFactory, 
                  this.privSynthesizerConfig = synthesizerConfig, this.privIsDisposed = !1, this.privSpeechSynthesizer = speechSynthesizer, 
                  this.privSessionAudioDestination = audioDestination, this.privSynthesisTurn = new SynthesisTurn, 
                  this.privConnectionEvents = new EventSource, this.privServiceEvents = new EventSource, 
                  this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer), this.privAgentConfig = new AgentConfig, 
                  this.connectionEvents.attach((connectionEvent => {
                      if ("ConnectionClosedEvent" === connectionEvent.name) {
                          const connectionClosedEvent = connectionEvent;
                          1e3 !== connectionClosedEvent.statusCode && this.cancelSynthesisLocal(CancellationReason.Error, 1007 === connectionClosedEvent.statusCode ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);
                      }
                  }));
              }
              get synthesisContext() {
                  return this.privSynthesisContext;
              }
              get agentConfig() {
                  return this.privAgentConfig;
              }
              get connectionEvents() {
                  return this.privConnectionEvents;
              }
              get serviceEvents() {
                  return this.privServiceEvents;
              }
              set activityTemplate(messagePayload) {
                  this.privActivityTemplate = messagePayload;
              }
              get activityTemplate() {
                  return this.privActivityTemplate;
              }
              set audioOutputFormat(format) {
                  this.privAudioOutputFormat = format, this.privSynthesisTurn.audioOutputFormat = format, 
                  void 0 !== this.privSessionAudioDestination && (this.privSessionAudioDestination.format = format), 
                  void 0 !== this.synthesisContext && (this.synthesisContext.audioOutputFormat = format);
              }
              static addHeader(audio, format) {
                  if (!format.hasHeader) return audio;
                  format.updateHeader(audio.byteLength);
                  const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);
                  return tmp.set(new Uint8Array(format.header), 0), tmp.set(new Uint8Array(audio), format.header.byteLength), 
                  tmp.buffer;
              }
              isDisposed() {
                  return this.privIsDisposed;
              }
              dispose(reason) {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      if (this.privIsDisposed = !0, void 0 !== this.privSessionAudioDestination && this.privSessionAudioDestination.close(), 
                      void 0 !== this.privConnectionConfigurationPromise) {
                          const connection = yield this.privConnectionConfigurationPromise;
                          yield connection.dispose(reason);
                      }
                  }));
              }
              connect() {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      yield this.connectImpl();
                  }));
              }
              sendNetworkMessage(path, payload) {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      const type = "string" == typeof payload ? MessageType.Text : MessageType.Binary, contentType = "string" == typeof payload ? "application/json" : "";
                      return (yield this.fetchConnection()).send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));
                  }));
              }
              Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      let ssml;
                      if (ssml = isSSML ? text : this.privSpeechSynthesizer.buildSsml(text), void 0 !== this.speakOverride) return this.speakOverride(ssml, requestId, successCallback, errorCallBack);
                      this.privSuccessCallback = successCallback, this.privErrorCallback = errorCallBack, 
                      this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);
                      try {
                          yield this.connectImpl();
                          const connection = yield this.fetchConnection();
                          yield this.sendSynthesisContext(connection), yield this.sendSsmlMessage(connection, ssml, requestId);
                          const synthesisStartEventArgs = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(requestId, ResultReason.SynthesizingAudioStarted));
                          this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs), 
                          this.receiveMessage();
                      } catch (e) {
                          return this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e), 
                          Promise.reject(e);
                      }
                  }));
              }
              cancelSynthesis(requestId, cancellationReason, errorCode, error) {
                  const properties = new PropertyCollection;
                  properties.setProperty("CancellationErrorCode", CancellationErrorCode[errorCode]);
                  const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, void 0, error, properties);
                  if (this.privSpeechSynthesizer.SynthesisCanceled) {
                      const cancelEvent = new SpeechSynthesisEventArgs(result);
                      try {
                          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);
                      } catch (_a) {}
                  }
                  if (this.privSuccessCallback) try {
                      this.privSuccessCallback(result);
                  } catch (_b) {}
              }
              cancelSynthesisLocal(cancellationReason, errorCode, error) {
                  this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), 
                  this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error));
              }
              processTypeSpecificMessages(connectionMessage) {
                  return !0;
              }
              receiveMessage() {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      try {
                          const connection = yield this.fetchConnection(), message = yield connection.read();
                          if (void 0 !== this.receiveMessageOverride) return this.receiveMessageOverride();
                          if (this.privIsDisposed) return;
                          if (!message) return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
                          const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);
                          if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) switch (connectionMessage.path.toLowerCase()) {
                            case "turn.start":
                              this.privSynthesisTurn.onServiceTurnStartResponse();
                              break;

                            case "response":
                              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);
                              break;

                            case "audio":
                              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && connectionMessage.binaryBody) {
                                  if (this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody), this.privSpeechSynthesizer.synthesizing) try {
                                      const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat), ev = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudio, audioWithHeader));
                                      this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);
                                  } catch (error) {}
                                  void 0 !== this.privSessionAudioDestination && this.privSessionAudioDestination.write(connectionMessage.binaryBody);
                              }
                              break;

                            case "audio.metadata":
                              const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;
                              for (const metadata of metadataList) switch (metadata.Type) {
                                case MetadataType.WordBoundary:
                                case MetadataType.SentenceBoundary:
                                  this.privSynthesisTurn.onTextBoundaryEvent(metadata);
                                  const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);
                                  if (this.privSpeechSynthesizer.wordBoundary) try {
                                      this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);
                                  } catch (error) {}
                                  break;

                                case MetadataType.Bookmark:
                                  const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);
                                  if (this.privSpeechSynthesizer.bookmarkReached) try {
                                      this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);
                                  } catch (error) {}
                                  break;

                                case MetadataType.Viseme:
                                  if (this.privSynthesisTurn.onVisemeMetadataReceived(metadata), metadata.Data.IsLastAnimation) {
                                      const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                                      if (this.privSpeechSynthesizer.visemeReceived) try {
                                          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);
                                      } catch (error) {}
                                  }
                                  break;

                                case MetadataType.SessionEnd:
                                  this.privSynthesisTurn.onSessionEnd(metadata);
                              }
                              break;

                            case "turn.end":
                              let result;
                              this.privSynthesisTurn.onServiceTurnEndResponse();
                              try {
                                  const audioBuffer = yield this.privSynthesisTurn.getAllReceivedAudioWithHeader();
                                  result = new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer, void 0, void 0, this.privSynthesisTurn.audioDuration), 
                                  this.privSuccessCallback && this.privSuccessCallback(result);
                              } catch (error) {
                                  this.privErrorCallback && this.privErrorCallback(error);
                              }
                              if (this.privSpeechSynthesizer.synthesisCompleted) try {
                                  this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new SpeechSynthesisEventArgs(result));
                              } catch (e) {}
                              break;

                            default:
                              this.processTypeSpecificMessages(connectionMessage) || this.privServiceEvents && this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                          }
                          return this.receiveMessage();
                      } catch (e) {}
                  }));
              }
              sendSynthesisContext(connection) {
                  const synthesisContextJson = this.synthesisContext.toJSON();
                  if (synthesisContextJson) return connection.send(new SpeechConnectionMessage(MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", synthesisContextJson));
              }
              connectImpl(isUnAuthorized = !1) {
                  if (null != this.privConnectionPromise) return this.privConnectionPromise.then((connection => connection.state() === ConnectionState.Disconnected ? (this.privConnectionId = null, 
                  this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise), (() => (this.privConnectionId = null, 
                  this.privConnectionPromise = null, this.connectImpl())));
                  this.privAuthFetchEventId = createNoDashGuid(), this.privConnectionId = createNoDashGuid(), 
                  this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
                  const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
                  return this.privConnectionPromise = authPromise.then((result => SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      this.privSynthesisTurn.onAuthCompleted(!1);
                      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);
                      connection.events.attach((event => {
                          this.connectionEvents.onEvent(event);
                      }));
                      const response = yield connection.open();
                      return 200 === response.statusCode ? (this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode), 
                      Promise.resolve(connection)) : 403 !== response.statusCode || isUnAuthorized ? (this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode), 
                      Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`)) : this.connectImpl(!0);
                  }))), (error => {
                      throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(error);
                  })), this.privConnectionPromise.catch((() => {})), this.privConnectionPromise;
              }
              sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {
                  if (SpeechServiceConfigJson) return connection.send(new SpeechConnectionMessage(MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", SpeechServiceConfigJson));
              }
              sendSsmlMessage(connection, ssml, requestId) {
                  return connection.send(new SpeechConnectionMessage(MessageType.Text, "ssml", requestId, "application/ssml+xml", ssml));
              }
              fetchConnection() {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      return void 0 !== this.privConnectionConfigurationPromise ? this.privConnectionConfigurationPromise.then((connection => connection.state() === ConnectionState.Disconnected ? (this.privConnectionId = null, 
                      this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise), (() => (this.privConnectionId = null, 
                      this.privConnectionConfigurationPromise = void 0, this.fetchConnection()))) : (this.privConnectionConfigurationPromise = this.configureConnection(), 
                      yield this.privConnectionConfigurationPromise);
                  }));
              }
              configureConnection() {
                  return SynthesisAdapterBase_awaiter(this, void 0, void 0, (function*() {
                      const connection = yield this.connectImpl();
                      return void 0 !== this.configConnectionOverride ? this.configConnectionOverride(connection) : (yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), 
                      connection);
                  }));
              }
          }
          SynthesisAdapterBase.telemetryDataEnabled = !0;
          class BackgroundEvent extends PlatformEvent {
              constructor(error) {
                  super("BackgroundEvent", PlatformEvent_EventType.Error), this.privError = error;
              }
              get error() {
                  return this.privError;
              }
          }
          var SpeakerAudioDestination_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          const AudioFormatToMimeType = {
              [AudioFormatTag.PCM]: "audio/wav",
              [AudioFormatTag.MuLaw]: "audio/x-wav",
              [AudioFormatTag.MP3]: "audio/mpeg",
              [AudioFormatTag.OGG_OPUS]: "audio/ogg",
              [AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
              [AudioFormatTag.ALaw]: "audio/x-wav",
              [AudioFormatTag.FLAC]: "audio/flac"
          };
          class SpeakerAudioDestination {
              constructor(audioDestinationId) {
                  this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, 
                  this.privBytesReceived = 0, this.privId = audioDestinationId || createNoDashGuid(), 
                  this.privIsPaused = !1, this.privIsClosed = !1;
              }
              id() {
                  return this.privId;
              }
              write(buffer, cb, err) {
                  void 0 !== this.privAudioBuffer ? (this.privAudioBuffer.push(buffer), this.updateSourceBuffer().then((() => {
                      cb && cb();
                  }), (error => {
                      err && err(error);
                  }))) : void 0 !== this.privAudioOutputStream && (this.privAudioOutputStream.write(buffer), 
                  this.privBytesReceived += buffer.byteLength);
              }
              close(cb, err) {
                  if (this.privIsClosed = !0, void 0 !== this.privSourceBuffer) this.handleSourceBufferUpdateEnd().then((() => {
                      cb && cb();
                  }), (error => {
                      err && err(error);
                  })); else if (void 0 !== this.privAudioOutputStream && "undefined" != typeof window) if (this.privFormat.formatTag !== AudioFormatTag.PCM && this.privFormat.formatTag !== AudioFormatTag.MuLaw && this.privFormat.formatTag !== AudioFormatTag.ALaw || !1 !== this.privFormat.hasHeader) {
                      let receivedAudio = new ArrayBuffer(this.privBytesReceived);
                      this.privAudioOutputStream.read(receivedAudio).then((() => {
                          receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);
                          const audioBlob = new Blob([ receivedAudio ], {
                              type: AudioFormatToMimeType[this.privFormat.formatTag]
                          });
                          this.privAudio.src = window.URL.createObjectURL(audioBlob), this.notifyPlayback().then((() => {
                              cb && cb();
                          }), (error => {
                              err && err(error);
                          }));
                      }), (error => {
                          err && err(error);
                      }));
                  } else console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), 
                  this.onAudioEnd && this.onAudioEnd(this); else this.onAudioEnd && this.onAudioEnd(this);
              }
              set format(format) {
                  if ("undefined" != typeof AudioContext || "undefined" != typeof window && void 0 !== window.webkitAudioContext) {
                      this.privFormat = format;
                      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];
                      void 0 === mimeType ? console.warn(`Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : "undefined" != typeof MediaSource && MediaSource.isTypeSupported(mimeType) ? (this.privAudio = new Audio, 
                      this.privAudioBuffer = [], this.privMediaSource = new MediaSource, this.privAudio.src = URL.createObjectURL(this.privMediaSource), 
                      this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
                          this.privMediaSourceOpened = !0, this.privMediaSource.duration = 1800, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType), 
                          this.privSourceBuffer.onupdate = () => {
                              this.updateSourceBuffer().catch((reason => {
                                  Events.instance.onEvent(new BackgroundEvent(reason));
                              }));
                          }, this.privSourceBuffer.onupdateend = () => {
                              this.handleSourceBufferUpdateEnd().catch((reason => {
                                  Events.instance.onEvent(new BackgroundEvent(reason));
                              }));
                          }, this.privSourceBuffer.onupdatestart = () => {
                              this.privAppendingToBuffer = !1;
                          };
                      }, this.updateSourceBuffer().catch((reason => {
                          Events.instance.onEvent(new BackgroundEvent(reason));
                      }))) : (console.warn(`Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), 
                      this.privAudioOutputStream = new PullAudioOutputStreamImpl, this.privAudioOutputStream.format = this.privFormat, 
                      this.privAudio = new Audio);
                  }
              }
              get volume() {
                  var _a, _b;
                  return null !== (_b = null === (_a = this.privAudio) || void 0 === _a ? void 0 : _a.volume) && void 0 !== _b ? _b : -1;
              }
              set volume(volume) {
                  this.privAudio && (this.privAudio.volume = volume);
              }
              mute() {
                  this.privAudio && (this.privAudio.muted = !0);
              }
              unmute() {
                  this.privAudio && (this.privAudio.muted = !1);
              }
              get isClosed() {
                  return this.privIsClosed;
              }
              get currentTime() {
                  return void 0 !== this.privAudio ? this.privAudio.currentTime : -1;
              }
              pause() {
                  this.privIsPaused || void 0 === this.privAudio || (this.privAudio.pause(), this.privIsPaused = !0);
              }
              resume(cb, err) {
                  this.privIsPaused && void 0 !== this.privAudio && (this.privAudio.play().then((() => {
                      cb && cb();
                  }), (error => {
                      err && err(error);
                  })), this.privIsPaused = !1);
              }
              get internalAudio() {
                  return this.privAudio;
              }
              updateSourceBuffer() {
                  return SpeakerAudioDestination_awaiter(this, void 0, void 0, (function*() {
                      if (void 0 !== this.privAudioBuffer && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
                          this.privAppendingToBuffer = !0;
                          const binary = this.privAudioBuffer.shift();
                          try {
                              this.privSourceBuffer.appendBuffer(binary);
                          } catch (error) {
                              return this.privAudioBuffer.unshift(binary), void console.log("buffer filled, pausing addition of binaries until space is made");
                          }
                          yield this.notifyPlayback();
                      } else this.canEndStream() && (yield this.handleSourceBufferUpdateEnd());
                  }));
              }
              handleSourceBufferUpdateEnd() {
                  return SpeakerAudioDestination_awaiter(this, void 0, void 0, (function*() {
                      this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), 
                      yield this.notifyPlayback());
                  }));
              }
              notifyPlayback() {
                  return SpeakerAudioDestination_awaiter(this, void 0, void 0, (function*() {
                      this.privPlaybackStarted || void 0 === this.privAudio || (this.privPlaybackStarted = !0, 
                      this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
                          this.onAudioEnd && this.onAudioEnd(this);
                      }, this.privIsPaused || (yield this.privAudio.play()));
                  }));
              }
              canEndStream() {
                  return this.isClosed && void 0 !== this.privSourceBuffer && 0 === this.privAudioBuffer.length && this.privMediaSourceOpened && !this.privAppendingToBuffer && "open" === this.privMediaSource.readyState;
              }
              sourceBufferAvailable() {
                  return void 0 !== this.privSourceBuffer && !this.privSourceBuffer.updating;
              }
          }
          class PushAudioOutputStreamCallback {}
          var fs_ignored_ = __webpack_require__("?03bb");
          class AudioFileWriter {
              constructor(filename) {
                  Contracts.throwIfNullOrUndefined(fs_ignored_.openSync, "\nFile System access not available, please use Push or PullAudioOutputStream"), 
                  this.privFd = fs_ignored_.openSync(filename, "w");
              }
              set format(format) {
                  Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = format;
                  let headerOffset = 0;
                  this.privAudioFormat.hasHeader && (headerOffset = this.privAudioFormat.header.byteLength), 
                  void 0 !== this.privFd && (this.privWriteStream = fs_ignored_.createWriteStream("", {
                      fd: this.privFd,
                      start: headerOffset,
                      autoClose: !1
                  }));
              }
              write(buffer) {
                  Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), 
                  void 0 !== this.privWriteStream && this.privWriteStream.write(new Uint8Array(buffer.slice(0)));
              }
              close() {
                  void 0 !== this.privFd && (this.privWriteStream.on("finish", (() => {
                      this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), 
                      fs_ignored_.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), 
                      fs_ignored_.closeSync(this.privFd), this.privFd = void 0;
                  })), this.privWriteStream.end());
              }
              id() {
                  return this.privId;
              }
          }
          class AudioConfig {
              static fromDefaultMicrophoneInput() {
                  const pcmRecorder = new PcmRecorder(!0);
                  return new AudioConfigImpl(new MicAudioSource(pcmRecorder));
              }
              static fromMicrophoneInput(deviceId) {
                  const pcmRecorder = new PcmRecorder(!0);
                  return new AudioConfigImpl(new MicAudioSource(pcmRecorder, deviceId));
              }
              static fromWavFileInput(file, name = "unnamedBuffer.wav") {
                  return new AudioConfigImpl(new FileAudioSource(file, name));
              }
              static fromStreamInput(audioStream) {
                  if (audioStream instanceof PullAudioInputStreamCallback) return new AudioConfigImpl(new PullAudioInputStreamImpl(audioStream));
                  if (audioStream instanceof AudioInputStream) return new AudioConfigImpl(audioStream);
                  if ("undefined" != typeof MediaStream && audioStream instanceof MediaStream) {
                      const pcmRecorder = new PcmRecorder(!1);
                      return new AudioConfigImpl(new MicAudioSource(pcmRecorder, null, null, audioStream));
                  }
                  throw new Error("Not Supported Type");
              }
              static fromDefaultSpeakerOutput() {
                  return new AudioOutputConfigImpl(new SpeakerAudioDestination);
              }
              static fromSpeakerOutput(player) {
                  if (void 0 === player) return AudioConfig.fromDefaultSpeakerOutput();
                  if (player instanceof SpeakerAudioDestination) return new AudioOutputConfigImpl(player);
                  throw new Error("Not Supported Type");
              }
              static fromAudioFileOutput(filename) {
                  return new AudioOutputConfigImpl(new AudioFileWriter(filename));
              }
              static fromStreamOutput(audioStream) {
                  if (audioStream instanceof PushAudioOutputStreamCallback) return new AudioOutputConfigImpl(new PushAudioOutputStreamImpl(audioStream));
                  if (audioStream instanceof PushAudioOutputStream) return new AudioOutputConfigImpl(audioStream);
                  if (audioStream instanceof PullAudioOutputStream) return new AudioOutputConfigImpl(audioStream);
                  throw new Error("Not Supported Type");
              }
          }
          class AudioConfigImpl extends AudioConfig {
              constructor(source) {
                  super(), this.privSource = source;
              }
              get format() {
                  return this.privSource.format;
              }
              close(cb, err) {
                  this.privSource.turnOff().then((() => {
                      cb && cb();
                  }), (error => {
                      err && err(error);
                  }));
              }
              id() {
                  return this.privSource.id();
              }
              get blob() {
                  return this.privSource.blob;
              }
              turnOn() {
                  return this.privSource.turnOn();
              }
              attach(audioNodeId) {
                  return this.privSource.attach(audioNodeId);
              }
              detach(audioNodeId) {
                  return this.privSource.detach(audioNodeId);
              }
              turnOff() {
                  return this.privSource.turnOff();
              }
              get events() {
                  return this.privSource.events;
              }
              setProperty(name, value) {
                  if (Contracts.throwIfNull(value, "value"), void 0 === this.privSource.setProperty) throw new Error("This AudioConfig instance does not support setting properties.");
                  this.privSource.setProperty(name, value);
              }
              getProperty(name, def) {
                  if (void 0 !== this.privSource.getProperty) return this.privSource.getProperty(name, def);
                  throw new Error("This AudioConfig instance does not support getting properties.");
              }
              get deviceInfo() {
                  return this.privSource.deviceInfo;
              }
          }
          class AudioOutputConfigImpl extends AudioConfig {
              constructor(destination) {
                  super(), this.privDestination = destination;
              }
              set format(format) {
                  this.privDestination.format = format;
              }
              write(buffer) {
                  this.privDestination.write(buffer);
              }
              close() {
                  this.privDestination.close();
              }
              id() {
                  return this.privDestination.id();
              }
              setProperty() {
                  throw new Error("This AudioConfig instance does not support setting properties.");
              }
              getProperty() {
                  throw new Error("This AudioConfig instance does not support getting properties.");
              }
          }
          var ws_ignored_ = __webpack_require__("?7ed4"), ws_ignored_default = __webpack_require__.n(ws_ignored_);
          class ConnectionOpenResponse {
              constructor(statusCode, reason) {
                  this.privStatusCode = statusCode, this.privReason = reason;
              }
              get statusCode() {
                  return this.privStatusCode;
              }
              get reason() {
                  return this.privReason;
              }
          }
          class RawWebsocketMessage {
              constructor(messageType, payload, id) {
                  if (this.privPayload = null, !payload) throw new ArgumentNullError("payload");
                  if (messageType === MessageType.Binary && "ArrayBuffer" !== payload.__proto__.constructor.name) throw new InvalidOperationError("Payload must be ArrayBuffer");
                  if (messageType === MessageType.Text && "string" != typeof payload) throw new InvalidOperationError("Payload must be a string");
                  this.privMessageType = messageType, this.privPayload = payload, this.privId = id || createNoDashGuid();
              }
              get messageType() {
                  return this.privMessageType;
              }
              get payload() {
                  return this.privPayload;
              }
              get textContent() {
                  if (this.privMessageType === MessageType.Binary) throw new InvalidOperationError("Not supported for binary message");
                  return this.privPayload;
              }
              get binaryContent() {
                  if (this.privMessageType === MessageType.Text) throw new InvalidOperationError("Not supported for text message");
                  return this.privPayload;
              }
              get id() {
                  return this.privId;
              }
          }
          var tls_ignored_ = __webpack_require__("?7556"), ocsp_ignored_ = __webpack_require__("?5a61");
          class OCSPEvent extends PlatformEvent {
              constructor(eventName, eventType, signature) {
                  super(eventName, eventType), this.privSignature = signature;
              }
          }
          class OCSPMemoryCacheHitEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPMemoryCacheHitEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPCacheMissEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPCacheMissEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPDiskCacheHitEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPDiskCacheHitEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPCacheUpdateNeededEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPCacheUpdateNeededEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPMemoryCacheStoreEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPMemoryCacheStoreEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPDiskCacheStoreEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPDiskCacheStoreEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPCacheUpdateCompleteEvent extends OCSPEvent {
              constructor(signature) {
                  super("OCSPCacheUpdateCompleteEvent", PlatformEvent_EventType.Debug, signature);
              }
          }
          class OCSPStapleReceivedEvent extends OCSPEvent {
              constructor() {
                  super("OCSPStapleReceivedEvent", PlatformEvent_EventType.Debug, "");
              }
          }
          class OCSPCacheEntryExpiredEvent extends OCSPEvent {
              constructor(serialNumber, expireTime) {
                  super("OCSPCacheEntryExpiredEvent", PlatformEvent_EventType.Debug, serialNumber), 
                  this.privExpireTime = expireTime;
              }
          }
          class OCSPCacheEntryNeedsRefreshEvent extends OCSPEvent {
              constructor(serialNumber, startTime, expireTime) {
                  super("OCSPCacheEntryNeedsRefreshEvent", PlatformEvent_EventType.Debug, serialNumber), 
                  this.privExpireTime = expireTime, this.privStartTime = startTime;
              }
          }
          class OCSPCacheHitEvent extends OCSPEvent {
              constructor(serialNumber, startTime, expireTime) {
                  super("OCSPCacheHitEvent", PlatformEvent_EventType.Debug, serialNumber), this.privExpireTime = expireTime, 
                  this.privExpireTimeString = new Date(expireTime).toLocaleDateString(), this.privStartTime = startTime, 
                  this.privStartTimeString = new Date(startTime).toLocaleTimeString();
              }
          }
          class OCSPVerificationFailedEvent extends OCSPEvent {
              constructor(serialNumber, error) {
                  super("OCSPVerificationFailedEvent", PlatformEvent_EventType.Debug, serialNumber), 
                  this.privError = error;
              }
          }
          class OCSPCacheFetchErrorEvent extends OCSPEvent {
              constructor(serialNumber, error) {
                  super("OCSPCacheFetchErrorEvent", PlatformEvent_EventType.Debug, serialNumber), 
                  this.privError = error;
              }
          }
          class OCSPResponseRetrievedEvent extends OCSPEvent {
              constructor(serialNumber) {
                  super("OCSPResponseRetrievedEvent", PlatformEvent_EventType.Debug, serialNumber);
              }
          }
          class OCSPCacheUpdateErrorEvent extends OCSPEvent {
              constructor(serialNumber, error) {
                  super("OCSPCacheUpdateErrorEvent", PlatformEvent_EventType.Debug, serialNumber), 
                  this.privError = error;
              }
          }
          var agent_base_ignored_ = __webpack_require__("?e474"), agent_base_ignored_default = __webpack_require__.n(agent_base_ignored_), async_disk_cache_ignored_ = __webpack_require__("?bc42"), async_disk_cache_ignored_default = __webpack_require__.n(async_disk_cache_ignored_), https_proxy_agent_ignored_ = __webpack_require__("?ddf1"), https_proxy_agent_ignored_default = __webpack_require__.n(https_proxy_agent_ignored_), net_ignored_ = __webpack_require__("?3d7d"), CertChecks_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class CertCheckAgent {
              constructor(proxyInfo) {
                  proxyInfo && (this.privProxyInfo = proxyInfo), CertCheckAgent.privDiskCache || (CertCheckAgent.privDiskCache = new (async_disk_cache_ignored_default())("microsoft-cognitiveservices-speech-sdk-cache", {
                      supportBuffer: !0,
                      location: "undefined" != typeof process && process.env.SPEECH_OCSP_CACHE_ROOT ? process.env.SPEECH_OCSP_CACHE_ROOT : void 0
                  }));
              }
              static forceReinitDiskCache() {
                  CertCheckAgent.privDiskCache = void 0, CertCheckAgent.privMemCache = {};
              }
              GetAgent(disableStapling) {
                  const agent = new (agent_base_ignored_default().Agent)(this.CreateConnection);
                  if (void 0 !== this.privProxyInfo && void 0 !== this.privProxyInfo.HostName && this.privProxyInfo.Port > 0) {
                      agent["privProxyInfo"] = this.privProxyInfo;
                  }
                  return agent;
              }
              static GetProxyAgent(proxyInfo) {
                  const httpProxyOptions = {
                      host: proxyInfo.HostName,
                      port: proxyInfo.Port
                  };
                  proxyInfo.UserName ? httpProxyOptions.headers = {
                      "Proxy-Authentication": "Basic " + new Buffer(`${proxyInfo.UserName}:${void 0 === proxyInfo.Password ? "" : proxyInfo.Password}`).toString("base64")
                  } : httpProxyOptions.headers = {}, httpProxyOptions.headers.requestOCSP = "true";
                  return new (https_proxy_agent_ignored_default())(httpProxyOptions);
              }
              static OCSPCheck(socketPromise, proxyInfo) {
                  return CertChecks_awaiter(this, void 0, void 0, (function*() {
                      let ocspRequest, stapling, resolved = !1;
                      const socket = yield socketPromise;
                      socket.cork();
                      const tlsSocket = socket;
                      return new Promise(((resolve, reject) => {
                          socket.on("OCSPResponse", (data => {
                              data && (this.onEvent(new OCSPStapleReceivedEvent), stapling = data);
                          })), socket.on("error", (error => {
                              resolved || (resolved = !0, socket.destroy(), reject(error));
                          })), tlsSocket.on("secure", (() => CertChecks_awaiter(this, void 0, void 0, (function*() {
                              const peer = tlsSocket.getPeerCertificate(!0);
                              try {
                                  const issuer = yield this.GetIssuer(peer);
                                  ocspRequest = ocsp_ignored_.request.generate(peer.raw, issuer.raw);
                                  const sig = ocspRequest.id.toString("hex");
                                  if (!stapling) {
                                      const cacheEntry = yield CertCheckAgent.GetResponseFromCache(sig, ocspRequest, proxyInfo);
                                      stapling = cacheEntry;
                                  }
                                  yield this.VerifyOCSPResponse(stapling, ocspRequest, proxyInfo), socket.uncork(), 
                                  resolved = !0, resolve(socket);
                              } catch (e) {
                                  socket.destroy(), resolved = !0, reject(e);
                              }
                          }))));
                      }));
                  }));
              }
              static GetIssuer(peer) {
                  return peer.issuerCertificate ? Promise.resolve(peer.issuerCertificate) : new Promise(((resolve, reject) => {
                      new ocsp_ignored_.Agent({}).fetchIssuer(peer, null, ((error, value) => {
                          error ? reject(error) : resolve(value);
                      }));
                  }));
              }
              static GetResponseFromCache(signature, ocspRequest, proxyInfo) {
                  return CertChecks_awaiter(this, void 0, void 0, (function*() {
                      let cachedResponse = CertCheckAgent.privMemCache[signature];
                      if (cachedResponse && this.onEvent(new OCSPMemoryCacheHitEvent(signature)), !cachedResponse) try {
                          const diskCacheResponse = yield CertCheckAgent.privDiskCache.get(signature);
                          diskCacheResponse.isCached && (CertCheckAgent.onEvent(new OCSPDiskCacheHitEvent(signature)), 
                          CertCheckAgent.StoreMemoryCacheEntry(signature, diskCacheResponse.value), cachedResponse = diskCacheResponse.value);
                      } catch (error) {
                          cachedResponse = null;
                      }
                      if (!cachedResponse) return cachedResponse;
                      try {
                          const cachedOcspResponse = ocsp_ignored_.utils.parseResponse(cachedResponse), tbsData = cachedOcspResponse.value.tbsResponseData;
                          if (tbsData.responses.length < 1) return void this.onEvent(new OCSPCacheFetchErrorEvent(signature, "Not enough data in cached response"));
                          const cachedStartTime = tbsData.responses[0].thisUpdate, cachedNextTime = tbsData.responses[0].nextUpdate;
                          if (cachedNextTime < Date.now() + this.testTimeOffset - 6e4) this.onEvent(new OCSPCacheEntryExpiredEvent(signature, cachedNextTime)), 
                          cachedResponse = null; else {
                              const minUpdate = Math.min(864e5, (cachedNextTime - cachedStartTime) / 2);
                              cachedNextTime - (Date.now() + this.testTimeOffset) < minUpdate ? (this.onEvent(new OCSPCacheEntryNeedsRefreshEvent(signature, cachedStartTime, cachedNextTime)), 
                              this.UpdateCache(ocspRequest, proxyInfo).catch((error => {
                                  this.onEvent(new OCSPCacheUpdateErrorEvent(signature, error.toString()));
                              }))) : this.onEvent(new OCSPCacheHitEvent(signature, cachedStartTime, cachedNextTime));
                          }
                      } catch (error) {
                          this.onEvent(new OCSPCacheFetchErrorEvent(signature, error)), cachedResponse = null;
                      }
                      return cachedResponse || this.onEvent(new OCSPCacheMissEvent(signature)), cachedResponse;
                  }));
              }
              static VerifyOCSPResponse(cacheValue, ocspRequest, proxyInfo) {
                  return CertChecks_awaiter(this, void 0, void 0, (function*() {
                      let ocspResponse = cacheValue;
                      return ocspResponse || (ocspResponse = yield CertCheckAgent.GetOCSPResponse(ocspRequest, proxyInfo)), 
                      new Promise(((resolve, reject) => {
                          ocsp_ignored_.verify({
                              request: ocspRequest,
                              response: ocspResponse
                          }, (error => {
                              error ? (CertCheckAgent.onEvent(new OCSPVerificationFailedEvent(ocspRequest.id.toString("hex"), error)), 
                              cacheValue ? this.VerifyOCSPResponse(null, ocspRequest, proxyInfo).then((() => {
                                  resolve();
                              }), (error => {
                                  reject(error);
                              })) : reject(error)) : (cacheValue || CertCheckAgent.StoreCacheEntry(ocspRequest.id.toString("hex"), ocspResponse), 
                              resolve());
                          }));
                      }));
                  }));
              }
              static UpdateCache(req, proxyInfo) {
                  return CertChecks_awaiter(this, void 0, void 0, (function*() {
                      const signature = req.id.toString("hex");
                      this.onEvent(new OCSPCacheUpdateNeededEvent(signature));
                      const rawResponse = yield this.GetOCSPResponse(req, proxyInfo);
                      this.StoreCacheEntry(signature, rawResponse), this.onEvent(new OCSPCacheUpdateCompleteEvent(req.id.toString("hex")));
                  }));
              }
              static StoreCacheEntry(sig, rawResponse) {
                  this.StoreMemoryCacheEntry(sig, rawResponse), this.StoreDiskCacheEntry(sig, rawResponse);
              }
              static StoreMemoryCacheEntry(sig, rawResponse) {
                  this.privMemCache[sig] = rawResponse, this.onEvent(new OCSPMemoryCacheStoreEvent(sig));
              }
              static StoreDiskCacheEntry(sig, rawResponse) {
                  this.privDiskCache.set(sig, rawResponse).then((() => {
                      this.onEvent(new OCSPDiskCacheStoreEvent(sig));
                  }));
              }
              static GetOCSPResponse(req, proxyInfo) {
                  let options = {};
                  if (proxyInfo) {
                      const agent = CertCheckAgent.GetProxyAgent(proxyInfo);
                      options.agent = agent;
                  }
                  return new Promise(((resolve, reject) => {
                      ocsp_ignored_.utils.getAuthorityInfo(req.cert, "1.3.6.1.5.5.7.48.1", ((error, uri) => {
                          if (error) return void reject(error);
                          const url = new URL(uri);
                          options = Object.assign(Object.assign({}, options), {
                              host: url.host,
                              protocol: url.protocol,
                              port: url.port,
                              path: url.pathname,
                              hostname: url.host
                          }), ocsp_ignored_.utils.getResponse(options, req.data, ((error, raw) => {
                              if (error) return void reject(error);
                              const certID = req.certID;
                              this.onEvent(new OCSPResponseRetrievedEvent(certID.toString("hex"))), resolve(raw);
                          }));
                      }));
                  }));
              }
              static onEvent(event) {
                  Events.instance.onEvent(event);
              }
              CreateConnection(request, options) {
                  const enableOCSP = "undefined" != typeof process && "0" !== process.env.NODE_TLS_REJECT_UNAUTHORIZED && "0" !== process.env.SPEECH_CONDUCT_OCSP_CHECK && options.secureEndpoint;
                  let socketPromise;
                  if (options = Object.assign(Object.assign({}, options), {
                      requestOCSP: !CertCheckAgent.forceDisableOCSPStapling,
                      servername: options.host
                  }), this.privProxyInfo) {
                      const baseAgent = CertCheckAgent.GetProxyAgent(this.privProxyInfo);
                      socketPromise = new Promise(((resolve, reject) => {
                          baseAgent.callback(request, options, ((error, socket) => {
                              error ? reject(error) : resolve(socket);
                          }));
                      }));
                  } else socketPromise = options.secureEndpoint ? Promise.resolve(tls_ignored_.connect(options)) : Promise.resolve(net_ignored_.connect(options));
                  return enableOCSP ? CertCheckAgent.OCSPCheck(socketPromise, this.privProxyInfo) : socketPromise;
              }
          }
          CertCheckAgent.testTimeOffset = 0, CertCheckAgent.forceDisableOCSPStapling = !1, 
          CertCheckAgent.privMemCache = {};
          var WebsocketMessageAdapter_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class WebsocketMessageAdapter {
              constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {
                  if (!uri) throw new ArgumentNullError("uri");
                  if (!messageFormatter) throw new ArgumentNullError("messageFormatter");
                  this.proxyInfo = proxyInfo, this.privConnectionEvents = new EventSource, this.privConnectionId = connectionId, 
                  this.privMessageFormatter = messageFormatter, this.privConnectionState = ConnectionState.None, 
                  this.privUri = uri, this.privHeaders = headers, this.privEnableCompression = enableCompression, 
                  this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId, this.privLastErrorReceived = "";
              }
              get state() {
                  return this.privConnectionState;
              }
              open() {
                  if (this.privConnectionState === ConnectionState.Disconnected) return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
                  if (this.privConnectionEstablishDeferral) return this.privConnectionEstablishDeferral.promise;
                  this.privConnectionEstablishDeferral = new Deferred, this.privCertificateValidatedDeferral = new Deferred, 
                  this.privConnectionState = ConnectionState.Connecting;
                  try {
                      if ("undefined" == typeof WebSocket || WebsocketMessageAdapter.forceNpmWebSocket) {
                          const options = {
                              headers: this.privHeaders,
                              perMessageDeflate: this.privEnableCompression
                          };
                          this.privCertificateValidatedDeferral.resolve();
                          const checkAgent = new CertCheckAgent(this.proxyInfo);
                          options.agent = checkAgent.GetAgent();
                          let protocol = new URL(this.privUri).protocol;
                          "wss:" === (null == protocol ? void 0 : protocol.toLocaleLowerCase()) ? protocol = "https:" : "ws:" === (null == protocol ? void 0 : protocol.toLocaleLowerCase()) && (protocol = "http:"), 
                          options.agent.protocol = protocol, this.privWebsocketClient = new (ws_ignored_default())(this.privUri, options);
                      } else this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
                      this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new Queue, 
                      this.privDisconnectDeferral = new Deferred, this.privSendMessageQueue = new Queue, 
                      this.processSendQueue().catch((reason => {
                          Events.instance.onEvent(new BackgroundEvent(reason));
                      }));
                  } catch (error) {
                      return this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error)), 
                      this.privConnectionEstablishDeferral.promise;
                  }
                  return this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri)), 
                  this.privWebsocketClient.onopen = () => {
                      this.privCertificateValidatedDeferral.promise.then((() => {
                          this.privConnectionState = ConnectionState.Connected, this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId)), 
                          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, ""));
                      }), (error => {
                          this.privConnectionEstablishDeferral.reject(error);
                      }));
                  }, this.privWebsocketClient.onerror = e => {
                      this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type)), 
                      this.privLastErrorReceived = e.message;
                  }, this.privWebsocketClient.onclose = e => {
                      this.privConnectionState === ConnectionState.Connecting ? (this.privConnectionState = ConnectionState.Disconnected, 
                      this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = ConnectionState.Disconnected, 
                      this.privWebsocketClient = null, this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason))), 
                      this.onClose(e.code, e.reason).catch((reason => {
                          Events.instance.onEvent(new BackgroundEvent(reason));
                      }));
                  }, this.privWebsocketClient.onmessage = e => {
                      const networkReceivedTime = (new Date).toISOString();
                      if (this.privConnectionState === ConnectionState.Connected) {
                          const deferred = new Deferred;
                          if (this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise), e.data instanceof ArrayBuffer) {
                              const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);
                              this.privMessageFormatter.toConnectionMessage(rawMessage).then((connectionMessage => {
                                  this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage)), 
                                  deferred.resolve(connectionMessage);
                              }), (error => {
                                  deferred.reject(`Invalid binary message format. Error: ${error}`);
                              }));
                          } else {
                              const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);
                              this.privMessageFormatter.toConnectionMessage(rawMessage).then((connectionMessage => {
                                  this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage)), 
                                  deferred.resolve(connectionMessage);
                              }), (error => {
                                  deferred.reject(`Invalid text message format. Error: ${error}`);
                              }));
                          }
                      }
                  }, this.privConnectionEstablishDeferral.promise;
              }
              send(message) {
                  if (this.privConnectionState !== ConnectionState.Connected) return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);
                  const messageSendStatusDeferral = new Deferred, messageSendDeferral = new Deferred;
                  return this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise), 
                  this.privMessageFormatter.fromConnectionMessage(message).then((rawMessage => {
                      messageSendDeferral.resolve({
                          Message: message,
                          RawWebsocketMessage: rawMessage,
                          sendStatusDeferral: messageSendStatusDeferral
                      });
                  }), (error => {
                      messageSendDeferral.reject(`Error formatting the message. ${error}`);
                  })), messageSendStatusDeferral.promise;
              }
              read() {
                  return this.privConnectionState !== ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
              }
              close(reason) {
                  return this.privWebsocketClient ? (this.privConnectionState !== ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, reason || "Normal closure by client"), 
                  this.privDisconnectDeferral.promise) : Promise.resolve();
              }
              get events() {
                  return this.privConnectionEvents;
              }
              sendRawMessage(sendItem) {
                  try {
                      return sendItem ? (this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, (new Date).toISOString(), sendItem.Message)), 
                      this.isWebsocketOpen ? (this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload), 
                      Promise.resolve()) : Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + sendItem.Message.id + " " + (new Error).stack)) : Promise.resolve();
                  } catch (e) {
                      return Promise.reject(`websocket send error: ${e}`);
                  }
              }
              onClose(code, reason) {
                  return WebsocketMessageAdapter_awaiter(this, void 0, void 0, (function*() {
                      const closeReason = `Connection closed. ${code}: ${reason}`;
                      this.privConnectionState = ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), 
                      yield this.privReceivingMessageQueue.drainAndDispose((() => {}), closeReason), yield this.privSendMessageQueue.drainAndDispose((pendingSendItem => {
                          pendingSendItem.sendStatusDeferral.reject(closeReason);
                      }), closeReason);
                  }));
              }
              processSendQueue() {
                  return WebsocketMessageAdapter_awaiter(this, void 0, void 0, (function*() {
                      for (;;) {
                          const itemToSend = this.privSendMessageQueue.dequeue(), sendItem = yield itemToSend;
                          if (!sendItem) return;
                          try {
                              yield this.sendRawMessage(sendItem), sendItem.sendStatusDeferral.resolve();
                          } catch (sendError) {
                              sendItem.sendStatusDeferral.reject(sendError);
                          }
                      }
                  }));
              }
              onEvent(event) {
                  this.privConnectionEvents.onEvent(event), Events.instance.onEvent(event);
              }
              get isWebsocketOpen() {
                  return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
              }
          }
          WebsocketMessageAdapter.forceNpmWebSocket = !1;
          var WebsocketConnection_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class WebsocketConnection {
              constructor(uri, queryParameters, headers, messageFormatter, proxyInfo, enableCompression = !1, connectionId) {
                  if (this.privIsDisposed = !1, !uri) throw new ArgumentNullError("uri");
                  if (!messageFormatter) throw new ArgumentNullError("messageFormatter");
                  this.privMessageFormatter = messageFormatter;
                  let queryParams = "", i = 0;
                  if (queryParameters) for (const paramName in queryParameters) if (paramName) {
                      queryParams += 0 === i && -1 === uri.indexOf("?") ? "?" : "&";
                      queryParams += `${paramName}=${encodeURIComponent(queryParameters[paramName])}`, 
                      i++;
                  }
                  if (headers) for (const headerName in headers) if (headerName) {
                      queryParams += 0 === i && -1 === uri.indexOf("?") ? "?" : "&";
                      queryParams += `${headerName}=${encodeURIComponent(headers[headerName])}`, i++;
                  }
                  this.privUri = uri + queryParams, this.privId = connectionId || createNoDashGuid(), 
                  this.privConnectionMessageAdapter = new WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, proxyInfo, headers, enableCompression);
              }
              dispose() {
                  return WebsocketConnection_awaiter(this, void 0, void 0, (function*() {
                      this.privIsDisposed = !0, this.privConnectionMessageAdapter && (yield this.privConnectionMessageAdapter.close());
                  }));
              }
              isDisposed() {
                  return this.privIsDisposed;
              }
              get id() {
                  return this.privId;
              }
              state() {
                  return this.privConnectionMessageAdapter.state;
              }
              open() {
                  return this.privConnectionMessageAdapter.open();
              }
              send(message) {
                  return this.privConnectionMessageAdapter.send(message);
              }
              read() {
                  return this.privConnectionMessageAdapter.read();
              }
              get events() {
                  return this.privConnectionMessageAdapter.events;
              }
          }
          class ProxyInfo {
              constructor(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
                  this.privProxyHostName = proxyHostName, this.privProxyPort = proxyPort, this.privProxyUserName = proxyUserName, 
                  this.privProxyPassword = proxyPassword;
              }
              static fromParameters(parameters) {
                  return new ProxyInfo(parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyPort), 10), parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyUserName), parameters.getProperty(PropertyId.SpeechServiceConnection_ProxyPassword));
              }
              static fromRecognizerConfig(config) {
                  return this.fromParameters(config.parameters);
              }
              get HostName() {
                  return this.privProxyHostName;
              }
              get Port() {
                  return this.privProxyPort;
              }
              get UserName() {
                  return this.privProxyUserName;
              }
              get Password() {
                  return this.privProxyPassword;
              }
          }
          class QueryParameterNames {}
          QueryParameterNames.BotId = "botid", QueryParameterNames.CustomSpeechDeploymentId = "cid", 
          QueryParameterNames.CustomVoiceDeploymentId = "deploymentId", QueryParameterNames.EnableAudioLogging = "storeAudio", 
          QueryParameterNames.EnableLanguageId = "lidEnabled", QueryParameterNames.EnableWordLevelTimestamps = "wordLevelTimestamps", 
          QueryParameterNames.EndSilenceTimeoutMs = "endSilenceTimeoutMs", QueryParameterNames.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs", 
          QueryParameterNames.Format = "format", QueryParameterNames.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs", 
          QueryParameterNames.Language = "language", QueryParameterNames.Profanity = "profanity", 
          QueryParameterNames.RequestBotStatusMessages = "enableBotMessageStatus", QueryParameterNames.StableIntermediateThreshold = "stableIntermediateThreshold", 
          QueryParameterNames.StableTranslation = "stableTranslation", QueryParameterNames.TestHooks = "testhooks", 
          QueryParameterNames.Postprocessing = "postprocessing";
          class ConnectionFactoryBase {
              static getHostSuffix(region) {
                  if (region) {
                      if (region.toLowerCase().startsWith("china")) return ".azure.cn";
                      if (region.toLowerCase().startsWith("usgov")) return ".azure.us";
                  }
                  return ".microsoft.com";
              }
              setCommonUrlParams(config, queryParams, endpoint) {
                  new Map([ [ PropertyId.Speech_SegmentationSilenceTimeoutMs, QueryParameterNames.SegmentationSilenceTimeoutMs ], [ PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames.EnableAudioLogging ], [ PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames.EndSilenceTimeoutMs ], [ PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames.InitialSilenceTimeoutMs ], [ PropertyId.SpeechServiceResponse_PostProcessingOption, QueryParameterNames.Postprocessing ], [ PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames.Profanity ], [ PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, QueryParameterNames.EnableWordLevelTimestamps ], [ PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames.StableIntermediateThreshold ] ]).forEach(((parameterName, propertyId) => {
                      this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
                  }));
                  const serviceProperties = JSON.parse(config.parameters.getProperty("ServiceProperties", "{}"));
                  Object.keys(serviceProperties).forEach((value => {
                      queryParams[value] = serviceProperties[value];
                  }));
              }
              setUrlParameter(propId, parameterName, config, queryParams, endpoint) {
                  const value = config.parameters.getProperty(propId, void 0);
                  !value || endpoint && -1 !== endpoint.search(parameterName) || (queryParams[parameterName] = value.toLocaleLowerCase());
              }
          }
          class WebsocketMessageFormatter {
              toConnectionMessage(message) {
                  const deferral = new Deferred;
                  try {
                      if (message.messageType === MessageType.Text) {
                          const textMessage = message.textContent;
                          let headers = {}, body = null;
                          if (textMessage) {
                              const headerBodySplit = textMessage.split("\r\n\r\n");
                              headerBodySplit && headerBodySplit.length > 0 && (headers = this.parseHeaders(headerBodySplit[0]), 
                              headerBodySplit.length > 1 && (body = headerBodySplit[1]));
                          }
                          deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));
                      } else if (message.messageType === MessageType.Binary) {
                          const binaryMessage = message.binaryContent;
                          let headers = {}, body = null;
                          if (!binaryMessage || binaryMessage.byteLength < 2) throw new Error("Invalid binary message format. Header length missing.");
                          const dataView = new DataView(binaryMessage), headerLength = dataView.getInt16(0);
                          if (binaryMessage.byteLength < headerLength + 2) throw new Error("Invalid binary message format. Header content missing.");
                          let headersString = "";
                          for (let i = 0; i < headerLength; i++) headersString += String.fromCharCode(dataView.getInt8(i + 2));
                          headers = this.parseHeaders(headersString), binaryMessage.byteLength > headerLength + 2 && (body = binaryMessage.slice(2 + headerLength)), 
                          deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));
                      }
                  } catch (e) {
                      deferral.reject(`Error formatting the message. Error: ${e}`);
                  }
                  return deferral.promise;
              }
              fromConnectionMessage(message) {
                  const deferral = new Deferred;
                  try {
                      if (message.messageType === MessageType.Text) {
                          const payload = `${this.makeHeaders(message)}\r\n${message.textBody ? message.textBody : ""}`;
                          deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));
                      } else if (message.messageType === MessageType.Binary) {
                          const headersString = this.makeHeaders(message), content = message.binaryBody, headerBuffer = this.stringToArrayBuffer(headersString), headerInt8Array = new Int8Array(headerBuffer), headerLength = headerInt8Array.byteLength, payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));
                          if (payloadInt8Array[0] = headerLength >> 8 & 255, payloadInt8Array[1] = 255 & headerLength, 
                          payloadInt8Array.set(headerInt8Array, 2), content) {
                              const bodyInt8Array = new Int8Array(content);
                              payloadInt8Array.set(bodyInt8Array, 2 + headerLength);
                          }
                          const payload = payloadInt8Array.buffer;
                          deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));
                      }
                  } catch (e) {
                      deferral.reject(`Error formatting the message. ${e}`);
                  }
                  return deferral.promise;
              }
              makeHeaders(message) {
                  let headersString = "";
                  if (message.headers) for (const header in message.headers) header && (headersString += `${header}: ${message.headers[header]}\r\n`);
                  return headersString;
              }
              parseHeaders(headersString) {
                  const headers = {};
                  if (headersString) {
                      const headerMatches = headersString.match(/[^\r\n]+/g);
                      if (headers) for (const header of headerMatches) if (header) {
                          const separatorIndex = header.indexOf(":"), headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header, headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : "";
                          headers[headerName] = headerValue;
                      }
                  }
                  return headers;
              }
              stringToArrayBuffer(str) {
                  const buffer = new ArrayBuffer(str.length), view = new DataView(buffer);
                  for (let i = 0; i < str.length; i++) view.setUint8(i, str.charCodeAt(i));
                  return buffer;
              }
          }
          class SpeechConnectionFactory extends ConnectionFactoryBase {
              constructor() {
                  super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", 
                  this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", 
                  this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", 
                  this.universalUri = "/speech/universal/v";
              }
              create(config, authInfo, connectionId) {
                  let endpoint = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint, void 0);
                  const region = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Region, void 0), hostSuffix = ConnectionFactoryBase.getHostSuffix(region), host = config.parameters.getProperty(PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix), queryParams = {}, endpointId = config.parameters.getProperty(PropertyId.SpeechServiceConnection_EndpointId, void 0), language = config.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
                  if (endpointId ? endpoint && -1 !== endpoint.search(QueryParameterNames.CustomSpeechDeploymentId) || (queryParams[QueryParameterNames.CustomSpeechDeploymentId] = endpointId) : language && (endpoint && -1 !== endpoint.search(QueryParameterNames.Language) || (queryParams[QueryParameterNames.Language] = language)), 
                  endpoint && -1 !== endpoint.search(QueryParameterNames.Format) || (queryParams[QueryParameterNames.Format] = config.parameters.getProperty("OutputFormat", OutputFormat[OutputFormat.Simple]).toLowerCase()), 
                  void 0 !== config.autoDetectSourceLanguages && (queryParams[QueryParameterNames.EnableLanguageId] = "true"), 
                  this.setCommonUrlParams(config, queryParams, endpoint), !endpoint) switch (config.recognitionMode) {
                    case RecognitionMode.Conversation:
                      endpoint = "true" === config.parameters.getProperty("ForceDictation", "false") ? host + this.dictationRelativeUri : void 0 !== config.recognitionEndpointVersion && parseInt(config.recognitionEndpointVersion, 10) > 1 ? `${host}${this.universalUri}${config.recognitionEndpointVersion}` : host + this.conversationRelativeUri;
                      break;

                    case RecognitionMode.Dictation:
                      endpoint = host + this.dictationRelativeUri;
                      break;

                    default:
                      endpoint = void 0 !== config.recognitionEndpointVersion && parseInt(config.recognitionEndpointVersion, 10) > 1 ? `${host}${this.universalUri}${config.recognitionEndpointVersion}` : host + this.interactiveRelativeUri;
                  }
                  const headers = {};
                  void 0 !== authInfo.token && "" !== authInfo.token && (headers[authInfo.headerName] = authInfo.token), 
                  headers[HeaderNames.ConnectionId] = connectionId, config.parameters.setProperty(PropertyId.SpeechServiceConnection_Url, endpoint);
                  const enableCompression = "true" === config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false");
                  return new WebsocketConnection(endpoint, queryParams, headers, new WebsocketMessageFormatter, ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
              }
          }
          class RecognitionResult {
              constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
                  this.privResultId = resultId, this.privReason = reason, this.privText = text, this.privDuration = duration, 
                  this.privOffset = offset, this.privLanguage = language, this.privLanguageDetectionConfidence = languageDetectionConfidence, 
                  this.privErrorDetails = errorDetails, this.privJson = json, this.privProperties = properties;
              }
              get resultId() {
                  return this.privResultId;
              }
              get reason() {
                  return this.privReason;
              }
              get text() {
                  return this.privText;
              }
              get duration() {
                  return this.privDuration;
              }
              get offset() {
                  return this.privOffset;
              }
              get language() {
                  return this.privLanguage;
              }
              get languageDetectionConfidence() {
                  return this.privLanguageDetectionConfidence;
              }
              get errorDetails() {
                  return this.privErrorDetails;
              }
              get json() {
                  return this.privJson;
              }
              get properties() {
                  return this.privProperties;
              }
          }
          class SpeechRecognitionResult extends RecognitionResult {
              constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
                  super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties), 
                  this.privSpeakerId = speakerId;
              }
              get speakerId() {
                  return this.privSpeakerId;
              }
          }
          class SessionEventArgs {
              constructor(sessionId) {
                  this.privSessionId = sessionId;
              }
              get sessionId() {
                  return this.privSessionId;
              }
          }
          class RecognitionEventArgs extends SessionEventArgs {
              constructor(offset, sessionId) {
                  super(sessionId), this.privOffset = offset;
              }
              get offset() {
                  return this.privOffset;
              }
          }
          class SpeechRecognitionEventArgs extends RecognitionEventArgs {
              constructor(result, offset, sessionId) {
                  super(offset, sessionId), this.privResult = result;
              }
              get result() {
                  return this.privResult;
              }
          }
          class CancellationEventArgsBase extends RecognitionEventArgs {
              constructor(reason, errorDetails, errorCode, offset, sessionId) {
                  super(offset, sessionId), this.privReason = reason, this.privErrorDetails = errorDetails, 
                  this.privErrorCode = errorCode;
              }
              get reason() {
                  return this.privReason;
              }
              get errorCode() {
                  return this.privErrorCode;
              }
              get errorDetails() {
                  return this.privErrorDetails;
              }
          }
          class SpeechRecognitionCanceledEventArgs extends CancellationEventArgsBase {}
          class ReplayableAudioNode {
              constructor(audioSource, bytesPerSecond) {
                  this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, 
                  this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, 
                  this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = audioSource, 
                  this.privBytesPerSecond = bytesPerSecond;
              }
              id() {
                  return this.privAudioNode.id();
              }
              read() {
                  if (this.privReplay && 0 !== this.privBuffers.length) {
                      const offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;
                      let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
                      0 != bytesToSeek % 2 && bytesToSeek++;
                      let i = 0;
                      for (;i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength; ) bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
                      if (i < this.privBuffers.length) {
                          const retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);
                          return this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e7, 
                          i === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
                              buffer: retVal,
                              isEnd: !1,
                              timeReceived: this.privBuffers[i].chunk.timeReceived
                          });
                      }
                  }
                  return this.privAudioNode.read().then((result => (result && result.buffer && (this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes)), 
                  this.privBufferedBytes += result.buffer.byteLength), result)));
              }
              detach() {
                  return this.privBuffers = void 0, this.privAudioNode.detach();
              }
              replay() {
                  this.privBuffers && 0 !== this.privBuffers.length && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
              }
              shrinkBuffers(offset) {
                  if (void 0 === this.privBuffers || 0 === this.privBuffers.length) return;
                  this.privLastShrinkOffset = offset;
                  const offsetToSeek = offset - this.privBufferStartOffset;
                  let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7), i = 0;
                  for (;i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength; ) bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
                  this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e7), 
                  this.privBuffers = this.privBuffers.slice(i);
              }
              findTimeAtOffset(offset) {
                  if (offset < this.privBufferStartOffset || void 0 === this.privBuffers) return 0;
                  for (const value of this.privBuffers) {
                      const startOffset = value.byteOffset / this.privBytesPerSecond * 1e7, endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
                      if (offset >= startOffset && offset <= endOffset) return value.chunk.timeReceived;
                  }
                  return 0;
              }
          }
          class BufferEntry {
              constructor(chunk, serial, byteOffset) {
                  this.chunk = chunk, this.serial = serial, this.byteOffset = byteOffset;
              }
          }
          class Timeout {
              static load(url) {
                  const scheduledTimeoutFunctions = new Map([ [ 0, () => {} ] ]), unhandledRequests = new Map, worker = new Worker(url);
                  worker.addEventListener("message", (({data}) => {
                      if (Timeout.isCallNotification(data)) {
                          const {params: {timerId}} = data, idOrFunc = scheduledTimeoutFunctions.get(timerId);
                          if ("number" == typeof idOrFunc) {
                              const unhandledTimerId = unhandledRequests.get(idOrFunc);
                              if (void 0 === unhandledTimerId || unhandledTimerId !== timerId) throw new Error("The timer is in an undefined state.");
                          } else {
                              if (void 0 === idOrFunc) throw new Error("The timer is in an undefined state.");
                              idOrFunc(), scheduledTimeoutFunctions.delete(timerId);
                          }
                      } else {
                          if (!Timeout.isClearResponse(data)) {
                              const {error: {message}} = data;
                              throw new Error(message);
                          }
                          {
                              const {id} = data, unhandledTimerId = unhandledRequests.get(id);
                              if (void 0 === unhandledTimerId) throw new Error("The timer is in an undefined state.");
                              unhandledRequests.delete(id), scheduledTimeoutFunctions.delete(unhandledTimerId);
                          }
                      }
                  }));
                  return {
                      clearTimeout: timerId => {
                          const id = Math.random();
                          unhandledRequests.set(id, timerId), scheduledTimeoutFunctions.set(timerId, id), 
                          worker.postMessage({
                              id,
                              method: "clear",
                              params: {
                                  timerId
                              }
                          });
                      },
                      setTimeout: (func, delay) => {
                          const timerId = Math.random();
                          return scheduledTimeoutFunctions.set(timerId, func), worker.postMessage({
                              id: null,
                              method: "set",
                              params: {
                                  delay,
                                  now: performance.now(),
                                  timerId
                              }
                          }), timerId;
                      }
                  };
              }
              static loadWorkerTimers() {
                  return () => {
                      if (null !== Timeout.workerTimers) return Timeout.workerTimers;
                      const blob = new Blob([ '!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error(\'There is no interval scheduled with the given id "\'.concat(e,\'".\'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error(\'There is no timeout scheduled with the given id "\'.concat(e,\'".\'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error(\'The given method "\'.concat(e.method,\'" is not supported\'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);' ], {
                          type: "application/javascript; charset=utf-8"
                      }), url = URL.createObjectURL(blob);
                      return Timeout.workerTimers = Timeout.load(url), Timeout.workerTimers.setTimeout((() => URL.revokeObjectURL(url)), 0), 
                      Timeout.workerTimers;
                  };
              }
              static isCallNotification(message) {
                  return void 0 !== message.method && "call" === message.method;
              }
              static isClearResponse(message) {
                  return null === message.error && "number" == typeof message.id;
              }
          }
          Timeout.workerTimers = null, Timeout.clearTimeout = timerId => Timeout.timers().clearTimeout(timerId), 
          Timeout.setTimeout = (func, delay) => Timeout.timers().setTimeout(func, delay), 
          Timeout.timers = Timeout.loadWorkerTimers();
          class SpeechRecognitionEvent extends PlatformEvent {
              constructor(eventName, requestId, sessionId, eventType = PlatformEvent_EventType.Info) {
                  super(eventName, eventType), this.privRequestId = requestId, this.privSessionId = sessionId;
              }
              get requestId() {
                  return this.privRequestId;
              }
              get sessionId() {
                  return this.privSessionId;
              }
          }
          class RecognitionTriggeredEvent extends SpeechRecognitionEvent {
              constructor(requestId, sessionId, audioSourceId, audioNodeId) {
                  super("RecognitionTriggeredEvent", requestId, sessionId), this.privAudioSourceId = audioSourceId, 
                  this.privAudioNodeId = audioNodeId;
              }
              get audioSourceId() {
                  return this.privAudioSourceId;
              }
              get audioNodeId() {
                  return this.privAudioNodeId;
              }
          }
          class ListeningStartedEvent extends SpeechRecognitionEvent {
              constructor(requestId, sessionId, audioSourceId, audioNodeId) {
                  super("ListeningStartedEvent", requestId, sessionId), this.privAudioSourceId = audioSourceId, 
                  this.privAudioNodeId = audioNodeId;
              }
              get audioSourceId() {
                  return this.privAudioSourceId;
              }
              get audioNodeId() {
                  return this.privAudioNodeId;
              }
          }
          class ConnectingToServiceEvent extends SpeechRecognitionEvent {
              constructor(requestId, authFetchEventid, sessionId) {
                  super("ConnectingToServiceEvent", requestId, sessionId), this.privAuthFetchEventid = authFetchEventid;
              }
              get authFetchEventid() {
                  return this.privAuthFetchEventid;
              }
          }
          class RecognitionStartedEvent extends SpeechRecognitionEvent {
              constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId) {
                  super("RecognitionStartedEvent", requestId, sessionId), this.privAudioSourceId = audioSourceId, 
                  this.privAudioNodeId = audioNodeId, this.privAuthFetchEventId = authFetchEventId;
              }
              get audioSourceId() {
                  return this.privAudioSourceId;
              }
              get audioNodeId() {
                  return this.privAudioNodeId;
              }
              get authFetchEventId() {
                  return this.privAuthFetchEventId;
              }
          }
          var RecognitionCompletionStatus;
          !function(RecognitionCompletionStatus) {
              RecognitionCompletionStatus[RecognitionCompletionStatus.Success = 0] = "Success", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.AudioSourceError = 1] = "AudioSourceError", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.AudioSourceTimeout = 2] = "AudioSourceTimeout", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.AuthTokenFetchError = 3] = "AuthTokenFetchError", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.UnAuthorized = 5] = "UnAuthorized", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.ConnectTimeout = 6] = "ConnectTimeout", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.ConnectError = 7] = "ConnectError", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", 
              RecognitionCompletionStatus[RecognitionCompletionStatus.UnknownError = 9] = "UnknownError";
          }(RecognitionCompletionStatus || (RecognitionCompletionStatus = {}));
          class ServiceTelemetryListener {
              constructor(requestId, audioSourceId, audioNodeId) {
                  this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, 
                  this.privConnectionEstablishMetric = null, this.privRequestId = requestId, this.privAudioSourceId = audioSourceId, 
                  this.privAudioNodeId = audioNodeId, this.privReceivedMessages = {}, this.privPhraseLatencies = [], 
                  this.privHypothesisLatencies = [];
              }
              phraseReceived(audioReceivedTime) {
                  audioReceivedTime > 0 && this.privPhraseLatencies.push(Date.now() - audioReceivedTime);
              }
              hypothesisReceived(audioReceivedTime) {
                  audioReceivedTime > 0 && this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);
              }
              onEvent(e) {
                  if (!this.privIsDisposed && (e instanceof RecognitionTriggeredEvent && e.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
                      End: e.eventTime,
                      Name: "ListeningTrigger",
                      Start: e.eventTime
                  }), e instanceof AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = e.eventTime), 
                  e instanceof AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = e.eventTime), 
                  e instanceof AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
                      End: e.eventTime,
                      Error: e.error,
                      Name: "Microphone",
                      Start: this.privMicStartTime
                  })), e instanceof AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
                      End: e.eventTime,
                      Error: e.error,
                      Name: "Microphone",
                      Start: this.privMicStartTime
                  })), e instanceof AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
                      End: e.eventTime,
                      Name: "Microphone",
                      Start: this.privMicStartTime
                  })), e instanceof ConnectingToServiceEvent && e.requestId === this.privRequestId && (this.privConnectionId = e.sessionId), 
                  e instanceof ConnectionStartEvent && e.connectionId === this.privConnectionId && (this.privConnectionStartTime = e.eventTime), 
                  e instanceof ConnectionEstablishedEvent && e.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
                      End: e.eventTime,
                      Id: this.privConnectionId,
                      Name: "Connection",
                      Start: this.privConnectionStartTime
                  })), e instanceof ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
                      End: e.eventTime,
                      Error: this.getConnectionError(e.statusCode),
                      Id: this.privConnectionId,
                      Name: "Connection",
                      Start: this.privConnectionStartTime
                  })), e instanceof ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId && e.message && e.message.headers && e.message.headers.path)) {
                      this.privReceivedMessages[e.message.headers.path] || (this.privReceivedMessages[e.message.headers.path] = new Array);
                      const maxMessagesToSend = 50;
                      this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend && this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);
                  }
              }
              getTelemetry() {
                  const metrics = new Array;
                  this.privListeningTriggerMetric && metrics.push(this.privListeningTriggerMetric), 
                  this.privMicMetric && metrics.push(this.privMicMetric), this.privConnectionEstablishMetric && metrics.push(this.privConnectionEstablishMetric), 
                  this.privPhraseLatencies.length > 0 && metrics.push({
                      PhraseLatencyMs: this.privPhraseLatencies
                  }), this.privHypothesisLatencies.length > 0 && metrics.push({
                      FirstHypothesisLatencyMs: this.privHypothesisLatencies
                  });
                  const telemetry = {
                      Metrics: metrics,
                      ReceivedMessages: this.privReceivedMessages
                  }, json = JSON.stringify(telemetry);
                  return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, 
                  this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], 
                  json;
              }
              get hasTelemetry() {
                  return 0 !== Object.keys(this.privReceivedMessages).length || null !== this.privListeningTriggerMetric || null !== this.privMicMetric || null !== this.privConnectionEstablishMetric || 0 !== this.privPhraseLatencies.length || 0 !== this.privHypothesisLatencies.length;
              }
              dispose() {
                  this.privIsDisposed = !0;
              }
              getConnectionError(statusCode) {
                  switch (statusCode) {
                    case 400:
                    case 1002:
                    case 1003:
                    case 1005:
                    case 1007:
                    case 1008:
                    case 1009:
                      return "BadRequest";

                    case 401:
                      return "Unauthorized";

                    case 403:
                      return "Forbidden";

                    case 503:
                    case 1001:
                      return "ServerUnavailable";

                    case 500:
                    case 1011:
                      return "ServerError";

                    case 408:
                    case 504:
                      return "Timeout";

                    default:
                      return "statuscode:" + statusCode.toString();
                  }
              }
          }
          var RequestSession_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class RequestSession {
              constructor(audioSourceId) {
                  this.privIsDisposed = !1, this.privDetachables = new Array, this.privIsAudioNodeDetached = !1, 
                  this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, 
                  this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, 
                  this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, 
                  this.privAudioSourceId = audioSourceId, this.privRequestId = createNoDashGuid(), 
                  this.privAudioNodeId = createNoDashGuid(), this.privTurnDeferral = new Deferred, 
                  this.privTurnDeferral.resolve();
              }
              get sessionId() {
                  return this.privSessionId;
              }
              get requestId() {
                  return this.privRequestId;
              }
              get audioNodeId() {
                  return this.privAudioNodeId;
              }
              get turnCompletionPromise() {
                  return this.privTurnDeferral.promise;
              }
              get isSpeechEnded() {
                  return this.privIsSpeechEnded;
              }
              get isRecognizing() {
                  return this.privIsRecognizing;
              }
              get currentTurnAudioOffset() {
                  return this.privTurnStartAudioOffset;
              }
              get recogNumber() {
                  return this.privRecogNumber;
              }
              get numConnectionAttempts() {
                  return this.privConnectionAttempts;
              }
              get bytesSent() {
                  return this.privBytesSent;
              }
              listenForServiceTelemetry(eventSource) {
                  this.privServiceTelemetryListener && this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));
              }
              startNewRecognition() {
                  this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, 
                  this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), 
                  this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
              }
              onAudioSourceAttachCompleted(audioNode, isError) {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      this.privAudioNode = audioNode, this.privIsAudioNodeDetached = !1, isError ? yield this.onComplete() : this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
                  }));
              }
              onPreConnectionStart(authFetchEventId, connectionId) {
                  this.privAuthFetchEventId = authFetchEventId, this.privSessionId = connectionId, 
                  this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
              }
              onAuthCompleted(isError) {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      isError && (yield this.onComplete());
                  }));
              }
              onConnectionEstablishCompleted(statusCode, reason) {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      if (200 === statusCode) return this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), 
                      this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, 
                      void (this.privBytesSent = 0);
                      403 === statusCode && (yield this.onComplete());
                  }));
              }
              onServiceTurnEndResponse(continuousRecognition) {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      this.privTurnDeferral.resolve(), !continuousRecognition || this.isSpeechEnded ? (yield this.onComplete(), 
                      this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, 
                      this.privAudioNode.replay());
                  }));
              }
              onSpeechContext() {
                  this.privRequestId = createNoDashGuid();
              }
              onServiceTurnStartResponse() {
                  this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), 
                  this.privTurnDeferral.promise.then().catch((() => {}))), this.privInTurn = !0, this.privTurnDeferral = new Deferred;
              }
              onHypothesis(offset) {
                  this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset)));
              }
              onPhraseRecognized(offset) {
                  this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset)), 
                  this.onServiceRecognized(offset);
              }
              onServiceRecognized(offset) {
                  this.privLastRecoOffset = offset, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(offset), 
                  this.privConnectionAttempts = 0;
              }
              onAudioSent(bytesSent) {
                  this.privBytesSent += bytesSent;
              }
              onRetryConnection() {
                  this.privConnectionAttempts++;
              }
              dispose() {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      if (!this.privIsDisposed) {
                          this.privIsDisposed = !0;
                          for (const detachable of this.privDetachables) yield detachable.detach();
                          this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), 
                          this.privIsRecognizing = !1;
                      }
                  }));
              }
              getTelemetry() {
                  return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
              }
              onStopRecognizing() {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      yield this.onComplete();
                  }));
              }
              onSpeechEnded() {
                  this.privIsSpeechEnded = !0;
              }
              onEvent(event) {
                  this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(event), 
                  Events.instance.onEvent(event);
              }
              onComplete() {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      this.privIsRecognizing && (this.privIsRecognizing = !1, yield this.detachAudioNode());
                  }));
              }
              detachAudioNode() {
                  return RequestSession_awaiter(this, void 0, void 0, (function*() {
                      this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && (yield this.privAudioNode.detach()));
                  }));
              }
          }
          class DynamicGrammarBuilder {
              addPhrase(phrase) {
                  this.privPhrases || (this.privPhrases = []), phrase instanceof Array ? this.privPhrases = this.privPhrases.concat(phrase) : this.privPhrases.push(phrase);
              }
              clearPhrases() {
                  this.privPhrases = void 0;
              }
              addReferenceGrammar(grammar) {
                  this.privGrammars || (this.privGrammars = []), grammar instanceof Array ? this.privGrammars = this.privGrammars.concat(grammar) : this.privGrammars.push(grammar);
              }
              clearGrammars() {
                  this.privGrammars = void 0;
              }
              generateGrammarObject() {
                  if (void 0 === this.privGrammars && void 0 === this.privPhrases) return;
                  const retObj = {};
                  if (retObj.ReferenceGrammars = this.privGrammars, void 0 !== this.privPhrases && 0 !== this.privPhrases.length) {
                      const retPhrases = [];
                      this.privPhrases.forEach((value => {
                          retPhrases.push({
                              Text: value
                          });
                      })), retObj.Groups = [ {
                          Type: "Generic",
                          Items: retPhrases
                      } ];
                  }
                  return retObj;
              }
          }
          class SpeechContext {
              constructor(dynamicGrammar) {
                  this.privContext = {}, this.privDynamicGrammar = dynamicGrammar;
              }
              setSection(sectionName, value) {
                  this.privContext[sectionName] = value;
              }
              setPronunciationAssessmentParams(params) {
                  void 0 === this.privContext.phraseDetection && (this.privContext.phraseDetection = {
                      enrichment: {
                          pronunciationAssessment: {}
                      }
                  }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(params), 
                  this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push("PronunciationAssessment"), 
                  -1 === this.privContext.phraseOutput.detailed.options.indexOf("SNR") && this.privContext.phraseOutput.detailed.options.push("SNR");
              }
              setWordLevelTimings() {
                  void 0 === this.privContext.phraseOutput && (this.privContext.phraseOutput = {
                      detailed: {
                          options: []
                      },
                      format: {}
                  }), void 0 === this.privContext.phraseOutput.detailed && (this.privContext.phraseOutput.detailed = {
                      options: []
                  }), this.privContext.phraseOutput.format = "Detailed", -1 === this.privContext.phraseOutput.detailed.options.indexOf("WordTimings") && this.privContext.phraseOutput.detailed.options.push("WordTimings");
              }
              toJSON() {
                  const dgi = this.privDynamicGrammar.generateGrammarObject();
                  this.setSection("dgi", dgi);
                  return JSON.stringify(this.privContext);
              }
          }
          class SpeechDetected {
              constructor(json) {
                  this.privSpeechStartDetected = JSON.parse(json);
              }
              static fromJSON(json) {
                  return new SpeechDetected(json);
              }
              get Offset() {
                  return this.privSpeechStartDetected.Offset;
              }
          }
          var SynthesisStatus, RecognitionStatus, ServiceRecognizerBase_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class ServiceRecognizerBase {
              constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
                  if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, 
                  this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.recognizeOverride = void 0, 
                  this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, 
                  this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, !authentication) throw new ArgumentNullError("authentication");
                  if (!connectionFactory) throw new ArgumentNullError("connectionFactory");
                  if (!audioSource) throw new ArgumentNullError("audioSource");
                  if (!recognizerConfig) throw new ArgumentNullError("recognizerConfig");
                  this.privMustReportEndOfStream = !1, this.privAuthentication = authentication, this.privConnectionFactory = connectionFactory, 
                  this.privAudioSource = audioSource, this.privRecognizerConfig = recognizerConfig, 
                  this.privIsDisposed = !1, this.privRecognizer = recognizer, this.privRequestSession = new RequestSession(this.privAudioSource.id()), 
                  this.privConnectionEvents = new EventSource, this.privServiceEvents = new EventSource, 
                  this.privDynamicGrammar = new DynamicGrammarBuilder, this.privSpeechContext = new SpeechContext(this.privDynamicGrammar), 
                  this.privAgentConfig = new AgentConfig, "undefined" != typeof Blob && "undefined" != typeof Worker && (this.privSetTimeout = Timeout.setTimeout), 
                  this.connectionEvents.attach((connectionEvent => {
                      if ("ConnectionClosedEvent" === connectionEvent.name) {
                          const connectionClosedEvent = connectionEvent;
                          (1003 === connectionClosedEvent.statusCode || 1007 === connectionClosedEvent.statusCode || 1002 === connectionClosedEvent.statusCode || 4e3 === connectionClosedEvent.statusCode || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(CancellationReason.Error, 1007 === connectionClosedEvent.statusCode ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);
                      }
                  }));
              }
              get audioSource() {
                  return this.privAudioSource;
              }
              get speechContext() {
                  return this.privSpeechContext;
              }
              get dynamicGrammar() {
                  return this.privDynamicGrammar;
              }
              get agentConfig() {
                  return this.privAgentConfig;
              }
              set conversationTranslatorToken(token) {
                  this.privRecognizerConfig.parameters.setProperty(PropertyId.ConversationTranslator_Token, token);
              }
              set authentication(auth) {
                  this.privAuthentication = this.authentication;
              }
              isDisposed() {
                  return this.privIsDisposed;
              }
              dispose(reason) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      if (this.privIsDisposed = !0, void 0 !== this.privConnectionConfigurationPromise) try {
                          const connection = yield this.privConnectionConfigurationPromise;
                          yield connection.dispose(reason);
                      } catch (error) {
                          return;
                      }
                  }));
              }
              get connectionEvents() {
                  return this.privConnectionEvents;
              }
              get serviceEvents() {
                  return this.privServiceEvents;
              }
              get recognitionMode() {
                  return this.privRecognizerConfig.recognitionMode;
              }
              recognize(recoMode, successCallback, errorCallBack) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      if (void 0 !== this.recognizeOverride) return void (yield this.recognizeOverride(recoMode, successCallback, errorCallBack));
                      this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = recoMode, 
                      this.privSuccessCallback = successCallback, this.privErrorCallback = errorCallBack, 
                      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
                      const conPromise = this.connectImpl();
                      let audioNode;
                      try {
                          const audioStreamNode = yield this.audioSource.attach(this.privRequestSession.audioNodeId), format = yield this.audioSource.format, deviceInfo = yield this.audioSource.deviceInfo;
                          this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === type.Microphones, 
                          audioNode = new ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec), yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, !1), 
                          this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
                              source: deviceInfo
                          };
                      } catch (error) {
                          throw yield this.privRequestSession.onStopRecognizing(), error;
                      }
                      try {
                          yield conPromise;
                      } catch (error) {
                          return void (yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error));
                      }
                      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);
                      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs), 
                      this.receiveMessage();
                      this.sendAudio(audioNode).catch((error => ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                          yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.RuntimeError, error);
                      }))));
                  }));
              }
              stopRecognizing() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      if (this.privRequestSession.isRecognizing) try {
                          yield this.audioSource.turnOff(), yield this.sendFinalAudio(), yield this.privRequestSession.onStopRecognizing(), 
                          yield this.privRequestSession.turnCompletionPromise;
                      } finally {
                          yield this.privRequestSession.dispose();
                      }
                  }));
              }
              connect() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      return yield this.connectImpl(), Promise.resolve();
                  }));
              }
              connectAsync(cb, err) {
                  this.connectImpl().then((() => {
                      try {
                          cb && cb();
                      } catch (e) {
                          err && err(e);
                      }
                  }), (reason => {
                      try {
                          err && err(reason);
                      } catch (error) {}
                  }));
              }
              disconnect() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      if (yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.NoError, "Disconnecting"), 
                      void 0 !== this.disconnectOverride && (yield this.disconnectOverride()), void 0 !== this.privConnectionPromise) try {
                          yield (yield this.privConnectionPromise).dispose();
                      } catch (error) {}
                      this.privConnectionPromise = void 0;
                  }));
              }
              sendMessage(message) {}
              sendNetworkMessage(path, payload) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      const type = "string" == typeof payload ? MessageType.Text : MessageType.Binary, contentType = "string" == typeof payload ? "application/json" : "";
                      return (yield this.fetchConnection()).send(new SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));
                  }));
              }
              set activityTemplate(messagePayload) {
                  this.privActivityTemplate = messagePayload;
              }
              get activityTemplate() {
                  return this.privActivityTemplate;
              }
              sendTelemetryData() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      const telemetryData = this.privRequestSession.getTelemetry();
                      if (!0 !== ServiceRecognizerBase.telemetryDataEnabled || this.privIsDisposed || null === telemetryData) return;
                      if (ServiceRecognizerBase.telemetryData) try {
                          ServiceRecognizerBase.telemetryData(telemetryData);
                      } catch (_a) {}
                      const connection = yield this.fetchConnection();
                      yield connection.send(new SpeechConnectionMessage(MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", telemetryData));
                  }));
              }
              cancelRecognitionLocal(cancellationReason, errorCode, error) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      this.privRequestSession.isRecognizing && (yield this.privRequestSession.onStopRecognizing(), 
                      this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error));
                  }));
              }
              receiveMessage() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      try {
                          if (this.privIsDisposed) return;
                          let connection = yield this.fetchConnection();
                          const message = yield connection.read();
                          if (void 0 !== this.receiveMessageOverride) return this.receiveMessageOverride();
                          if (!message) return this.privRequestSession.isRecognizing ? this.receiveMessage() : void 0;
                          this.privServiceHasSentMessage = !0;
                          const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);
                          if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) switch (connectionMessage.path.toLowerCase()) {
                            case "turn.start":
                              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
                              break;

                            case "speech.startdetected":
                              const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody), speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
                              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
                              break;

                            case "speech.enddetected":
                              let json;
                              json = connectionMessage.textBody.length > 0 ? connectionMessage.textBody : "{ Offset: 0 }";
                              const speechStopDetected = SpeechDetected.fromJSON(json);
                              this.privRecognizerConfig.isContinuousRecognition && this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);
                              const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
                              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
                              break;

                            case "turn.end":
                              yield this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, 
                              yield this.cancelRecognitionLocal(CancellationReason.EndOfStream, CancellationErrorCode.NoError, void 0));
                              const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);
                              if (yield this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), 
                              !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) return void (this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs));
                              connection = yield this.fetchConnection(), yield this.sendPrePayloadJSON(connection);
                              break;

                            default:
                              (yield this.processTypeSpecificMessages(connectionMessage)) || this.privServiceEvents && this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                          }
                          return this.receiveMessage();
                      } catch (error) {
                          return null;
                      }
                  }));
              }
              sendSpeechContext(connection, generateNewRequestId) {
                  const speechContextJson = this.speechContext.toJSON();
                  if (generateNewRequestId && this.privRequestSession.onSpeechContext(), speechContextJson) return connection.send(new SpeechConnectionMessage(MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", speechContextJson));
              }
              sendPrePayloadJSON(connection, generateNewRequestId = !0) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      if (void 0 !== this.sendPrePayloadJSONOverride) return this.sendPrePayloadJSONOverride(connection);
                      yield this.sendSpeechContext(connection, generateNewRequestId), yield this.sendWaveHeader(connection);
                  }));
              }
              sendWaveHeader(connection) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      const format = yield this.audioSource.format;
                      return connection.send(new SpeechConnectionMessage(MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", format.header));
                  }));
              }
              connectImpl() {
                  return void 0 !== this.privConnectionPromise ? this.privConnectionPromise.then((connection => connection.state() === ConnectionState.Disconnected ? (this.privConnectionId = null, 
                  this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise), (() => (this.privConnectionId = null, 
                  this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()))) : (this.privConnectionPromise = this.retryableConnect(), 
                  this.privConnectionPromise.catch((() => {})), void 0 !== this.postConnectImplOverride ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
              }
              sendSpeechServiceConfig(connection, requestSession, SpeechServiceConfigJson) {
                  if (requestSession.onSpeechContext(), !0 !== ServiceRecognizerBase.telemetryDataEnabled) {
                      const replacement = {
                          context: {
                              system: JSON.parse(SpeechServiceConfigJson).context.system
                          }
                      };
                      SpeechServiceConfigJson = JSON.stringify(replacement);
                  }
                  if ("true" === this.privRecognizerConfig.parameters.getProperty("TranscriptionService_SingleChannel", "false").toLowerCase()) {
                      const json = JSON.parse(SpeechServiceConfigJson);
                      json.context.DisableReferenceChannel = "True", json.context.MicSpec = "1_0_0", SpeechServiceConfigJson = JSON.stringify(json);
                  }
                  if (SpeechServiceConfigJson) return connection.send(new SpeechConnectionMessage(MessageType.Text, "speech.config", requestSession.requestId, "application/json", SpeechServiceConfigJson));
              }
              fetchConnection() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      return void 0 !== this.privConnectionConfigurationPromise ? this.privConnectionConfigurationPromise.then((connection => connection.state() === ConnectionState.Disconnected ? (this.privConnectionId = null, 
                      this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, 
                      this.fetchConnection()) : this.privConnectionConfigurationPromise), (() => (this.privConnectionId = null, 
                      this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, 
                      this.fetchConnection()))) : (this.privConnectionConfigurationPromise = this.configureConnection(), 
                      yield this.privConnectionConfigurationPromise);
                  }));
              }
              sendAudio(audioStreamNode) {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      const audioFormat = yield this.audioSource.format;
                      let nextSendTime = Date.now();
                      const fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1e3 * parseInt(fastLaneSizeMs, 10), startRecogNumber = this.privRequestSession.recogNumber, readAndUploadCycle = () => ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                          if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
                              const connection = yield this.fetchConnection(), audioStreamChunk = yield audioStreamNode.read();
                              if (this.privRequestSession.isSpeechEnded) return;
                              let payload, sendDelay;
                              if (!audioStreamChunk || audioStreamChunk.isEnd ? (payload = null, sendDelay = 0) : (payload = audioStreamChunk.buffer, 
                              this.privRequestSession.onAudioSent(payload.byteLength), sendDelay = maxSendUnthrottledBytes >= this.privRequestSession.bytesSent ? 0 : Math.max(0, nextSendTime - Date.now())), 
                              0 !== sendDelay && (yield this.delay(sendDelay)), null !== payload && (nextSendTime = Date.now() + 1e3 * payload.byteLength / (2 * audioFormat.avgBytesPerSec)), 
                              !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
                                  if (connection.send(new SpeechConnectionMessage(MessageType.Binary, "audio", this.privRequestSession.requestId, null, payload)).catch((() => {
                                      this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch((() => {}));
                                  })), !(null == audioStreamChunk ? void 0 : audioStreamChunk.isEnd)) return readAndUploadCycle();
                                  this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
                              }
                          }
                      }));
                      return readAndUploadCycle();
                  }));
              }
              retryableConnect() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      let isUnAuthorized = !1;
                      this.privAuthFetchEventId = createNoDashGuid();
                      const sessionId = this.privRequestSession.sessionId;
                      this.privConnectionId = void 0 !== sessionId ? sessionId : createNoDashGuid(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
                      let lastStatusCode = 0, lastReason = "";
                      for (;this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
                          const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId), auth = yield authPromise;
                          yield this.privRequestSession.onAuthCompleted(!1);
                          const connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId);
                          this.privRequestSession.listenForServiceTelemetry(connection.events), connection.events.attach((event => {
                              this.connectionEvents.onEvent(event);
                          }));
                          const response = yield connection.open();
                          if (200 === response.statusCode) return yield this.privRequestSession.onConnectionEstablishCompleted(response.statusCode), 
                          Promise.resolve(connection);
                          1006 === response.statusCode && (isUnAuthorized = !0), lastStatusCode = response.statusCode, 
                          lastReason = response.reason, this.privRequestSession.onRetryConnection();
                      }
                      return yield this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason), 
                      Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);
                  }));
              }
              delay(delayMs) {
                  return new Promise((resolve => this.privSetTimeout(resolve, delayMs)));
              }
              writeBufferToConsole(buffer) {
                  let out = "Buffer Size: ";
                  if (null === buffer) out += "null"; else {
                      const readView = new Uint8Array(buffer);
                      out += `${buffer.byteLength}\r\n`;
                      for (let i = 0; i < buffer.byteLength; i++) out += readView[i].toString(16).padStart(2, "0") + " ", 
                      (i + 1) % 16 == 0 && (console.info(out), out = "");
                  }
                  console.info(out);
              }
              sendFinalAudio() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      const connection = yield this.fetchConnection();
                      yield connection.send(new SpeechConnectionMessage(MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
                  }));
              }
              configureConnection() {
                  return ServiceRecognizerBase_awaiter(this, void 0, void 0, (function*() {
                      const connection = yield this.connectImpl();
                      return void 0 !== this.configConnectionOverride ? this.configConnectionOverride(connection) : (yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), 
                      yield this.sendPrePayloadJSON(connection, !1), connection);
                  }));
              }
          }
          ServiceRecognizerBase.telemetryDataEnabled = !0;
          class SpeechHypothesis {
              constructor(json) {
                  this.privSpeechHypothesis = JSON.parse(json);
              }
              static fromJSON(json) {
                  return new SpeechHypothesis(json);
              }
              get Text() {
                  return this.privSpeechHypothesis.Text;
              }
              get Offset() {
                  return this.privSpeechHypothesis.Offset;
              }
              get Duration() {
                  return this.privSpeechHypothesis.Duration;
              }
              get Language() {
                  return void 0 === this.privSpeechHypothesis.PrimaryLanguage ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
              }
              get LanguageDetectionConfidence() {
                  return void 0 === this.privSpeechHypothesis.PrimaryLanguage ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
              }
              get SpeakerId() {
                  return this.privSpeechHypothesis.SpeakerId;
              }
          }
          !function(SynthesisStatus) {
              SynthesisStatus[SynthesisStatus.Success = 0] = "Success", SynthesisStatus[SynthesisStatus.SynthesisEnd = 1] = "SynthesisEnd", 
              SynthesisStatus[SynthesisStatus.Error = 2] = "Error";
          }(SynthesisStatus || (SynthesisStatus = {})), function(RecognitionStatus) {
              RecognitionStatus[RecognitionStatus.Success = 0] = "Success", RecognitionStatus[RecognitionStatus.NoMatch = 1] = "NoMatch", 
              RecognitionStatus[RecognitionStatus.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", 
              RecognitionStatus[RecognitionStatus.BabbleTimeout = 3] = "BabbleTimeout", RecognitionStatus[RecognitionStatus.Error = 4] = "Error", 
              RecognitionStatus[RecognitionStatus.EndOfDictation = 5] = "EndOfDictation", RecognitionStatus[RecognitionStatus.TooManyRequests = 6] = "TooManyRequests", 
              RecognitionStatus[RecognitionStatus.BadRequest = 7] = "BadRequest", RecognitionStatus[RecognitionStatus.Forbidden = 8] = "Forbidden";
          }(RecognitionStatus || (RecognitionStatus = {}));
          class SimpleSpeechPhrase {
              constructor(json) {
                  this.privSimpleSpeechPhrase = JSON.parse(json), this.privSimpleSpeechPhrase.RecognitionStatus = RecognitionStatus[this.privSimpleSpeechPhrase.RecognitionStatus];
              }
              static fromJSON(json) {
                  return new SimpleSpeechPhrase(json);
              }
              get RecognitionStatus() {
                  return this.privSimpleSpeechPhrase.RecognitionStatus;
              }
              get DisplayText() {
                  return this.privSimpleSpeechPhrase.DisplayText;
              }
              get Offset() {
                  return this.privSimpleSpeechPhrase.Offset;
              }
              get Duration() {
                  return this.privSimpleSpeechPhrase.Duration;
              }
              get Language() {
                  return void 0 === this.privSimpleSpeechPhrase.PrimaryLanguage ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
              }
              get LanguageDetectionConfidence() {
                  return void 0 === this.privSimpleSpeechPhrase.PrimaryLanguage ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
              }
              get SpeakerId() {
                  return this.privSimpleSpeechPhrase.SpeakerId;
              }
          }
          class EnumTranslation {
              static implTranslateRecognitionResult(recognitionStatus) {
                  let reason = ResultReason.Canceled;
                  switch (recognitionStatus) {
                    case RecognitionStatus.Success:
                      reason = ResultReason.RecognizedSpeech;
                      break;

                    case RecognitionStatus.NoMatch:
                    case RecognitionStatus.InitialSilenceTimeout:
                    case RecognitionStatus.BabbleTimeout:
                    case RecognitionStatus.EndOfDictation:
                      reason = ResultReason.NoMatch;
                      break;

                    case RecognitionStatus.Error:
                    case RecognitionStatus.BadRequest:
                    case RecognitionStatus.Forbidden:
                    default:
                      reason = ResultReason.Canceled;
                  }
                  return reason;
              }
              static implTranslateCancelResult(recognitionStatus) {
                  let reason = CancellationReason.EndOfStream;
                  switch (recognitionStatus) {
                    case RecognitionStatus.Success:
                    case RecognitionStatus.EndOfDictation:
                    case RecognitionStatus.NoMatch:
                      reason = CancellationReason.EndOfStream;
                      break;

                    case RecognitionStatus.InitialSilenceTimeout:
                    case RecognitionStatus.BabbleTimeout:
                    case RecognitionStatus.Error:
                    case RecognitionStatus.BadRequest:
                    case RecognitionStatus.Forbidden:
                    default:
                      reason = CancellationReason.Error;
                  }
                  return reason;
              }
              static implTranslateCancelErrorCode(recognitionStatus) {
                  let reason = CancellationErrorCode.NoError;
                  switch (recognitionStatus) {
                    case RecognitionStatus.Error:
                      reason = CancellationErrorCode.ServiceError;
                      break;

                    case RecognitionStatus.TooManyRequests:
                      reason = CancellationErrorCode.TooManyRequests;
                      break;

                    case RecognitionStatus.BadRequest:
                      reason = CancellationErrorCode.BadRequestParameters;
                      break;

                    case RecognitionStatus.Forbidden:
                      reason = CancellationErrorCode.Forbidden;
                      break;

                    default:
                      reason = CancellationErrorCode.NoError;
                  }
                  return reason;
              }
              static implTranslateErrorDetails(cancellationErrorCode) {
                  let errorDetails = "The speech service encountered an internal error and could not continue.";
                  switch (cancellationErrorCode) {
                    case CancellationErrorCode.Forbidden:
                      errorDetails = "The recognizer is using a free subscription that ran out of quota.";
                      break;

                    case CancellationErrorCode.BadRequestParameters:
                      errorDetails = "Invalid parameter or unsupported audio format in the request.";
                      break;

                    case CancellationErrorCode.TooManyRequests:
                      errorDetails = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
                  }
                  return errorDetails;
              }
          }
          class DetailedSpeechPhrase {
              constructor(json) {
                  this.privDetailedSpeechPhrase = JSON.parse(json), this.privDetailedSpeechPhrase.RecognitionStatus = RecognitionStatus[this.privDetailedSpeechPhrase.RecognitionStatus];
              }
              static fromJSON(json) {
                  return new DetailedSpeechPhrase(json);
              }
              getJsonWithCorrectedOffsets(baseOffset) {
                  if (this.privDetailedSpeechPhrase.NBest) {
                      let firstWordOffset;
                      for (const phrase of this.privDetailedSpeechPhrase.NBest) if (phrase.Words && phrase.Words[0]) {
                          firstWordOffset = phrase.Words[0].Offset;
                          break;
                      }
                      if (firstWordOffset && firstWordOffset < baseOffset) {
                          const offset = baseOffset - firstWordOffset;
                          for (const details of this.privDetailedSpeechPhrase.NBest) if (details.Words) for (const word of details.Words) word.Offset += offset;
                      }
                  }
                  return JSON.stringify(this.privDetailedSpeechPhrase);
              }
              get RecognitionStatus() {
                  return this.privDetailedSpeechPhrase.RecognitionStatus;
              }
              get NBest() {
                  return this.privDetailedSpeechPhrase.NBest;
              }
              get Duration() {
                  return this.privDetailedSpeechPhrase.Duration;
              }
              get Offset() {
                  return this.privDetailedSpeechPhrase.Offset;
              }
              get Language() {
                  return void 0 === this.privDetailedSpeechPhrase.PrimaryLanguage ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
              }
              get LanguageDetectionConfidence() {
                  return void 0 === this.privDetailedSpeechPhrase.PrimaryLanguage ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
              }
              get Text() {
                  return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
              }
              get SpeakerId() {
                  return this.privDetailedSpeechPhrase.SpeakerId;
              }
          }
          var SpeechServiceRecognizer_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class SpeechServiceRecognizer extends ServiceRecognizerBase {
              constructor(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer) {
                  if (super(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer), 
                  this.privSpeechRecognizer = speechRecognizer, void 0 !== recognizerConfig.autoDetectSourceLanguages) {
                      const sourceLanguages = recognizerConfig.autoDetectSourceLanguages.split(",");
                      this.privSpeechContext.setSection("languageId", {
                          Priority: recognizerConfig.languageIdPriority,
                          languages: sourceLanguages,
                          mode: recognizerConfig.languageIdMode,
                          onSuccess: {
                              action: "Recognize"
                          },
                          onUnknown: {
                              action: "None"
                          }
                      }), this.privSpeechContext.setSection("phraseOutput", {
                          interimResults: {
                              resultType: "Auto"
                          },
                          phraseResults: {
                              resultType: "Always"
                          }
                      });
                      const customModels = recognizerConfig.sourceLanguageModels;
                      void 0 !== customModels && this.privSpeechContext.setSection("phraseDetection", {
                          customModels,
                          onInterim: {
                              action: "None"
                          },
                          onSuccess: {
                              action: "None"
                          }
                      });
                  }
              }
              processTypeSpecificMessages(connectionMessage) {
                  return SpeechServiceRecognizer_awaiter(this, void 0, void 0, (function*() {
                      let result;
                      const resultProps = new PropertyCollection;
                      resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
                      let processed = !1;
                      switch (connectionMessage.path.toLowerCase()) {
                        case "speech.hypothesis":
                        case "speech.fragment":
                          const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody), offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;
                          result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, void 0, void 0, connectionMessage.textBody, resultProps), 
                          this.privRequestSession.onHypothesis(offset);
                          const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
                          if (this.privSpeechRecognizer.recognizing) try {
                              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, ev);
                          } catch (error) {}
                          processed = !0;
                          break;

                        case "speech.phrase":
                          const simple = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody), resultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
                          if (this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration), 
                          ResultReason.Canceled === resultReason) {
                              const cancelReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus), cancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
                              yield this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
                          } else {
                              if (!this.privRequestSession.isSpeechEnded || resultReason !== ResultReason.NoMatch || simple.RecognitionStatus === RecognitionStatus.InitialSilenceTimeout) {
                                  if (this.privRecognizerConfig.parameters.getProperty("OutputFormat") === OutputFormat[OutputFormat.Simple]) result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset + this.privRequestSession.currentTurnAudioOffset, simple.Language, simple.LanguageDetectionConfidence, void 0, void 0, connectionMessage.textBody, resultProps); else {
                                      const detailed = DetailedSpeechPhrase.fromJSON(connectionMessage.textBody), totalOffset = detailed.Offset + this.privRequestSession.currentTurnAudioOffset, offsetCorrectedJson = detailed.getJsonWithCorrectedOffsets(totalOffset);
                                      result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === RecognitionStatus.Success ? detailed.NBest[0].Display : void 0, detailed.Duration, totalOffset, detailed.Language, detailed.LanguageDetectionConfidence, void 0, void 0, offsetCorrectedJson, resultProps);
                                  }
                                  const event = new SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
                                  if (this.privSpeechRecognizer.recognized) try {
                                      this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, event);
                                  } catch (error) {}
                              }
                              if (this.privSuccessCallback) {
                                  try {
                                      this.privSuccessCallback(result);
                                  } catch (e) {
                                      this.privErrorCallback && this.privErrorCallback(e);
                                  }
                                  this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                              }
                          }
                          processed = !0;
                      }
                      return processed;
                  }));
              }
              cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
                  const properties = new PropertyCollection;
                  if (properties.setProperty("CancellationErrorCode", CancellationErrorCode[errorCode]), 
                  this.privSpeechRecognizer.canceled) {
                      const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, void 0, sessionId);
                      try {
                          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, cancelEvent);
                      } catch (_a) {}
                  }
                  if (this.privSuccessCallback) {
                      const result = new SpeechRecognitionResult(requestId, ResultReason.Canceled, void 0, void 0, void 0, void 0, void 0, void 0, error, void 0, properties);
                      try {
                          this.privSuccessCallback(result), this.privSuccessCallback = void 0;
                      } catch (_b) {}
                  }
              }
          }
          class AuthInfo {
              constructor(headerName, token) {
                  this.privHeaderName = headerName, this.privToken = token;
              }
              get headerName() {
                  return this.privHeaderName;
              }
              get token() {
                  return this.privToken;
              }
          }
          class CognitiveSubscriptionKeyAuthentication {
              constructor(subscriptionKey) {
                  if (!subscriptionKey) throw new ArgumentNullError("subscriptionKey");
                  this.privAuthInfo = new AuthInfo(HeaderNames.AuthKey, subscriptionKey);
              }
              fetch(authFetchEventId) {
                  return Promise.resolve(this.privAuthInfo);
              }
              fetchOnExpiry(authFetchEventId) {
                  return Promise.resolve(this.privAuthInfo);
              }
          }
          class CognitiveTokenAuthentication {
              constructor(fetchCallback, fetchOnExpiryCallback) {
                  if (!fetchCallback) throw new ArgumentNullError("fetchCallback");
                  if (!fetchOnExpiryCallback) throw new ArgumentNullError("fetchOnExpiryCallback");
                  this.privFetchCallback = fetchCallback, this.privFetchOnExpiryCallback = fetchOnExpiryCallback;
              }
              fetch(authFetchEventId) {
                  return this.privFetchCallback(authFetchEventId).then((token => new AuthInfo("Authorization", CognitiveTokenAuthentication.privTokenPrefix + token)));
              }
              fetchOnExpiry(authFetchEventId) {
                  return this.privFetchOnExpiryCallback(authFetchEventId).then((token => new AuthInfo("Authorization", CognitiveTokenAuthentication.privTokenPrefix + token)));
              }
          }
          CognitiveTokenAuthentication.privTokenPrefix = "bearer ";
          var Recognizer_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class Recognizer {
              constructor(audioConfig, properties, connectionFactory) {
                  this.audioConfig = void 0 !== audioConfig ? audioConfig : AudioConfig.fromDefaultMicrophoneInput(), 
                  this.privDisposed = !1, this.privProperties = properties.clone(), this.privConnectionFactory = connectionFactory, 
                  this.implCommonRecognizerSetup();
              }
              close(cb, errorCb) {
                  Contracts.throwIfDisposed(this.privDisposed), marshalPromiseToCallbacks(this.dispose(!0), cb, errorCb);
              }
              get internalData() {
                  return this.privReco;
              }
              dispose(disposing) {
                  return Recognizer_awaiter(this, void 0, void 0, (function*() {
                      this.privDisposed || (this.privDisposed = !0, disposing && this.privReco && (yield this.privReco.audioSource.turnOff(), 
                      yield this.privReco.dispose()));
                  }));
              }
              static get telemetryEnabled() {
                  return ServiceRecognizerBase.telemetryDataEnabled;
              }
              static enableTelemetry(enabled) {
                  ServiceRecognizerBase.telemetryDataEnabled = enabled;
              }
              implCommonRecognizerSetup() {
                  let osPlatform = "undefined" != typeof window ? "Browser" : "Node", osName = "unknown", osVersion = "unknown";
                  "undefined" != typeof navigator && (osPlatform = osPlatform + "/" + navigator.platform, 
                  osName = navigator.userAgent, osVersion = navigator.appVersion);
                  const recognizerConfig = this.createRecognizerConfig(new SpeechServiceConfig(new RecognizerConfig_Context(new OS(osPlatform, osName, osVersion))));
                  this.privReco = this.createServiceRecognizer(Recognizer.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, recognizerConfig);
              }
              recognizeOnceAsyncImpl(recognitionMode) {
                  return Recognizer_awaiter(this, void 0, void 0, (function*() {
                      Contracts.throwIfDisposed(this.privDisposed);
                      const ret = new Deferred;
                      yield this.implRecognizerStop(), yield this.privReco.recognize(recognitionMode, ret.resolve, ret.reject);
                      const result = yield ret.promise;
                      return yield this.implRecognizerStop(), result;
                  }));
              }
              startContinuousRecognitionAsyncImpl(recognitionMode) {
                  return Recognizer_awaiter(this, void 0, void 0, (function*() {
                      Contracts.throwIfDisposed(this.privDisposed), yield this.implRecognizerStop(), yield this.privReco.recognize(recognitionMode, void 0, void 0);
                  }));
              }
              stopContinuousRecognitionAsyncImpl() {
                  return Recognizer_awaiter(this, void 0, void 0, (function*() {
                      Contracts.throwIfDisposed(this.privDisposed), yield this.implRecognizerStop();
                  }));
              }
              implRecognizerStop() {
                  return Recognizer_awaiter(this, void 0, void 0, (function*() {
                      this.privReco && (yield this.privReco.stopRecognizing());
                  }));
              }
              static getAuthFromProperties(properties) {
                  const subscriptionKey = properties.getProperty(PropertyId.SpeechServiceConnection_Key, void 0);
                  return subscriptionKey && "" !== subscriptionKey ? new CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new CognitiveTokenAuthentication((() => {
                      const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, void 0);
                      return Promise.resolve(authorizationToken);
                  }), (() => {
                      const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, void 0);
                      return Promise.resolve(authorizationToken);
                  }));
              }
          }
          var SpeechRecognizer_awaiter = function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))((function(resolve, reject) {
                  function fulfilled(value) {
                      try {
                          step(generator.next(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function rejected(value) {
                      try {
                          step(generator.throw(value));
                      } catch (e) {
                          reject(e);
                      }
                  }
                  function step(result) {
                      var value;
                      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P((function(resolve) {
                          resolve(value);
                      }))).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
              }));
          };
          class SpeechRecognizer extends Recognizer {
              constructor(speechConfig, audioConfig) {
                  const speechConfigImpl = speechConfig;
                  Contracts.throwIfNull(speechConfigImpl, "speechConfig"), Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage), PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]), 
                  super(audioConfig, speechConfigImpl.properties, new SpeechConnectionFactory), this.privDisposedRecognizer = !1;
              }
              static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
                  const speechConfigImpl = speechConfig;
                  autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
                  return new SpeechRecognizer(speechConfig, audioConfig);
              }
              get endpointId() {
                  return Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
              }
              get authorizationToken() {
                  return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);
              }
              set authorizationToken(token) {
                  Contracts.throwIfNullOrWhitespace(token, "token"), this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, token);
              }
              get speechRecognitionLanguage() {
                  return Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);
              }
              get outputFormat() {
                  return Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty("OutputFormat", OutputFormat[OutputFormat.Simple]) === OutputFormat[OutputFormat.Simple] ? OutputFormat.Simple : OutputFormat.Detailed;
              }
              get properties() {
                  return this.privProperties;
              }
              recognizeOnceAsync(cb, err) {
                  marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(RecognitionMode.Interactive), cb, err);
              }
              startContinuousRecognitionAsync(cb, err) {
                  marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);
              }
              stopContinuousRecognitionAsync(cb, err) {
                  marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
              }
              startKeywordRecognitionAsync(model, cb, err) {
                  Contracts.throwIfNull(model, "model"), err && err("Not yet implemented.");
              }
              stopKeywordRecognitionAsync(cb) {
                  cb && cb();
              }
              close(cb, errorCb) {
                  Contracts.throwIfDisposed(this.privDisposedRecognizer), marshalPromiseToCallbacks(this.dispose(!0), cb, errorCb);
              }
              dispose(disposing) {
                  const _super = Object.create(null, {
                      dispose: {
                          get: () => super.dispose
                      }
                  });
                  return SpeechRecognizer_awaiter(this, void 0, void 0, (function*() {
                      this.privDisposedRecognizer || (disposing && (this.privDisposedRecognizer = !0, 
                      yield this.implRecognizerStop()), yield _super.dispose.call(this, disposing));
                  }));
              }
              createRecognizerConfig(speechConfig) {
                  return new RecognizerConfig(speechConfig, this.properties);
              }
              createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
                  return new SpeechServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig, this);
              }
          }
          const useSpeechRecognition = ({stream, bizId, name, index, onReceived, onSpeechEnd}) => {
              const stopSpeechCount = (0, react.useRef)(0), statusRef = (0, react.useRef)(!1), sessionRef = (0, 
              react.useRef)(!1), recognizerRef = (0, react.useRef)(null), timeStampRef = (0, react.useRef)(Date.now()), currentResultIdRef = (0, 
              react.useRef)(index ? `${Date.now()}_${index}` : Date.now().toString()), [speechText, setSpeechText] = (0, 
              react.useState)({
                  st: Date.now(),
                  text: "",
                  lang: "",
                  state: !1
              }), getToken = (0, react.useCallback)((async () => {
                  if (!bizId) return null;
                  try {
                      return await async function() {
                          return content_script_sendMessage("get-ms-token", null, "background");
                      }();
                  } catch (error) {
                      return console.log("getMSToken", error), null;
                  }
              }), [ bizId ]), initSpeech = (0, react.useCallback)((async () => {
                  console.log("!!** startSpeech: initSpeech", "2", name);
                  const token = await getToken();
                  if (console.log("%cIceg-Logger >> @@speech", "color: white; background: green;", token, stream), 
                  !token || !1 === statusRef.current) return console.log("!!** startSpeech: status return", statusRef.current), 
                  void (sessionRef.current = !1);
                  const speechConfig = SpeechConfig.fromAuthorizationToken(token.third_token, "japaneast");
                  speechConfig.setProperty("SpeechServiceResponse_PostProcessingOption", "TrueText"), 
                  speechConfig.setProperty("SpeechServiceResponse_ProfanityOption", "Raw"), speechConfig.setProperty("SpeechServiceConnection_SpeakerIdMode", "TrueText"), 
                  speechConfig.setProperty("ConversationTranscriptionInRoomAndOnline", "TrueText"), 
                  speechConfig.setProperty("DifferentiateGuestSpeakers", "TrueText");
                  const autoDetectSourceLanguageConfig = token.language_endpoints ? AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs(token.language_endpoints.map((item => SourceLanguageConfig.fromLanguage(item.lang, item.endpoint || void 0)))) : AutoDetectSourceLanguageConfig.fromLanguages([ "en-US", "ja-JP", "zh-CN", "de-DE", "fr-FR", "es-ES", "ru-RU", "ko-KR", "pt-PT", "hi-IN" ]);
                  autoDetectSourceLanguageConfig.mode = LanguageIdMode.Continuous, console.log("## speech change audio stream", stream);
                  const audioConfig = stream ? AudioConfig.fromStreamInput(stream) : AudioConfig.fromDefaultMicrophoneInput(), recognizer = SpeechRecognizer.FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig);
                  return recognizer.recognizing = (_s, e) => {
                      e.result.text && onReceived?.({
                          json: e.result.json,
                          sourceLang: e.result.language,
                          resultId: currentResultIdRef.current
                      });
                  }, recognizer.recognized = (_s, e) => {
                      trackEvent({
                          event_type: "TranslateSubtitle",
                          trigger_type: "Automatic",
                          trigger_control: "Recognized"
                      }), e.result.text && onReceived?.({
                          json: e.result.json,
                          sourceLang: e.result.language,
                          resultId: currentResultIdRef.current
                      }), currentResultIdRef.current = index ? `${Date.now()}_${index}` : Date.now().toString();
                  }, recognizer.canceled = async (_s, e) => {
                      if (sentry.captureException(new Error(`SPEECH: Canceled ${e.reason} ${e.errorDetails}`)), 
                      console.log(`##speech CANCELED: Reason=${e.reason} ${e.errorDetails}`), statusRef.current) {
                          await stopSpeech(), statusRef.current = !0, sessionRef.current = !1, initSpeech();
                          const timer = setInterval((() => {
                              statusRef.current && sessionRef.current ? clearInterval(timer) : initSpeech();
                          }), 5e3);
                      }
                  }, recognizer.speechStartDetected = async _s => {
                      console.log("!!** start speech detected");
                  }, recognizer.speechEndDetected = async _s => {
                      stopSpeechCount.current = stopSpeechCount.current + 1, console.log("!!** end speech detected"), 
                      2 === stopSpeechCount.current && onSpeechEnd?.();
                  }, recognizer.sessionStarted = async _s => {
                      sentry.captureException(new Error("SPEECH: start  session")), console.log("!!** start speech session"), 
                      sessionRef.current = !0;
                  }, recognizer.sessionStopped = async (_s, e) => {
                      if (sessionRef.current = !1, !recognizerRef.current) return;
                      console.log("!!** stop speech session"), sentry.captureException(new Error("SPEECH: stop session")), 
                      sessionRef.current = !1;
                      const token = await getToken();
                      recognizerRef.current && token && (recognizerRef.current.authorizationToken = token.third_token), 
                      console.log("##speech Session stopped.", e.sessionId);
                  }, recognizerRef.current = recognizer, () => {
                      recognizer.close(), statusRef.current = !1, console.log("!!** startSpeech: status return", statusRef.current), 
                      recognizerRef.current = null;
                  };
              }), [ getToken, stream ]), stopSpeech = (0, react.useCallback)((() => new Promise(((resolve, reject) => {
                  console.log("**** stopSpeech: status 1", statusRef.current), statusRef.current = !1, 
                  tokenTimer.current && (clearInterval(tokenTimer.current), tokenTimer.current = void 0), 
                  recognizerRef.current && recognizerRef.current.stopContinuousRecognitionAsync((() => {
                      resolve(0);
                  }), (err => {
                      reject(err), console.error(`Failed to stop recognition: ${err}`);
                  }));
              }))), []), tokenTimer = (0, react.useRef)(), startSpeech = (0, react.useCallback)((async () => {
                  statusRef.current = !0, console.log("!!** startSpeech: status 1", statusRef.current), 
                  console.log("!!** startSpeech", "1"), recognizerRef.current || await initSpeech(), 
                  tokenTimer.current && (clearInterval(tokenTimer.current), tokenTimer.current = void 0), 
                  stopSpeech().finally((() => {
                      statusRef.current = !0, tokenTimer.current = setInterval((async () => {
                          console.log("!!** startSpeech: status 3", statusRef.current);
                          const token = await getToken();
                          recognizerRef.current && token && (recognizerRef.current.authorizationToken = token.third_token);
                      }), 6e5), recognizerRef.current && recognizerRef.current.startContinuousRecognitionAsync((() => {
                          timeStampRef.current = Date.now(), trackEvent({
                              event_type: "TranslateSubtitle",
                              trigger_type: "Automatic",
                              trigger_control: "RecongnizeStart"
                          });
                      }), (err => {
                          console.error(`Failed to start recognition: ${err}`);
                      }));
                  }));
              }), [ getToken, initSpeech, stopSpeech ]), closeSpeech = (0, react.useCallback)((() => {
                  console.log("!!** closeSpeech: status 1", statusRef.current), statusRef.current = !1, 
                  recognizerRef.current && (recognizerRef.current.stopContinuousRecognitionAsync((() => {
                      trackEvent({
                          event_type: "TranslateSubtitle",
                          trigger_type: "Automatic",
                          trigger_control: "RecongnizeStop"
                      });
                  }), (err => {
                      console.log("!!** close4", name), console.error(`Failed to stop recognition: ${err}`);
                  })), recognizerRef.current.close(), recognizerRef.current = null, stopSpeechCount.current = 0);
              }), []);
              return {
                  initSpeech,
                  startSpeech,
                  stopSpeech,
                  speechText,
                  clearSpeech: () => {
                      setSpeechText((tx => ({
                          ...tx,
                          text: ""
                      })));
                  },
                  closeSpeech
              };
          };
          var _div;
          const stopListen = () => {
              window.dispatchEvent(new CustomEvent("subtitle::yt-playing-listen", {
                  detail: {
                      type: "stop"
                  },
                  bubbles: !0
              }));
          };
          async function getLocalSubtitle() {
              const videoId = new URLSearchParams(window.location.search).get("v");
              if (!videoId) return {
                  rawTranscript: []
              };
              const transcriptLangOptionsWithLink = await async function(videoId) {
                  const timestampInSeconds = Math.floor(Date.now() / 1e3) + 1800, videoPageResponse = await fetch(`https://www.youtube.com/watch?v=${videoId}&bpctr=${timestampInSeconds}`), splittedHtml = (await videoPageResponse.text()).split('"captions":');
                  return splittedHtml.length < 2 ? [] : JSON.parse(splittedHtml[1].split(',"videoDetails')[0].replace("\n", "")).playerCaptionsTracklistRenderer.captionTracks.map((i => ({
                      language: i.name.simpleText,
                      link: i.baseUrl,
                      languageCode: i.languageCode
                  }))).sort((x => "en" === langFormator[x?.languageCode] ? -1 : 0));
              }(videoId);
              if (0 === transcriptLangOptionsWithLink.length) return {
                  rawTranscript: [],
                  lang: "en"
              };
              if (![ "zh-Hans", "zh-Hant", "zh-CN", "zh-TW", "zh-HK", "zh", "ja", "ko", "th", "en-US", "en" ].includes(transcriptLangOptionsWithLink[0]?.languageCode || "no-lang")) return {
                  rawTranscript: [],
                  lang: "en"
              };
              const {rawTranscript, lang} = await getConverTranscript({
                  transcriptLangOptionsWithLink
              });
              return {
                  rawTranscript,
                  lang
              };
          }
          const subtitleDom = ({bizId}) => {
              const mqttConnected = useMqttStatus(), mediaStreamRef = (0, react.useRef)(new MediaStream), {startSpeech, stopSpeech, closeSpeech} = useSpeechRecognition({
                  stream: mediaStreamRef.current,
                  bizId,
                  onReceived: msg => {
                      const {translateLang} = userConfig.getState().config;
                      stores_mqtt.getState().sendSubtitle(msg.json, msg.sourceLang, translateLang, "", void 0, msg.resultId);
                  },
                  onSpeechEnd: () => {
                      "hidden" === document.visibilityState && console.log("onStopSpeech & visibilityState hidden");
                  }
              }), isClose = (0, react.useRef)(!1), statusRef = (0, react.useRef)({
                  load: !1,
                  isLocalSubtitle: !1
              }), clearListenerRef = (0, react.useRef)((() => {})), currentIndexRef = (0, react.useRef)(-10), sendLocalSubtitle = (0, 
              react.useCallback)(((subtitleList, subLang) => {
                  let currentIndex = -1;
                  const tempDiv = document.createElement("div"), eventHandlerFn = ev => {
                      if (isClose.current) return;
                      if (!appConfig.getState().canTranscribe) return;
                      const {detail: {time: currentTime}} = ev, currentSubtitle = -1 === currentIndex ? {
                          start: -1,
                          duration: 0,
                          text: ""
                      } : subtitleList[currentIndex], nextSubtitle = subtitleList[currentIndex + 1];
                      if (currentSubtitle.start <= currentTime && nextSubtitle.start > currentTime) return;
                      let index = 0;
                      for (;index < subtitleList.length && Number(subtitleList[index].start) < currentTime; ) ++index;
                      const newCurrentSubtitle = subtitleList[index - 1];
                      if (currentIndex = index - 1, tempDiv.innerHTML = newCurrentSubtitle?.text || "", 
                      !stores_mqtt.getState().status) return void window.removeEventListener("subtitle::yt-playing-result", eventHandlerFn);
                      if (currentIndexRef.current === currentIndex) return;
                      currentIndexRef.current = currentIndex;
                      const {translateLang} = userConfig.getState().config, item = {
                          st: `st:${Date.now()}`,
                          text: tempDiv.textContent || "",
                          lang: subLang || "en",
                          translateText: "",
                          translateLang,
                          isComplete: !1
                      }, json = JSON.stringify({
                          originalText: item.text,
                          resultId: item.st,
                          isComplete: !0,
                          RecognitionStatus: "Success"
                      }), {sendSubtitle} = stores_mqtt.getState();
                      langFormator[item.lang] === translateLang || subtitle.getState().addMessage(item), 
                      sendSubtitle(json, item.lang, translateLang, "Youtube-Local", "GOOGLE");
                  };
                  console.log("addEventListener subtitle::yt-playing-result"), window.addEventListener("subtitle::yt-playing-result", eventHandlerFn), 
                  clearListenerRef.current = () => {
                      window.removeEventListener("subtitle::yt-playing-result", eventHandlerFn), console.log("removeEventListener subtitle::yt-playing-result"), 
                      stopListen();
                  };
              }), []);
              return (0, react.useEffect)((() => {
                  let isCanceled = !1;
                  isClose.current = !1;
                  return (async () => {
                      statusRef.current = {
                          load: !0,
                          isLocalSubtitle: !1
                      };
                      const video = document.querySelector("video"), audioTracks = await async function(video) {
                          return new Promise((resolve => {
                              if (video && video.src.length > 0) {
                                  const timer = setInterval((() => {
                                      const newVideo = document.querySelector("video"), mediaStream = newVideo?.captureStream(), audioTracks = mediaStream.getAudioTracks();
                                      console.log("!! setInterval", video, newVideo, audioTracks), audioTracks.length > 0 && (clearInterval(timer), 
                                      resolve(audioTracks));
                                  }), 200);
                              } else resolve([]);
                          }));
                      }(video);
                      if (audioTracks.length > 0 && mqttConnected) {
                          mediaStreamRef.current.addTrack(audioTracks[0]);
                          const tracks = mediaStreamRef.current.getTracks();
                          tracks.length > 1 && mediaStreamRef.current.removeTrack(tracks[0]), console.log("!! tracks", tracks), 
                          video.addEventListener("ended", (() => {
                              stopSpeech(), closeSpeech();
                          }));
                          const {rawTranscript, lang} = await getLocalSubtitle();
                          if (isClose.current) return void (statusRef.current = {
                              load: !1,
                              isLocalSubtitle: !1
                          });
                          rawTranscript.length > 0 ? (appConfig.getState().setHasExistSubtitles(!0), console.log("rawTranscript", rawTranscript), 
                          sendLocalSubtitle(rawTranscript, lang), window.dispatchEvent(new CustomEvent("subtitle::yt-playing-listen", {
                              detail: {
                                  type: "start"
                              },
                              bubbles: !0
                          }))) : isCanceled || startSpeech(), statusRef.current = {
                              load: !1,
                              isLocalSubtitle: rawTranscript.length > 0
                          };
                      } else clearListenerRef.current(), closeSpeech(), stopListen(), console.log("stopListen else"), 
                      statusRef.current = {
                          load: !1,
                          isLocalSubtitle: !1
                      };
                  })(), () => {
                      console.log("!! end --"), isClose.current = !0, isCanceled = !0, clearListenerRef.current();
                      const timer = setInterval((() => {
                          statusRef.current.load || (clearInterval(timer), !statusRef.current.isLocalSubtitle && isClose.current && (console.log("!! return close event close Speech"), 
                          closeSpeech()));
                      }), 50);
                  };
              }), [ mqttConnected ]), _div || (_div = (0, jsx_runtime.jsx)("div", {
                  className: "subtitle-dom"
              }));
          };
          function TranslateProvider({children}) {
              const bizId = useInfoStore((({bizId}) => bizId)), canTranscribe = useAppConfigStore((({canTranscribe}) => canTranscribe)), limited = useLimited(), MachineTran = onMsg => {
                  onMachineTranslationCallback = msg => {
                      onMsg("google-translate", JSON.stringify(msg));
                  };
              }, clientNext = useMqttStore((({client}) => client));
              return (0, react.useEffect)((() => {
                  const onMessage = (_, buffer) => {
                      if (!buffer) return;
                      const str = buffer instanceof Uint8Array ? buffer.toString() : buffer, result = JSON.parse(str);
                      if ("MEET_SUBTITLE_TRANSLATE_TEXT" === result.type) {
                          const {resultId, translateText, translateLang, isComplete, subtitleId} = result.data, index = subtitle.getState().messages.findIndex((item => item.st === resultId));
                          index > -1 && subtitle.getState().updateMessage({
                              translateText,
                              translateLang,
                              isComplete,
                              subtitleId
                          }, index), isComplete && trackEvent({
                              event_type: "Translate",
                              trigger_type: "Automatic",
                              trigger_control: "TranslateReceive",
                              event_id: resultId
                          });
                      }
                      if ("MEET_SUBTITLE_TEXT" === result.type) {
                          const {translateLang} = userConfig.getState().config, {resultId, originalText, originalLang, isComplete} = result.data, index = subtitle.getState().messages.findIndex((item => item.st === resultId));
                          index > -1 ? subtitle.getState().updateMessage({
                              text: originalText,
                              lang: originalLang,
                              isComplete: !!isComplete && originalLang === translateLang
                          }, index) : subtitle.getState().addMessage({
                              st: resultId,
                              text: originalText,
                              lang: originalLang,
                              translateText: originalLang === translateLang ? void 0 : "",
                              isComplete
                          });
                      }
                      if ("MEET_SUBTITLE_UPDATE" === result.type) {
                          const {originalText, translateLang, translateText, subtitleId} = result.data, index = subtitle.getState().messages.findIndex((item => item.subtitleId === subtitleId));
                          index > -1 && subtitle.getState().updateMessage({
                              text: originalText,
                              isComplete: !0,
                              translateLang,
                              translateText
                          }, index, !0);
                      }
                  };
                  clientNext?.client.on("message", onMessage), MachineTran(onMessage);
              }), [ clientNext ]), (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                  children: [ !canTranscribe || limited ? null : (0, jsx_runtime.jsx)("div", {
                      className: "avatars",
                      children: (0, jsx_runtime.jsx)(subtitleDom, {
                          bizId
                      }, "local")
                  }), children ]
              });
          }
          const isMobile = navigator.userAgent.toLocaleLowerCase().includes("mobi"), eventName = {
              up: isMobile ? "touchend" : "mouseup",
              down: isMobile ? "touchstart" : "mousedown",
              move: isMobile ? "touchmove" : "mousemove"
          };
          class Panel {
              constructor({wrapper: _wrapper, overlay: _overlay, resizer: _resizer, events, canDrag}) {
                  defineProperty_defineProperty(this, "obj", {
                      wrapper: void 0,
                      overlay: void 0,
                      resizer: void 0
                  }), defineProperty_defineProperty(this, "events", {}), defineProperty_defineProperty(this, "state", {
                      draggable: !1,
                      resizeable: !1,
                      location: {
                          x: -1,
                          y: -1
                      },
                      translate: {
                          x: -1,
                          y: -1
                      },
                      size: {
                          width: -1,
                          height: -1
                      }
                  }), defineProperty_defineProperty(this, "canDrag", void 0), defineProperty_defineProperty(this, "destroy", (() => {
                      this.wrapperMove.destroy(), this.wrapperResize.destroy(), this.windowResizeCheck.destroy();
                  })), defineProperty_defineProperty(this, "setPosition", ((x, y) => {
                      const {wrapper} = this.obj;
                      wrapper && (this.state.translate.x = x, this.state.translate.y = y, wrapper.style.transform = `translate(${x}px, ${y}px)`);
                  })), defineProperty_defineProperty(this, "setSize", ((w, h) => {
                      const {wrapper} = this.obj;
                      wrapper && (w && (this.state.size.width = w, wrapper.style.width = `${w}px`), h && (this.state.size.height = h, 
                      wrapper.style.height = `${h}px`));
                  })), defineProperty_defineProperty(this, "staticToFixed", (props => {
                      if (!this.obj.wrapper) return;
                      this.state.draggable = !0;
                      const offset = {
                          x: 0,
                          y: 0,
                          width: 0,
                          height: 0,
                          ...props.offset
                      }, {wrapper} = this.obj, {size, translate} = this.state;
                      if (!(props.usingPrevSets && (size.width > -1 || size.height > -1) && (translate.x > -1 || translate.y > -1))) {
                          const w = props.size?.width || wrapper.clientWidth + offset.width, h = props.size?.height || wrapper.clientHeight + offset.height;
                          this.setSize(w, h);
                          const {top, left} = wrapper.getBoundingClientRect(), x = props.position?.x ?? left + offset.x, y = props.position?.y ?? top + offset.y;
                          this.setPosition(x, y);
                      }
                      this.fixPositionAndSize(), wrapper.classList.add("draggable"), wrapper.style.top = "0", 
                      wrapper.style.left = "0", wrapper.style.position = "fixed";
                  })), defineProperty_defineProperty(this, "fixedToStatic", (() => {
                      if (!this.obj.wrapper) return;
                      this.state.draggable = !1;
                      const {wrapper} = this.obj;
                      wrapper.classList.remove("draggable"), wrapper.style.top = "", wrapper.style.left = "", 
                      wrapper.style.width = "", wrapper.style.height = "", wrapper.style.position = "", 
                      wrapper.style.transform = "";
                  })), defineProperty_defineProperty(this, "toggle", (props => {
                      this.state.draggable ? this.fixedToStatic() : this.staticToFixed(props);
                  })), defineProperty_defineProperty(this, "fixPositionAndSize", (() => {
                      const {size, translate} = this.state;
                      let x = translate.x, y = translate.y, w = size.width, h = size.height;
                      w >= window.innerWidth && (w = window.innerWidth), h >= window.innerHeight && (h = window.innerHeight), 
                      x + w >= window.innerWidth && (x = window.innerWidth - w), y + h >= window.innerHeight && (y = window.innerHeight - h), 
                      this.setPosition(x, y), this.setSize(w, h);
                  })), defineProperty_defineProperty(this, "getPointerPosition", (ev => {
                      let x = 0, y = 0;
                      return "touches" in ev ? (x = ev.touches[0].clientX, y = ev.touches[0].clientY) : (x = ev.clientX, 
                      y = ev.clientY), [ x, y ];
                  })), defineProperty_defineProperty(this, "wrapperMove", {
                      init: () => {
                          const {wrapper, overlay} = this.obj;
                          wrapper && overlay && wrapper.addEventListener(eventName.down, this.wrapperMove.onDown);
                      },
                      destroy: () => {
                          const {wrapper, overlay} = this.obj;
                          wrapper && overlay && wrapper.removeEventListener(eventName.down, this.wrapperMove.onDown);
                      },
                      onUp: () => {
                          const {wrapper, overlay} = this.obj;
                          wrapper && overlay && (wrapper.style.userSelect = "", overlay.classList.remove("active"), 
                          document.removeEventListener(eventName.move, this.wrapperMove.onMove), document.removeEventListener(eventName.up, this.wrapperMove.onUp), 
                          this.events.onMoveEnd?.());
                      },
                      onDown: e => {
                          const ev = e, {wrapper, overlay} = this.obj;
                          if (!wrapper || !overlay) return;
                          if (!this.state.draggable) return;
                          if (this.canDrag) {
                              if (!this.canDrag(ev.target)) return;
                          } else if (ev.target !== wrapper) return;
                          ev.preventDefault(), wrapper.style.userSelect = "none", overlay.classList.add("active");
                          const [x, y] = this.getPointerPosition(ev);
                          this.state.location.x = x - this.state.translate.x, this.state.location.y = y - this.state.translate.y, 
                          document.addEventListener(eventName.move, this.wrapperMove.onMove), document.addEventListener(eventName.up, this.wrapperMove.onUp);
                      },
                      onMove: e => {
                          const ev = e, {wrapper} = this.obj;
                          wrapper && window.requestAnimationFrame((() => {
                              if (!this.state.draggable) return;
                              let [x, y] = this.getPointerPosition(ev);
                              x -= this.state.location.x, y -= this.state.location.y, x <= 0 && (x = 0), y <= 0 && (y = 0);
                              const maxX = window.innerWidth - wrapper.clientWidth, maxY = window.innerHeight - wrapper.clientHeight;
                              x >= maxX && (x = maxX), y >= maxY && (y = maxY), this.setPosition(x, y);
                          }));
                      }
                  }), defineProperty_defineProperty(this, "windowResizeCheck", {
                      onResizeFrame: () => {
                          this.obj.wrapper && this.state.draggable && this.fixPositionAndSize();
                      },
                      onResize: () => {
                          window.requestAnimationFrame(this.windowResizeCheck.onResizeFrame);
                      },
                      init: () => {
                          window.addEventListener("resize", this.windowResizeCheck.onResize);
                      },
                      destroy: () => {
                          window.removeEventListener("resize", this.windowResizeCheck.onResize);
                      }
                  }), defineProperty_defineProperty(this, "wrapperResize", {
                      minSize: {
                          width: 0,
                          height: 0
                      },
                      prevSize: {
                          width: 0,
                          height: 0
                      },
                      prevPosition: {
                          x: -1,
                          y: -1
                      },
                      pointer: {
                          x: -1,
                          y: -1
                      },
                      direction: [],
                      getDirection: className => className.includes("-tl") ? [ "top", "left" ] : className.includes("-tr") ? [ "top", "right" ] : className.includes("-bl") ? [ "bottom", "left" ] : className.includes("-br") ? [ "bottom", "right" ] : className.includes("-t") ? [ "top" ] : className.includes("-l") ? [ void 0, "left" ] : className.includes("-b") ? [ "bottom" ] : className.includes("-r") ? [ void 0, "right" ] : [],
                      checkIsPlus: direction => "top" === direction[0] && "left" === direction[1] || void 0 === direction[0] && "left" === direction[1] || "top" === direction[0] && void 0 === direction[1] ? [ !1, !1 ] : "top" === direction[0] && "right" === direction[1] ? [ !0, !1 ] : "bottom" === direction[0] && "left" === direction[1] ? [ !1, !0 ] : [ !0, !0 ],
                      init: () => {
                          const {resizer} = this.obj;
                          resizer && this.state.resizeable && (resizer.innerHTML = '<span class="resizer-vertical resizer-t"></span>\n        <span class="resizer-horizontal resizer-l"></span>\n        <span class="resizer-vertical resizer-b"></span>\n        <span class="resizer-horizontal resizer-r"></span>\n        <span class="resizer-corner resizer-tl"></span>\n        <span class="resizer-corner resizer-tr"></span>\n        <span class="resizer-corner resizer-bl"></span>\n        <span class="resizer-corner resizer-br"></span>\n      ', 
                          resizer.addEventListener(eventName.down, this.wrapperResize.onDown));
                      },
                      destroy: () => {
                          const {resizer} = this.obj;
                          resizer && this.state.resizeable && resizer.removeEventListener(eventName.down, this.wrapperResize.onDown);
                      },
                      onUp: () => {
                          const {overlay} = this.obj;
                          overlay && (overlay.classList.remove("active"), document.removeEventListener(eventName.up, this.wrapperResize.onUp), 
                          document.removeEventListener(eventName.move, this.wrapperResize.onMove), this.events.onResizeEnd?.());
                      },
                      onDown: e => {
                          const ev = e, {wrapper, overlay} = this.obj;
                          if (!wrapper || !overlay) return;
                          ev.stopPropagation(), ev.preventDefault(), overlay.classList.add("active");
                          const self = this.wrapperResize;
                          this.state.draggable ? (self.prevSize.height = this.state.size.height, self.prevSize.width = this.state.size.width, 
                          self.prevPosition.x = this.state.translate.x, self.prevPosition.y = this.state.translate.y) : (self.prevSize.height = wrapper.offsetHeight, 
                          self.prevSize.width = wrapper.offsetWidth);
                          const target = ev.target;
                          self.direction = self.getDirection(target.className);
                          const [x, y] = this.getPointerPosition(ev);
                          self.pointer.x = x, self.pointer.y = y, document.addEventListener(eventName.up, this.wrapperResize.onUp), 
                          document.addEventListener(eventName.move, this.wrapperResize.onMove);
                      },
                      onMove: e => {
                          const ev = e;
                          window.requestAnimationFrame((() => {
                              const {prevSize, pointer, prevPosition, direction, checkIsPlus, minSize} = this.wrapperResize, [x, y] = this.getPointerPosition(ev), offsetX = direction[0] && !direction[1] ? 0 : x - pointer.x, offsetY = direction[1] && !direction[0] ? 0 : y - pointer.y, isPlus = checkIsPlus(direction);
                              let maxW, maxH, w = isPlus[0] ? prevSize.width + offsetX : prevSize.width - offsetX, h = isPlus[1] ? prevSize.height + offsetY : prevSize.height - offsetY, minW = minSize.width, minH = minSize.height;
                              if (this.state.draggable) {
                                  const {translate} = this.state;
                                  maxW = isPlus[0] ? window.innerWidth - translate.x : prevPosition.x + prevSize.width, 
                                  maxH = isPlus[1] ? window.innerHeight - translate.y : prevPosition.y + prevSize.height;
                              } else maxW = window.innerWidth, maxH = window.innerHeight;
                              if (w <= minW ? w = minW : w >= maxW && (w = maxW), h <= minH ? h = minH : h >= maxH && (h = maxH), 
                              this.state.draggable) {
                                  let posX = prevPosition.x + (isPlus[0] ? 0 : offsetX), posY = prevPosition.y + (isPlus[1] ? 0 : offsetY);
                                  const maxPosX = prevPosition.x + prevSize.width - minW, maxPosY = prevPosition.y + prevSize.height - minH;
                                  posX < 0 && (posX = 0), posY < 0 && (posY = 0), w !== minW || isPlus[0] || (posX = maxPosX), 
                                  h !== minH || isPlus[1] || (posY = maxPosY), this.setPosition(posX, posY);
                              }
                              this.setSize(w, h);
                          }));
                      }
                  }), this.obj.wrapper = _wrapper, this.obj.overlay = _overlay, this.events = events || {}, 
                  _resizer && (this.obj.resizer = _resizer.el, this.state.resizeable = !0, _resizer.minSize && (this.wrapperResize.minSize = {
                      ...this.wrapperResize.minSize,
                      ..._resizer.minSize
                  })), canDrag && (this.canDrag = canDrag), this.wrapperMove.init(), this.wrapperResize.init(), 
                  this.windowResizeCheck.init();
              }
              get positionAndSize() {
                  return {
                      ...this.state.translate,
                      ...this.state.size
                  };
              }
          }
          const dragPanel_translate = function({onMouseEnter, onMouseLeave, children}) {
              const panelRef = (0, react.useRef)(), overlayRef = (0, react.useRef)(null), wrapperRef = (0, 
              react.useRef)(null), resizerRef = (0, react.useRef)(null);
              return (0, react.useLayoutEffect)((() => {
                  if (wrapperRef.current && overlayRef.current && resizerRef.current) return panelRef.current = new Panel({
                      wrapper: wrapperRef.current,
                      overlay: overlayRef.current,
                      resizer: {
                          el: resizerRef.current,
                          minSize: {
                              width: 400,
                              height: 250
                          }
                      },
                      events: {
                          onMoveEnd: () => {
                              if (panelRef.current) {
                                  const {x, y} = panelRef.current.positionAndSize;
                                  uiConfig.getState().setPosition("translate", {
                                      x,
                                      y
                                  });
                              }
                          },
                          onResizeEnd: () => {
                              if (panelRef.current) {
                                  const {width, height} = panelRef.current.positionAndSize;
                                  uiConfig.getState().setSize("translate", {
                                      width,
                                      height
                                  });
                              }
                          }
                      },
                      canDrag: target => "felo-header" === target.className
                  }), () => {
                      panelRef.current?.destroy();
                  };
              }), []), (0, react.useEffect)((() => {
                  const {position, size} = uiConfig.getState(), initialSets = function() {
                      const width = window.innerWidth > 850 ? 850 : window.innerWidth;
                      return {
                          x: Math.round((window.innerWidth - width) / 2),
                          y: window.innerHeight - 260 - 100,
                          width,
                          height: 260
                      };
                  }();
                  initialSets && panelRef.current?.staticToFixed({
                      position: {
                          x: position?.x ?? initialSets.x ?? void 0,
                          y: position?.y ?? initialSets.y ?? void 0
                      },
                      size: {
                          width: size?.width && size?.width > 0 ? size.width : initialSets.width ?? void 0,
                          height: size?.height && size.height > 0 ? size.height : initialSets.height ?? void 0
                      },
                      usingPrevSets: !0
                  });
              }), []), (0, jsx_runtime.jsxs)("div", {
                  onMouseEnter,
                  onMouseLeave,
                  children: [ (0, jsx_runtime.jsx)("div", {
                      ref: overlayRef,
                      className: "f-d-overlay"
                  }), (0, jsx_runtime.jsxs)("div", {
                      ref: wrapperRef,
                      className: "f-d-panel",
                      children: [ (0, jsx_runtime.jsx)("div", {
                          ref: resizerRef,
                          className: "f-d-resizer"
                      }), (0, jsx_runtime.jsx)("div", {
                          className: "f-d-body",
                          children
                      }) ]
                  }) ]
              });
          };
          function r(e) {
              var t, f, n = "";
              if ("string" == typeof e || "number" == typeof e) n += e; else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), 
              n += f); else for (t in e) e[t] && (n && (n += " "), n += t);
              return n;
          }
          const dist_clsx = function() {
              for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), 
              n += t);
              return n;
          }, inst_isMobile = navigator.userAgent.toLocaleLowerCase().includes("mobi"), inst_eventName = {
              up: inst_isMobile ? "touchend" : "mouseup",
              down: inst_isMobile ? "touchstart" : "mousedown",
              move: inst_isMobile ? "touchmove" : "mousemove"
          };
          class DragButton {
              constructor({wrapper: _wrapper, overlay: _overlay, initialY}) {
                  defineProperty_defineProperty(this, "obj", {
                      wrapper: void 0,
                      overlay: void 0
                  }), defineProperty_defineProperty(this, "state", {
                      prevMouseOnWrapY: -1,
                      prevWrapY: -1,
                      wrapY: -1
                  }), defineProperty_defineProperty(this, "isMoved", !1), defineProperty_defineProperty(this, "destroy", (() => {
                      this.wrapperMove.destroy(), this.windowResizeCheck.destroy();
                  })), defineProperty_defineProperty(this, "setPositionY", (y => {
                      const {wrapper} = this.obj;
                      wrapper && (this.state.wrapY = y, wrapper.style.transform = `translateY(${y}px)`);
                  })), defineProperty_defineProperty(this, "fixPositionAndSize", (() => {
                      if (!this.obj.wrapper) return;
                      let y = this.state.wrapY, h = this.obj.wrapper.clientHeight;
                      y + h >= window.innerHeight && (y = window.innerHeight - h), this.setPositionY(y);
                  })), defineProperty_defineProperty(this, "getPointerPosition", (ev => {
                      let y = 0;
                      return y = "touches" in ev ? ev.touches[0].clientY : ev.clientY, y;
                  })), defineProperty_defineProperty(this, "wrapperMove", {
                      init: () => {
                          const {wrapper, overlay} = this.obj;
                          wrapper && overlay && wrapper.addEventListener(inst_eventName.down, this.wrapperMove.onDown);
                      },
                      destroy: () => {
                          const {wrapper, overlay} = this.obj;
                          wrapper && overlay && wrapper.removeEventListener(inst_eventName.down, this.wrapperMove.onDown);
                      },
                      onUp: () => {
                          const {wrapper, overlay} = this.obj;
                          wrapper && overlay && (wrapper.style.userSelect = "", overlay.classList.remove("active"), 
                          document.removeEventListener(inst_eventName.move, this.wrapperMove.onMove), document.removeEventListener(inst_eventName.up, this.wrapperMove.onUp), 
                          this.isMoved = this.state.prevWrapY !== this.state.wrapY);
                      },
                      onDown: e => {
                          const ev = e, {wrapper, overlay} = this.obj;
                          if (!wrapper || !overlay) return;
                          ev.preventDefault(), wrapper.style.userSelect = "none", overlay.classList.add("active");
                          const y = this.getPointerPosition(ev);
                          this.state.prevMouseOnWrapY = y - this.state.wrapY, this.state.prevWrapY = this.state.wrapY, 
                          document.addEventListener(inst_eventName.move, this.wrapperMove.onMove), document.addEventListener(inst_eventName.up, this.wrapperMove.onUp), 
                          this.isMoved = !1;
                      },
                      onMove: e => {
                          const ev = e, {wrapper} = this.obj;
                          wrapper && window.requestAnimationFrame((() => {
                              let y = this.getPointerPosition(ev);
                              y -= this.state.prevMouseOnWrapY, y <= 0 && (y = 0);
                              const maxY = window.innerHeight - wrapper.clientHeight;
                              y >= maxY && (y = maxY), this.setPositionY(y);
                          }));
                      }
                  }), defineProperty_defineProperty(this, "windowResizeCheck", {
                      onResizeFrame: () => {
                          this.obj.wrapper && this.fixPositionAndSize();
                      },
                      onResize: () => {
                          window.requestAnimationFrame(this.windowResizeCheck.onResizeFrame);
                      },
                      init: () => {
                          window.addEventListener("resize", this.windowResizeCheck.onResize);
                      },
                      destroy: () => {
                          window.removeEventListener("resize", this.windowResizeCheck.onResize);
                      }
                  }), this.obj.wrapper = _wrapper, this.obj.overlay = _overlay, initialY && initialY >= 0 && this.setPositionY(initialY), 
                  this.wrapperMove.init(), this.windowResizeCheck.init();
              }
          }
          const index_module_overlay = "qH_B5IKTrDyMv2bg06Fu", index_module_panel = "MTwFRnZbgaN7TS8EMQxJ";
          const dragButton = function({className, onClick, children}) {
              const panelRef = (0, react.useRef)(), overlayRef = (0, react.useRef)(null), wrapperRef = (0, 
              react.useRef)(null);
              return (0, react.useLayoutEffect)((() => {
                  if (wrapperRef.current && overlayRef.current) return panelRef.current = new DragButton({
                      wrapper: wrapperRef.current,
                      overlay: overlayRef.current,
                      initialY: 300
                  }), window.panel = panelRef.current, () => {
                      panelRef.current?.destroy();
                  };
              }), []), (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                  children: [ (0, jsx_runtime.jsx)("div", {
                      ref: overlayRef,
                      className: index_module_overlay
                  }), (0, jsx_runtime.jsx)("div", {
                      ref: wrapperRef,
                      className: dist_clsx(index_module_panel, className),
                      onClick: () => {
                          panelRef.current && !panelRef.current.isMoved && onClick?.();
                      },
                      children
                  }) ]
              });
          };
          var _svg, _svg2, _svg3, _svg4, _svg5, _svg6, _svg7;
          function Felo() {
              return _svg || (_svg = (0, jsx_runtime.jsxs)("svg", {
                  width: "43",
                  height: "16",
                  viewBox: "0 0 43 16",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [ (0, jsx_runtime.jsx)("path", {
                      d: "M0 15.99h3.118v-5.917h7.499V7.469h-7.5V3.648c0-.3.245-.544.547-.544h8.142V0H2.002A1.997 1.997 0 0 0 0 1.993V15.99zM28.642 0h-3.087v16h3.087V0z",
                      fill: "currentColor"
                  }), (0, jsx_runtime.jsx)("path", {
                      fillRule: "evenodd",
                      clipRule: "evenodd",
                      d: "M15.07 11.055h9.127l.028-.148a6.22 6.22 0 0 0 .103-1.13c0-3.431-2.794-6.213-6.24-6.213-3.447 0-6.241 2.782-6.241 6.213 0 .031 0 .068-.002.107-.002.09-.004.195.003.272l.001.017c.02.237.035.4.085.643l.016.09.027.15h.011a6.513 6.513 0 0 0 6.328 4.934c1.8 0 3.43-.727 4.61-1.902l.128-.128-1.96-1.95-.126.157a3.397 3.397 0 0 1-2.652 1.268 3.398 3.398 0 0 1-3.246-2.38zm3.017-4.935a3.121 3.121 0 0 1 3.036 2.38h-6.072a3.121 3.121 0 0 1 3.036-2.38zM36.16 15.99c3.446 0 6.24-2.781 6.24-6.213 0-3.431-2.794-6.213-6.24-6.213-3.447 0-6.24 2.782-6.24 6.213 0 3.432 2.793 6.213 6.24 6.213zm3.122-6.213c0 2.047-1.423 3.658-3.122 3.658-1.7 0-3.123-1.61-3.123-3.658 0-2.047 1.424-3.657 3.123-3.657 1.699 0 3.122 1.61 3.122 3.657z",
                      fill: "currentColor"
                  }) ]
              }));
          }
          function TranslatorLogo() {
              return _svg2 || (_svg2 = (0, jsx_runtime.jsxs)("svg", {
                  width: "28",
                  height: "28",
                  viewBox: "0 0 28 28",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [ (0, jsx_runtime.jsx)("path", {
                      fillRule: "evenodd",
                      clipRule: "evenodd",
                      d: "M6.614 13.156c.339 0 .614.277.614.618v1.65c0 3.759 3.023 6.806 6.753 6.806s6.753-3.047 6.753-6.806v-1.65c0-.341.275-.618.614-.618.34 0 .614.277.614.618v1.65c0 4.442-3.573 8.043-7.98 8.043-4.409 0-7.982-3.6-7.982-8.043v-1.65c0-.341.275-.618.614-.618z",
                      fill: "url(#paint0_linear_22605_10081)"
                  }), (0, jsx_runtime.jsx)("path", {
                      fillRule: "evenodd",
                      clipRule: "evenodd",
                      d: "M13.981 5.732c-3.051 0-5.525 2.493-5.525 5.568v4.124c0 3.076 2.474 5.569 5.525 5.569 3.052 0 5.525-2.493 5.525-5.569V11.3c0-3.075-2.473-5.568-5.525-5.568z",
                      fill: "url(#paint1_linear_22605_10081)"
                  }), (0, jsx_runtime.jsx)("path", {
                      fillRule: "evenodd",
                      clipRule: "evenodd",
                      d: "M4.3 6.176c.273 0 .493.22.493.492v5.617a.493.493 0 0 1-.985 0V6.668c0-.272.22-.492.493-.492zM2.898 7.229a.493.493 0 0 0-.493.492v3.51a.493.493 0 0 0 .985 0v-3.51a.493.493 0 0 0-.492-.492zM13.06 8.79l-1.649.99a.662.662 0 0 1-.34.094H7.599a.493.493 0 0 1-.983-.048v-.702a.493.493 0 0 1 .865-.322.543.543 0 0 1 .078-.006h3.398l2.18-1.308a.662.662 0 0 1 1.002.568v1.91l1.693-1.068a.662.662 0 0 1 .353-.102h4.121c.067 0 .13.012.19.034a.492.492 0 0 1 .888.294v.702a.493.493 0 0 1-.984.04.541.541 0 0 1-.094.008h-4l-2.23 1.405a.662.662 0 0 1-1.015-.56V8.791zM1.493 8.633c.272 0 .492.22.492.492v.702a.493.493 0 1 1-.985 0v-.702c0-.272.22-.492.493-.492zM27 9.125a.493.493 0 0 0-.985 0v.702a.493.493 0 0 0 .985 0v-.702zm-5.198-1.404a.493.493 0 1 1 .986 0v3.51a.493.493 0 0 1-.986 0v-3.51zM5.705 7.23c.272 0 .493.22.493.492v3.51a.493.493 0 0 1-.986 0v-3.51c0-.272.22-.492.493-.492zm19.89.492a.493.493 0 1 0-.984 0v3.51a.493.493 0 0 0 .985 0v-3.51zm-1.403-1.053a.493.493 0 0 0-.986 0v5.617a.493.493 0 0 0 .986 0V6.668z",
                      fill: "#C8BFFB"
                  }), (0, jsx_runtime.jsxs)("defs", {
                      children: [ (0, jsx_runtime.jsxs)("linearGradient", {
                          id: "paint0_linear_22605_10081",
                          x1: "13.981",
                          y1: "5.732",
                          x2: "13.981",
                          y2: "23.467",
                          gradientUnits: "userSpaceOnUse",
                          children: [ (0, jsx_runtime.jsx)("stop", {
                              stopColor: "#B7ACFF"
                          }), (0, jsx_runtime.jsx)("stop", {
                              offset: "1",
                              stopColor: "#593EFF"
                          }) ]
                      }), (0, jsx_runtime.jsxs)("linearGradient", {
                          id: "paint1_linear_22605_10081",
                          x1: "13.981",
                          y1: "5.732",
                          x2: "13.981",
                          y2: "23.467",
                          gradientUnits: "userSpaceOnUse",
                          children: [ (0, jsx_runtime.jsx)("stop", {
                              stopColor: "#B7ACFF"
                          }), (0, jsx_runtime.jsx)("stop", {
                              offset: "1",
                              stopColor: "#593EFF"
                          }) ]
                      }) ]
                  }) ]
              }));
          }
          function CloseWithPadding() {
              return _svg3 || (_svg3 = (0, jsx_runtime.jsxs)("svg", {
                  width: "20",
                  height: "20",
                  viewBox: "0 0 20 20",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [ (0, jsx_runtime.jsx)("g", {
                      clipPath: "url(#clip0_22620_232)",
                      stroke: "#fff",
                      strokeWidth: "1.5",
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      children: (0, jsx_runtime.jsx)("path", {
                          d: "M15 5L5 15M5 5l10 10"
                      })
                  }), (0, jsx_runtime.jsx)("defs", {
                      children: (0, jsx_runtime.jsx)("clipPath", {
                          id: "clip0_22620_232",
                          children: (0, jsx_runtime.jsx)("path", {
                              fill: "#fff",
                              d: "M0 0h20v20H0z"
                          })
                      })
                  }) ]
              }));
          }
          function SubtitleContinue() {
              return _svg4 || (_svg4 = (0, jsx_runtime.jsx)("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "16",
                  height: "16",
                  viewBox: "0 0 16 16",
                  fill: "none",
                  children: (0, jsx_runtime.jsx)("path", {
                      d: "M2.75 8V4.723a.25.25 0 0 1 .374-.217l2.879 1.645 2.855 1.632a.25.25 0 0 1 0 .434L6.003 9.85l-2.879 1.645a.25.25 0 0 1-.374-.217V8z",
                      stroke: "#fff",
                      strokeWidth: "1.5",
                      strokeLinejoin: "round"
                  })
              }));
          }
          function SubtitleRetranslate() {
              return _svg5 || (_svg5 = (0, jsx_runtime.jsx)("svg", {
                  width: "20",
                  height: "22",
                  viewBox: "0 0 20 22",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: (0, jsx_runtime.jsxs)("g", {
                      stroke: "currentColor",
                      strokeWidth: "1.3",
                      strokeLinecap: "round",
                      children: [ (0, jsx_runtime.jsx)("path", {
                          d: "M16.09 8.288A6.667 6.667 0 0 0 5.297 6.275M2.693 5.596L3.3 8.23a.833.833 0 0 0 .999.625l2.633-.608"
                      }), (0, jsx_runtime.jsx)("g", {
                          children: (0, jsx_runtime.jsx)("path", {
                              d: "M3.91 13.711a6.667 6.667 0 0 0 10.674 2.13M17.307 16.404l-.608-2.633a.833.833 0 0 0-1-.625l-2.632.608"
                          })
                      }) ]
                  })
              }));
          }
          function Warning() {
              return _svg6 || (_svg6 = (0, jsx_runtime.jsxs)("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "16",
                  height: "16",
                  viewBox: "0 0 16 16",
                  fill: "none",
                  children: [ (0, jsx_runtime.jsx)("circle", {
                      cx: "8",
                      cy: "8",
                      r: "7",
                      fill: "#F97066"
                  }), (0, jsx_runtime.jsx)("path", {
                      d: "M7.545 4.077a.913.913 0 0 1 1.278.919l-.364 4.006a.548.548 0 0 1-1.09 0l-.365-4.006a.913.913 0 0 1 .541-.919zM8.786 11.203a.872.872 0 1 1-1.744 0 .872.872 0 0 1 1.744 0z",
                      fill: "#FCE7E6"
                  }) ]
              }));
          }
          function NoticeClose() {
              return _svg7 || (_svg7 = (0, jsx_runtime.jsxs)("svg", {
                  xmlns: "http://www.w3.org/2000/svg",
                  width: "20",
                  height: "20",
                  viewBox: "0 0 20 20",
                  fill: "none",
                  children: [ (0, jsx_runtime.jsx)("g", {
                      clipPath: "url(#clip0_22654_1599)",
                      stroke: "currentColor",
                      strokeWidth: "1.5",
                      strokeLinecap: "round",
                      strokeLinejoin: "round",
                      children: (0, jsx_runtime.jsx)("path", {
                          d: "M15 5L5 15M5 5l10 10"
                      })
                  }), (0, jsx_runtime.jsx)("defs", {
                      children: (0, jsx_runtime.jsx)("clipPath", {
                          id: "clip0_22654_1599",
                          children: (0, jsx_runtime.jsx)("path", {
                              fill: "currentColor",
                              d: "M0 0h20v20H0z"
                          })
                      })
                  }) ]
              }));
          }
          function omit_omit(obj, fields) {
              var clone = _objectSpread2({}, obj);
              return Array.isArray(fields) && fields.forEach((function(key) {
                  delete clone[key];
              })), clone;
          }
          const isVisible = function(element) {
              if (!element) return !1;
              if (element instanceof Element) {
                  if (element.offsetParent) return !0;
                  if (element.getBBox) {
                      var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
                      if (width || height) return !0;
                  }
                  if (element.getBoundingClientRect) {
                      var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
                      if (_width || _height) return !0;
                  }
              }
              return !1;
          }, {isValidElement: reactNode_isValidElement} = react_namespaceObject;
          function reactNode_isFragment(child) {
              return child && reactNode_isValidElement(child) && child.type === react.Fragment;
          }
          function cloneElement(element, props) {
              return function(element, replacement, props) {
                  return reactNode_isValidElement(element) ? react.cloneElement(element, "function" == typeof props ? props(element.props || {}) : props) : replacement;
              }(element, element, props);
          }
          function useEvent(callback) {
              var fnRef = react.useRef();
              fnRef.current = callback;
              var memoFn = react.useCallback((function() {
                  for (var _fnRef$current, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return null === (_fnRef$current = fnRef.current) || void 0 === _fnRef$current ? void 0 : _fnRef$current.call.apply(_fnRef$current, [ fnRef ].concat(args));
              }), []);
              return memoFn;
          }
          function hasValue(value) {
              return void 0 !== value;
          }
          function useMergedState(defaultStateValue, option) {
              var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState, _useState2 = slicedToArray_slicedToArray(useSafeState((function() {
                  return hasValue(value) ? value : hasValue(defaultValue) ? "function" == typeof defaultValue ? defaultValue() : defaultValue : "function" == typeof defaultStateValue ? defaultStateValue() : defaultStateValue;
              })), 2), innerValue = _useState2[0], setInnerValue = _useState2[1], mergedValue = void 0 !== value ? value : innerValue, postMergedValue = postState ? postState(mergedValue) : mergedValue, onChangeFn = useEvent(onChange), _useState4 = slicedToArray_slicedToArray(useSafeState([ mergedValue ]), 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
              return useLayoutUpdateEffect((function() {
                  var prev = prevValue[0];
                  innerValue !== prev && onChangeFn(innerValue, prev);
              }), [ prevValue ]), useLayoutUpdateEffect((function() {
                  hasValue(value) || setInnerValue(value);
              }), [ value ]), [ postMergedValue, useEvent((function(updater, ignoreDestroy) {
                  setInnerValue(updater, ignoreDestroy), setPrevValue([ mergedValue ], ignoreDestroy);
              })) ];
          }
          const enableStatistic = "undefined" != typeof CSSINJS_STATISTIC;
          let recording = !0;
          function statistic_merge() {
              for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) objs[_key] = arguments[_key];
              if (!enableStatistic) return Object.assign.apply(Object, [ {} ].concat(objs));
              recording = !1;
              const ret = {};
              return objs.forEach((obj => {
                  Object.keys(obj).forEach((key => {
                      Object.defineProperty(ret, key, {
                          configurable: !0,
                          enumerable: !0,
                          get: () => obj[key]
                      });
                  }));
              })), recording = !0, ret;
          }
          const statistic = {};
          function statistic_noop() {}
          function genComponentStyleHook(componentName, styleFn, getDefaultToken) {
              let options = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
              const cells = Array.isArray(componentName) ? componentName : [ componentName, componentName ], [component] = cells, concatComponent = cells.join("-");
              return prefixCls => {
                  const [theme, token, hashId] = useToken(), {getPrefixCls, iconPrefixCls, csp} = (0, 
                  react.useContext)(context_ConfigContext), rootPrefixCls = getPrefixCls(), sharedConfig = {
                      theme,
                      token,
                      hashId,
                      nonce: () => null == csp ? void 0 : csp.nonce,
                      clientOnly: options.clientOnly,
                      order: options.order || -999
                  };
                  return useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
                      clientOnly: !1,
                      path: [ "Shared", rootPrefixCls ]
                  }), (() => [ {
                      "&": genLinkStyle(token)
                  } ])), util_useResetIconStyle(iconPrefixCls), [ useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
                      path: [ concatComponent, prefixCls, iconPrefixCls ]
                  }), (() => {
                      const {token: proxyToken, flush} = function(token) {
                          let tokenKeys, proxy = token, flush = statistic_noop;
                          return enableStatistic && (tokenKeys = new Set, proxy = new Proxy(token, {
                              get: (obj, prop) => (recording && tokenKeys.add(prop), obj[prop])
                          }), flush = (componentName, componentToken) => {
                              var _a;
                              statistic[componentName] = {
                                  global: Array.from(tokenKeys),
                                  component: Object.assign(Object.assign({}, null === (_a = statistic[componentName]) || void 0 === _a ? void 0 : _a.component), componentToken)
                              };
                          }), {
                              token: proxy,
                              keys: tokenKeys,
                              flush
                          };
                      }(token), customComponentToken = Object.assign({}, token[component]);
                      if (options.deprecatedTokens) {
                          const {deprecatedTokens} = options;
                          deprecatedTokens.forEach((_ref => {
                              let [oldTokenKey, newTokenKey] = _ref;
                              var _a;
                              ((null == customComponentToken ? void 0 : customComponentToken[oldTokenKey]) || (null == customComponentToken ? void 0 : customComponentToken[newTokenKey])) && (null !== (_a = customComponentToken[newTokenKey]) && void 0 !== _a || (customComponentToken[newTokenKey] = null == customComponentToken ? void 0 : customComponentToken[oldTokenKey]));
                          }));
                      }
                      const defaultComponentToken = "function" == typeof getDefaultToken ? getDefaultToken(statistic_merge(proxyToken, null != customComponentToken ? customComponentToken : {})) : getDefaultToken, mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), customComponentToken), mergedToken = statistic_merge(proxyToken, {
                          componentCls: `.${prefixCls}`,
                          prefixCls,
                          iconCls: `.${iconPrefixCls}`,
                          antCls: `.${rootPrefixCls}`
                      }, mergedComponentToken), styleInterpolation = styleFn(mergedToken, {
                          hashId,
                          prefixCls,
                          rootPrefixCls,
                          iconPrefixCls,
                          overrideComponentToken: customComponentToken
                      });
                      return flush(component, mergedComponentToken), [ !1 === options.resetStyle ? null : genCommonStyle(token, prefixCls), styleInterpolation ];
                  })), hashId ];
              };
          }
          const genWaveStyle = token => {
              const {componentCls, colorPrimary} = token;
              return {
                  [componentCls]: {
                      position: "absolute",
                      background: "transparent",
                      pointerEvents: "none",
                      boxSizing: "border-box",
                      color: `var(--wave-color, ${colorPrimary})`,
                      boxShadow: "0 0 0 0 currentcolor",
                      opacity: .2,
                      "&.wave-motion-appear": {
                          transition: [ `box-shadow 0.4s ${token.motionEaseOutCirc}`, `opacity 2s ${token.motionEaseOutCirc}` ].join(","),
                          "&-active": {
                              boxShadow: "0 0 0 6px currentcolor",
                              opacity: 0
                          },
                          "&.wave-quick": {
                              transition: [ `box-shadow 0.3s ${token.motionEaseInOut}`, `opacity 0.35s ${token.motionEaseInOut}` ].join(",")
                          }
                      }
                  }
              };
          }, wave_style = genComponentStyleHook("Wave", (token => [ genWaveStyle(token) ]));
          function _regeneratorRuntime() {
              _regeneratorRuntime = function() {
                  return exports;
              };
              var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
                  obj[key] = desc.value;
              }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
              function define(obj, key, value) {
                  return Object.defineProperty(obj, key, {
                      value,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0
                  }), obj[key];
              }
              try {
                  define({}, "");
              } catch (err) {
                  define = function(obj, key, value) {
                      return obj[key] = value;
                  };
              }
              function wrap(innerFn, outerFn, self, tryLocsList) {
                  var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
                  return defineProperty(generator, "_invoke", {
                      value: makeInvokeMethod(innerFn, self, context)
                  }), generator;
              }
              function tryCatch(fn, obj, arg) {
                  try {
                      return {
                          type: "normal",
                          arg: fn.call(obj, arg)
                      };
                  } catch (err) {
                      return {
                          type: "throw",
                          arg: err
                      };
                  }
              }
              exports.wrap = wrap;
              var ContinueSentinel = {};
              function Generator() {}
              function GeneratorFunction() {}
              function GeneratorFunctionPrototype() {}
              var IteratorPrototype = {};
              define(IteratorPrototype, iteratorSymbol, (function() {
                  return this;
              }));
              var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
              NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
              var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
              function defineIteratorMethods(prototype) {
                  [ "next", "throw", "return" ].forEach((function(method) {
                      define(prototype, method, (function(arg) {
                          return this._invoke(method, arg);
                      }));
                  }));
              }
              function AsyncIterator(generator, PromiseImpl) {
                  function invoke(method, arg, resolve, reject) {
                      var record = tryCatch(generator[method], generator, arg);
                      if ("throw" !== record.type) {
                          var result = record.arg, value = result.value;
                          return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then((function(value) {
                              invoke("next", value, resolve, reject);
                          }), (function(err) {
                              invoke("throw", err, resolve, reject);
                          })) : PromiseImpl.resolve(value).then((function(unwrapped) {
                              result.value = unwrapped, resolve(result);
                          }), (function(error) {
                              return invoke("throw", error, resolve, reject);
                          }));
                      }
                      reject(record.arg);
                  }
                  var previousPromise;
                  defineProperty(this, "_invoke", {
                      value: function(method, arg) {
                          function callInvokeWithMethodAndArg() {
                              return new PromiseImpl((function(resolve, reject) {
                                  invoke(method, arg, resolve, reject);
                              }));
                          }
                          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                      }
                  });
              }
              function makeInvokeMethod(innerFn, self, context) {
                  var state = "suspendedStart";
                  return function(method, arg) {
                      if ("executing" === state) throw new Error("Generator is already running");
                      if ("completed" === state) {
                          if ("throw" === method) throw arg;
                          return doneResult();
                      }
                      for (context.method = method, context.arg = arg; ;) {
                          var delegate = context.delegate;
                          if (delegate) {
                              var delegateResult = maybeInvokeDelegate(delegate, context);
                              if (delegateResult) {
                                  if (delegateResult === ContinueSentinel) continue;
                                  return delegateResult;
                              }
                          }
                          if ("next" === context.method) context.sent = context._sent = context.arg; else if ("throw" === context.method) {
                              if ("suspendedStart" === state) throw state = "completed", context.arg;
                              context.dispatchException(context.arg);
                          } else "return" === context.method && context.abrupt("return", context.arg);
                          state = "executing";
                          var record = tryCatch(innerFn, self, context);
                          if ("normal" === record.type) {
                              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                              return {
                                  value: record.arg,
                                  done: context.done
                              };
                          }
                          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                      }
                  };
              }
              function maybeInvokeDelegate(delegate, context) {
                  var methodName = context.method, method = delegate.iterator[methodName];
                  if (void 0 === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", 
                  context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", 
                  context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), 
                  ContinueSentinel;
                  var record = tryCatch(method, delegate.iterator, context.arg);
                  if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, 
                  context.delegate = null, ContinueSentinel;
                  var info = record.arg;
                  return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, 
                  "return" !== context.method && (context.method = "next", context.arg = void 0), 
                  context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), 
                  context.delegate = null, ContinueSentinel);
              }
              function pushTryEntry(locs) {
                  var entry = {
                      tryLoc: locs[0]
                  };
                  1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], 
                  entry.afterLoc = locs[3]), this.tryEntries.push(entry);
              }
              function resetTryEntry(entry) {
                  var record = entry.completion || {};
                  record.type = "normal", delete record.arg, entry.completion = record;
              }
              function Context(tryLocsList) {
                  this.tryEntries = [ {
                      tryLoc: "root"
                  } ], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
              }
              function values(iterable) {
                  if (iterable) {
                      var iteratorMethod = iterable[iteratorSymbol];
                      if (iteratorMethod) return iteratorMethod.call(iterable);
                      if ("function" == typeof iterable.next) return iterable;
                      if (!isNaN(iterable.length)) {
                          var i = -1, next = function next() {
                              for (;++i < iterable.length; ) if (hasOwn.call(iterable, i)) return next.value = iterable[i], 
                              next.done = !1, next;
                              return next.value = void 0, next.done = !0, next;
                          };
                          return next.next = next;
                      }
                  }
                  return {
                      next: doneResult
                  };
              }
              function doneResult() {
                  return {
                      value: void 0,
                      done: !0
                  };
              }
              return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
                  value: GeneratorFunctionPrototype,
                  configurable: !0
              }), defineProperty(GeneratorFunctionPrototype, "constructor", {
                  value: GeneratorFunction,
                  configurable: !0
              }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), 
              exports.isGeneratorFunction = function(genFun) {
                  var ctor = "function" == typeof genFun && genFun.constructor;
                  return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
              }, exports.mark = function(genFun) {
                  return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, 
                  define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), 
                  genFun;
              }, exports.awrap = function(arg) {
                  return {
                      __await: arg
                  };
              }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, (function() {
                  return this;
              })), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
                  void 0 === PromiseImpl && (PromiseImpl = Promise);
                  var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
                  return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then((function(result) {
                      return result.done ? result.value : iter.next();
                  }));
              }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, (function() {
                  return this;
              })), define(Gp, "toString", (function() {
                  return "[object Generator]";
              })), exports.keys = function(val) {
                  var object = Object(val), keys = [];
                  for (var key in object) keys.push(key);
                  return keys.reverse(), function next() {
                      for (;keys.length; ) {
                          var key = keys.pop();
                          if (key in object) return next.value = key, next.done = !1, next;
                      }
                      return next.done = !0, next;
                  };
              }, exports.values = values, Context.prototype = {
                  constructor: Context,
                  reset: function(skipTempReset) {
                      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, 
                      this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), 
                      !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
                  },
                  stop: function() {
                      this.done = !0;
                      var rootRecord = this.tryEntries[0].completion;
                      if ("throw" === rootRecord.type) throw rootRecord.arg;
                      return this.rval;
                  },
                  dispatchException: function(exception) {
                      if (this.done) throw exception;
                      var context = this;
                      function handle(loc, caught) {
                          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", 
                          context.arg = void 0), !!caught;
                      }
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                          var entry = this.tryEntries[i], record = entry.completion;
                          if ("root" === entry.tryLoc) return handle("end");
                          if (entry.tryLoc <= this.prev) {
                              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                              if (hasCatch && hasFinally) {
                                  if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                                  if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                              } else if (hasCatch) {
                                  if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                              } else {
                                  if (!hasFinally) throw new Error("try statement without catch or finally");
                                  if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                              }
                          }
                      }
                  },
                  abrupt: function(type, arg) {
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                          var entry = this.tryEntries[i];
                          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                              var finallyEntry = entry;
                              break;
                          }
                      }
                      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
                      var record = finallyEntry ? finallyEntry.completion : {};
                      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", 
                      this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
                  },
                  complete: function(record, afterLoc) {
                      if ("throw" === record.type) throw record.arg;
                      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, 
                      this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), 
                      ContinueSentinel;
                  },
                  finish: function(finallyLoc) {
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                          var entry = this.tryEntries[i];
                          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), 
                          resetTryEntry(entry), ContinueSentinel;
                      }
                  },
                  catch: function(tryLoc) {
                      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                          var entry = this.tryEntries[i];
                          if (entry.tryLoc === tryLoc) {
                              var record = entry.completion;
                              if ("throw" === record.type) {
                                  var thrown = record.arg;
                                  resetTryEntry(entry);
                              }
                              return thrown;
                          }
                      }
                      throw new Error("illegal catch attempt");
                  },
                  delegateYield: function(iterable, resultName, nextLoc) {
                      return this.delegate = {
                          iterator: values(iterable),
                          resultName,
                          nextLoc
                      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
                  }
              }, exports;
          }
          function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
              try {
                  var info = gen[key](arg), value = info.value;
              } catch (error) {
                  return void reject(error);
              }
              info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
          }
          function _asyncToGenerator(fn) {
              return function() {
                  var self = this, args = arguments;
                  return new Promise((function(resolve, reject) {
                      var gen = fn.apply(self, args);
                      function _next(value) {
                          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
                      }
                      function _throw(err) {
                          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
                      }
                      _next(void 0);
                  }));
              };
          }
          var createRoot, render_fullClone = _objectSpread2({}, react_dom_namespaceObject), render_version = render_fullClone.version, reactRender = render_fullClone.render, unmountComponentAtNode = render_fullClone.unmountComponentAtNode;
          try {
              Number((render_version || "").split(".")[0]) >= 18 && (createRoot = render_fullClone.createRoot);
          } catch (e) {}
          function toggleWarning(skip) {
              var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = render_fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
              __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && "object" === _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) && (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip);
          }
          var MARK = "__rc_react_root__";
          function render(node, container) {
              createRoot ? function(node, container) {
                  toggleWarning(!0);
                  var root = container[MARK] || createRoot(container);
                  toggleWarning(!1), root.render(node), container[MARK] = root;
              }(node, container) : function(node, container) {
                  reactRender(node, container);
              }(node, container);
          }
          function modernUnmount(_x) {
              return _modernUnmount.apply(this, arguments);
          }
          function _modernUnmount() {
              return (_modernUnmount = _asyncToGenerator(_regeneratorRuntime().mark((function _callee(container) {
                  return _regeneratorRuntime().wrap((function(_context) {
                      for (;;) switch (_context.prev = _context.next) {
                        case 0:
                          return _context.abrupt("return", Promise.resolve().then((function() {
                              var _container$MARK;
                              null === (_container$MARK = container[MARK]) || void 0 === _container$MARK || _container$MARK.unmount(), 
                              delete container[MARK];
                          })));

                        case 1:
                        case "end":
                          return _context.stop();
                      }
                  }), _callee);
              })))).apply(this, arguments);
          }
          function legacyUnmount(container) {
              unmountComponentAtNode(container);
          }
          function _unmount() {
              return (_unmount = _asyncToGenerator(_regeneratorRuntime().mark((function _callee2(container) {
                  return _regeneratorRuntime().wrap((function(_context2) {
                      for (;;) switch (_context2.prev = _context2.next) {
                        case 0:
                          if (void 0 === createRoot) {
                              _context2.next = 2;
                              break;
                          }
                          return _context2.abrupt("return", modernUnmount(container));

                        case 2:
                          legacyUnmount(container);

                        case 3:
                        case "end":
                          return _context2.stop();
                      }
                  }), _callee2);
              })))).apply(this, arguments);
          }
          function isValidWaveColor(color) {
              return color && "#fff" !== color && "#ffffff" !== color && "rgb(255, 255, 255)" !== color && "rgba(255, 255, 255, 1)" !== color && function(color) {
                  const match = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
                  return !(match && match[1] && match[2] && match[3] && match[1] === match[2] && match[2] === match[3]);
              }(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && "transparent" !== color;
          }
          function validateNum(value) {
              return Number.isNaN(value) ? 0 : value;
          }
          const WaveEffect = props => {
              const {className, target, component} = props, divRef = react.useRef(null), [color, setWaveColor] = react.useState(null), [borderRadius, setBorderRadius] = react.useState([]), [left, setLeft] = react.useState(0), [top, setTop] = react.useState(0), [width, setWidth] = react.useState(0), [height, setHeight] = react.useState(0), [enabled, setEnabled] = react.useState(!1), waveStyle = {
                  left,
                  top,
                  width,
                  height,
                  borderRadius: borderRadius.map((radius => `${radius}px`)).join(" ")
              };
              function syncPos() {
                  const nodeStyle = getComputedStyle(target);
                  setWaveColor(function(node) {
                      const {borderTopColor, borderColor, backgroundColor} = getComputedStyle(node);
                      return isValidWaveColor(borderTopColor) ? borderTopColor : isValidWaveColor(borderColor) ? borderColor : isValidWaveColor(backgroundColor) ? backgroundColor : null;
                  }(target));
                  const isStatic = "static" === nodeStyle.position, {borderLeftWidth, borderTopWidth} = nodeStyle;
                  setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth))), 
                  setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth))), 
                  setWidth(target.offsetWidth), setHeight(target.offsetHeight);
                  const {borderTopLeftRadius, borderTopRightRadius, borderBottomLeftRadius, borderBottomRightRadius} = nodeStyle;
                  setBorderRadius([ borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius ].map((radius => validateNum(parseFloat(radius)))));
              }
              if (color && (waveStyle["--wave-color"] = color), react.useEffect((() => {
                  if (target) {
                      const id = es_raf((() => {
                          syncPos(), setEnabled(!0);
                      }));
                      let resizeObserver;
                      return "undefined" != typeof ResizeObserver && (resizeObserver = new ResizeObserver(syncPos), 
                      resizeObserver.observe(target)), () => {
                          es_raf.cancel(id), null == resizeObserver || resizeObserver.disconnect();
                      };
                  }
              }), []), !enabled) return null;
              const isSmallComponent = ("Checkbox" === component || "Radio" === component) && (null == target ? void 0 : target.classList.contains("ant-wave-target"));
              return react.createElement(es, {
                  visible: !0,
                  motionAppear: !0,
                  motionName: "wave-motion",
                  motionDeadline: 5e3,
                  onAppearEnd: (_, event) => {
                      var _a;
                      if (event.deadline || "opacity" === event.propertyName) {
                          const holder = null === (_a = divRef.current) || void 0 === _a ? void 0 : _a.parentElement;
                          (function(_x2) {
                              return _unmount.apply(this, arguments);
                          })(holder).then((() => {
                              null == holder || holder.remove();
                          }));
                      }
                      return !1;
                  }
              }, (_ref => {
                  let {className: motionClassName} = _ref;
                  return react.createElement("div", {
                      ref: divRef,
                      className: classnames_default()(className, {
                          "wave-quick": isSmallComponent
                      }, motionClassName),
                      style: waveStyle
                  });
              }));
          }, wave_WaveEffect = (target, info) => {
              var _a;
              const {component} = info;
              if ("Checkbox" === component && !(null === (_a = target.querySelector("input")) || void 0 === _a ? void 0 : _a.checked)) return;
              const holder = document.createElement("div");
              holder.style.position = "absolute", holder.style.left = "0px", holder.style.top = "0px", 
              null == target || target.insertBefore(holder, null == target ? void 0 : target.firstChild), 
              render(react.createElement(WaveEffect, Object.assign({}, info, {
                  target
              })), holder);
          };
          const wave = props => {
              const {children, disabled, component} = props, {getPrefixCls} = (0, react.useContext)(context_ConfigContext), containerRef = (0, 
              react.useRef)(null), prefixCls = getPrefixCls("wave"), [, hashId] = wave_style(prefixCls), showWave = function(nodeRef, className, component) {
                  const {wave} = react.useContext(context_ConfigContext), [, token, hashId] = useToken(), showWave = useEvent((event => {
                      const node = nodeRef.current;
                      if ((null == wave ? void 0 : wave.disabled) || !node) return;
                      const targetNode = node.querySelector(".ant-wave-target") || node, {showEffect} = wave || {};
                      (showEffect || wave_WaveEffect)(targetNode, {
                          className,
                          token,
                          component,
                          event,
                          hashId
                      });
                  })), rafId = react.useRef();
                  return event => {
                      es_raf.cancel(rafId.current), rafId.current = es_raf((() => {
                          showWave(event);
                      }));
                  };
              }(containerRef, classnames_default()(prefixCls, hashId), component);
              if (react.useEffect((() => {
                  const node = containerRef.current;
                  if (!node || 1 !== node.nodeType || disabled) return;
                  const onClick = e => {
                      !isVisible(e.target) || !node.getAttribute || node.getAttribute("disabled") || node.disabled || node.className.includes("disabled") || node.className.includes("-leave") || showWave(e);
                  };
                  return node.addEventListener("click", onClick, !0), () => {
                      node.removeEventListener("click", onClick, !0);
                  };
              }), [ disabled ]), !react.isValidElement(children)) return null != children ? children : null;
              return cloneElement(children, {
                  ref: supportRef(children) ? composeRef(children.ref, containerRef) : containerRef
              });
          }, hooks_useSize = customSize => {
              const size = react.useContext(config_provider_SizeContext);
              return react.useMemo((() => customSize ? "string" == typeof customSize ? null != customSize ? customSize : size : customSize instanceof Function ? customSize(size) : size : size), [ customSize, size ]);
          };
          function toArray_toArray(children) {
              var option = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, ret = [];
              return react.Children.forEach(children, (function(child) {
                  (null != child || option.keepEmpty) && (Array.isArray(child) ? ret = ret.concat(toArray_toArray(child)) : (0, 
                  react_is.isFragment)(child) && child.props ? ret = ret.concat(toArray_toArray(child.props.children, option)) : ret.push(child));
              })), ret;
          }
          const SpaceCompactItemContext = react.createContext(null), NoCompactStyle = _ref => {
              let {children} = _ref;
              return react.createElement(SpaceCompactItemContext.Provider, {
                  value: null
              }, children);
          };
          var button_group_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const GroupSizeContext = react.createContext(void 0), button_group = props => {
              const {getPrefixCls, direction} = react.useContext(context_ConfigContext), {prefixCls: customizePrefixCls, size, className} = props, others = button_group_rest(props, [ "prefixCls", "size", "className" ]), prefixCls = getPrefixCls("btn-group", customizePrefixCls), [, , hashId] = useToken();
              let sizeCls = "";
              switch (size) {
                case "large":
                  sizeCls = "lg";
                  break;

                case "small":
                  sizeCls = "sm";
              }
              const classes = classnames_default()(prefixCls, {
                  [`${prefixCls}-${sizeCls}`]: sizeCls,
                  [`${prefixCls}-rtl`]: "rtl" === direction
              }, className, hashId);
              return react.createElement(GroupSizeContext.Provider, {
                  value: size
              }, react.createElement("div", Object.assign({}, others, {
                  className: classes
              })));
          }, rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/, isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
          function buttonHelpers_isString(str) {
              return "string" == typeof str;
          }
          function isUnBorderedButtonType(type) {
              return "text" === type || "link" === type;
          }
          function spaceChildren(children, needInserted) {
              let isPrevChildPure = !1;
              const childList = [];
              return react.Children.forEach(children, (child => {
                  const type = typeof child, isCurrentChildPure = "string" === type || "number" === type;
                  if (isPrevChildPure && isCurrentChildPure) {
                      const lastIndex = childList.length - 1, lastChild = childList[lastIndex];
                      childList[lastIndex] = `${lastChild}${child}`;
                  } else childList.push(child);
                  isPrevChildPure = isCurrentChildPure;
              })), react.Children.map(childList, (child => function(child, needInserted) {
                  if (null == child) return;
                  const SPACE = needInserted ? " " : "";
                  return "string" != typeof child && "number" != typeof child && buttonHelpers_isString(child.type) && isTwoCNChar(child.props.children) ? cloneElement(child, {
                      children: child.props.children.split("").join(SPACE)
                  }) : buttonHelpers_isString(child) ? isTwoCNChar(child) ? react.createElement("span", null, child.split("").join(SPACE)) : react.createElement("span", null, child) : reactNode_isFragment(child) ? react.createElement("span", null, child) : child;
              }(child, needInserted)));
          }
          const IconWrapper = (0, react.forwardRef)(((props, ref) => {
              const {className, style, children, prefixCls} = props, iconWrapperCls = classnames_default()(`${prefixCls}-icon`, className);
              return react.createElement("span", {
                  ref,
                  className: iconWrapperCls,
                  style
              }, children);
          })), button_IconWrapper = IconWrapper;
          const asn_LoadingOutlined = {
              icon: {
                  tag: "svg",
                  attrs: {
                      viewBox: "0 0 1024 1024",
                      focusable: "false"
                  },
                  children: [ {
                      tag: "path",
                      attrs: {
                          d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z"
                      }
                  } ]
              },
              name: "loading",
              theme: "outlined"
          };
          function getRoot(ele) {
              var _ele$getRootNode;
              return null == ele || null === (_ele$getRootNode = ele.getRootNode) || void 0 === _ele$getRootNode ? void 0 : _ele$getRootNode.call(ele);
          }
          function getShadowRoot(ele) {
              return function(ele) {
                  return getRoot(ele) instanceof ShadowRoot;
              }(ele) ? getRoot(ele) : null;
          }
          function isIconDefinition(target) {
              return "object" === _typeof(target) && "string" == typeof target.name && "string" == typeof target.theme && ("object" === _typeof(target.icon) || "function" == typeof target.icon);
          }
          function normalizeAttrs() {
              var attrs = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              return Object.keys(attrs).reduce((function(acc, key) {
                  var input, val = attrs[key];
                  if ("class" === key) acc.className = val, delete acc.class; else delete acc[key], 
                  acc[(input = key, input.replace(/-(.)/g, (function(match, g) {
                      return g.toUpperCase();
                  })))] = val;
                  return acc;
              }), {});
          }
          function utils_generate(node, key, rootProps) {
              return rootProps ? react.createElement(node.tag, _objectSpread2(_objectSpread2({
                  key
              }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map((function(child, index) {
                  return utils_generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
              }))) : react.createElement(node.tag, _objectSpread2({
                  key
              }, normalizeAttrs(node.attrs)), (node.children || []).map((function(child, index) {
                  return utils_generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
              })));
          }
          function getSecondaryColor(primaryColor) {
              return generate(primaryColor)[0];
          }
          function normalizeTwoToneColors(twoToneColor) {
              return twoToneColor ? Array.isArray(twoToneColor) ? twoToneColor : [ twoToneColor ] : [];
          }
          var IconBase_excluded = [ "icon", "className", "onClick", "style", "primaryColor", "secondaryColor" ], twoToneColorPalette = {
              primaryColor: "#333",
              secondaryColor: "#E6E6E6",
              calculated: !1
          };
          var IconBase = function(props) {
              var eleRef, _useContext, csp, prefixCls, mergedStyleStr, valid, message, icon = props.icon, className = props.className, onClick = props.onClick, style = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = objectWithoutProperties_objectWithoutProperties(props, IconBase_excluded), svgRef = react.useRef(), colors = twoToneColorPalette;
              if (primaryColor && (colors = {
                  primaryColor,
                  secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
              }), eleRef = svgRef, _useContext = (0, react.useContext)(Context), csp = _useContext.csp, 
              prefixCls = _useContext.prefixCls, mergedStyleStr = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n", 
              prefixCls && (mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls)), (0, 
              react.useEffect)((function() {
                  var shadowRoot = getShadowRoot(eleRef.current);
                  updateCSS(mergedStyleStr, "@ant-design-icons", {
                      prepend: !0,
                      csp,
                      attachTo: shadowRoot
                  });
              }), []), valid = isIconDefinition(icon), message = "icon should be icon definiton, but got ".concat(icon), 
              es_warning(valid, "[@ant-design/icons] ".concat(message)), !isIconDefinition(icon)) return null;
              var target = icon;
              return target && "function" == typeof target.icon && (target = _objectSpread2(_objectSpread2({}, target), {}, {
                  icon: target.icon(colors.primaryColor, colors.secondaryColor)
              })), utils_generate(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
                  className,
                  onClick,
                  style,
                  "data-icon": target.name,
                  width: "1em",
                  height: "1em",
                  fill: "currentColor",
                  "aria-hidden": "true"
              }, restProps), {}, {
                  ref: svgRef
              }));
          };
          IconBase.displayName = "IconReact", IconBase.getTwoToneColors = function() {
              return _objectSpread2({}, twoToneColorPalette);
          }, IconBase.setTwoToneColors = function(_ref) {
              var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
              twoToneColorPalette.primaryColor = primaryColor, twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor), 
              twoToneColorPalette.calculated = !!secondaryColor;
          };
          const components_IconBase = IconBase;
          function setTwoToneColor(twoToneColor) {
              var _normalizeTwoToneColo2 = slicedToArray_slicedToArray(normalizeTwoToneColors(twoToneColor), 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
              return components_IconBase.setTwoToneColors({
                  primaryColor,
                  secondaryColor
              });
          }
          var AntdIcon_excluded = [ "className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor" ];
          setTwoToneColor(blue.primary);
          var Icon = react.forwardRef((function(props, ref) {
              var _classNames, className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = objectWithoutProperties_objectWithoutProperties(props, AntdIcon_excluded), _React$useContext = react.useContext(Context), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = void 0 === _React$useContext$pre ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName, classString = classnames_default()(rootClassName, prefixCls, (defineProperty_defineProperty(_classNames = {}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), 
              defineProperty_defineProperty(_classNames, "".concat(prefixCls, "-spin"), !!spin || "loading" === icon.name), 
              _classNames), className), iconTabIndex = tabIndex;
              void 0 === iconTabIndex && onClick && (iconTabIndex = -1);
              var svgStyle = rotate ? {
                  msTransform: "rotate(".concat(rotate, "deg)"),
                  transform: "rotate(".concat(rotate, "deg)")
              } : void 0, _normalizeTwoToneColo2 = slicedToArray_slicedToArray(normalizeTwoToneColors(twoToneColor), 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
              return react.createElement("span", _extends({
                  role: "img",
                  "aria-label": icon.name
              }, restProps, {
                  ref,
                  tabIndex: iconTabIndex,
                  onClick,
                  className: classString
              }), react.createElement(components_IconBase, {
                  icon,
                  primaryColor,
                  secondaryColor,
                  style: svgStyle
              }));
          }));
          Icon.displayName = "AntdIcon", Icon.getTwoToneColor = function() {
              var colors = components_IconBase.getTwoToneColors();
              return colors.calculated ? [ colors.primaryColor, colors.secondaryColor ] : colors.primaryColor;
          }, Icon.setTwoToneColor = setTwoToneColor;
          const AntdIcon = Icon;
          var LoadingOutlined_LoadingOutlined = function(props, ref) {
              return react.createElement(AntdIcon, _extends({}, props, {
                  ref,
                  icon: asn_LoadingOutlined
              }));
          };
          const icons_LoadingOutlined = react.forwardRef(LoadingOutlined_LoadingOutlined), InnerLoadingIcon = (0, 
          react.forwardRef)(((_ref, ref) => {
              let {prefixCls, className, style, iconClassName} = _ref;
              const mergedIconCls = classnames_default()(`${prefixCls}-loading-icon`, className);
              return react.createElement(button_IconWrapper, {
                  prefixCls,
                  className: mergedIconCls,
                  style,
                  ref
              }, react.createElement(icons_LoadingOutlined, {
                  className: iconClassName
              }));
          })), getCollapsedWidth = () => ({
              width: 0,
              opacity: 0,
              transform: "scale(0)"
          }), getRealWidth = node => ({
              width: node.scrollWidth,
              opacity: 1,
              transform: "scale(1)"
          }), button_LoadingIcon = props => {
              const {prefixCls, loading, existIcon, className, style} = props, visible = !!loading;
              return existIcon ? react.createElement(InnerLoadingIcon, {
                  prefixCls,
                  className,
                  style
              }) : react.createElement(es, {
                  visible,
                  motionName: `${prefixCls}-loading-icon-motion`,
                  motionLeave: visible,
                  removeOnLeave: !0,
                  onAppearStart: getCollapsedWidth,
                  onAppearActive: getRealWidth,
                  onEnterStart: getCollapsedWidth,
                  onEnterActive: getRealWidth,
                  onLeaveStart: getRealWidth,
                  onLeaveActive: getCollapsedWidth
              }, ((_ref2, ref) => {
                  let {className: motionCls, style: motionStyle} = _ref2;
                  return react.createElement(InnerLoadingIcon, {
                      prefixCls,
                      className,
                      style: Object.assign(Object.assign({}, style), motionStyle),
                      ref,
                      iconClassName: motionCls
                  });
              }));
          }, genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
              [`> span, > ${buttonTypeCls}`]: {
                  "&:not(:last-child)": {
                      [`&, & > ${buttonTypeCls}`]: {
                          "&:not(:disabled)": {
                              borderInlineEndColor: borderColor
                          }
                      }
                  },
                  "&:not(:first-child)": {
                      [`&, & > ${buttonTypeCls}`]: {
                          "&:not(:disabled)": {
                              borderInlineStartColor: borderColor
                          }
                      }
                  }
              }
          }), group = token => {
              const {componentCls, fontSize, lineWidth, groupBorderColor, colorErrorHover} = token;
              return {
                  [`${componentCls}-group`]: [ {
                      position: "relative",
                      display: "inline-flex",
                      [`> span, > ${componentCls}`]: {
                          "&:not(:last-child)": {
                              [`&, & > ${componentCls}`]: {
                                  borderStartEndRadius: 0,
                                  borderEndEndRadius: 0
                              }
                          },
                          "&:not(:first-child)": {
                              marginInlineStart: -lineWidth,
                              [`&, & > ${componentCls}`]: {
                                  borderStartStartRadius: 0,
                                  borderEndStartRadius: 0
                              }
                          }
                      },
                      [componentCls]: {
                          position: "relative",
                          zIndex: 1,
                          "&:hover,\n          &:focus,\n          &:active": {
                              zIndex: 2
                          },
                          "&[disabled]": {
                              zIndex: 0
                          }
                      },
                      [`${componentCls}-icon-only`]: {
                          fontSize
                      }
                  }, genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor), genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover) ]
              };
          }, genSharedButtonStyle = token => {
              const {componentCls, iconCls, fontWeight} = token;
              return {
                  [componentCls]: {
                      outline: "none",
                      position: "relative",
                      display: "inline-block",
                      fontWeight,
                      whiteSpace: "nowrap",
                      textAlign: "center",
                      backgroundImage: "none",
                      backgroundColor: "transparent",
                      border: `${token.lineWidth}px ${token.lineType} transparent`,
                      cursor: "pointer",
                      transition: `all ${token.motionDurationMid} ${token.motionEaseInOut}`,
                      userSelect: "none",
                      touchAction: "manipulation",
                      lineHeight: token.lineHeight,
                      color: token.colorText,
                      "&:disabled > *": {
                          pointerEvents: "none"
                      },
                      "> span": {
                          display: "inline-block"
                      },
                      [`${componentCls}-icon`]: {
                          lineHeight: 0
                      },
                      [`> ${iconCls} + span, > span + ${iconCls}`]: {
                          marginInlineStart: token.marginXS
                      },
                      [`&:not(${componentCls}-icon-only) > ${componentCls}-icon`]: {
                          [`&${componentCls}-loading-icon, &:not(:last-child)`]: {
                              marginInlineEnd: token.marginXS
                          }
                      },
                      "> a": {
                          color: "currentColor"
                      },
                      "&:not(:disabled)": Object.assign({}, genFocusStyle(token)),
                      [`&${componentCls}-two-chinese-chars::first-letter`]: {
                          letterSpacing: "0.34em"
                      },
                      [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
                          marginInlineEnd: "-0.34em",
                          letterSpacing: "0.34em"
                      },
                      [`&-icon-only${componentCls}-compact-item`]: {
                          flex: "none"
                      },
                      [`&-compact-item${componentCls}-primary`]: {
                          [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
                              position: "relative",
                              "&:before": {
                                  position: "absolute",
                                  top: -token.lineWidth,
                                  insetInlineStart: -token.lineWidth,
                                  display: "inline-block",
                                  width: token.lineWidth,
                                  height: `calc(100% + ${2 * token.lineWidth}px)`,
                                  backgroundColor: token.colorPrimaryHover,
                                  content: '""'
                              }
                          }
                      },
                      "&-compact-vertical-item": {
                          [`&${componentCls}-primary`]: {
                              [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
                                  position: "relative",
                                  "&:before": {
                                      position: "absolute",
                                      top: -token.lineWidth,
                                      insetInlineStart: -token.lineWidth,
                                      display: "inline-block",
                                      width: `calc(100% + ${2 * token.lineWidth}px)`,
                                      height: token.lineWidth,
                                      backgroundColor: token.colorPrimaryHover,
                                      content: '""'
                                  }
                              }
                          }
                      }
                  }
              };
          }, genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({
              [`&:not(:disabled):not(${btnCls}-disabled)`]: {
                  "&:hover": hoverStyle,
                  "&:active": activeStyle
              }
          }), genCircleButtonStyle = token => ({
              minWidth: token.controlHeight,
              paddingInlineStart: 0,
              paddingInlineEnd: 0,
              borderRadius: "50%"
          }), genRoundButtonStyle = token => ({
              borderRadius: token.controlHeight,
              paddingInlineStart: token.controlHeight / 2,
              paddingInlineEnd: token.controlHeight / 2
          }), genDisabledStyle = token => ({
              cursor: "not-allowed",
              borderColor: token.borderColorDisabled,
              color: token.colorTextDisabled,
              backgroundColor: token.colorBgContainerDisabled,
              boxShadow: "none"
          }), genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
              [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
                  color: textColor || void 0,
                  backgroundColor: background,
                  borderColor: borderColor || void 0,
                  boxShadow: "none"
              }, genHoverActiveButtonStyle(btnCls, Object.assign({
                  backgroundColor: background
              }, hoverStyle), Object.assign({
                  backgroundColor: background
              }, activeStyle))), {
                  "&:disabled": {
                      cursor: "not-allowed",
                      color: textColorDisabled || void 0,
                      borderColor: borderColorDisabled || void 0
                  }
              })
          }), genSolidDisabledButtonStyle = token => ({
              [`&:disabled, &${token.componentCls}-disabled`]: Object.assign({}, genDisabledStyle(token))
          }), genSolidButtonStyle = token => Object.assign({}, genSolidDisabledButtonStyle(token)), genPureDisabledButtonStyle = token => ({
              [`&:disabled, &${token.componentCls}-disabled`]: {
                  cursor: "not-allowed",
                  color: token.colorTextDisabled
              }
          }), genDefaultButtonStyle = token => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token)), {
              backgroundColor: token.defaultBg,
              borderColor: token.defaultBorderColor,
              color: token.defaultColor,
              boxShadow: token.defaultShadow
          }), genHoverActiveButtonStyle(token.componentCls, {
              color: token.colorPrimaryHover,
              borderColor: token.colorPrimaryHover
          }, {
              color: token.colorPrimaryActive,
              borderColor: token.colorPrimaryActive
          })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.defaultGhostColor, token.defaultGhostBorderColor, token.colorTextDisabled, token.colorBorder)), {
              [`&${token.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
                  color: token.colorError,
                  borderColor: token.colorError
              }, genHoverActiveButtonStyle(token.componentCls, {
                  color: token.colorErrorHover,
                  borderColor: token.colorErrorBorderHover
              }, {
                  color: token.colorErrorActive,
                  borderColor: token.colorErrorActive
              })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.colorError, token.colorError, token.colorTextDisabled, token.colorBorder)), genSolidDisabledButtonStyle(token))
          }), genPrimaryButtonStyle = token => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token)), {
              color: token.primaryColor,
              backgroundColor: token.colorPrimary,
              boxShadow: token.primaryShadow
          }), genHoverActiveButtonStyle(token.componentCls, {
              color: token.colorTextLightSolid,
              backgroundColor: token.colorPrimaryHover
          }, {
              color: token.colorTextLightSolid,
              backgroundColor: token.colorPrimaryActive
          })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.colorPrimary, token.colorPrimary, token.colorTextDisabled, token.colorBorder, {
              color: token.colorPrimaryHover,
              borderColor: token.colorPrimaryHover
          }, {
              color: token.colorPrimaryActive,
              borderColor: token.colorPrimaryActive
          })), {
              [`&${token.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
                  backgroundColor: token.colorError,
                  boxShadow: token.dangerShadow,
                  color: token.dangerColor
              }, genHoverActiveButtonStyle(token.componentCls, {
                  backgroundColor: token.colorErrorHover
              }, {
                  backgroundColor: token.colorErrorActive
              })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.colorError, token.colorError, token.colorTextDisabled, token.colorBorder, {
                  color: token.colorErrorHover,
                  borderColor: token.colorErrorHover
              }, {
                  color: token.colorErrorActive,
                  borderColor: token.colorErrorActive
              })), genSolidDisabledButtonStyle(token))
          }), genDashedButtonStyle = token => Object.assign(Object.assign({}, genDefaultButtonStyle(token)), {
              borderStyle: "dashed"
          }), genLinkButtonStyle = token => Object.assign(Object.assign(Object.assign({
              color: token.colorLink
          }, genHoverActiveButtonStyle(token.componentCls, {
              color: token.colorLinkHover,
              backgroundColor: token.linkHoverBg
          }, {
              color: token.colorLinkActive
          })), genPureDisabledButtonStyle(token)), {
              [`&${token.componentCls}-dangerous`]: Object.assign(Object.assign({
                  color: token.colorError
              }, genHoverActiveButtonStyle(token.componentCls, {
                  color: token.colorErrorHover
              }, {
                  color: token.colorErrorActive
              })), genPureDisabledButtonStyle(token))
          }), genTextButtonStyle = token => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle(token.componentCls, {
              color: token.colorText,
              backgroundColor: token.textHoverBg
          }, {
              color: token.colorText,
              backgroundColor: token.colorBgTextActive
          })), genPureDisabledButtonStyle(token)), {
              [`&${token.componentCls}-dangerous`]: Object.assign(Object.assign({
                  color: token.colorError
              }, genPureDisabledButtonStyle(token)), genHoverActiveButtonStyle(token.componentCls, {
                  color: token.colorErrorHover,
                  backgroundColor: token.colorErrorBg
              }, {
                  color: token.colorErrorHover,
                  backgroundColor: token.colorErrorBg
              }))
          }), genTypeButtonStyle = token => {
              const {componentCls} = token;
              return {
                  [`${componentCls}-default`]: genDefaultButtonStyle(token),
                  [`${componentCls}-primary`]: genPrimaryButtonStyle(token),
                  [`${componentCls}-dashed`]: genDashedButtonStyle(token),
                  [`${componentCls}-link`]: genLinkButtonStyle(token),
                  [`${componentCls}-text`]: genTextButtonStyle(token),
                  [`${componentCls}-ghost`]: genGhostButtonStyle(token.componentCls, token.ghostBg, token.colorBgContainer, token.colorBgContainer, token.colorTextDisabled, token.colorBorder)
              };
          }, genSizeButtonStyle = function(token) {
              let sizePrefixCls = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
              const {componentCls, controlHeight, fontSize, lineHeight, lineWidth, borderRadius, buttonPaddingHorizontal, iconCls} = token;
              return [ {
                  [`${componentCls}${sizePrefixCls}`]: {
                      fontSize,
                      height: controlHeight,
                      padding: `${Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth)}px ${buttonPaddingHorizontal}px`,
                      borderRadius,
                      [`&${`${componentCls}-icon-only`}`]: {
                          width: controlHeight,
                          paddingInlineStart: 0,
                          paddingInlineEnd: 0,
                          [`&${componentCls}-round`]: {
                              width: "auto"
                          },
                          [iconCls]: {
                              fontSize: token.buttonIconOnlyFontSize
                          }
                      },
                      [`&${componentCls}-loading`]: {
                          opacity: token.opacityLoading,
                          cursor: "default"
                      },
                      [`${componentCls}-loading-icon`]: {
                          transition: `width ${token.motionDurationSlow} ${token.motionEaseInOut}, opacity ${token.motionDurationSlow} ${token.motionEaseInOut}`
                      }
                  }
              }, {
                  [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token)
              }, {
                  [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token)
              } ];
          }, genSizeBaseButtonStyle = token => genSizeButtonStyle(statistic_merge(token, {
              fontSize: token.contentFontSize
          })), genSizeSmallButtonStyle = token => {
              const smallToken = statistic_merge(token, {
                  controlHeight: token.controlHeightSM,
                  fontSize: token.contentFontSizeSM,
                  padding: token.paddingXS,
                  buttonPaddingHorizontal: token.paddingInlineSM,
                  borderRadius: token.borderRadiusSM,
                  buttonIconOnlyFontSize: token.onlyIconSizeSM
              });
              return genSizeButtonStyle(smallToken, `${token.componentCls}-sm`);
          }, genSizeLargeButtonStyle = token => {
              const largeToken = statistic_merge(token, {
                  controlHeight: token.controlHeightLG,
                  fontSize: token.contentFontSizeLG,
                  buttonPaddingHorizontal: token.paddingInlineLG,
                  borderRadius: token.borderRadiusLG,
                  buttonIconOnlyFontSize: token.onlyIconSizeLG
              });
              return genSizeButtonStyle(largeToken, `${token.componentCls}-lg`);
          }, genBlockButtonStyle = token => {
              const {componentCls} = token;
              return {
                  [componentCls]: {
                      [`&${componentCls}-block`]: {
                          width: "100%"
                      }
                  }
              };
          }, prepareToken = token => {
              const {paddingInline, onlyIconSize} = token;
              return statistic_merge(token, {
                  buttonPaddingHorizontal: paddingInline,
                  buttonIconOnlyFontSize: onlyIconSize
              });
          }, prepareComponentToken = token => ({
              fontWeight: 400,
              defaultShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlTmpOutline}`,
              primaryShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlOutline}`,
              dangerShadow: `0 ${token.controlOutlineWidth}px 0 ${token.colorErrorOutline}`,
              primaryColor: token.colorTextLightSolid,
              dangerColor: token.colorTextLightSolid,
              borderColorDisabled: token.colorBorder,
              defaultGhostColor: token.colorBgContainer,
              ghostBg: "transparent",
              defaultGhostBorderColor: token.colorBgContainer,
              paddingInline: token.paddingContentHorizontal - token.lineWidth,
              paddingInlineLG: token.paddingContentHorizontal - token.lineWidth,
              paddingInlineSM: 8 - token.lineWidth,
              onlyIconSize: token.fontSizeLG,
              onlyIconSizeSM: token.fontSizeLG - 2,
              onlyIconSizeLG: token.fontSizeLG + 2,
              groupBorderColor: token.colorPrimaryHover,
              linkHoverBg: "transparent",
              textHoverBg: token.colorBgTextHover,
              defaultColor: token.colorText,
              defaultBg: token.colorBgContainer,
              defaultBorderColor: token.colorBorder,
              defaultBorderColorDisabled: token.colorBorder,
              contentFontSize: token.fontSize,
              contentFontSizeSM: token.fontSize,
              contentFontSizeLG: token.fontSizeLG
          }), button_style = genComponentStyleHook("Button", (token => {
              const buttonToken = prepareToken(token);
              return [ genSharedButtonStyle(buttonToken), genSizeSmallButtonStyle(buttonToken), genSizeBaseButtonStyle(buttonToken), genSizeLargeButtonStyle(buttonToken), genBlockButtonStyle(buttonToken), genTypeButtonStyle(buttonToken), group(buttonToken) ];
          }), prepareComponentToken);
          function compactItemBorder(token, parentCls, options) {
              const {focusElCls, focus, borderElCls} = options, childCombinator = borderElCls ? "> *" : "", hoverEffects = [ "hover", focus ? "focus" : null, "active" ].filter(Boolean).map((n => `&:${n} ${childCombinator}`)).join(",");
              return {
                  [`&-item:not(${parentCls}-last-item)`]: {
                      marginInlineEnd: -token.lineWidth
                  },
                  "&-item": Object.assign(Object.assign({
                      [hoverEffects]: {
                          zIndex: 2
                      }
                  }, focusElCls ? {
                      [`&${focusElCls}`]: {
                          zIndex: 2
                      }
                  } : {}), {
                      [`&[disabled] ${childCombinator}`]: {
                          zIndex: 0
                      }
                  })
              };
          }
          function compactItemBorderRadius(prefixCls, parentCls, options) {
              const {borderElCls} = options, childCombinator = borderElCls ? `> ${borderElCls}` : "";
              return {
                  [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
                      borderRadius: 0
                  },
                  [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
                      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
                          borderStartEndRadius: 0,
                          borderEndEndRadius: 0
                      }
                  },
                  [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
                      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
                          borderStartStartRadius: 0,
                          borderEndStartRadius: 0
                      }
                  }
              };
          }
          function genCompactItemStyle(token) {
              let options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                  focus: !0
              };
              const {componentCls} = token, compactCls = `${componentCls}-compact`;
              return {
                  [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
              };
          }
          function compactItemVerticalBorder(token, parentCls) {
              return {
                  [`&-item:not(${parentCls}-last-item)`]: {
                      marginBottom: -token.lineWidth
                  },
                  "&-item": {
                      "&:hover,&:focus,&:active": {
                          zIndex: 2
                      },
                      "&[disabled]": {
                          zIndex: 0
                      }
                  }
              };
          }
          function genCompactItemVerticalStyle(token) {
              const compactCls = `${token.componentCls}-compact-vertical`;
              return {
                  [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token, compactCls)), (prefixCls = token.componentCls, 
                  parentCls = compactCls, {
                      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
                          borderRadius: 0
                      },
                      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
                          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
                              borderEndEndRadius: 0,
                              borderEndStartRadius: 0
                          }
                      },
                      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
                          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
                              borderStartStartRadius: 0,
                              borderStartEndRadius: 0
                          }
                      }
                  }))
              };
              var prefixCls, parentCls;
          }
          const compactCmp = ((componentName, styleFn, getDefaultToken, options) => {
              const useStyle = genComponentStyleHook(componentName, styleFn, getDefaultToken, Object.assign({
                  resetStyle: !1,
                  order: -998
              }, options));
              return _ref2 => {
                  let {prefixCls} = _ref2;
                  return useStyle(prefixCls), null;
              };
          })([ "Button", "compact" ], (token => {
              const buttonToken = prepareToken(token);
              return [ genCompactItemStyle(buttonToken), genCompactItemVerticalStyle(buttonToken) ];
          }), prepareComponentToken);
          var button_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const InternalButton = (props, ref) => {
              var _a, _b;
              const {loading = !1, prefixCls: customizePrefixCls, type = "default", danger, shape = "default", size: customizeSize, styles, disabled: customDisabled, className, rootClassName, children, icon, ghost = !1, block = !1, htmlType = "button", classNames: customClassNames, style: customStyle = {}} = props, rest = button_rest(props, [ "loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType", "classNames", "style" ]), {getPrefixCls, autoInsertSpaceInButton, direction, button} = (0, 
              react.useContext)(context_ConfigContext), prefixCls = getPrefixCls("btn", customizePrefixCls), [wrapSSR, hashId] = button_style(prefixCls), disabled = (0, 
              react.useContext)(config_provider_DisabledContext), mergedDisabled = null != customDisabled ? customDisabled : disabled, groupSize = (0, 
              react.useContext)(GroupSizeContext), loadingOrDelay = (0, react.useMemo)((() => function(loading) {
                  if ("object" == typeof loading && loading) {
                      const delay = null == loading ? void 0 : loading.delay;
                      return {
                          loading: !1,
                          delay: Number.isNaN(delay) || "number" != typeof delay ? 0 : delay
                      };
                  }
                  return {
                      loading: !!loading,
                      delay: 0
                  };
              }(loading)), [ loading ]), [innerLoading, setLoading] = (0, react.useState)(loadingOrDelay.loading), [hasTwoCNChar, setHasTwoCNChar] = (0, 
              react.useState)(!1), buttonRef = composeRef(ref, (0, react.createRef)()), needInserted = 1 === react.Children.count(children) && !icon && !isUnBorderedButtonType(type);
              (0, react.useEffect)((() => {
                  let delayTimer = null;
                  return loadingOrDelay.delay > 0 ? delayTimer = setTimeout((() => {
                      delayTimer = null, setLoading(!0);
                  }), loadingOrDelay.delay) : setLoading(loadingOrDelay.loading), function() {
                      delayTimer && (clearTimeout(delayTimer), delayTimer = null);
                  };
              }), [ loadingOrDelay ]), (0, react.useEffect)((() => {
                  if (!buttonRef || !buttonRef.current || !1 === autoInsertSpaceInButton) return;
                  const buttonText = buttonRef.current.textContent;
                  needInserted && isTwoCNChar(buttonText) ? hasTwoCNChar || setHasTwoCNChar(!0) : hasTwoCNChar && setHasTwoCNChar(!1);
              }), [ buttonRef ]);
              const handleClick = e => {
                  const {onClick} = props;
                  innerLoading || mergedDisabled ? e.preventDefault() : null == onClick || onClick(e);
              };
              const autoInsertSpace = !1 !== autoInsertSpaceInButton, {compactSize, compactItemClassnames} = ((prefixCls, direction) => {
                  const compactItemContext = react.useContext(SpaceCompactItemContext), compactItemClassnames = react.useMemo((() => {
                      if (!compactItemContext) return "";
                      const {compactDirection, isFirstItem, isLastItem} = compactItemContext, separator = "vertical" === compactDirection ? "-vertical-" : "-";
                      return classnames_default()(`${prefixCls}-compact${separator}item`, {
                          [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
                          [`${prefixCls}-compact${separator}last-item`]: isLastItem,
                          [`${prefixCls}-compact${separator}item-rtl`]: "rtl" === direction
                      });
                  }), [ prefixCls, direction, compactItemContext ]);
                  return {
                      compactSize: null == compactItemContext ? void 0 : compactItemContext.compactSize,
                      compactDirection: null == compactItemContext ? void 0 : compactItemContext.compactDirection,
                      compactItemClassnames
                  };
              })(prefixCls, direction), sizeClassNameMap = {
                  large: "lg",
                  small: "sm",
                  middle: void 0
              }, sizeFullName = hooks_useSize((ctxSize => {
                  var _a, _b;
                  return null !== (_b = null !== (_a = null != customizeSize ? customizeSize : compactSize) && void 0 !== _a ? _a : groupSize) && void 0 !== _b ? _b : ctxSize;
              })), sizeCls = sizeFullName && sizeClassNameMap[sizeFullName] || "", iconType = innerLoading ? "loading" : icon, linkButtonRestProps = omit_omit(rest, [ "navigate" ]), classes = classnames_default()(prefixCls, hashId, {
                  [`${prefixCls}-${shape}`]: "default" !== shape && shape,
                  [`${prefixCls}-${type}`]: type,
                  [`${prefixCls}-${sizeCls}`]: sizeCls,
                  [`${prefixCls}-icon-only`]: !children && 0 !== children && !!iconType,
                  [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type),
                  [`${prefixCls}-loading`]: innerLoading,
                  [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
                  [`${prefixCls}-block`]: block,
                  [`${prefixCls}-dangerous`]: !!danger,
                  [`${prefixCls}-rtl`]: "rtl" === direction
              }, compactItemClassnames, className, rootClassName, null == button ? void 0 : button.className), fullStyle = Object.assign(Object.assign({}, null == button ? void 0 : button.style), customStyle), iconClasses = classnames_default()(null == customClassNames ? void 0 : customClassNames.icon, null === (_a = null == button ? void 0 : button.classNames) || void 0 === _a ? void 0 : _a.icon), iconStyle = Object.assign(Object.assign({}, (null == styles ? void 0 : styles.icon) || {}), (null === (_b = null == button ? void 0 : button.styles) || void 0 === _b ? void 0 : _b.icon) || {}), iconNode = icon && !innerLoading ? react.createElement(button_IconWrapper, {
                  prefixCls,
                  className: iconClasses,
                  style: iconStyle
              }, icon) : react.createElement(button_LoadingIcon, {
                  existIcon: !!icon,
                  prefixCls,
                  loading: !!innerLoading
              }), kids = children || 0 === children ? spaceChildren(children, needInserted && autoInsertSpace) : null;
              if (void 0 !== linkButtonRestProps.href) return wrapSSR(react.createElement("a", Object.assign({}, linkButtonRestProps, {
                  className: classnames_default()(classes, {
                      [`${prefixCls}-disabled`]: mergedDisabled
                  }),
                  style: fullStyle,
                  onClick: handleClick,
                  ref: buttonRef
              }), iconNode, kids));
              let buttonNode = react.createElement("button", Object.assign({}, rest, {
                  type: htmlType,
                  className: classes,
                  style: fullStyle,
                  onClick: handleClick,
                  disabled: mergedDisabled,
                  ref: buttonRef
              }), iconNode, kids, compactItemClassnames && react.createElement(compactCmp, {
                  key: "compact",
                  prefixCls
              }));
              return isUnBorderedButtonType(type) || (buttonNode = react.createElement(wave, {
                  component: "Button",
                  disabled: !!innerLoading
              }, buttonNode)), wrapSSR(buttonNode);
          }, Button = (0, react.forwardRef)(InternalButton);
          Button.Group = button_group, Button.__ANT_BUTTON = !0;
          const es_button = Button;
          var propList = "".concat("accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap", " ").concat("onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError").split(/[\s\n]+/);
          function pickAttrs_match(key, prefix) {
              return 0 === key.indexOf(prefix);
          }
          const RadioGroupContext = react.createContext(null), RadioGroupContextProvider = RadioGroupContext.Provider, context = RadioGroupContext, RadioOptionTypeContext = react.createContext(null), RadioOptionTypeContextProvider = RadioOptionTypeContext.Provider;
          var es_excluded = [ "prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange" ], Checkbox = (0, 
          react.forwardRef)((function(props, ref) {
              var _classNames, _props$prefixCls = props.prefixCls, prefixCls = void 0 === _props$prefixCls ? "rc-checkbox" : _props$prefixCls, className = props.className, style = props.style, checked = props.checked, disabled = props.disabled, _props$defaultChecked = props.defaultChecked, defaultChecked = void 0 !== _props$defaultChecked && _props$defaultChecked, _props$type = props.type, type = void 0 === _props$type ? "checkbox" : _props$type, title = props.title, onChange = props.onChange, inputProps = objectWithoutProperties_objectWithoutProperties(props, es_excluded), inputRef = (0, 
              react.useRef)(null), _useMergedState2 = slicedToArray_slicedToArray(useMergedState(defaultChecked, {
                  value: checked
              }), 2), rawValue = _useMergedState2[0], setRawValue = _useMergedState2[1];
              (0, react.useImperativeHandle)(ref, (function() {
                  return {
                      focus: function() {
                          var _inputRef$current;
                          null === (_inputRef$current = inputRef.current) || void 0 === _inputRef$current || _inputRef$current.focus();
                      },
                      blur: function() {
                          var _inputRef$current2;
                          null === (_inputRef$current2 = inputRef.current) || void 0 === _inputRef$current2 || _inputRef$current2.blur();
                      },
                      input: inputRef.current
                  };
              }));
              var classString = classnames_default()(prefixCls, className, (defineProperty_defineProperty(_classNames = {}, "".concat(prefixCls, "-checked"), rawValue), 
              defineProperty_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), 
              _classNames));
              return react.createElement("span", {
                  className: classString,
                  title,
                  style
              }, react.createElement("input", _extends({}, inputProps, {
                  className: "".concat(prefixCls, "-input"),
                  ref: inputRef,
                  onChange: function(e) {
                      disabled || ("checked" in props || setRawValue(e.target.checked), null == onChange || onChange({
                          target: _objectSpread2(_objectSpread2({}, props), {}, {
                              type,
                              checked: e.target.checked
                          }),
                          stopPropagation: function() {
                              e.stopPropagation();
                          },
                          preventDefault: function() {
                              e.preventDefault();
                          },
                          nativeEvent: e.nativeEvent
                      }));
                  },
                  disabled,
                  checked: !!rawValue,
                  type
              })), react.createElement("span", {
                  className: "".concat(prefixCls, "-inner")
              }));
          }));
          const rc_checkbox_es = Checkbox;
          var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS", warningFunc = function() {
              es_warning(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
          };
          const FieldContext = react.createContext({
              getFieldValue: warningFunc,
              getFieldsValue: warningFunc,
              getFieldError: warningFunc,
              getFieldWarning: warningFunc,
              getFieldsError: warningFunc,
              isFieldsTouched: warningFunc,
              isFieldTouched: warningFunc,
              isFieldValidating: warningFunc,
              isFieldsValidating: warningFunc,
              resetFields: warningFunc,
              setFields: warningFunc,
              setFieldValue: warningFunc,
              setFieldsValue: warningFunc,
              validateFields: warningFunc,
              submit: warningFunc,
              getInternalHooks: function() {
                  return warningFunc(), {
                      dispatch: warningFunc,
                      initEntityValue: warningFunc,
                      registerField: warningFunc,
                      useSubscribe: warningFunc,
                      setInitialValues: warningFunc,
                      destroyForm: warningFunc,
                      setCallbacks: warningFunc,
                      registerWatch: warningFunc,
                      getFields: warningFunc,
                      setValidateMessages: warningFunc,
                      setPreserve: warningFunc,
                      getInitialValue: warningFunc
                  };
              }
          });
          const es_ListContext = react.createContext(null);
          function typeUtil_toArray(value) {
              return null == value ? [] : Array.isArray(value) ? value : [ value ];
          }
          function dist_web_extends() {
              return dist_web_extends = Object.assign ? Object.assign.bind() : function(target) {
                  for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                  }
                  return target;
              }, dist_web_extends.apply(this, arguments);
          }
          function dist_web_getPrototypeOf(o) {
              return dist_web_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(o) {
                  return o.__proto__ || Object.getPrototypeOf(o);
              }, dist_web_getPrototypeOf(o);
          }
          function dist_web_setPrototypeOf(o, p) {
              return dist_web_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, p) {
                  return o.__proto__ = p, o;
              }, dist_web_setPrototypeOf(o, p);
          }
          function _construct(Parent, args, Class) {
              return _construct = function() {
                  if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                  if (Reflect.construct.sham) return !1;
                  if ("function" == typeof Proxy) return !0;
                  try {
                      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), 
                      !0;
                  } catch (e) {
                      return !1;
                  }
              }() ? Reflect.construct.bind() : function(Parent, args, Class) {
                  var a = [ null ];
                  a.push.apply(a, args);
                  var instance = new (Function.bind.apply(Parent, a));
                  return Class && dist_web_setPrototypeOf(instance, Class.prototype), instance;
              }, _construct.apply(null, arguments);
          }
          function _wrapNativeSuper(Class) {
              var _cache = "function" == typeof Map ? new Map : void 0;
              return _wrapNativeSuper = function(Class) {
                  if (null === Class || (fn = Class, -1 === Function.toString.call(fn).indexOf("[native code]"))) return Class;
                  var fn;
                  if ("function" != typeof Class) throw new TypeError("Super expression must either be null or a function");
                  if (void 0 !== _cache) {
                      if (_cache.has(Class)) return _cache.get(Class);
                      _cache.set(Class, Wrapper);
                  }
                  function Wrapper() {
                      return _construct(Class, arguments, dist_web_getPrototypeOf(this).constructor);
                  }
                  return Wrapper.prototype = Object.create(Class.prototype, {
                      constructor: {
                          value: Wrapper,
                          enumerable: !1,
                          writable: !0,
                          configurable: !0
                      }
                  }), dist_web_setPrototypeOf(Wrapper, Class);
              }, _wrapNativeSuper(Class);
          }
          var formatRegExp = /%[sdj%]/g;
          function convertFieldsError(errors) {
              if (!errors || !errors.length) return null;
              var fields = {};
              return errors.forEach((function(error) {
                  var field = error.field;
                  fields[field] = fields[field] || [], fields[field].push(error);
              })), fields;
          }
          function dist_web_format(template) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
              var i = 0, len = args.length;
              if ("function" == typeof template) return template.apply(null, args);
              if ("string" == typeof template) {
                  var str = template.replace(formatRegExp, (function(x) {
                      if ("%%" === x) return "%";
                      if (i >= len) return x;
                      switch (x) {
                        case "%s":
                          return String(args[i++]);

                        case "%d":
                          return Number(args[i++]);

                        case "%j":
                          try {
                              return JSON.stringify(args[i++]);
                          } catch (_) {
                              return "[Circular]";
                          }
                          break;

                        default:
                          return x;
                      }
                  }));
                  return str;
              }
              return template;
          }
          function isEmptyValue(value, type) {
              return null == value || (!("array" !== type || !Array.isArray(value) || value.length) || !(!function(type) {
                  return "string" === type || "url" === type || "hex" === type || "email" === type || "date" === type || "pattern" === type;
              }(type) || "string" != typeof value || value));
          }
          function asyncSerialArray(arr, func, callback) {
              var index = 0, arrLength = arr.length;
              !function next(errors) {
                  if (errors && errors.length) callback(errors); else {
                      var original = index;
                      index += 1, original < arrLength ? func(arr[original], next) : callback([]);
                  }
              }([]);
          }
          "undefined" != typeof process && process.env;
          var AsyncValidationError = function(_Error) {
              var subClass, superClass;
              function AsyncValidationError(errors, fields) {
                  var _this;
                  return (_this = _Error.call(this, "Async Validation Error") || this).errors = errors, 
                  _this.fields = fields, _this;
              }
              return superClass = _Error, (subClass = AsyncValidationError).prototype = Object.create(superClass.prototype), 
              subClass.prototype.constructor = subClass, dist_web_setPrototypeOf(subClass, superClass), 
              AsyncValidationError;
          }(_wrapNativeSuper(Error));
          function asyncMap(objArr, option, func, callback, source) {
              if (option.first) {
                  var _pending = new Promise((function(resolve, reject) {
                      var flattenArr = function(objArr) {
                          var ret = [];
                          return Object.keys(objArr).forEach((function(k) {
                              ret.push.apply(ret, objArr[k] || []);
                          })), ret;
                      }(objArr);
                      asyncSerialArray(flattenArr, func, (function(errors) {
                          return callback(errors), errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
                      }));
                  }));
                  return _pending.catch((function(e) {
                      return e;
                  })), _pending;
              }
              var firstFields = !0 === option.firstFields ? Object.keys(objArr) : option.firstFields || [], objArrKeys = Object.keys(objArr), objArrLength = objArrKeys.length, total = 0, results = [], pending = new Promise((function(resolve, reject) {
                  var next = function(errors) {
                      if (results.push.apply(results, errors), ++total === objArrLength) return callback(results), 
                      results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
                  };
                  objArrKeys.length || (callback(results), resolve(source)), objArrKeys.forEach((function(key) {
                      var arr = objArr[key];
                      -1 !== firstFields.indexOf(key) ? asyncSerialArray(arr, func, next) : function(arr, func, callback) {
                          var results = [], total = 0, arrLength = arr.length;
                          function count(errors) {
                              results.push.apply(results, errors || []), ++total === arrLength && callback(results);
                          }
                          arr.forEach((function(a) {
                              func(a, count);
                          }));
                      }(arr, func, next);
                  }));
              }));
              return pending.catch((function(e) {
                  return e;
              })), pending;
          }
          function complementError(rule, source) {
              return function(oe) {
                  var fieldValue, obj;
                  return fieldValue = rule.fullFields ? function(value, path) {
                      for (var v = value, i = 0; i < path.length; i++) {
                          if (null == v) return v;
                          v = v[path[i]];
                      }
                      return v;
                  }(source, rule.fullFields) : source[oe.field || rule.fullField], (obj = oe) && void 0 !== obj.message ? (oe.field = oe.field || rule.fullField, 
                  oe.fieldValue = fieldValue, oe) : {
                      message: "function" == typeof oe ? oe() : oe,
                      fieldValue,
                      field: oe.field || rule.fullField
                  };
              };
          }
          function deepMerge(target, source) {
              if (source) for (var s in source) if (source.hasOwnProperty(s)) {
                  var value = source[s];
                  "object" == typeof value && "object" == typeof target[s] ? target[s] = dist_web_extends({}, target[s], value) : target[s] = value;
              }
              return target;
          }
          var urlReg, required$1 = function(rule, value, source, errors, options, type) {
              !rule.required || source.hasOwnProperty(rule.field) && !isEmptyValue(value, type || rule.type) || errors.push(dist_web_format(options.messages.required, rule.fullField));
          }, pattern$2_email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, pattern$2_hex = /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i, types = {
              integer: function(value) {
                  return types.number(value) && parseInt(value, 10) === value;
              },
              float: function(value) {
                  return types.number(value) && !types.integer(value);
              },
              array: function(value) {
                  return Array.isArray(value);
              },
              regexp: function(value) {
                  if (value instanceof RegExp) return !0;
                  try {
                      return !!new RegExp(value);
                  } catch (e) {
                      return !1;
                  }
              },
              date: function(value) {
                  return "function" == typeof value.getTime && "function" == typeof value.getMonth && "function" == typeof value.getYear && !isNaN(value.getTime());
              },
              number: function(value) {
                  return !isNaN(value) && "number" == typeof value;
              },
              object: function(value) {
                  return "object" == typeof value && !types.array(value);
              },
              method: function(value) {
                  return "function" == typeof value;
              },
              email: function(value) {
                  return "string" == typeof value && value.length <= 320 && !!value.match(pattern$2_email);
              },
              url: function(value) {
                  return "string" == typeof value && value.length <= 2048 && !!value.match(function() {
                      if (urlReg) return urlReg;
                      var b = function(options) {
                          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=[a-fA-F\\d:])|(?<=[a-fA-F\\d:])(?=\\s|$))" : "";
                      }, v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", v6seg = "[a-fA-F\\d]{1,4}", v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)"), v4exact = new RegExp("^" + v4 + "$"), v6exact = new RegExp("^" + v6 + "$"), ip = function(options) {
                          return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
                      };
                      ip.v4 = function(options) {
                          return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
                      }, ip.v6 = function(options) {
                          return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
                      };
                      var ipv4 = ip.v4().source, ipv6 = ip.v6().source;
                      return urlReg = new RegExp("(?:^(?:(?:(?:[a-z]+:)?//)|www\\.)(?:\\S+(?::\\S*)?@)?(?:localhost|" + ipv4 + "|" + ipv6 + '|(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#][^\\s"]*)?$)', "i");
                  }());
              },
              hex: function(value) {
                  return "string" == typeof value && !!value.match(pattern$2_hex);
              }
          }, rules = {
              required: required$1,
              whitespace: function(rule, value, source, errors, options) {
                  (/^\s+$/.test(value) || "" === value) && errors.push(dist_web_format(options.messages.whitespace, rule.fullField));
              },
              type: function(rule, value, source, errors, options) {
                  if (rule.required && void 0 === value) required$1(rule, value, source, errors, options); else {
                      var ruleType = rule.type;
                      [ "integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex" ].indexOf(ruleType) > -1 ? types[ruleType](value) || errors.push(dist_web_format(options.messages.types[ruleType], rule.fullField, rule.type)) : ruleType && typeof value !== rule.type && errors.push(dist_web_format(options.messages.types[ruleType], rule.fullField, rule.type));
                  }
              },
              range: function(rule, value, source, errors, options) {
                  var len = "number" == typeof rule.len, min = "number" == typeof rule.min, max = "number" == typeof rule.max, val = value, key = null, num = "number" == typeof value, str = "string" == typeof value, arr = Array.isArray(value);
                  if (num ? key = "number" : str ? key = "string" : arr && (key = "array"), !key) return !1;
                  arr && (val = value.length), str && (val = value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length), 
                  len ? val !== rule.len && errors.push(dist_web_format(options.messages[key].len, rule.fullField, rule.len)) : min && !max && val < rule.min ? errors.push(dist_web_format(options.messages[key].min, rule.fullField, rule.min)) : max && !min && val > rule.max ? errors.push(dist_web_format(options.messages[key].max, rule.fullField, rule.max)) : min && max && (val < rule.min || val > rule.max) && errors.push(dist_web_format(options.messages[key].range, rule.fullField, rule.min, rule.max));
              },
              enum: function(rule, value, source, errors, options) {
                  rule.enum = Array.isArray(rule.enum) ? rule.enum : [], -1 === rule.enum.indexOf(value) && errors.push(dist_web_format(options.messages.enum, rule.fullField, rule.enum.join(", ")));
              },
              pattern: function(rule, value, source, errors, options) {
                  if (rule.pattern) if (rule.pattern instanceof RegExp) rule.pattern.lastIndex = 0, 
                  rule.pattern.test(value) || errors.push(dist_web_format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern)); else if ("string" == typeof rule.pattern) {
                      new RegExp(rule.pattern).test(value) || errors.push(dist_web_format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
                  }
              }
          }, dist_web_type = function(rule, value, callback, source, options) {
              var ruleType = rule.type, errors = [];
              if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                  if (isEmptyValue(value, ruleType) && !rule.required) return callback();
                  rules.required(rule, value, source, errors, options, ruleType), isEmptyValue(value, ruleType) || rules.type(rule, value, source, errors, options);
              }
              callback(errors);
          }, validators = {
              string: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value, "string") && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options, "string"), isEmptyValue(value, "string") || (rules.type(rule, value, source, errors, options), 
                      rules.range(rule, value, source, errors, options), rules.pattern(rule, value, source, errors, options), 
                      !0 === rule.whitespace && rules.whitespace(rule, value, source, errors, options));
                  }
                  callback(errors);
              },
              method: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && rules.type(rule, value, source, errors, options);
                  }
                  callback(errors);
              },
              number: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if ("" === value && (value = void 0), isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && (rules.type(rule, value, source, errors, options), 
                      rules.range(rule, value, source, errors, options));
                  }
                  callback(errors);
              },
              boolean: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && rules.type(rule, value, source, errors, options);
                  }
                  callback(errors);
              },
              regexp: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), isEmptyValue(value) || rules.type(rule, value, source, errors, options);
                  }
                  callback(errors);
              },
              integer: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && (rules.type(rule, value, source, errors, options), 
                      rules.range(rule, value, source, errors, options));
                  }
                  callback(errors);
              },
              float: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && (rules.type(rule, value, source, errors, options), 
                      rules.range(rule, value, source, errors, options));
                  }
                  callback(errors);
              },
              array: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (null == value && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options, "array"), null != value && (rules.type(rule, value, source, errors, options), 
                      rules.range(rule, value, source, errors, options));
                  }
                  callback(errors);
              },
              object: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && rules.type(rule, value, source, errors, options);
                  }
                  callback(errors);
              },
              enum: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), void 0 !== value && rules.enum(rule, value, source, errors, options);
                  }
                  callback(errors);
              },
              pattern: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value, "string") && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options), isEmptyValue(value, "string") || rules.pattern(rule, value, source, errors, options);
                  }
                  callback(errors);
              },
              date: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value, "date") && !rule.required) return callback();
                      var dateObject;
                      if (rules.required(rule, value, source, errors, options), !isEmptyValue(value, "date")) dateObject = value instanceof Date ? value : new Date(value), 
                      rules.type(rule, dateObject, source, errors, options), dateObject && rules.range(rule, dateObject.getTime(), source, errors, options);
                  }
                  callback(errors);
              },
              url: dist_web_type,
              hex: dist_web_type,
              email: dist_web_type,
              required: function(rule, value, callback, source, options) {
                  var errors = [], type = Array.isArray(value) ? "array" : typeof value;
                  rules.required(rule, value, source, errors, options, type), callback(errors);
              },
              any: function(rule, value, callback, source, options) {
                  var errors = [];
                  if (rule.required || !rule.required && source.hasOwnProperty(rule.field)) {
                      if (isEmptyValue(value) && !rule.required) return callback();
                      rules.required(rule, value, source, errors, options);
                  }
                  callback(errors);
              }
          };
          function newMessages() {
              return {
                  default: "Validation error on field %s",
                  required: "%s is required",
                  enum: "%s must be one of %s",
                  whitespace: "%s cannot be empty",
                  date: {
                      format: "%s date %s is invalid for format %s",
                      parse: "%s date could not be parsed, %s is invalid ",
                      invalid: "%s date %s is invalid"
                  },
                  types: {
                      string: "%s is not a %s",
                      method: "%s is not a %s (function)",
                      array: "%s is not an %s",
                      object: "%s is not an %s",
                      number: "%s is not a %s",
                      date: "%s is not a %s",
                      boolean: "%s is not a %s",
                      integer: "%s is not an %s",
                      float: "%s is not a %s",
                      regexp: "%s is not a valid %s",
                      email: "%s is not a valid %s",
                      url: "%s is not a valid %s",
                      hex: "%s is not a valid %s"
                  },
                  string: {
                      len: "%s must be exactly %s characters",
                      min: "%s must be at least %s characters",
                      max: "%s cannot be longer than %s characters",
                      range: "%s must be between %s and %s characters"
                  },
                  number: {
                      len: "%s must equal %s",
                      min: "%s cannot be less than %s",
                      max: "%s cannot be greater than %s",
                      range: "%s must be between %s and %s"
                  },
                  array: {
                      len: "%s must be exactly %s in length",
                      min: "%s cannot be less than %s in length",
                      max: "%s cannot be greater than %s in length",
                      range: "%s must be between %s and %s in length"
                  },
                  pattern: {
                      mismatch: "%s value %s does not match pattern %s"
                  },
                  clone: function() {
                      var cloned = JSON.parse(JSON.stringify(this));
                      return cloned.clone = this.clone, cloned;
                  }
              };
          }
          var messages = newMessages(), Schema = function() {
              function Schema(descriptor) {
                  this.rules = null, this._messages = messages, this.define(descriptor);
              }
              var _proto = Schema.prototype;
              return _proto.define = function(rules) {
                  var _this = this;
                  if (!rules) throw new Error("Cannot configure a schema with no rules");
                  if ("object" != typeof rules || Array.isArray(rules)) throw new Error("Rules must be an object");
                  this.rules = {}, Object.keys(rules).forEach((function(name) {
                      var item = rules[name];
                      _this.rules[name] = Array.isArray(item) ? item : [ item ];
                  }));
              }, _proto.messages = function(_messages) {
                  return _messages && (this._messages = deepMerge(newMessages(), _messages)), this._messages;
              }, _proto.validate = function(source_, o, oc) {
                  var _this2 = this;
                  void 0 === o && (o = {}), void 0 === oc && (oc = function() {});
                  var source = source_, options = o, callback = oc;
                  if ("function" == typeof options && (callback = options, options = {}), !this.rules || 0 === Object.keys(this.rules).length) return callback && callback(null, source), 
                  Promise.resolve(source);
                  if (options.messages) {
                      var messages$1 = this.messages();
                      messages$1 === messages && (messages$1 = newMessages()), deepMerge(messages$1, options.messages), 
                      options.messages = messages$1;
                  } else options.messages = this.messages();
                  var series = {};
                  (options.keys || Object.keys(this.rules)).forEach((function(z) {
                      var arr = _this2.rules[z], value = source[z];
                      arr.forEach((function(r) {
                          var rule = r;
                          "function" == typeof rule.transform && (source === source_ && (source = dist_web_extends({}, source)), 
                          value = source[z] = rule.transform(value)), (rule = "function" == typeof rule ? {
                              validator: rule
                          } : dist_web_extends({}, rule)).validator = _this2.getValidationMethod(rule), rule.validator && (rule.field = z, 
                          rule.fullField = rule.fullField || z, rule.type = _this2.getType(rule), series[z] = series[z] || [], 
                          series[z].push({
                              rule,
                              value,
                              source,
                              field: z
                          }));
                      }));
                  }));
                  var errorFields = {};
                  return asyncMap(series, options, (function(data, doIt) {
                      var res, rule = data.rule, deep = !("object" !== rule.type && "array" !== rule.type || "object" != typeof rule.fields && "object" != typeof rule.defaultField);
                      function addFullField(key, schema) {
                          return dist_web_extends({}, schema, {
                              fullField: rule.fullField + "." + key,
                              fullFields: rule.fullFields ? [].concat(rule.fullFields, [ key ]) : [ key ]
                          });
                      }
                      function cb(e) {
                          void 0 === e && (e = []);
                          var errorList = Array.isArray(e) ? e : [ e ];
                          !options.suppressWarning && errorList.length && Schema.warning("async-validator:", errorList), 
                          errorList.length && void 0 !== rule.message && (errorList = [].concat(rule.message));
                          var filledErrors = errorList.map(complementError(rule, source));
                          if (options.first && filledErrors.length) return errorFields[rule.field] = 1, doIt(filledErrors);
                          if (deep) {
                              if (rule.required && !data.value) return void 0 !== rule.message ? filledErrors = [].concat(rule.message).map(complementError(rule, source)) : options.error && (filledErrors = [ options.error(rule, dist_web_format(options.messages.required, rule.field)) ]), 
                              doIt(filledErrors);
                              var fieldsSchema = {};
                              rule.defaultField && Object.keys(data.value).map((function(key) {
                                  fieldsSchema[key] = rule.defaultField;
                              })), fieldsSchema = dist_web_extends({}, fieldsSchema, data.rule.fields);
                              var paredFieldsSchema = {};
                              Object.keys(fieldsSchema).forEach((function(field) {
                                  var fieldSchema = fieldsSchema[field], fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [ fieldSchema ];
                                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                              }));
                              var schema = new Schema(paredFieldsSchema);
                              schema.messages(options.messages), data.rule.options && (data.rule.options.messages = options.messages, 
                              data.rule.options.error = options.error), schema.validate(data.value, data.rule.options || options, (function(errs) {
                                  var finalErrors = [];
                                  filledErrors && filledErrors.length && finalErrors.push.apply(finalErrors, filledErrors), 
                                  errs && errs.length && finalErrors.push.apply(finalErrors, errs), doIt(finalErrors.length ? finalErrors : null);
                              }));
                          } else doIt(filledErrors);
                      }
                      if (deep = deep && (rule.required || !rule.required && data.value), rule.field = data.field, 
                      rule.asyncValidator) res = rule.asyncValidator(rule, data.value, cb, data.source, options); else if (rule.validator) {
                          try {
                              res = rule.validator(rule, data.value, cb, data.source, options);
                          } catch (error) {
                              null == console.error || console.error(error), options.suppressValidatorError || setTimeout((function() {
                                  throw error;
                              }), 0), cb(error.message);
                          }
                          !0 === res ? cb() : !1 === res ? cb("function" == typeof rule.message ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails") : res instanceof Array ? cb(res) : res instanceof Error && cb(res.message);
                      }
                      res && res.then && res.then((function() {
                          return cb();
                      }), (function(e) {
                          return cb(e);
                      }));
                  }), (function(results) {
                      !function(results) {
                          for (var e, _errors, errors = [], fields = {}, i = 0; i < results.length; i++) e = results[i], 
                          _errors = void 0, Array.isArray(e) ? errors = (_errors = errors).concat.apply(_errors, e) : errors.push(e);
                          errors.length ? (fields = convertFieldsError(errors), callback(errors, fields)) : callback(null, source);
                      }(results);
                  }), source);
              }, _proto.getType = function(rule) {
                  if (void 0 === rule.type && rule.pattern instanceof RegExp && (rule.type = "pattern"), 
                  "function" != typeof rule.validator && rule.type && !validators.hasOwnProperty(rule.type)) throw new Error(dist_web_format("Unknown rule type %s", rule.type));
                  return rule.type || "string";
              }, _proto.getValidationMethod = function(rule) {
                  if ("function" == typeof rule.validator) return rule.validator;
                  var keys = Object.keys(rule), messageIndex = keys.indexOf("message");
                  return -1 !== messageIndex && keys.splice(messageIndex, 1), 1 === keys.length && "required" === keys[0] ? validators.required : validators[this.getType(rule)] || void 0;
              }, Schema;
          }();
          Schema.register = function(type, validator) {
              if ("function" != typeof validator) throw new Error("Cannot register a validator by type, validator is not a function");
              validators[type] = validator;
          }, Schema.warning = function() {}, Schema.messages = messages, Schema.validators = validators;
          var messages_typeTemplate = "'${name}' is not a valid ${type}", defaultValidateMessages = {
              default: "Validation error on field '${name}'",
              required: "'${name}' is required",
              enum: "'${name}' must be one of [${enum}]",
              whitespace: "'${name}' cannot be empty",
              date: {
                  format: "'${name}' is invalid for format date",
                  parse: "'${name}' could not be parsed as date",
                  invalid: "'${name}' is invalid date"
              },
              types: {
                  string: messages_typeTemplate,
                  method: messages_typeTemplate,
                  array: messages_typeTemplate,
                  object: messages_typeTemplate,
                  number: messages_typeTemplate,
                  date: messages_typeTemplate,
                  boolean: messages_typeTemplate,
                  integer: messages_typeTemplate,
                  float: messages_typeTemplate,
                  regexp: messages_typeTemplate,
                  email: messages_typeTemplate,
                  url: messages_typeTemplate,
                  hex: messages_typeTemplate
              },
              string: {
                  len: "'${name}' must be exactly ${len} characters",
                  min: "'${name}' must be at least ${min} characters",
                  max: "'${name}' cannot be longer than ${max} characters",
                  range: "'${name}' must be between ${min} and ${max} characters"
              },
              number: {
                  len: "'${name}' must equal ${len}",
                  min: "'${name}' cannot be less than ${min}",
                  max: "'${name}' cannot be greater than ${max}",
                  range: "'${name}' must be between ${min} and ${max}"
              },
              array: {
                  len: "'${name}' must be exactly ${len} in length",
                  min: "'${name}' cannot be less than ${min} in length",
                  max: "'${name}' cannot be greater than ${max} in length",
                  range: "'${name}' must be between ${min} and ${max} in length"
              },
              pattern: {
                  mismatch: "'${name}' does not match pattern ${pattern}"
              }
          }, AsyncValidator = Schema;
          function replaceMessage(template, kv) {
              return template.replace(/\$\{\w+\}/g, (function(str) {
                  var key = str.slice(2, -1);
                  return kv[key];
              }));
          }
          var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
          function validateRule(_x, _x2, _x3, _x4, _x5) {
              return _validateRule.apply(this, arguments);
          }
          function _validateRule() {
              return _validateRule = _asyncToGenerator(_regeneratorRuntime().mark((function _callee2(name, value, rule, options, messageVariables) {
                  var cloneRule, originValidator, subRuleField, validator, messages, result, subResults, kv, fillVariableResult;
                  return _regeneratorRuntime().wrap((function(_context2) {
                      for (;;) switch (_context2.prev = _context2.next) {
                        case 0:
                          return delete (cloneRule = _objectSpread2({}, rule)).ruleIndex, AsyncValidator.warning = function() {}, 
                          cloneRule.validator && (originValidator = cloneRule.validator, cloneRule.validator = function() {
                              try {
                                  return originValidator.apply(void 0, arguments);
                              } catch (error) {
                                  return console.error(error), Promise.reject(CODE_LOGIC_ERROR);
                              }
                          }), subRuleField = null, cloneRule && "array" === cloneRule.type && cloneRule.defaultField && (subRuleField = cloneRule.defaultField, 
                          delete cloneRule.defaultField), validator = new AsyncValidator(defineProperty_defineProperty({}, name, [ cloneRule ])), 
                          messages = merge(defaultValidateMessages, options.validateMessages), validator.messages(messages), 
                          result = [], _context2.prev = 10, _context2.next = 13, Promise.resolve(validator.validate(defineProperty_defineProperty({}, name, value), _objectSpread2({}, options)));

                        case 13:
                          _context2.next = 18;
                          break;

                        case 15:
                          _context2.prev = 15, _context2.t0 = _context2.catch(10), _context2.t0.errors && (result = _context2.t0.errors.map((function(_ref4, index) {
                              var message = _ref4.message, mergedMessage = message === CODE_LOGIC_ERROR ? messages.default : message;
                              return react.isValidElement(mergedMessage) ? react.cloneElement(mergedMessage, {
                                  key: "error_".concat(index)
                              }) : mergedMessage;
                          })));

                        case 18:
                          if (result.length || !subRuleField) {
                              _context2.next = 23;
                              break;
                          }
                          return _context2.next = 21, Promise.all(value.map((function(subValue, i) {
                              return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
                          })));

                        case 21:
                          return subResults = _context2.sent, _context2.abrupt("return", subResults.reduce((function(prev, errors) {
                              return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));
                          }), []));

                        case 23:
                          return kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                              name,
                              enum: (rule.enum || []).join(", ")
                          }, messageVariables), fillVariableResult = result.map((function(error) {
                              return "string" == typeof error ? replaceMessage(error, kv) : error;
                          })), _context2.abrupt("return", fillVariableResult);

                        case 26:
                        case "end":
                          return _context2.stop();
                      }
                  }), _callee2, null, [ [ 10, 15 ] ]);
              }))), _validateRule.apply(this, arguments);
          }
          function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
              var summaryPromise, name = namePath.join("."), filledRules = rules.map((function(currentRule, ruleIndex) {
                  var originValidatorFunc = currentRule.validator, cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
                      ruleIndex
                  });
                  return originValidatorFunc && (cloneRule.validator = function(rule, val, callback) {
                      var hasPromise = !1, promise = originValidatorFunc(rule, val, (function() {
                          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                          Promise.resolve().then((function() {
                              es_warning(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored."), 
                              hasPromise || callback.apply(void 0, args);
                          }));
                      }));
                      hasPromise = promise && "function" == typeof promise.then && "function" == typeof promise.catch, 
                      es_warning(hasPromise, "`callback` is deprecated. Please return a promise instead."), 
                      hasPromise && promise.then((function() {
                          callback();
                      })).catch((function(err) {
                          callback(err || " ");
                      }));
                  }), cloneRule;
              })).sort((function(_ref, _ref2) {
                  var w1 = _ref.warningOnly, i1 = _ref.ruleIndex, w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
                  return !!w1 == !!w2 ? i1 - i2 : w1 ? 1 : -1;
              }));
              if (!0 === validateFirst) summaryPromise = new Promise(function() {
                  var _ref3 = _asyncToGenerator(_regeneratorRuntime().mark((function _callee(resolve, reject) {
                      var i, rule, errors;
                      return _regeneratorRuntime().wrap((function(_context) {
                          for (;;) switch (_context.prev = _context.next) {
                            case 0:
                              i = 0;

                            case 1:
                              if (!(i < filledRules.length)) {
                                  _context.next = 12;
                                  break;
                              }
                              return rule = filledRules[i], _context.next = 5, validateRule(name, value, rule, options, messageVariables);

                            case 5:
                              if (!(errors = _context.sent).length) {
                                  _context.next = 9;
                                  break;
                              }
                              return reject([ {
                                  errors,
                                  rule
                              } ]), _context.abrupt("return");

                            case 9:
                              i += 1, _context.next = 1;
                              break;

                            case 12:
                              resolve([]);

                            case 13:
                            case "end":
                              return _context.stop();
                          }
                      }), _callee);
                  })));
                  return function(_x6, _x7) {
                      return _ref3.apply(this, arguments);
                  };
              }()); else {
                  var rulePromises = filledRules.map((function(rule) {
                      return validateRule(name, value, rule, options, messageVariables).then((function(errors) {
                          return {
                              errors,
                              rule
                          };
                      }));
                  }));
                  summaryPromise = (validateFirst ? function(_x9) {
                      return _finishOnFirstFailed.apply(this, arguments);
                  }(rulePromises) : function(_x8) {
                      return _finishOnAllFailed.apply(this, arguments);
                  }(rulePromises)).then((function(errors) {
                      return Promise.reject(errors);
                  }));
              }
              return summaryPromise.catch((function(e) {
                  return e;
              })), summaryPromise;
          }
          function _finishOnAllFailed() {
              return (_finishOnAllFailed = _asyncToGenerator(_regeneratorRuntime().mark((function _callee3(rulePromises) {
                  return _regeneratorRuntime().wrap((function(_context3) {
                      for (;;) switch (_context3.prev = _context3.next) {
                        case 0:
                          return _context3.abrupt("return", Promise.all(rulePromises).then((function(errorsList) {
                              var _ref5;
                              return (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                          })));

                        case 1:
                        case "end":
                          return _context3.stop();
                      }
                  }), _callee3);
              })))).apply(this, arguments);
          }
          function _finishOnFirstFailed() {
              return _finishOnFirstFailed = _asyncToGenerator(_regeneratorRuntime().mark((function _callee4(rulePromises) {
                  var count;
                  return _regeneratorRuntime().wrap((function(_context4) {
                      for (;;) switch (_context4.prev = _context4.next) {
                        case 0:
                          return count = 0, _context4.abrupt("return", new Promise((function(resolve) {
                              rulePromises.forEach((function(promise) {
                                  promise.then((function(ruleError) {
                                      ruleError.errors.length && resolve([ ruleError ]), (count += 1) === rulePromises.length && resolve([]);
                                  }));
                              }));
                          })));

                        case 2:
                        case "end":
                          return _context4.stop();
                      }
                  }), _callee4);
              }))), _finishOnFirstFailed.apply(this, arguments);
          }
          function getNamePath(path) {
              return typeUtil_toArray(path);
          }
          function cloneByNamePathList(store, namePathList) {
              var newStore = {};
              return namePathList.forEach((function(namePath) {
                  var value = get(store, namePath);
                  newStore = set(newStore, namePath, value);
              })), newStore;
          }
          function containsNamePath(namePathList, namePath) {
              var partialMatch = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
              return namePathList && namePathList.some((function(path) {
                  return matchNamePath(namePath, path, partialMatch);
              }));
          }
          function matchNamePath(namePath, subNamePath) {
              return !(!namePath || !subNamePath) && (!(!(arguments.length > 2 && void 0 !== arguments[2] && arguments[2]) && namePath.length !== subNamePath.length) && subNamePath.every((function(nameUnit, i) {
                  return namePath[i] === nameUnit;
              })));
          }
          function defaultGetValueFromEvent(valuePropName) {
              var event = arguments.length <= 1 ? void 0 : arguments[1];
              return event && event.target && "object" === _typeof(event.target) && valuePropName in event.target ? event.target[valuePropName] : event;
          }
          function valueUtil_move(array, moveIndex, toIndex) {
              var length = array.length;
              if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) return array;
              var item = array[moveIndex], diff = moveIndex - toIndex;
              return diff > 0 ? [].concat(_toConsumableArray(array.slice(0, toIndex)), [ item ], _toConsumableArray(array.slice(toIndex, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, length))) : diff < 0 ? [].concat(_toConsumableArray(array.slice(0, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, toIndex + 1)), [ item ], _toConsumableArray(array.slice(toIndex + 1, length))) : array;
          }
          var Field_excluded = [ "name" ], EMPTY_ERRORS = [];
          function requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {
              return "function" == typeof shouldUpdate ? shouldUpdate(prev, next, "source" in info ? {
                  source: info.source
              } : {}) : prevValue !== nextValue;
          }
          var Field = function(_React$Component) {
              _inherits(Field, _React$Component);
              var _super = _createSuper(Field);
              function Field(props) {
                  var _this;
                  (_classCallCheck(this, Field), defineProperty_defineProperty(_assertThisInitialized(_this = _super.call(this, props)), "state", {
                      resetCount: 0
                  }), defineProperty_defineProperty(_assertThisInitialized(_this), "cancelRegisterFunc", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "mounted", !1), defineProperty_defineProperty(_assertThisInitialized(_this), "touched", !1), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "dirty", !1), defineProperty_defineProperty(_assertThisInitialized(_this), "validatePromise", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "prevValidating", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "errors", EMPTY_ERRORS), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "cancelRegister", (function() {
                      var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
                      _this.cancelRegisterFunc && _this.cancelRegisterFunc(isListField, preserve, getNamePath(name)), 
                      _this.cancelRegisterFunc = null;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getNamePath", (function() {
                      var _this$props2 = _this.props, name = _this$props2.name, _fieldContext$prefixN = _this$props2.fieldContext.prefixName;
                      return void 0 !== name ? [].concat(_toConsumableArray(void 0 === _fieldContext$prefixN ? [] : _fieldContext$prefixN), _toConsumableArray(name)) : [];
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getRules", (function() {
                      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules = void 0 === _this$props3$rules ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
                      return rules.map((function(rule) {
                          return "function" == typeof rule ? rule(fieldContext) : rule;
                      }));
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "refresh", (function() {
                      _this.mounted && _this.setState((function(_ref) {
                          return {
                              resetCount: _ref.resetCount + 1
                          };
                      }));
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "metaCache", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "triggerMetaEvent", (function(destroy) {
                      var onMetaChange = _this.props.onMetaChange;
                      if (onMetaChange) {
                          var _meta = _objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
                              destroy
                          });
                          es_isEqual(_this.metaCache, _meta) || onMetaChange(_meta), _this.metaCache = _meta;
                      } else _this.metaCache = null;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "onStoreChange", (function(prevStore, namePathList, info) {
                      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = void 0 === _this$props4$dependen ? [] : _this$props4$dependen, onReset = _this$props4.onReset, store = info.store, namePath = _this.getNamePath(), prevValue = _this.getValue(prevStore), curValue = _this.getValue(store), namePathMatch = namePathList && containsNamePath(namePathList, namePath);
                      switch ("valueUpdate" === info.type && "external" === info.source && prevValue !== curValue && (_this.touched = !0, 
                      _this.dirty = !0, _this.validatePromise = null, _this.errors = EMPTY_ERRORS, _this.warnings = EMPTY_ERRORS, 
                      _this.triggerMetaEvent()), info.type) {
                        case "reset":
                          if (!namePathList || namePathMatch) return _this.touched = !1, _this.dirty = !1, 
                          _this.validatePromise = void 0, _this.errors = EMPTY_ERRORS, _this.warnings = EMPTY_ERRORS, 
                          _this.triggerMetaEvent(), null == onReset || onReset(), void _this.refresh();
                          break;

                        case "remove":
                          if (shouldUpdate) return void _this.reRender();
                          break;

                        case "setField":
                          var data = info.data;
                          if (namePathMatch) return "touched" in data && (_this.touched = data.touched), "validating" in data && !("originRCField" in data) && (_this.validatePromise = data.validating ? Promise.resolve([]) : null), 
                          "errors" in data && (_this.errors = data.errors || EMPTY_ERRORS), "warnings" in data && (_this.warnings = data.warnings || EMPTY_ERRORS), 
                          _this.dirty = !0, _this.triggerMetaEvent(), void _this.reRender();
                          if ("value" in data && containsNamePath(namePathList, namePath, !0)) return void _this.reRender();
                          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) return void _this.reRender();
                          break;

                        case "dependenciesUpdate":
                          if (dependencies.map(getNamePath).some((function(dependency) {
                              return containsNamePath(info.relatedFields, dependency);
                          }))) return void _this.reRender();
                          break;

                        default:
                          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) return void _this.reRender();
                      }
                      !0 === shouldUpdate && _this.reRender();
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "validateRules", (function(options) {
                      var namePath = _this.getNamePath(), currentValue = _this.getValue(), _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = void 0 !== _ref2$validateOnly && _ref2$validateOnly, rootPromise = Promise.resolve().then(_asyncToGenerator(_regeneratorRuntime().mark((function _callee() {
                          var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
                          return _regeneratorRuntime().wrap((function(_context) {
                              for (;;) switch (_context.prev = _context.next) {
                                case 0:
                                  if (_this.mounted) {
                                      _context.next = 2;
                                      break;
                                  }
                                  return _context.abrupt("return", []);

                                case 2:
                                  if (_this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, 
                                  validateFirst = void 0 !== _this$props5$validate && _this$props5$validate, messageVariables = _this$props5.messageVariables, 
                                  validateDebounce = _this$props5.validateDebounce, filteredRules = _this.getRules(), 
                                  triggerName && (filteredRules = filteredRules.filter((function(rule) {
                                      return rule;
                                  })).filter((function(rule) {
                                      var validateTrigger = rule.validateTrigger;
                                      return !validateTrigger || typeUtil_toArray(validateTrigger).includes(triggerName);
                                  }))), !validateDebounce || !triggerName) {
                                      _context.next = 10;
                                      break;
                                  }
                                  return _context.next = 8, new Promise((function(resolve) {
                                      setTimeout(resolve, validateDebounce);
                                  }));

                                case 8:
                                  if (_this.validatePromise === rootPromise) {
                                      _context.next = 10;
                                      break;
                                  }
                                  return _context.abrupt("return", []);

                                case 10:
                                  return (promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables)).catch((function(e) {
                                      return e;
                                  })).then((function() {
                                      var ruleErrors = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : EMPTY_ERRORS;
                                      if (_this.validatePromise === rootPromise) {
                                          var _ruleErrors$forEach;
                                          _this.validatePromise = null;
                                          var nextErrors = [], nextWarnings = [];
                                          null === (_ruleErrors$forEach = ruleErrors.forEach) || void 0 === _ruleErrors$forEach || _ruleErrors$forEach.call(ruleErrors, (function(_ref4) {
                                              var warningOnly = _ref4.rule.warningOnly, _ref4$errors = _ref4.errors, errors = void 0 === _ref4$errors ? EMPTY_ERRORS : _ref4$errors;
                                              warningOnly ? nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors)) : nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                                          })), _this.errors = nextErrors, _this.warnings = nextWarnings, _this.triggerMetaEvent(), 
                                          _this.reRender();
                                      }
                                  })), _context.abrupt("return", promise);

                                case 13:
                                case "end":
                                  return _context.stop();
                              }
                          }), _callee);
                      }))));
                      return validateOnly || (_this.validatePromise = rootPromise, _this.dirty = !0, _this.errors = EMPTY_ERRORS, 
                      _this.warnings = EMPTY_ERRORS, _this.triggerMetaEvent(), _this.reRender()), rootPromise;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "isFieldValidating", (function() {
                      return !!_this.validatePromise;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "isFieldTouched", (function() {
                      return _this.touched;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "isFieldDirty", (function() {
                      return !(!_this.dirty && void 0 === _this.props.initialValue) || void 0 !== (0, 
                      _this.props.fieldContext.getInternalHooks(HOOK_MARK).getInitialValue)(_this.getNamePath());
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getErrors", (function() {
                      return _this.errors;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getWarnings", (function() {
                      return _this.warnings;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "isListField", (function() {
                      return _this.props.isListField;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "isList", (function() {
                      return _this.props.isList;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "isPreserve", (function() {
                      return _this.props.preserve;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getMeta", (function() {
                      return _this.prevValidating = _this.isFieldValidating(), {
                          touched: _this.isFieldTouched(),
                          validating: _this.prevValidating,
                          errors: _this.errors,
                          warnings: _this.warnings,
                          name: _this.getNamePath(),
                          validated: null === _this.validatePromise
                      };
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getOnlyChild", (function(children) {
                      if ("function" == typeof children) {
                          var _meta2 = _this.getMeta();
                          return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
                              isFunction: !0
                          });
                      }
                      var childList = toArray_toArray(children);
                      return 1 === childList.length && react.isValidElement(childList[0]) ? {
                          child: childList[0],
                          isFunction: !1
                      } : {
                          child: childList,
                          isFunction: !1
                      };
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getValue", (function(store) {
                      var getFieldsValue = _this.props.fieldContext.getFieldsValue, namePath = _this.getNamePath();
                      return get(store || getFieldsValue(!0), namePath);
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "getControlled", (function() {
                      var childProps = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext, mergedValidateTrigger = void 0 !== validateTrigger ? validateTrigger : fieldContext.validateTrigger, namePath = _this.getNamePath(), getInternalHooks = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue, dispatch = getInternalHooks(HOOK_MARK).dispatch, value = _this.getValue(), mergedGetValueProps = getValueProps || function(val) {
                          return defineProperty_defineProperty({}, valuePropName, val);
                      }, originTriggerFunc = childProps[trigger], control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
                      return control[trigger] = function() {
                          var newValue;
                          _this.touched = !0, _this.dirty = !0, _this.triggerMetaEvent();
                          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                          newValue = getValueFromEvent ? getValueFromEvent.apply(void 0, args) : defaultGetValueFromEvent.apply(void 0, [ valuePropName ].concat(args)), 
                          normalize && (newValue = normalize(newValue, value, getFieldsValue(!0))), dispatch({
                              type: "updateValue",
                              namePath,
                              value: newValue
                          }), originTriggerFunc && originTriggerFunc.apply(void 0, args);
                      }, typeUtil_toArray(mergedValidateTrigger || []).forEach((function(triggerName) {
                          var originTrigger = control[triggerName];
                          control[triggerName] = function() {
                              originTrigger && originTrigger.apply(void 0, arguments);
                              var rules = _this.props.rules;
                              rules && rules.length && dispatch({
                                  type: "validateField",
                                  namePath,
                                  triggerName
                              });
                          };
                      })), control;
                  })), props.fieldContext) && (0, (0, props.fieldContext.getInternalHooks)(HOOK_MARK).initEntityValue)(_assertThisInitialized(_this));
                  return _this;
              }
              return _createClass(Field, [ {
                  key: "componentDidMount",
                  value: function() {
                      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
                      if (this.mounted = !0, fieldContext) {
                          var registerField = (0, fieldContext.getInternalHooks)(HOOK_MARK).registerField;
                          this.cancelRegisterFunc = registerField(this);
                      }
                      !0 === shouldUpdate && this.reRender();
                  }
              }, {
                  key: "componentWillUnmount",
                  value: function() {
                      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
                  }
              }, {
                  key: "reRender",
                  value: function() {
                      this.mounted && this.forceUpdate();
                  }
              }, {
                  key: "render",
                  value: function() {
                      var returnChildNode, resetCount = this.state.resetCount, children = this.props.children, _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child;
                      return _this$getOnlyChild.isFunction ? returnChildNode = child : react.isValidElement(child) ? returnChildNode = react.cloneElement(child, this.getControlled(child.props)) : (es_warning(!child, "`children` of Field is not validate ReactElement."), 
                      returnChildNode = child), react.createElement(react.Fragment, {
                          key: resetCount
                      }, returnChildNode);
                  }
              } ]), Field;
          }(react.Component);
          defineProperty_defineProperty(Field, "contextType", FieldContext), defineProperty_defineProperty(Field, "defaultProps", {
              trigger: "onChange",
              valuePropName: "value"
          });
          const es_Field = function(_ref6) {
              var name = _ref6.name, restProps = objectWithoutProperties_objectWithoutProperties(_ref6, Field_excluded), fieldContext = react.useContext(FieldContext), listContext = react.useContext(es_ListContext), namePath = void 0 !== name ? getNamePath(name) : void 0, key = "keep";
              return restProps.isListField || (key = "_".concat((namePath || []).join("_"))), 
              react.createElement(Field, _extends({
                  key,
                  name: namePath,
                  isListField: !!listContext
              }, restProps, {
                  fieldContext
              }));
          };
          const es_List = function(_ref) {
              var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField, context = react.useContext(FieldContext), wrapperListContext = react.useContext(es_ListContext), keyManager = react.useRef({
                  keys: [],
                  id: 0
              }).current, prefixName = react.useMemo((function() {
                  var parentPrefixName = getNamePath(context.prefixName) || [];
                  return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
              }), [ context.prefixName, name ]), fieldContext = react.useMemo((function() {
                  return _objectSpread2(_objectSpread2({}, context), {}, {
                      prefixName
                  });
              }), [ context, prefixName ]), listContext = react.useMemo((function() {
                  return {
                      getKey: function(namePath) {
                          var len = prefixName.length, pathName = namePath[len];
                          return [ keyManager.keys[pathName], namePath.slice(len + 1) ];
                      }
                  };
              }), [ prefixName ]);
              return "function" != typeof children ? (es_warning(!1, "Form.List only accepts function as children."), 
              null) : react.createElement(es_ListContext.Provider, {
                  value: listContext
              }, react.createElement(FieldContext.Provider, {
                  value: fieldContext
              }, react.createElement(es_Field, {
                  name: [],
                  shouldUpdate: function(prevValue, nextValue, _ref2) {
                      return "internal" !== _ref2.source && prevValue !== nextValue;
                  },
                  rules,
                  validateTrigger,
                  initialValue,
                  isList: !0,
                  isListField: null != isListField ? isListField : !!wrapperListContext
              }, (function(_ref3, meta) {
                  var _ref3$value = _ref3.value, value = void 0 === _ref3$value ? [] : _ref3$value, onChange = _ref3.onChange, getFieldValue = context.getFieldValue, getNewValue = function() {
                      return getFieldValue(prefixName || []) || [];
                  }, operations = {
                      add: function(defaultValue, index) {
                          var newValue = getNewValue();
                          index >= 0 && index <= newValue.length ? (keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index)), [ keyManager.id ], _toConsumableArray(keyManager.keys.slice(index))), 
                          onChange([].concat(_toConsumableArray(newValue.slice(0, index)), [ defaultValue ], _toConsumableArray(newValue.slice(index))))) : (keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [ keyManager.id ]), 
                          onChange([].concat(_toConsumableArray(newValue), [ defaultValue ]))), keyManager.id += 1;
                      },
                      remove: function(index) {
                          var newValue = getNewValue(), indexSet = new Set(Array.isArray(index) ? index : [ index ]);
                          indexSet.size <= 0 || (keyManager.keys = keyManager.keys.filter((function(_, keysIndex) {
                              return !indexSet.has(keysIndex);
                          })), onChange(newValue.filter((function(_, valueIndex) {
                              return !indexSet.has(valueIndex);
                          }))));
                      },
                      move: function(from, to) {
                          if (from !== to) {
                              var newValue = getNewValue();
                              from < 0 || from >= newValue.length || to < 0 || to >= newValue.length || (keyManager.keys = valueUtil_move(keyManager.keys, from, to), 
                              onChange(valueUtil_move(newValue, from, to)));
                          }
                      }
                  }, listValue = value || [];
                  return Array.isArray(listValue) || (listValue = []), children(listValue.map((function(__, index) {
                      var key = keyManager.keys[index];
                      return void 0 === key && (keyManager.keys[index] = keyManager.id, key = keyManager.keys[index], 
                      keyManager.id += 1), {
                          name: index,
                          key,
                          isListField: !0
                      };
                  })), operations, meta);
              }))));
          };
          function NameMap_normalize(namePath) {
              return namePath.map((function(cell) {
                  return "".concat(_typeof(cell), ":").concat(cell);
              })).join("__@field_split__");
          }
          var NameMap = function() {
              function NameMap() {
                  _classCallCheck(this, NameMap), defineProperty_defineProperty(this, "kvs", new Map);
              }
              return _createClass(NameMap, [ {
                  key: "set",
                  value: function(key, value) {
                      this.kvs.set(NameMap_normalize(key), value);
                  }
              }, {
                  key: "get",
                  value: function(key) {
                      return this.kvs.get(NameMap_normalize(key));
                  }
              }, {
                  key: "update",
                  value: function(key, updater) {
                      var next = updater(this.get(key));
                      next ? this.set(key, next) : this.delete(key);
                  }
              }, {
                  key: "delete",
                  value: function(key) {
                      this.kvs.delete(NameMap_normalize(key));
                  }
              }, {
                  key: "map",
                  value: function(callback) {
                      return _toConsumableArray(this.kvs.entries()).map((function(_ref) {
                          var _ref2 = slicedToArray_slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1], cells = key.split("__@field_split__");
                          return callback({
                              key: cells.map((function(cell) {
                                  var _cell$match2 = slicedToArray_slicedToArray(cell.match(/^([^:]*):(.*)$/), 3), type = _cell$match2[1], unit = _cell$match2[2];
                                  return "number" === type ? Number(unit) : unit;
                              })),
                              value
                          });
                      }));
                  }
              }, {
                  key: "toJSON",
                  value: function() {
                      var json = {};
                      return this.map((function(_ref3) {
                          var key = _ref3.key, value = _ref3.value;
                          return json[key.join(".")] = value, null;
                      })), json;
                  }
              } ]), NameMap;
          }();
          const utils_NameMap = NameMap;
          var useForm_excluded = [ "name" ], FormStore = _createClass((function FormStore(forceRootUpdate) {
              var _this = this;
              _classCallCheck(this, FormStore), defineProperty_defineProperty(this, "formHooked", !1), 
              defineProperty_defineProperty(this, "forceRootUpdate", void 0), defineProperty_defineProperty(this, "subscribable", !0), 
              defineProperty_defineProperty(this, "store", {}), defineProperty_defineProperty(this, "fieldEntities", []), 
              defineProperty_defineProperty(this, "initialValues", {}), defineProperty_defineProperty(this, "callbacks", {}), 
              defineProperty_defineProperty(this, "validateMessages", null), defineProperty_defineProperty(this, "preserve", null), 
              defineProperty_defineProperty(this, "lastValidatePromise", null), defineProperty_defineProperty(this, "getForm", (function() {
                  return {
                      getFieldValue: _this.getFieldValue,
                      getFieldsValue: _this.getFieldsValue,
                      getFieldError: _this.getFieldError,
                      getFieldWarning: _this.getFieldWarning,
                      getFieldsError: _this.getFieldsError,
                      isFieldsTouched: _this.isFieldsTouched,
                      isFieldTouched: _this.isFieldTouched,
                      isFieldValidating: _this.isFieldValidating,
                      isFieldsValidating: _this.isFieldsValidating,
                      resetFields: _this.resetFields,
                      setFields: _this.setFields,
                      setFieldValue: _this.setFieldValue,
                      setFieldsValue: _this.setFieldsValue,
                      validateFields: _this.validateFields,
                      submit: _this.submit,
                      _init: !0,
                      getInternalHooks: _this.getInternalHooks
                  };
              })), defineProperty_defineProperty(this, "getInternalHooks", (function(key) {
                  return key === HOOK_MARK ? (_this.formHooked = !0, {
                      dispatch: _this.dispatch,
                      initEntityValue: _this.initEntityValue,
                      registerField: _this.registerField,
                      useSubscribe: _this.useSubscribe,
                      setInitialValues: _this.setInitialValues,
                      destroyForm: _this.destroyForm,
                      setCallbacks: _this.setCallbacks,
                      setValidateMessages: _this.setValidateMessages,
                      getFields: _this.getFields,
                      setPreserve: _this.setPreserve,
                      getInitialValue: _this.getInitialValue,
                      registerWatch: _this.registerWatch
                  }) : (es_warning(!1, "`getInternalHooks` is internal usage. Should not call directly."), 
                  null);
              })), defineProperty_defineProperty(this, "useSubscribe", (function(subscribable) {
                  _this.subscribable = subscribable;
              })), defineProperty_defineProperty(this, "prevWithoutPreserves", null), defineProperty_defineProperty(this, "setInitialValues", (function(initialValues, init) {
                  if (_this.initialValues = initialValues || {}, init) {
                      var _this$prevWithoutPres, nextStore = merge(initialValues, _this.store);
                      null === (_this$prevWithoutPres = _this.prevWithoutPreserves) || void 0 === _this$prevWithoutPres || _this$prevWithoutPres.map((function(_ref) {
                          var namePath = _ref.key;
                          nextStore = set(nextStore, namePath, get(initialValues, namePath));
                      })), _this.prevWithoutPreserves = null, _this.updateStore(nextStore);
                  }
              })), defineProperty_defineProperty(this, "destroyForm", (function() {
                  var prevWithoutPreserves = new utils_NameMap;
                  _this.getFieldEntities(!0).forEach((function(entity) {
                      _this.isMergedPreserve(entity.isPreserve()) || prevWithoutPreserves.set(entity.getNamePath(), !0);
                  })), _this.prevWithoutPreserves = prevWithoutPreserves;
              })), defineProperty_defineProperty(this, "getInitialValue", (function(namePath) {
                  var initValue = get(_this.initialValues, namePath);
                  return namePath.length ? merge(initValue) : initValue;
              })), defineProperty_defineProperty(this, "setCallbacks", (function(callbacks) {
                  _this.callbacks = callbacks;
              })), defineProperty_defineProperty(this, "setValidateMessages", (function(validateMessages) {
                  _this.validateMessages = validateMessages;
              })), defineProperty_defineProperty(this, "setPreserve", (function(preserve) {
                  _this.preserve = preserve;
              })), defineProperty_defineProperty(this, "watchList", []), defineProperty_defineProperty(this, "registerWatch", (function(callback) {
                  return _this.watchList.push(callback), function() {
                      _this.watchList = _this.watchList.filter((function(fn) {
                          return fn !== callback;
                      }));
                  };
              })), defineProperty_defineProperty(this, "notifyWatch", (function() {
                  var namePath = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                  if (_this.watchList.length) {
                      var values = _this.getFieldsValue(), allValues = _this.getFieldsValue(!0);
                      _this.watchList.forEach((function(callback) {
                          callback(values, allValues, namePath);
                      }));
                  }
              })), defineProperty_defineProperty(this, "timeoutId", null), defineProperty_defineProperty(this, "warningUnhooked", (function() {
                  0;
              })), defineProperty_defineProperty(this, "updateStore", (function(nextStore) {
                  _this.store = nextStore;
              })), defineProperty_defineProperty(this, "getFieldEntities", (function() {
                  return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? _this.fieldEntities.filter((function(field) {
                      return field.getNamePath().length;
                  })) : _this.fieldEntities;
              })), defineProperty_defineProperty(this, "getFieldsMap", (function() {
                  var pure = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], cache = new utils_NameMap;
                  return _this.getFieldEntities(pure).forEach((function(field) {
                      var namePath = field.getNamePath();
                      cache.set(namePath, field);
                  })), cache;
              })), defineProperty_defineProperty(this, "getFieldEntitiesForNamePathList", (function(nameList) {
                  if (!nameList) return _this.getFieldEntities(!0);
                  var cache = _this.getFieldsMap(!0);
                  return nameList.map((function(name) {
                      var namePath = getNamePath(name);
                      return cache.get(namePath) || {
                          INVALIDATE_NAME_PATH: getNamePath(name)
                      };
                  }));
              })), defineProperty_defineProperty(this, "getFieldsValue", (function(nameList, filterFunc) {
                  var mergedNameList, mergedFilterFunc, mergedStrict;
                  if (_this.warningUnhooked(), !0 === nameList || Array.isArray(nameList) ? (mergedNameList = nameList, 
                  mergedFilterFunc = filterFunc) : nameList && "object" === _typeof(nameList) && (mergedStrict = nameList.strict, 
                  mergedFilterFunc = nameList.filter), !0 === mergedNameList && !mergedFilterFunc) return _this.store;
                  var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null), filteredNameList = [];
                  return fieldEntities.forEach((function(entity) {
                      var _isListField, _ref3, _isList, _ref2, namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
                      if (mergedStrict) {
                          if (null !== (_isList = (_ref2 = entity).isList) && void 0 !== _isList && _isList.call(_ref2)) return;
                      } else if (!mergedNameList && null !== (_isListField = (_ref3 = entity).isListField) && void 0 !== _isListField && _isListField.call(_ref3)) return;
                      if (mergedFilterFunc) {
                          var meta = "getMeta" in entity ? entity.getMeta() : null;
                          mergedFilterFunc(meta) && filteredNameList.push(namePath);
                      } else filteredNameList.push(namePath);
                  })), cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
              })), defineProperty_defineProperty(this, "getFieldValue", (function(name) {
                  _this.warningUnhooked();
                  var namePath = getNamePath(name);
                  return get(_this.store, namePath);
              })), defineProperty_defineProperty(this, "getFieldsError", (function(nameList) {
                  return _this.warningUnhooked(), _this.getFieldEntitiesForNamePathList(nameList).map((function(entity, index) {
                      return entity && !("INVALIDATE_NAME_PATH" in entity) ? {
                          name: entity.getNamePath(),
                          errors: entity.getErrors(),
                          warnings: entity.getWarnings()
                      } : {
                          name: getNamePath(nameList[index]),
                          errors: [],
                          warnings: []
                      };
                  }));
              })), defineProperty_defineProperty(this, "getFieldError", (function(name) {
                  _this.warningUnhooked();
                  var namePath = getNamePath(name);
                  return _this.getFieldsError([ namePath ])[0].errors;
              })), defineProperty_defineProperty(this, "getFieldWarning", (function(name) {
                  _this.warningUnhooked();
                  var namePath = getNamePath(name);
                  return _this.getFieldsError([ namePath ])[0].warnings;
              })), defineProperty_defineProperty(this, "isFieldsTouched", (function() {
                  _this.warningUnhooked();
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  var namePathList, arg0 = args[0], arg1 = args[1], isAllFieldsTouched = !1;
                  0 === args.length ? namePathList = null : 1 === args.length ? Array.isArray(arg0) ? (namePathList = arg0.map(getNamePath), 
                  isAllFieldsTouched = !1) : (namePathList = null, isAllFieldsTouched = arg0) : (namePathList = arg0.map(getNamePath), 
                  isAllFieldsTouched = arg1);
                  var fieldEntities = _this.getFieldEntities(!0), isFieldTouched = function(field) {
                      return field.isFieldTouched();
                  };
                  if (!namePathList) return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
                  var map = new utils_NameMap;
                  namePathList.forEach((function(shortNamePath) {
                      map.set(shortNamePath, []);
                  })), fieldEntities.forEach((function(field) {
                      var fieldNamePath = field.getNamePath();
                      namePathList.forEach((function(shortNamePath) {
                          shortNamePath.every((function(nameUnit, i) {
                              return fieldNamePath[i] === nameUnit;
                          })) && map.update(shortNamePath, (function(list) {
                              return [].concat(_toConsumableArray(list), [ field ]);
                          }));
                      }));
                  }));
                  var isNamePathListTouched = function(entities) {
                      return entities.some(isFieldTouched);
                  }, namePathListEntities = map.map((function(_ref4) {
                      return _ref4.value;
                  }));
                  return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
              })), defineProperty_defineProperty(this, "isFieldTouched", (function(name) {
                  return _this.warningUnhooked(), _this.isFieldsTouched([ name ]);
              })), defineProperty_defineProperty(this, "isFieldsValidating", (function(nameList) {
                  _this.warningUnhooked();
                  var fieldEntities = _this.getFieldEntities();
                  if (!nameList) return fieldEntities.some((function(testField) {
                      return testField.isFieldValidating();
                  }));
                  var namePathList = nameList.map(getNamePath);
                  return fieldEntities.some((function(testField) {
                      var fieldNamePath = testField.getNamePath();
                      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
                  }));
              })), defineProperty_defineProperty(this, "isFieldValidating", (function(name) {
                  return _this.warningUnhooked(), _this.isFieldsValidating([ name ]);
              })), defineProperty_defineProperty(this, "resetWithFieldInitialValue", (function() {
                  var info = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cache = new utils_NameMap, fieldEntities = _this.getFieldEntities(!0);
                  fieldEntities.forEach((function(field) {
                      var initialValue = field.props.initialValue, namePath = field.getNamePath();
                      if (void 0 !== initialValue) {
                          var records = cache.get(namePath) || new Set;
                          records.add({
                              entity: field,
                              value: initialValue
                          }), cache.set(namePath, records);
                      }
                  }));
                  var requiredFieldEntities;
                  info.entities ? requiredFieldEntities = info.entities : info.namePathList ? (requiredFieldEntities = [], 
                  info.namePathList.forEach((function(namePath) {
                      var _requiredFieldEntitie, records = cache.get(namePath);
                      records && (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map((function(r) {
                          return r.entity;
                      }))));
                  }))) : requiredFieldEntities = fieldEntities, requiredFieldEntities.forEach((function(field) {
                      if (void 0 !== field.props.initialValue) {
                          var namePath = field.getNamePath();
                          if (void 0 !== _this.getInitialValue(namePath)) es_warning(!1, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it.")); else {
                              var records = cache.get(namePath);
                              if (records && records.size > 1) es_warning(!1, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick.")); else if (records) {
                                  var originValue = _this.getFieldValue(namePath);
                                  info.skipExist && void 0 !== originValue || _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                              }
                          }
                      }
                  }));
              })), defineProperty_defineProperty(this, "resetFields", (function(nameList) {
                  _this.warningUnhooked();
                  var prevStore = _this.store;
                  if (!nameList) return _this.updateStore(merge(_this.initialValues)), _this.resetWithFieldInitialValue(), 
                  _this.notifyObservers(prevStore, null, {
                      type: "reset"
                  }), void _this.notifyWatch();
                  var namePathList = nameList.map(getNamePath);
                  namePathList.forEach((function(namePath) {
                      var initialValue = _this.getInitialValue(namePath);
                      _this.updateStore(set(_this.store, namePath, initialValue));
                  })), _this.resetWithFieldInitialValue({
                      namePathList
                  }), _this.notifyObservers(prevStore, namePathList, {
                      type: "reset"
                  }), _this.notifyWatch(namePathList);
              })), defineProperty_defineProperty(this, "setFields", (function(fields) {
                  _this.warningUnhooked();
                  var prevStore = _this.store, namePathList = [];
                  fields.forEach((function(fieldData) {
                      var name = fieldData.name, data = objectWithoutProperties_objectWithoutProperties(fieldData, useForm_excluded), namePath = getNamePath(name);
                      namePathList.push(namePath), "value" in data && _this.updateStore(set(_this.store, namePath, data.value)), 
                      _this.notifyObservers(prevStore, [ namePath ], {
                          type: "setField",
                          data: fieldData
                      });
                  })), _this.notifyWatch(namePathList);
              })), defineProperty_defineProperty(this, "getFields", (function() {
                  return _this.getFieldEntities(!0).map((function(field) {
                      var namePath = field.getNamePath(), fieldData = _objectSpread2(_objectSpread2({}, field.getMeta()), {}, {
                          name: namePath,
                          value: _this.getFieldValue(namePath)
                      });
                      return Object.defineProperty(fieldData, "originRCField", {
                          value: !0
                      }), fieldData;
                  }));
              })), defineProperty_defineProperty(this, "initEntityValue", (function(entity) {
                  var initialValue = entity.props.initialValue;
                  if (void 0 !== initialValue) {
                      var namePath = entity.getNamePath();
                      void 0 === get(_this.store, namePath) && _this.updateStore(set(_this.store, namePath, initialValue));
                  }
              })), defineProperty_defineProperty(this, "isMergedPreserve", (function(fieldPreserve) {
                  var mergedPreserve = void 0 !== fieldPreserve ? fieldPreserve : _this.preserve;
                  return null == mergedPreserve || mergedPreserve;
              })), defineProperty_defineProperty(this, "registerField", (function(entity) {
                  _this.fieldEntities.push(entity);
                  var namePath = entity.getNamePath();
                  if (_this.notifyWatch([ namePath ]), void 0 !== entity.props.initialValue) {
                      var prevStore = _this.store;
                      _this.resetWithFieldInitialValue({
                          entities: [ entity ],
                          skipExist: !0
                      }), _this.notifyObservers(prevStore, [ entity.getNamePath() ], {
                          type: "valueUpdate",
                          source: "internal"
                      });
                  }
                  return function(isListField, preserve) {
                      var subNamePath = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                      if (_this.fieldEntities = _this.fieldEntities.filter((function(item) {
                          return item !== entity;
                      })), !_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
                          var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
                          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every((function(field) {
                              return !matchNamePath(field.getNamePath(), namePath);
                          }))) {
                              var _prevStore = _this.store;
                              _this.updateStore(set(_prevStore, namePath, defaultValue, !0)), _this.notifyObservers(_prevStore, [ namePath ], {
                                  type: "remove"
                              }), _this.triggerDependenciesUpdate(_prevStore, namePath);
                          }
                      }
                      _this.notifyWatch([ namePath ]);
                  };
              })), defineProperty_defineProperty(this, "dispatch", (function(action) {
                  switch (action.type) {
                    case "updateValue":
                      var namePath = action.namePath, value = action.value;
                      _this.updateValue(namePath, value);
                      break;

                    case "validateField":
                      var _namePath = action.namePath, triggerName = action.triggerName;
                      _this.validateFields([ _namePath ], {
                          triggerName
                      });
                  }
              })), defineProperty_defineProperty(this, "notifyObservers", (function(prevStore, namePathList, info) {
                  if (_this.subscribable) {
                      var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
                          store: _this.getFieldsValue(!0)
                      });
                      _this.getFieldEntities().forEach((function(_ref5) {
                          (0, _ref5.onStoreChange)(prevStore, namePathList, mergedInfo);
                      }));
                  } else _this.forceRootUpdate();
              })), defineProperty_defineProperty(this, "triggerDependenciesUpdate", (function(prevStore, namePath) {
                  var childrenFields = _this.getDependencyChildrenFields(namePath);
                  return childrenFields.length && _this.validateFields(childrenFields), _this.notifyObservers(prevStore, childrenFields, {
                      type: "dependenciesUpdate",
                      relatedFields: [ namePath ].concat(_toConsumableArray(childrenFields))
                  }), childrenFields;
              })), defineProperty_defineProperty(this, "updateValue", (function(name, value) {
                  var namePath = getNamePath(name), prevStore = _this.store;
                  _this.updateStore(set(_this.store, namePath, value)), _this.notifyObservers(prevStore, [ namePath ], {
                      type: "valueUpdate",
                      source: "internal"
                  }), _this.notifyWatch([ namePath ]);
                  var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath), onValuesChange = _this.callbacks.onValuesChange;
                  onValuesChange && onValuesChange(cloneByNamePathList(_this.store, [ namePath ]), _this.getFieldsValue());
                  _this.triggerOnFieldsChange([ namePath ].concat(_toConsumableArray(childrenFields)));
              })), defineProperty_defineProperty(this, "setFieldsValue", (function(store) {
                  _this.warningUnhooked();
                  var prevStore = _this.store;
                  if (store) {
                      var nextStore = merge(_this.store, store);
                      _this.updateStore(nextStore);
                  }
                  _this.notifyObservers(prevStore, null, {
                      type: "valueUpdate",
                      source: "external"
                  }), _this.notifyWatch();
              })), defineProperty_defineProperty(this, "setFieldValue", (function(name, value) {
                  _this.setFields([ {
                      name,
                      value
                  } ]);
              })), defineProperty_defineProperty(this, "getDependencyChildrenFields", (function(rootNamePath) {
                  var children = new Set, childrenFields = [], dependencies2fields = new utils_NameMap;
                  _this.getFieldEntities().forEach((function(field) {
                      (field.props.dependencies || []).forEach((function(dependency) {
                          var dependencyNamePath = getNamePath(dependency);
                          dependencies2fields.update(dependencyNamePath, (function() {
                              var fields = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Set;
                              return fields.add(field), fields;
                          }));
                      }));
                  }));
                  return function fillChildren(namePath) {
                      (dependencies2fields.get(namePath) || new Set).forEach((function(field) {
                          if (!children.has(field)) {
                              children.add(field);
                              var fieldNamePath = field.getNamePath();
                              field.isFieldDirty() && fieldNamePath.length && (childrenFields.push(fieldNamePath), 
                              fillChildren(fieldNamePath));
                          }
                      }));
                  }(rootNamePath), childrenFields;
              })), defineProperty_defineProperty(this, "triggerOnFieldsChange", (function(namePathList, filedErrors) {
                  var onFieldsChange = _this.callbacks.onFieldsChange;
                  if (onFieldsChange) {
                      var fields = _this.getFields();
                      if (filedErrors) {
                          var cache = new utils_NameMap;
                          filedErrors.forEach((function(_ref6) {
                              var name = _ref6.name, errors = _ref6.errors;
                              cache.set(name, errors);
                          })), fields.forEach((function(field) {
                              field.errors = cache.get(field.name) || field.errors;
                          }));
                      }
                      var changedFields = fields.filter((function(_ref7) {
                          var fieldName = _ref7.name;
                          return containsNamePath(namePathList, fieldName);
                      }));
                      changedFields.length && onFieldsChange(changedFields, fields);
                  }
              })), defineProperty_defineProperty(this, "validateFields", (function(arg1, arg2) {
                  var _options, nameList, options;
                  _this.warningUnhooked(), Array.isArray(arg1) || "string" == typeof arg1 || "string" == typeof arg2 ? (nameList = arg1, 
                  options = arg2) : options = arg1;
                  var provideNameList = !!nameList, namePathList = provideNameList ? nameList.map(getNamePath) : [], promiseList = [], TMP_SPLIT = String(Date.now()), validateNamePathList = new Set, recursive = null === (_options = options) || void 0 === _options ? void 0 : _options.recursive;
                  _this.getFieldEntities(!0).forEach((function(field) {
                      if (provideNameList || namePathList.push(field.getNamePath()), field.props.rules && field.props.rules.length) {
                          var fieldNamePath = field.getNamePath();
                          if (validateNamePathList.add(fieldNamePath.join(TMP_SPLIT)), !provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
                              var promise = field.validateRules(_objectSpread2({
                                  validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
                              }, options));
                              promiseList.push(promise.then((function() {
                                  return {
                                      name: fieldNamePath,
                                      errors: [],
                                      warnings: []
                                  };
                              })).catch((function(ruleErrors) {
                                  var _ruleErrors$forEach, mergedErrors = [], mergedWarnings = [];
                                  return null === (_ruleErrors$forEach = ruleErrors.forEach) || void 0 === _ruleErrors$forEach || _ruleErrors$forEach.call(ruleErrors, (function(_ref8) {
                                      var warningOnly = _ref8.rule.warningOnly, errors = _ref8.errors;
                                      warningOnly ? mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors)) : mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
                                  })), mergedErrors.length ? Promise.reject({
                                      name: fieldNamePath,
                                      errors: mergedErrors,
                                      warnings: mergedWarnings
                                  }) : {
                                      name: fieldNamePath,
                                      errors: mergedErrors,
                                      warnings: mergedWarnings
                                  };
                              })));
                          }
                      }
                  }));
                  var summaryPromise = function(promiseList) {
                      var hasError = !1, count = promiseList.length, results = [];
                      return promiseList.length ? new Promise((function(resolve, reject) {
                          promiseList.forEach((function(promise, index) {
                              promise.catch((function(e) {
                                  return hasError = !0, e;
                              })).then((function(result) {
                                  count -= 1, results[index] = result, count > 0 || (hasError && reject(results), 
                                  resolve(results));
                              }));
                          }));
                      })) : Promise.resolve([]);
                  }(promiseList);
                  _this.lastValidatePromise = summaryPromise, summaryPromise.catch((function(results) {
                      return results;
                  })).then((function(results) {
                      var resultNamePathList = results.map((function(_ref9) {
                          return _ref9.name;
                      }));
                      _this.notifyObservers(_this.store, resultNamePathList, {
                          type: "validateFinish"
                      }), _this.triggerOnFieldsChange(resultNamePathList, results);
                  }));
                  var returnPromise = summaryPromise.then((function() {
                      return _this.lastValidatePromise === summaryPromise ? Promise.resolve(_this.getFieldsValue(namePathList)) : Promise.reject([]);
                  })).catch((function(results) {
                      var errorList = results.filter((function(result) {
                          return result && result.errors.length;
                      }));
                      return Promise.reject({
                          values: _this.getFieldsValue(namePathList),
                          errorFields: errorList,
                          outOfDate: _this.lastValidatePromise !== summaryPromise
                      });
                  }));
                  returnPromise.catch((function(e) {
                      return e;
                  }));
                  var triggerNamePathList = namePathList.filter((function(namePath) {
                      return validateNamePathList.has(namePath.join(TMP_SPLIT));
                  }));
                  return _this.triggerOnFieldsChange(triggerNamePathList), returnPromise;
              })), defineProperty_defineProperty(this, "submit", (function() {
                  _this.warningUnhooked(), _this.validateFields().then((function(values) {
                      var onFinish = _this.callbacks.onFinish;
                      if (onFinish) try {
                          onFinish(values);
                      } catch (err) {
                          console.error(err);
                      }
                  })).catch((function(e) {
                      var onFinishFailed = _this.callbacks.onFinishFailed;
                      onFinishFailed && onFinishFailed(e);
                  }));
              })), this.forceRootUpdate = forceRootUpdate;
          }));
          const es_useForm = function(form) {
              var formRef = react.useRef(), forceUpdate = slicedToArray_slicedToArray(react.useState({}), 2)[1];
              if (!formRef.current) if (form) formRef.current = form; else {
                  var formStore = new FormStore((function() {
                      forceUpdate({});
                  }));
                  formRef.current = formStore.getForm();
              }
              return [ formRef.current ];
          };
          var FormContext = react.createContext({
              triggerFormChange: function() {},
              triggerFormFinish: function() {},
              registerForm: function() {},
              unregisterForm: function() {}
          });
          const es_FormContext = FormContext;
          var Form_excluded = [ "name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed" ];
          const es_Form = function(_ref, ref) {
              var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component = void 0 === _ref$component ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = void 0 === _ref$validateTrigger ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = objectWithoutProperties_objectWithoutProperties(_ref, Form_excluded), formContext = react.useContext(es_FormContext), formInstance = slicedToArray_slicedToArray(es_useForm(form), 1)[0], _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _getInternalHooks.useSubscribe, setInitialValues = _getInternalHooks.setInitialValues, setCallbacks = _getInternalHooks.setCallbacks, setValidateMessages = _getInternalHooks.setValidateMessages, setPreserve = _getInternalHooks.setPreserve, destroyForm = _getInternalHooks.destroyForm;
              react.useImperativeHandle(ref, (function() {
                  return formInstance;
              })), react.useEffect((function() {
                  return formContext.registerForm(name, formInstance), function() {
                      formContext.unregisterForm(name);
                  };
              }), [ formContext, formInstance, name ]), setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages)), 
              setCallbacks({
                  onValuesChange,
                  onFieldsChange: function(changedFields) {
                      if (formContext.triggerFormChange(name, changedFields), _onFieldsChange) {
                          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) rest[_key - 1] = arguments[_key];
                          _onFieldsChange.apply(void 0, [ changedFields ].concat(rest));
                      }
                  },
                  onFinish: function(values) {
                      formContext.triggerFormFinish(name, values), _onFinish && _onFinish(values);
                  },
                  onFinishFailed
              }), setPreserve(preserve);
              var childrenNode, mountRef = react.useRef(null);
              setInitialValues(initialValues, !mountRef.current), mountRef.current || (mountRef.current = !0), 
              react.useEffect((function() {
                  return destroyForm;
              }), []);
              var childrenRenderProps = "function" == typeof children;
              childrenRenderProps ? childrenNode = children(formInstance.getFieldsValue(!0), formInstance) : childrenNode = children;
              useSubscribe(!childrenRenderProps);
              var prevFieldsRef = react.useRef();
              react.useEffect((function() {
                  (function(source, target) {
                      if (source === target) return !0;
                      if (!source && target || source && !target) return !1;
                      if (!source || !target || "object" !== _typeof(source) || "object" !== _typeof(target)) return !1;
                      var sourceKeys = Object.keys(source), targetKeys = Object.keys(target);
                      return _toConsumableArray(new Set([].concat(sourceKeys, targetKeys))).every((function(key) {
                          var sourceValue = source[key], targetValue = target[key];
                          return "function" == typeof sourceValue && "function" == typeof targetValue || sourceValue === targetValue;
                      }));
                  })(prevFieldsRef.current || [], fields || []) || formInstance.setFields(fields || []), 
                  prevFieldsRef.current = fields;
              }), [ fields, formInstance ]);
              var formContextValue = react.useMemo((function() {
                  return _objectSpread2(_objectSpread2({}, formInstance), {}, {
                      validateTrigger
                  });
              }), [ formInstance, validateTrigger ]), wrapperNode = react.createElement(es_ListContext.Provider, {
                  value: null
              }, react.createElement(FieldContext.Provider, {
                  value: formContextValue
              }, childrenNode));
              return !1 === Component ? wrapperNode : react.createElement(Component, _extends({}, restProps, {
                  onSubmit: function(event) {
                      event.preventDefault(), event.stopPropagation(), formInstance.submit();
                  },
                  onReset: function(event) {
                      var _restProps$onReset;
                      event.preventDefault(), formInstance.resetFields(), null === (_restProps$onReset = restProps.onReset) || void 0 === _restProps$onReset || _restProps$onReset.call(restProps, event);
                  }
              }), wrapperNode);
          };
          function useWatch_stringify(value) {
              try {
                  return JSON.stringify(value);
              } catch (err) {
                  return Math.random();
              }
          }
          var useWatchWarning = function() {};
          const es_useWatch = function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
              var _args$ = args[0], dependencies = void 0 === _args$ ? [] : _args$, _args$2 = args[1], _form = void 0 === _args$2 ? {} : _args$2, options = function(form) {
                  return form && !!form._init;
              }(_form) ? {
                  form: _form
              } : _form, form = options.form, _useState2 = slicedToArray_slicedToArray((0, react.useState)(), 2), value = _useState2[0], setValue = _useState2[1], valueStr = (0, 
              react.useMemo)((function() {
                  return useWatch_stringify(value);
              }), [ value ]), valueStrRef = (0, react.useRef)(valueStr);
              valueStrRef.current = valueStr;
              var fieldContext = (0, react.useContext)(FieldContext), formInstance = form || fieldContext, isValidForm = formInstance && formInstance._init, namePath = getNamePath(dependencies), namePathRef = (0, 
              react.useRef)(namePath);
              return namePathRef.current = namePath, useWatchWarning(namePath), (0, react.useEffect)((function() {
                  if (isValidForm) {
                      var getFieldsValue = formInstance.getFieldsValue, cancelRegister = (0, (0, formInstance.getInternalHooks)(HOOK_MARK).registerWatch)((function(values, allValues) {
                          var newValue = get(options.preserve ? allValues : values, namePathRef.current), nextValueStr = useWatch_stringify(newValue);
                          valueStrRef.current !== nextValueStr && (valueStrRef.current = nextValueStr, setValue(newValue));
                      })), initialValue = get(options.preserve ? getFieldsValue(!0) : getFieldsValue(), namePathRef.current);
                      return value !== initialValue && setValue(initialValue), cancelRegister;
                  }
              }), [ isValidForm ]), value;
          };
          var RefForm = react.forwardRef(es_Form);
          RefForm.FormProvider = function(_ref) {
              var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children, formContext = react.useContext(FormContext), formsRef = react.useRef({});
              return react.createElement(FormContext.Provider, {
                  value: _objectSpread2(_objectSpread2({}, formContext), {}, {
                      validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
                      triggerFormChange: function(name, changedFields) {
                          onFormChange && onFormChange(name, {
                              changedFields,
                              forms: formsRef.current
                          }), formContext.triggerFormChange(name, changedFields);
                      },
                      triggerFormFinish: function(name, values) {
                          onFormFinish && onFormFinish(name, {
                              values,
                              forms: formsRef.current
                          }), formContext.triggerFormFinish(name, values);
                      },
                      registerForm: function(name, form) {
                          name && (formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, defineProperty_defineProperty({}, name, form))), 
                          formContext.registerForm(name, form);
                      },
                      unregisterForm: function(name) {
                          var newForms = _objectSpread2({}, formsRef.current);
                          delete newForms[name], formsRef.current = newForms, formContext.unregisterForm(name);
                      }
                  })
              }, children);
          }, RefForm.Field = es_Field, RefForm.List = es_List, RefForm.useForm = es_useForm, 
          RefForm.useWatch = es_useWatch;
          const FormItemInputContext = react.createContext({});
          const getGroupRadioStyle = token => {
              const {componentCls, antCls} = token, groupPrefixCls = `${componentCls}-group`;
              return {
                  [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token)), {
                      display: "inline-block",
                      fontSize: 0,
                      [`&${groupPrefixCls}-rtl`]: {
                          direction: "rtl"
                      },
                      [`${antCls}-badge ${antCls}-badge-count`]: {
                          zIndex: 1
                      },
                      [`> ${antCls}-badge:not(:first-child) > ${antCls}-button-wrapper`]: {
                          borderInlineStart: "none"
                      }
                  })
              };
          }, getRadioBasicStyle = token => {
              const {componentCls, wrapperMarginInlineEnd, colorPrimary, radioSize, motionDurationSlow, motionDurationMid, motionEaseInOutCirc, colorBgContainer, colorBorder, lineWidth, dotSize, colorBgContainerDisabled, colorTextDisabled, paddingXS, dotColorDisabled, lineType, radioDotDisabledSize, wireframe, colorWhite} = token, radioInnerPrefixCls = `${componentCls}-inner`;
              return {
                  [`${componentCls}-wrapper`]: Object.assign(Object.assign({}, resetComponent(token)), {
                      display: "inline-flex",
                      alignItems: "baseline",
                      marginInlineStart: 0,
                      marginInlineEnd: wrapperMarginInlineEnd,
                      cursor: "pointer",
                      [`&${componentCls}-wrapper-rtl`]: {
                          direction: "rtl"
                      },
                      "&-disabled": {
                          cursor: "not-allowed",
                          color: token.colorTextDisabled
                      },
                      "&::after": {
                          display: "inline-block",
                          width: 0,
                          overflow: "hidden",
                          content: '"\\a0"'
                      },
                      [`${componentCls}-checked::after`]: {
                          position: "absolute",
                          insetBlockStart: 0,
                          insetInlineStart: 0,
                          width: "100%",
                          height: "100%",
                          border: `${lineWidth}px ${lineType} ${colorPrimary}`,
                          borderRadius: "50%",
                          visibility: "hidden",
                          content: '""'
                      },
                      [componentCls]: Object.assign(Object.assign({}, resetComponent(token)), {
                          position: "relative",
                          display: "inline-block",
                          outline: "none",
                          cursor: "pointer",
                          alignSelf: "center",
                          borderRadius: "50%"
                      }),
                      [`${componentCls}-wrapper:hover &,\n        &:hover ${radioInnerPrefixCls}`]: {
                          borderColor: colorPrimary
                      },
                      [`${componentCls}-input:focus-visible + ${radioInnerPrefixCls}`]: Object.assign({}, genFocusOutline(token)),
                      [`${componentCls}:hover::after, ${componentCls}-wrapper:hover &::after`]: {
                          visibility: "visible"
                      },
                      [`${componentCls}-inner`]: {
                          "&::after": {
                              boxSizing: "border-box",
                              position: "absolute",
                              insetBlockStart: "50%",
                              insetInlineStart: "50%",
                              display: "block",
                              width: radioSize,
                              height: radioSize,
                              marginBlockStart: radioSize / -2,
                              marginInlineStart: radioSize / -2,
                              backgroundColor: wireframe ? colorPrimary : colorWhite,
                              borderBlockStart: 0,
                              borderInlineStart: 0,
                              borderRadius: radioSize,
                              transform: "scale(0)",
                              opacity: 0,
                              transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`,
                              content: '""'
                          },
                          boxSizing: "border-box",
                          position: "relative",
                          insetBlockStart: 0,
                          insetInlineStart: 0,
                          display: "block",
                          width: radioSize,
                          height: radioSize,
                          backgroundColor: colorBgContainer,
                          borderColor: colorBorder,
                          borderStyle: "solid",
                          borderWidth: lineWidth,
                          borderRadius: "50%",
                          transition: `all ${motionDurationMid}`
                      },
                      [`${componentCls}-input`]: {
                          position: "absolute",
                          inset: 0,
                          zIndex: 1,
                          cursor: "pointer",
                          opacity: 0
                      },
                      [`${componentCls}-checked`]: {
                          [radioInnerPrefixCls]: {
                              borderColor: colorPrimary,
                              backgroundColor: wireframe ? colorBgContainer : colorPrimary,
                              "&::after": {
                                  transform: `scale(${dotSize / radioSize})`,
                                  opacity: 1,
                                  transition: `all ${motionDurationSlow} ${motionEaseInOutCirc}`
                              }
                          }
                      },
                      [`${componentCls}-disabled`]: {
                          cursor: "not-allowed",
                          [radioInnerPrefixCls]: {
                              backgroundColor: colorBgContainerDisabled,
                              borderColor: colorBorder,
                              cursor: "not-allowed",
                              "&::after": {
                                  backgroundColor: dotColorDisabled
                              }
                          },
                          [`${componentCls}-input`]: {
                              cursor: "not-allowed"
                          },
                          [`${componentCls}-disabled + span`]: {
                              color: colorTextDisabled,
                              cursor: "not-allowed"
                          },
                          [`&${componentCls}-checked`]: {
                              [radioInnerPrefixCls]: {
                                  "&::after": {
                                      transform: `scale(${radioDotDisabledSize / radioSize})`
                                  }
                              }
                          }
                      },
                      [`span${componentCls} + *`]: {
                          paddingInlineStart: paddingXS,
                          paddingInlineEnd: paddingXS
                      }
                  })
              };
          }, getRadioButtonStyle = token => {
              const {buttonColor, controlHeight, componentCls, lineWidth, lineType, colorBorder, motionDurationSlow, motionDurationMid, buttonPaddingInline, fontSize, buttonBg, fontSizeLG, controlHeightLG, controlHeightSM, paddingXS, borderRadius, borderRadiusSM, borderRadiusLG, buttonCheckedBg, buttonSolidCheckedColor, colorTextDisabled, colorBgContainerDisabled, buttonCheckedBgDisabled, buttonCheckedColorDisabled, colorPrimary, colorPrimaryHover, colorPrimaryActive, buttonSolidCheckedBg, buttonSolidCheckedHoverBg, buttonSolidCheckedActiveBg} = token;
              return {
                  [`${componentCls}-button-wrapper`]: {
                      position: "relative",
                      display: "inline-block",
                      height: controlHeight,
                      margin: 0,
                      paddingInline: buttonPaddingInline,
                      paddingBlock: 0,
                      color: buttonColor,
                      fontSize,
                      lineHeight: controlHeight - 2 * lineWidth + "px",
                      background: buttonBg,
                      border: `${lineWidth}px ${lineType} ${colorBorder}`,
                      borderBlockStartWidth: lineWidth + .02,
                      borderInlineStartWidth: 0,
                      borderInlineEndWidth: lineWidth,
                      cursor: "pointer",
                      transition: [ `color ${motionDurationMid}`, `background ${motionDurationMid}`, `box-shadow ${motionDurationMid}` ].join(","),
                      a: {
                          color: buttonColor
                      },
                      [`> ${componentCls}-button`]: {
                          position: "absolute",
                          insetBlockStart: 0,
                          insetInlineStart: 0,
                          zIndex: -1,
                          width: "100%",
                          height: "100%"
                      },
                      "&:not(:first-child)": {
                          "&::before": {
                              position: "absolute",
                              insetBlockStart: -lineWidth,
                              insetInlineStart: -lineWidth,
                              display: "block",
                              boxSizing: "content-box",
                              width: 1,
                              height: "100%",
                              paddingBlock: lineWidth,
                              paddingInline: 0,
                              backgroundColor: colorBorder,
                              transition: `background-color ${motionDurationSlow}`,
                              content: '""'
                          }
                      },
                      "&:first-child": {
                          borderInlineStart: `${lineWidth}px ${lineType} ${colorBorder}`,
                          borderStartStartRadius: borderRadius,
                          borderEndStartRadius: borderRadius
                      },
                      "&:last-child": {
                          borderStartEndRadius: borderRadius,
                          borderEndEndRadius: borderRadius
                      },
                      "&:first-child:last-child": {
                          borderRadius
                      },
                      [`${componentCls}-group-large &`]: {
                          height: controlHeightLG,
                          fontSize: fontSizeLG,
                          lineHeight: controlHeightLG - 2 * lineWidth + "px",
                          "&:first-child": {
                              borderStartStartRadius: borderRadiusLG,
                              borderEndStartRadius: borderRadiusLG
                          },
                          "&:last-child": {
                              borderStartEndRadius: borderRadiusLG,
                              borderEndEndRadius: borderRadiusLG
                          }
                      },
                      [`${componentCls}-group-small &`]: {
                          height: controlHeightSM,
                          paddingInline: paddingXS - lineWidth,
                          paddingBlock: 0,
                          lineHeight: controlHeightSM - 2 * lineWidth + "px",
                          "&:first-child": {
                              borderStartStartRadius: borderRadiusSM,
                              borderEndStartRadius: borderRadiusSM
                          },
                          "&:last-child": {
                              borderStartEndRadius: borderRadiusSM,
                              borderEndEndRadius: borderRadiusSM
                          }
                      },
                      "&:hover": {
                          position: "relative",
                          color: colorPrimary
                      },
                      "&:has(:focus-visible)": Object.assign({}, genFocusOutline(token)),
                      [`${componentCls}-inner, input[type='checkbox'], input[type='radio']`]: {
                          width: 0,
                          height: 0,
                          opacity: 0,
                          pointerEvents: "none"
                      },
                      [`&-checked:not(${componentCls}-button-wrapper-disabled)`]: {
                          zIndex: 1,
                          color: colorPrimary,
                          background: buttonCheckedBg,
                          borderColor: colorPrimary,
                          "&::before": {
                              backgroundColor: colorPrimary
                          },
                          "&:first-child": {
                              borderColor: colorPrimary
                          },
                          "&:hover": {
                              color: colorPrimaryHover,
                              borderColor: colorPrimaryHover,
                              "&::before": {
                                  backgroundColor: colorPrimaryHover
                              }
                          },
                          "&:active": {
                              color: colorPrimaryActive,
                              borderColor: colorPrimaryActive,
                              "&::before": {
                                  backgroundColor: colorPrimaryActive
                              }
                          }
                      },
                      [`${componentCls}-group-solid &-checked:not(${componentCls}-button-wrapper-disabled)`]: {
                          color: buttonSolidCheckedColor,
                          background: buttonSolidCheckedBg,
                          borderColor: buttonSolidCheckedBg,
                          "&:hover": {
                              color: buttonSolidCheckedColor,
                              background: buttonSolidCheckedHoverBg,
                              borderColor: buttonSolidCheckedHoverBg
                          },
                          "&:active": {
                              color: buttonSolidCheckedColor,
                              background: buttonSolidCheckedActiveBg,
                              borderColor: buttonSolidCheckedActiveBg
                          }
                      },
                      "&-disabled": {
                          color: colorTextDisabled,
                          backgroundColor: colorBgContainerDisabled,
                          borderColor: colorBorder,
                          cursor: "not-allowed",
                          "&:first-child, &:hover": {
                              color: colorTextDisabled,
                              backgroundColor: colorBgContainerDisabled,
                              borderColor: colorBorder
                          }
                      },
                      [`&-disabled${componentCls}-button-wrapper-checked`]: {
                          color: buttonCheckedColorDisabled,
                          backgroundColor: buttonCheckedBgDisabled,
                          borderColor: colorBorder,
                          boxShadow: "none"
                      }
                  }
              };
          }, getDotSize = radioSize => radioSize - 8, radio_style = genComponentStyleHook("Radio", (token => {
              const {controlOutline, controlOutlineWidth, radioSize} = token, radioFocusShadow = `0 0 0 ${controlOutlineWidth}px ${controlOutline}`, radioButtonFocusShadow = radioFocusShadow, radioToken = statistic_merge(token, {
                  radioDotDisabledSize: getDotSize(radioSize),
                  radioFocusShadow,
                  radioButtonFocusShadow
              });
              return [ getGroupRadioStyle(radioToken), getRadioBasicStyle(radioToken), getRadioButtonStyle(radioToken) ];
          }), (token => {
              const {wireframe, padding, marginXS, lineWidth, fontSizeLG, colorText, colorBgContainer, colorTextDisabled, controlItemBgActiveDisabled, colorTextLightSolid, colorPrimary, colorPrimaryHover, colorPrimaryActive} = token, radioSize = fontSizeLG;
              return {
                  radioSize,
                  dotSize: wireframe ? getDotSize(radioSize) : radioSize - 2 * (4 + lineWidth),
                  dotColorDisabled: colorTextDisabled,
                  buttonSolidCheckedColor: colorTextLightSolid,
                  buttonSolidCheckedBg: colorPrimary,
                  buttonSolidCheckedHoverBg: colorPrimaryHover,
                  buttonSolidCheckedActiveBg: colorPrimaryActive,
                  buttonBg: colorBgContainer,
                  buttonCheckedBg: colorBgContainer,
                  buttonColor: colorText,
                  buttonCheckedBgDisabled: controlItemBgActiveDisabled,
                  buttonCheckedColorDisabled: colorTextDisabled,
                  buttonPaddingInline: padding - lineWidth,
                  wrapperMarginInlineEnd: marginXS
              };
          }));
          var radio_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const InternalRadio = (props, ref) => {
              var _a, _b;
              const groupContext = react.useContext(context), radioOptionTypeContext = react.useContext(RadioOptionTypeContext), {getPrefixCls, direction, radio} = react.useContext(context_ConfigContext), mergedRef = composeRef(ref, react.useRef(null)), {isFormItemInput} = react.useContext(FormItemInputContext);
              const onChange = e => {
                  var _a, _b;
                  null === (_a = props.onChange) || void 0 === _a || _a.call(props, e), null === (_b = null == groupContext ? void 0 : groupContext.onChange) || void 0 === _b || _b.call(groupContext, e);
              }, {prefixCls: customizePrefixCls, className, rootClassName, children, style} = props, restProps = radio_rest(props, [ "prefixCls", "className", "rootClassName", "children", "style" ]), radioPrefixCls = getPrefixCls("radio", customizePrefixCls), isButtonType = "button" === ((null == groupContext ? void 0 : groupContext.optionType) || radioOptionTypeContext), prefixCls = isButtonType ? `${radioPrefixCls}-button` : radioPrefixCls, [wrapSSR, hashId] = radio_style(radioPrefixCls), radioProps = Object.assign({}, restProps), disabled = react.useContext(config_provider_DisabledContext);
              groupContext && (radioProps.name = groupContext.name, radioProps.onChange = onChange, 
              radioProps.checked = props.value === groupContext.value, radioProps.disabled = null !== (_a = radioProps.disabled) && void 0 !== _a ? _a : groupContext.disabled), 
              radioProps.disabled = null !== (_b = radioProps.disabled) && void 0 !== _b ? _b : disabled;
              const wrapperClassString = classnames_default()(`${prefixCls}-wrapper`, {
                  [`${prefixCls}-wrapper-checked`]: radioProps.checked,
                  [`${prefixCls}-wrapper-disabled`]: radioProps.disabled,
                  [`${prefixCls}-wrapper-rtl`]: "rtl" === direction,
                  [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
              }, null == radio ? void 0 : radio.className, className, rootClassName, hashId);
              return wrapSSR(react.createElement(wave, {
                  component: "Radio",
                  disabled: radioProps.disabled
              }, react.createElement("label", {
                  className: wrapperClassString,
                  style: Object.assign(Object.assign({}, null == radio ? void 0 : radio.style), style),
                  onMouseEnter: props.onMouseEnter,
                  onMouseLeave: props.onMouseLeave
              }, react.createElement(rc_checkbox_es, Object.assign({}, radioProps, {
                  className: classnames_default()(radioProps.className, !isButtonType && "ant-wave-target"),
                  type: "radio",
                  prefixCls,
                  ref: mergedRef
              })), void 0 !== children ? react.createElement("span", null, children) : null)));
          };
          const radio_radio = react.forwardRef(InternalRadio), RadioGroup = react.forwardRef(((props, ref) => {
              const {getPrefixCls, direction} = react.useContext(context_ConfigContext), [value, setValue] = useMergedState(props.defaultValue, {
                  value: props.value
              }), {prefixCls: customizePrefixCls, className, rootClassName, options, buttonStyle = "outline", disabled, children, size: customizeSize, style, id, onMouseEnter, onMouseLeave, onFocus, onBlur} = props, prefixCls = getPrefixCls("radio", customizePrefixCls), groupPrefixCls = `${prefixCls}-group`, [wrapSSR, hashId] = radio_style(prefixCls);
              let childrenToRender = children;
              options && options.length > 0 && (childrenToRender = options.map((option => "string" == typeof option || "number" == typeof option ? react.createElement(radio_radio, {
                  key: option.toString(),
                  prefixCls,
                  disabled,
                  value: option,
                  checked: value === option
              }, option) : react.createElement(radio_radio, {
                  key: `radio-group-value-options-${option.value}`,
                  prefixCls,
                  disabled: option.disabled || disabled,
                  value: option.value,
                  checked: value === option.value,
                  title: option.title,
                  style: option.style
              }, option.label))));
              const mergedSize = hooks_useSize(customizeSize), classString = classnames_default()(groupPrefixCls, `${groupPrefixCls}-${buttonStyle}`, {
                  [`${groupPrefixCls}-${mergedSize}`]: mergedSize,
                  [`${groupPrefixCls}-rtl`]: "rtl" === direction
              }, className, rootClassName, hashId);
              return wrapSSR(react.createElement("div", Object.assign({}, function(props) {
                  var mergedConfig, ariaOnly = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                  mergedConfig = !1 === ariaOnly ? {
                      aria: !0,
                      data: !0,
                      attr: !0
                  } : !0 === ariaOnly ? {
                      aria: !0
                  } : _objectSpread2({}, ariaOnly);
                  var attrs = {};
                  return Object.keys(props).forEach((function(key) {
                      (mergedConfig.aria && ("role" === key || pickAttrs_match(key, "aria-")) || mergedConfig.data && pickAttrs_match(key, "data-") || mergedConfig.attr && propList.includes(key)) && (attrs[key] = props[key]);
                  })), attrs;
              }(props, {
                  aria: !0,
                  data: !0
              }), {
                  className: classString,
                  style,
                  onMouseEnter,
                  onMouseLeave,
                  onFocus,
                  onBlur,
                  id,
                  ref
              }), react.createElement(RadioGroupContextProvider, {
                  value: {
                      onChange: ev => {
                          const lastValue = value, val = ev.target.value;
                          "value" in props || setValue(val);
                          const {onChange} = props;
                          onChange && val !== lastValue && onChange(ev);
                      },
                      value,
                      disabled: props.disabled,
                      name: props.name,
                      optionType: props.optionType
                  }
              }, childrenToRender)));
          })), radio_group = react.memo(RadioGroup);
          var radioButton_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const RadioButton = (props, ref) => {
              const {getPrefixCls} = react.useContext(context_ConfigContext), {prefixCls: customizePrefixCls} = props, radioProps = radioButton_rest(props, [ "prefixCls" ]), prefixCls = getPrefixCls("radio", customizePrefixCls);
              return react.createElement(RadioOptionTypeContextProvider, {
                  value: "button"
              }, react.createElement(radio_radio, Object.assign({
                  prefixCls
              }, radioProps, {
                  type: "radio",
                  ref
              })));
          }, radioButton = react.forwardRef(RadioButton), radio_Radio = radio_radio;
          radio_Radio.Button = radioButton, radio_Radio.Group = radio_group, radio_Radio.__ANT_RADIO = !0;
          const es_radio = radio_Radio;
          const floatingCloseModal = function({y, onClose}) {
              const [value, setValue] = (0, react.useState)(0);
              return (0, jsx_runtime.jsxs)("div", {
                  className: "felo-floating-close-modal",
                  style: {
                      top: `${y}px`
                  },
                  children: [ (0, jsx_runtime.jsx)("h1", {
                      className: "close-modal-title",
                      children: chrome.i18n.getMessage("PLUGIN__close_confirm_title")
                  }), (0, jsx_runtime.jsxs)("div", {
                      className: "close-modal-radios",
                      children: [ (0, jsx_runtime.jsx)(es_radio, {
                          checked: 0 === value,
                          onClick: () => setValue(0),
                          children: chrome.i18n.getMessage("PLUGIN__close_until_next")
                      }), (0, jsx_runtime.jsx)(es_radio, {
                          checked: 1 === value,
                          onClick: () => setValue(1),
                          children: chrome.i18n.getMessage("PLUGIN__close_with_website")
                      }), (0, jsx_runtime.jsx)(es_radio, {
                          checked: 2 === value,
                          onClick: () => setValue(2),
                          children: chrome.i18n.getMessage("PLUGIN__close_global")
                      }) ]
                  }), (0, jsx_runtime.jsxs)("div", {
                      className: "close-modal-tips",
                      children: [ (0, jsx_runtime.jsx)("p", {
                          children: chrome.i18n.getMessage("PLUGIN__close_tips_first")
                      }), (0, jsx_runtime.jsx)("p", {
                          dangerouslySetInnerHTML: {
                              __html: chrome.i18n.getMessage("PLUGIN__close_tips_second")
                          }
                      }) ]
                  }), (0, jsx_runtime.jsxs)("footer", {
                      className: "close-modal-action",
                      children: [ (0, jsx_runtime.jsx)(es_button, {
                          onClick: onClose,
                          children: chrome.i18n.getMessage("cancel")
                      }), (0, jsx_runtime.jsx)(es_button, {
                          type: "primary",
                          onClick: () => {
                              switch (value) {
                                case 0:
                                  sessionStorage.setItem("hideFloatingSwitch", "1"), uiConfig.getState().setFloatingSwitchVisible(!1);
                                  break;

                                case 1:
                                  uiConfig.getState().setFloatingSwitchVisible(!1), userConfig.getState().addShortcutIgnoreSite(window.location.host);
                                  break;

                                case 2:
                                  chrome.runtime.sendMessage({
                                      type: "hide-floating-btn"
                                  });
                              }
                              onClose();
                          },
                          children: chrome.i18n.getMessage("confirm")
                      }) ]
                  }) ]
              });
          };
          var _TranslatorLogo, _FloatingBtn;
          const onClick = () => {
              const {visible, floatingSwitchHighlight} = uiConfig.getState();
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_from: "FloatingButton",
                  trigger_control: visible ? "CloseSubtitle" : "OpenSubtitle"
              }), visible ? window.postMessage({
                  type: "subtitle:close"
              }, "*") : (floatingSwitchHighlight && uiConfig.getState().setFloatingSwitchHighlight(!1), 
              window.postMessage({
                  type: "subtitle:start",
                  val: `floating-${Math.floor(1e3 * Math.random())}`
              }, "*"));
          };
          function FloatingBtn() {
              const visible = useUIConfigStore((({floatingSwitchVisible}) => floatingSwitchVisible)), active = useUIConfigStore((({floatingSwitchHighlight}) => floatingSwitchHighlight)), panelVisible = useVisible(), [closeModalY, setCloseModalY] = (0, 
              react.useState)(-1);
              return visible ? (0, jsx_runtime.jsxs)(antdConfigProvider, {
                  children: [ (0, jsx_runtime.jsxs)(dragButton, {
                      className: "floating-wrapper",
                      onClick,
                      children: [ (0, jsx_runtime.jsx)("div", {
                          className: "floating-close",
                          onClick: ev => {
                              ev.stopPropagation(), setCloseModalY(-1 === closeModalY ? ev.clientY : -1);
                          }
                      }), (0, jsx_runtime.jsxs)("div", {
                          className: dist_clsx("floating-btn", active && "heartbeat", panelVisible && "active"),
                          children: [ _TranslatorLogo || (_TranslatorLogo = (0, jsx_runtime.jsx)(TranslatorLogo, {})), chrome.i18n.getMessage(panelVisible ? "PLUGIN__close_subtitle" : "PLUGIN__open_subtitle") ]
                      }) ]
                  }), closeModalY > -1 && (0, jsx_runtime.jsx)(floatingCloseModal, {
                      y: closeModalY,
                      onClose: () => setCloseModalY(-1)
                  }) ]
              }) : null;
          }
          function debounce(delay, callback, options) {
              var _ref$atBegin = (options || {}).atBegin;
              return function(delay, callback, options) {
                  var timeoutID, _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = void 0 !== _ref$noTrailing && _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = void 0 !== _ref$noLeading && _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = void 0 === _ref$debounceMode ? void 0 : _ref$debounceMode, cancelled = !1, lastExec = 0;
                  function clearExistingTimeout() {
                      timeoutID && clearTimeout(timeoutID);
                  }
                  function wrapper() {
                      for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) arguments_[_key] = arguments[_key];
                      var self = this, elapsed = Date.now() - lastExec;
                      function exec() {
                          lastExec = Date.now(), callback.apply(self, arguments_);
                      }
                      function clear() {
                          timeoutID = void 0;
                      }
                      cancelled || (noLeading || !debounceMode || timeoutID || exec(), clearExistingTimeout(), 
                      void 0 === debounceMode && elapsed > delay ? noLeading ? (lastExec = Date.now(), 
                      noTrailing || (timeoutID = setTimeout(debounceMode ? clear : exec, delay))) : exec() : !0 !== noTrailing && (timeoutID = setTimeout(debounceMode ? clear : exec, void 0 === debounceMode ? delay - elapsed : delay)));
                  }
                  return wrapper.cancel = function(options) {
                      var _ref2$upcomingOnly = (options || {}).upcomingOnly, upcomingOnly = void 0 !== _ref2$upcomingOnly && _ref2$upcomingOnly;
                      clearExistingTimeout(), cancelled = !upcomingOnly;
                  }, wrapper;
              }(delay, callback, {
                  debounceMode: !1 !== (void 0 !== _ref$atBegin && _ref$atBegin)
              });
          }
          const antSpinMove = new Keyframes("antSpinMove", {
              to: {
                  opacity: 1
              }
          }), antRotate = new Keyframes("antRotate", {
              to: {
                  transform: "rotate(405deg)"
              }
          }), genSpinStyle = token => ({
              [`${token.componentCls}`]: Object.assign(Object.assign({}, resetComponent(token)), {
                  position: "absolute",
                  display: "none",
                  color: token.colorPrimary,
                  fontSize: 0,
                  textAlign: "center",
                  verticalAlign: "middle",
                  opacity: 0,
                  transition: `transform ${token.motionDurationSlow} ${token.motionEaseInOutCirc}`,
                  "&-spinning": {
                      position: "static",
                      display: "inline-block",
                      opacity: 1
                  },
                  "&-nested-loading": {
                      position: "relative",
                      [`> div > ${token.componentCls}`]: {
                          position: "absolute",
                          top: 0,
                          insetInlineStart: 0,
                          zIndex: 4,
                          display: "block",
                          width: "100%",
                          height: "100%",
                          maxHeight: token.contentHeight,
                          [`${token.componentCls}-dot`]: {
                              position: "absolute",
                              top: "50%",
                              insetInlineStart: "50%",
                              margin: -token.dotSize / 2
                          },
                          [`${token.componentCls}-text`]: {
                              position: "absolute",
                              top: "50%",
                              width: "100%",
                              paddingTop: (token.dotSize - token.fontSize) / 2 + 2,
                              textShadow: `0 1px 2px ${token.colorBgContainer}`,
                              fontSize: token.fontSize
                          },
                          [`&${token.componentCls}-show-text ${token.componentCls}-dot`]: {
                              marginTop: -token.dotSize / 2 - 10
                          },
                          "&-sm": {
                              [`${token.componentCls}-dot`]: {
                                  margin: -token.dotSizeSM / 2
                              },
                              [`${token.componentCls}-text`]: {
                                  paddingTop: (token.dotSizeSM - token.fontSize) / 2 + 2
                              },
                              [`&${token.componentCls}-show-text ${token.componentCls}-dot`]: {
                                  marginTop: -token.dotSizeSM / 2 - 10
                              }
                          },
                          "&-lg": {
                              [`${token.componentCls}-dot`]: {
                                  margin: -token.dotSizeLG / 2
                              },
                              [`${token.componentCls}-text`]: {
                                  paddingTop: (token.dotSizeLG - token.fontSize) / 2 + 2
                              },
                              [`&${token.componentCls}-show-text ${token.componentCls}-dot`]: {
                                  marginTop: -token.dotSizeLG / 2 - 10
                              }
                          }
                      },
                      [`${token.componentCls}-container`]: {
                          position: "relative",
                          transition: `opacity ${token.motionDurationSlow}`,
                          "&::after": {
                              position: "absolute",
                              top: 0,
                              insetInlineEnd: 0,
                              bottom: 0,
                              insetInlineStart: 0,
                              zIndex: 10,
                              width: "100%",
                              height: "100%",
                              background: token.colorBgContainer,
                              opacity: 0,
                              transition: `all ${token.motionDurationSlow}`,
                              content: '""',
                              pointerEvents: "none"
                          }
                      },
                      [`${token.componentCls}-blur`]: {
                          clear: "both",
                          opacity: .5,
                          userSelect: "none",
                          pointerEvents: "none",
                          "&::after": {
                              opacity: .4,
                              pointerEvents: "auto"
                          }
                      }
                  },
                  "&-tip": {
                      color: token.spinDotDefault
                  },
                  [`${token.componentCls}-dot`]: {
                      position: "relative",
                      display: "inline-block",
                      fontSize: token.dotSize,
                      width: "1em",
                      height: "1em",
                      "&-item": {
                          position: "absolute",
                          display: "block",
                          width: (token.dotSize - token.marginXXS / 2) / 2,
                          height: (token.dotSize - token.marginXXS / 2) / 2,
                          backgroundColor: token.colorPrimary,
                          borderRadius: "100%",
                          transform: "scale(0.75)",
                          transformOrigin: "50% 50%",
                          opacity: .3,
                          animationName: antSpinMove,
                          animationDuration: "1s",
                          animationIterationCount: "infinite",
                          animationTimingFunction: "linear",
                          animationDirection: "alternate",
                          "&:nth-child(1)": {
                              top: 0,
                              insetInlineStart: 0
                          },
                          "&:nth-child(2)": {
                              top: 0,
                              insetInlineEnd: 0,
                              animationDelay: "0.4s"
                          },
                          "&:nth-child(3)": {
                              insetInlineEnd: 0,
                              bottom: 0,
                              animationDelay: "0.8s"
                          },
                          "&:nth-child(4)": {
                              bottom: 0,
                              insetInlineStart: 0,
                              animationDelay: "1.2s"
                          }
                      },
                      "&-spin": {
                          transform: "rotate(45deg)",
                          animationName: antRotate,
                          animationDuration: "1.2s",
                          animationIterationCount: "infinite",
                          animationTimingFunction: "linear"
                      }
                  },
                  [`&-sm ${token.componentCls}-dot`]: {
                      fontSize: token.dotSizeSM,
                      i: {
                          width: (token.dotSizeSM - token.marginXXS / 2) / 2,
                          height: (token.dotSizeSM - token.marginXXS / 2) / 2
                      }
                  },
                  [`&-lg ${token.componentCls}-dot`]: {
                      fontSize: token.dotSizeLG,
                      i: {
                          width: (token.dotSizeLG - token.marginXXS) / 2,
                          height: (token.dotSizeLG - token.marginXXS) / 2
                      }
                  },
                  [`&${token.componentCls}-show-text ${token.componentCls}-text`]: {
                      display: "block"
                  }
              })
          }), spin_style = genComponentStyleHook("Spin", (token => {
              const spinToken = statistic_merge(token, {
                  spinDotDefault: token.colorTextDescription
              });
              return [ genSpinStyle(spinToken) ];
          }), (token => ({
              contentHeight: 400,
              dotSize: token.controlHeightLG / 2,
              dotSizeSM: .35 * token.controlHeightLG,
              dotSizeLG: token.controlHeight
          })));
          var spin_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          let defaultIndicator = null;
          const Spin = props => {
              const {spinPrefixCls: prefixCls, spinning: customSpinning = !0, delay = 0, className, rootClassName, size = "default", tip, wrapperClassName, style, children, hashId} = props, restProps = spin_rest(props, [ "spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId" ]), [spinning, setSpinning] = react.useState((() => customSpinning && !function(spinning, delay) {
                  return !!spinning && !!delay && !isNaN(Number(delay));
              }(customSpinning, delay)));
              react.useEffect((() => {
                  if (customSpinning) {
                      const showSpinning = debounce(delay, (() => {
                          setSpinning(!0);
                      }));
                      return showSpinning(), () => {
                          var _a;
                          null === (_a = null == showSpinning ? void 0 : showSpinning.cancel) || void 0 === _a || _a.call(showSpinning);
                      };
                  }
                  setSpinning(!1);
              }), [ delay, customSpinning ]);
              const isNestedPattern = react.useMemo((() => void 0 !== children), [ children ]);
              const {direction, spin} = react.useContext(context_ConfigContext), spinClassName = classnames_default()(prefixCls, null == spin ? void 0 : spin.className, {
                  [`${prefixCls}-sm`]: "small" === size,
                  [`${prefixCls}-lg`]: "large" === size,
                  [`${prefixCls}-spinning`]: spinning,
                  [`${prefixCls}-show-text`]: !!tip,
                  [`${prefixCls}-rtl`]: "rtl" === direction
              }, className, rootClassName, hashId), containerClassName = classnames_default()(`${prefixCls}-container`, {
                  [`${prefixCls}-blur`]: spinning
              }), divProps = omit_omit(restProps, [ "indicator", "prefixCls" ]), mergedStyle = Object.assign(Object.assign({}, null == spin ? void 0 : spin.style), style), spinElement = react.createElement("div", Object.assign({}, divProps, {
                  style: mergedStyle,
                  className: spinClassName,
                  "aria-live": "polite",
                  "aria-busy": spinning
              }), function(prefixCls, props) {
                  const {indicator} = props, dotClassName = `${prefixCls}-dot`;
                  return null === indicator ? null : reactNode_isValidElement(indicator) ? cloneElement(indicator, {
                      className: classnames_default()(indicator.props.className, dotClassName)
                  }) : reactNode_isValidElement(defaultIndicator) ? cloneElement(defaultIndicator, {
                      className: classnames_default()(defaultIndicator.props.className, dotClassName)
                  }) : react.createElement("span", {
                      className: classnames_default()(dotClassName, `${prefixCls}-dot-spin`)
                  }, react.createElement("i", {
                      className: `${prefixCls}-dot-item`,
                      key: 1
                  }), react.createElement("i", {
                      className: `${prefixCls}-dot-item`,
                      key: 2
                  }), react.createElement("i", {
                      className: `${prefixCls}-dot-item`,
                      key: 3
                  }), react.createElement("i", {
                      className: `${prefixCls}-dot-item`,
                      key: 4
                  }));
              }(prefixCls, props), tip && isNestedPattern ? react.createElement("div", {
                  className: `${prefixCls}-text`
              }, tip) : null);
              return isNestedPattern ? react.createElement("div", Object.assign({}, divProps, {
                  className: classnames_default()(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
              }), spinning && react.createElement("div", {
                  key: "loading"
              }, spinElement), react.createElement("div", {
                  className: containerClassName,
                  key: "container"
              }, children)) : spinElement;
          }, SpinFC = props => {
              const {prefixCls: customizePrefixCls} = props, {getPrefixCls} = react.useContext(context_ConfigContext), spinPrefixCls = getPrefixCls("spin", customizePrefixCls), [wrapSSR, hashId] = spin_style(spinPrefixCls), spinClassProps = Object.assign(Object.assign({}, props), {
                  spinPrefixCls,
                  hashId
              });
              return wrapSSR(react.createElement(Spin, Object.assign({}, spinClassProps)));
          };
          SpinFC.setDefaultIndicator = indicator => {
              defaultIndicator = indicator;
          };
          const spin = SpinFC;
          const hooks_useDisplayStatus = function() {
              const limited = useLimited(), mqttErrorMsg = useMqttStore((({errorMsg}) => errorMsg)), limitErrorMsg = useLimitStore((({errorMsg}) => errorMsg)), status = useMqttStatus(), noCapture = useUIConfigStore((({noCapture}) => noCapture)), paused = usePaused();
              return noCapture ? [ "noCapture", void 0 ] : limitErrorMsg ? [ "error", `${chrome.i18n.getMessage("load_fail")} (${limitErrorMsg})` ] : void 0 === limited ? [ "loading", chrome.i18n.getMessage("loading") ] : !0 === limited ? [ "limited", void 0 ] : mqttErrorMsg && "STILL_USING" !== mqttErrorMsg ? [ "error", `${chrome.i18n.getMessage("load_fail")} (${mqttErrorMsg})` ] : void 0 !== status || paused ? !1 !== status || paused ? [ void 0, void 0 ] : [ "error", chrome.i18n.getMessage("mqtt_close") ] : [ "loading", chrome.i18n.getMessage("loading") ];
          };
          var noCapture_div;
          let linkUrl = "https://docs.google.com/document/d/1tJd2NLO_hcoyYNRYijRU8qa0jIPE2JW00zd8HzNKHUg/edit?usp=sharing";
          const language = chrome.i18n.getUILanguage();
          language.includes("zh") ? linkUrl = "https://docs.google.com/document/d/1VGjsJmWo0Qqxz8z5F9Y3JrhohVMQSuud5MOLWUaT63M/edit?usp=sharing" : language.includes("ja") && (linkUrl = "https://docs.google.com/document/d/1tJd2NLO_hcoyYNRYijRU8qa0jIPE2JW00zd8HzNKHUg/edit?usp=sharing");
          const noCapture = () => (0, jsx_runtime.jsxs)("div", {
              className: "felo-no-capture",
              children: [ noCapture_div || (noCapture_div = (0, jsx_runtime.jsx)("div", {
                  className: "felo-n-c-header",
                  children: (0, jsx_runtime.jsx)("img", {
                      src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAAuCAYAAABXuSs3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWpSURBVHgBzZlbbxNHFMf/M7u+xYTYhRBiVNVQwkWoSoBAealk8lKpL4VPQOAL0A9QKaFVH/pSwUvFG/AJSqVKVR9KXLVFKOXiUCRaJKRNBCGkxDhOgu29zPTM2gaHJCbx2El+0to7e/3vmXPOnJ1l0KSvLxXjAX6KQfaBsQ8kbWISMTBaKtA2i0lmAWIMjKc928tkMmkLGjA0gBJrBIwzJOQUiU2hESRL092v3hn99RoaYE3CfesG+Xmy6Be1FtXEoh65enf0xoW1nLRq4f0nUikp+BVaTaI1WCRneLU98E7hFR8eYoysvA5Qb150HXGBYiBX97h6O0l00gzyH1TAYX2xPFucrBfAKwpXoo0gH0HrXONd1BW/rPBNILrKiuKXCPdTXZDfw8aL9iE3zYiy+EU+z98+UAUiNoloBVm2zyxrenv7G44cGxik7HEFmxAmxMnbt9PpanuRxUn0EDRpb2M4vD+IgaNhHNodQMBsaHBeguT8inLjatusrhw5PqDlIt1xD0ODBvoObYNpBFDuTAanNIeffn6My79sxUwxBA2SNGqrsWRYNV5bnG4zCA2+/GwC/QeCJNpEVbS6fMBg+GRvFke7Z6ALXfF81eq+cOXb0AzI2XkPUriVlqzciUO4RdivipjIR9EEYjzEB9WKL5xK0jPQ5MF4GPAc0iz9K6qAKSNIv4nZUhDNgAn2ufrnarBpuDSt4ZUwSLOoXN1A2SYS3Iyg68B+fHcuh1SPvrtQMZPy6yfDMJpSh5z6eAHMVMEn3lhd/ZO1eagNPQcT+Pqsi9O9z6GLenHhkosUNOneWkAyESp7h7Dpx6vs8coLV1lGItwex7lPbYRMD1pw2cfpXr3QZHvEhhmJQLolEq6WAuks0lINVu67j6AY6OzqQGpfFjpQ6ZvkZKYkNIkGy0EpXRuiOEuaSZhNpYU7DzgLtE/4S2l+ljwngP4PS9CD9aqkm4QmUjIU8zNQ3ccMFZiMBBYom3A/uzCD3IdSZSG/gEjHNhzugS4xE03gWT6M3CRZk4QGIm3+NuYUSXyQdJNwbvuWnpt+hWg8j8TOCPbtmMej6S1okJiR2LV7GJosOCYORmcQ5XlK5UUyrgPPVu5A7iOEL17x4MEcgl4e7dtjiAfyuPGwA41CwpM0/rMwNBDkKn8+3YF/n2yBPeeiQ87iZdYBpyB1SiUEwiFKLEH89beN6ecCXfEF7Hk/iKcTBTx+2ZjVyVWYKtC1pxocwZGZifvL5XvSr1SO73wB2+X4ZjCL0JaYSun4frSHcswjJLZPYzK/Fw1iKR/PoMkvDp4su8bNZ53oDBfhlmYqgQpkqUL86uZH0IJmxbiUchwtRLmREJVSQDSrNhdjygwZtBCXxEoh/YKxObJpOPPkCBeOuI4WQjmFLC7La01S7poY4/7bs5RptAiXgtYpuOTnBX+g0oYmSzO30pZfj0vOfkSLKJHw+TkP9sIcHEdAG+ZdVX++cFES1JA5tAAVnL8/bMd/41ncn2iDDjScWXdG0/6kqCosMDVlFbt37YlQR6bQAsZexPHbPzHcz74HLZi88OypdctfrW4rz32ze1RZJLEJUda+Ozqyu9p+/ZavgpQLeRabFEqqw7Vto7YxOWlZiUQyTnnrBDYTTF4i3/62dtOSuUPPkcM0mrZ0UFoLykW8yGJrK5YIVy4jDHlanYANRmkQXJ7MpJd+nVh5Yv9EKskFG9moYH0t+tbyE/t8pRPVCerEjbA83TNTT7TCqHeBqSdWrqszeY0q0si6BSwFomiTZzN/pKfqHoZVcuRYapDED7XKdVTPqnRcOwdejzVXPf3HB4YFzTU26wEog+U4Y5fcNnFxuSBciYbLNdUDJP5M45/EVUXKr3tR79paBFfRrjNV9jEc+g5q0gMI9EqaYGI1r4LKovRwOaZeEZkcl4JlRFRcb0RsLf8DpCBV/6PCYxUAAAAASUVORK5CYII=",
                      alt: "icon"
                  })
              })), (0, jsx_runtime.jsx)("h4", {
                  className: "felo-n-c-info",
                  children: chrome.i18n.getMessage("PLUGIN__NoCaptureInfo")
              }), (0, jsx_runtime.jsx)("img", {
                  className: "felo-n-c-img",
                  src: `chrome-extension://${chrome.runtime.id}/img/no-capture.svg`,
                  alt: "demo"
              }), (0, jsx_runtime.jsxs)("a", {
                  className: "felo-n-c-link",
                  href: linkUrl,
                  target: "_block",
                  children: [ chrome.i18n.getMessage("PLUGIN__NoCaptureFailAlert"), " >>" ]
              }) ]
          });
          var _NoCapture, _Spin, _Spin3;
          const Falert = ({children}) => {
              const [display, displayMsg] = hooks_useDisplayStatus();
              return "noCapture" === display ? _NoCapture || (_NoCapture = (0, jsx_runtime.jsx)(noCapture, {})) : "loading" === display || "error" === display ? (0, 
              jsx_runtime.jsxs)("div", {
                  className: "felo-loading",
                  children: [ "loading" === display && (_Spin || (_Spin = (0, jsx_runtime.jsx)(spin, {}))), displayMsg ]
              }) : children;
          }, RecognizingTip = () => {
              const limited = useLimited(), paused = usePaused();
              return limited ? null : (0, jsx_runtime.jsxs)("div", {
                  className: "felo-loading",
                  children: [ _Spin3 || (_Spin3 = (0, jsx_runtime.jsx)(spin, {})), chrome.i18n.getMessage(paused ? "messageStop" : "RecognizTip") ]
              });
          };
          var toolbar_svg, toolbar_svg2, toolbar_svg3, toolbar_svg4, toolbar_svg5, _Continue, _Translating;
          function Continue() {
              return toolbar_svg || (toolbar_svg = (0, jsx_runtime.jsx)("svg", {
                  width: "8",
                  height: "10",
                  viewBox: "0 0 8 10",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: (0, jsx_runtime.jsx)("path", {
                      d: "M.9 5V1.723a.35.35 0 0 1 .524-.304l2.879 1.645 2.855 1.632a.35.35 0 0 1 0 .608L4.303 6.936 1.423 8.58A.35.35 0 0 1 .9 8.277V5z",
                      stroke: "currentColor",
                      strokeWidth: "1.3",
                      strokeLinejoin: "round"
                  })
              }));
          }
          function Translating() {
              return toolbar_svg2 || (toolbar_svg2 = (0, jsx_runtime.jsxs)("svg", {
                  width: "11",
                  height: "12",
                  viewBox: "0 0 11 12",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [ (0, jsx_runtime.jsx)("rect", {
                      x: "3.286",
                      y: "1",
                      width: "4.571",
                      height: "7.429",
                      rx: "2.286",
                      fill: "currentColor",
                      stroke: "currentColor",
                      strokeWidth: ".75"
                  }), (0, jsx_runtime.jsx)("path", {
                      d: "M10.143 6.429a4.571 4.571 0 0 1-9.143 0",
                      stroke: "currentColor",
                      strokeWidth: "1.2",
                      strokeLinecap: "round"
                  }) ]
              }));
          }
          function HistoryWithPadding() {
              return toolbar_svg3 || (toolbar_svg3 = (0, jsx_runtime.jsxs)("svg", {
                  width: "24",
                  height: "24",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [ (0, jsx_runtime.jsx)("path", {
                      d: "M18 10V8.474a1 1 0 0 0-.367-.774L14.702 5.3A1.333 1.333 0 0 0 13.857 5H8a2 2 0 0 0-2 2v9.333a2 2 0 0 0 2 2h3M16.5 14.5v.933c0 .042.02.08.056.104l.694.463",
                      stroke: "currentColor",
                      strokeWidth: "1.2",
                      strokeLinecap: "round"
                  }), (0, jsx_runtime.jsx)("circle", {
                      cx: "16.5",
                      cy: "15.5",
                      r: "3.1",
                      stroke: "currentColor",
                      strokeWidth: "1.2"
                  }), (0, jsx_runtime.jsx)("path", {
                      d: "M13.934 5.333a.6.6 0 1 0-1.2 0h1.2zM18 9.933h.6v-1.2H18v1.2zm-5.267-4.6v2.5h1.2v-2.5h-1.2zm2.1 4.6H18v-1.2h-3.166v1.2zm-2.1-2.1c0 1.16.94 2.1 2.1 2.1v-1.2a.9.9 0 0 1-.9-.9h-1.2z",
                      fill: "currentColor"
                  }) ]
              }));
          }
          function SettingsWithPadding() {
              return toolbar_svg4 || (toolbar_svg4 = (0, jsx_runtime.jsxs)("svg", {
                  width: "24",
                  height: "24",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: [ (0, jsx_runtime.jsx)("path", {
                      d: "M10.86 6.054c.34-1.405 2.34-1.405 2.68 0a1.379 1.379 0 0 0 2.058.852c1.235-.752 2.648.661 1.896 1.896a1.38 1.38 0 0 0 .852 2.058c1.405.34 1.405 2.34 0 2.68a1.38 1.38 0 0 0-.852 2.058c.752 1.235-.661 2.648-1.896 1.896a1.38 1.38 0 0 0-2.058.852c-.34 1.405-2.34 1.405-2.68 0a1.38 1.38 0 0 0-2.058-.852c-1.235.752-2.648-.661-1.896-1.896a1.38 1.38 0 0 0-.852-2.058c-1.405-.34-1.405-2.34 0-2.68a1.379 1.379 0 0 0 .852-2.058c-.752-1.235.661-2.648 1.896-1.896a1.379 1.379 0 0 0 2.058-.852z",
                      stroke: "currentColor",
                      strokeWidth: "1.2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round"
                  }), (0, jsx_runtime.jsx)("path", {
                      d: "M14.8 12.4a2.4 2.4 0 1 1-4.801 0 2.4 2.4 0 0 1 4.801 0z",
                      stroke: "currentColor",
                      strokeWidth: "1.2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round"
                  }) ]
              }));
          }
          function HiddenWithPadding() {
              return toolbar_svg5 || (toolbar_svg5 = (0, jsx_runtime.jsx)("svg", {
                  width: "24",
                  height: "24",
                  viewBox: "0 0 24 24",
                  fill: "none",
                  xmlns: "http://www.w3.org/2000/svg",
                  children: (0, jsx_runtime.jsx)("path", {
                      d: "M6 18l4.667-4.667M13.334 10.667L18 6M17.334 10.667h-4v-4M6.667 13.333h4v4",
                      stroke: "currentColor",
                      strokeWidth: "1.2",
                      strokeLinecap: "round",
                      strokeLinejoin: "round"
                  })
              }));
          }
          const stopBox = () => {
              const paused = usePaused(), connected = useMqttStatus(), clickLimit = (0, react.useRef)(Date.now()), renderText = paused ? "start" : connected ? "translating" : "loading";
              return (0, jsx_runtime.jsxs)("div", {
                  className: dist_clsx("felo-stop-box", connected && "active"),
                  onClick: () => {
                      const now = Date.now();
                      if (now - 3e3 > clickLimit.current) if (paused) {
                          const {bizId} = stores_info.getState(), {noCapture, connectBlocked} = uiConfig.getState();
                          if (!limit.getState().count || !bizId || noCapture || connectBlocked) return;
                          clickLimit.current = now, window.postMessage({
                              type: "subtitle:continue"
                          });
                      } else clickLimit.current = now, window.postMessage({
                          type: "subtitle:pause"
                      });
                  },
                  role: "button",
                  tabIndex: 0,
                  children: [ paused ? _Continue || (_Continue = (0, jsx_runtime.jsx)(Continue, {})) : _Translating || (_Translating = (0, 
                  jsx_runtime.jsx)(Translating, {})), chrome.i18n.getMessage(renderText) ]
              });
          }, onLoginWithoutCheck = () => new Promise(((resolve, reject) => {
              try {
                  console.log("@@event", "loginin"), (resolve => {
                      const accountUrl = `${FeloIDUrl}/login?app_id=subtitle&redirect_uri=${subtitleUrl}/login_popup_callback`, openWindowReference = window.open(accountUrl, "_blank", "width=800,height=600");
                      openWindowReference && openWindowReference.focus();
                      let timer = -1, timeout = -1;
                      timer = setInterval((() => {
                          openWindowReference && openWindowReference.closed && (clearInterval(timer), clearTimeout(timeout), 
                          resolve());
                      }), 1e3), timeout = setTimeout((() => {
                          clearInterval(timer), openWindowReference && openWindowReference.close();
                      }), 3e5);
                  })(resolve);
              } catch (error) {
                  reject(error);
              }
          })), historyNoticePopup_index_module_popup = "Cb8oXYDZFaMXAu8pLvT1", historyNoticePopup_index_module_close = "Z2Ho8hc41CrrQ4WtfLQ5";
          var _CloseWithPadding;
          const historyNoticePopup = function({onClick, children}) {
              const visible = useHistoryPopupVisible();
              return (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                  children: [ (0, react.cloneElement)(children, {
                      onClick: () => {
                          user.getState().logined ? onClick() : uiConfig.getState().setHistoryPopupVisible(!visible);
                      }
                  }), visible && (0, jsx_runtime.jsxs)("div", {
                      className: historyNoticePopup_index_module_popup,
                      children: [ (0, jsx_runtime.jsx)("a", {
                          onClick: onLoginWithoutCheck,
                          children: chrome.i18n.getMessage("login_to_view_history")
                      }), (0, jsx_runtime.jsx)("span", {
                          className: historyNoticePopup_index_module_close,
                          onClick: () => uiConfig.getState().setHistoryPopupVisible(!1),
                          children: _CloseWithPadding || (_CloseWithPadding = (0, jsx_runtime.jsx)(CloseWithPadding, {}))
                      }) ]
                  }) ]
              });
          }, style_module_toast = "whCRRNQKw3KYhnZZvqNe", style_module_text = "heEi1kDnIBbNqWKfOlLb", style_module_close = "lDRYe3mCDldQyWofM89x", style_module_action = "QNhxje8p4mIER7PTefbA", style_module_btn = "ig49IrtjGd9mCk6HxKyv", style_module_white = "KaMntNInTP6u76GAyBLO", style_module_bordered = "JOOx56nu6FCypAFBAGEN";
          var _Warning;
          const onOk = () => {
              uiConfig.setState({
                  connectBlocked: !1
              }), window.postMessage({
                  type: "subtitle:reload",
                  stillConnect: !0
              });
          }, onCancel = () => {
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_control: "CloseSubtitle"
              }), uiConfig.setState({
                  connectBlocked: !1
              });
          }, connectBlockedTips = () => (0, jsx_runtime.jsxs)("div", {
              className: style_module_toast,
              children: [ (0, jsx_runtime.jsxs)("div", {
                  className: style_module_text,
                  children: [ _Warning || (_Warning = (0, jsx_runtime.jsx)(Warning, {})), chrome.i18n.getMessage("continueConnectTips") ]
              }), (0, jsx_runtime.jsxs)("div", {
                  className: style_module_action,
                  children: [ (0, jsx_runtime.jsx)("button", {
                      className: dist_clsx(style_module_btn, style_module_bordered),
                      onClick: onCancel,
                      children: chrome.i18n.getMessage("cancel")
                  }), (0, jsx_runtime.jsx)("button", {
                      className: style_module_btn,
                      onClick: onOk,
                      children: chrome.i18n.getMessage("confirm")
                  }) ]
              }) ]
          });
          var limitedTips_Warning;
          const onLogin = () => {
              onLoginWithoutCheck();
          }, onRedirectInvite = () => {
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_control: "OpenInviteBox"
              }), appConfig.getState().setInviteClicked(!0), window.open(`${subtitleUrl}/invite`);
          }, onRedirectPricing = () => {
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_control: "OpenPayLink"
              }), window.open(`${subtitleUrl}/pricing`);
          }, limitedTips = () => {
              const logined = useLogined(), inviteClicked = useAppConfigStore((({inviteClicked}) => inviteClicked)), {loginEarnTime} = appConfig.getState();
              return (0, jsx_runtime.jsxs)("div", {
                  className: style_module_toast,
                  children: [ (0, jsx_runtime.jsxs)("div", {
                      className: style_module_text,
                      children: [ limitedTips_Warning || (limitedTips_Warning = (0, jsx_runtime.jsx)(Warning, {})), logined ? chrome.i18n.getMessage("limit_buy") : chrome.i18n.getMessage("limit_signup", loginEarnTime.toString()) ]
                  }), (0, jsx_runtime.jsx)("div", {
                      className: style_module_action,
                      children: logined ? (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                          children: [ !inviteClicked && (0, jsx_runtime.jsx)("button", {
                              className: dist_clsx(style_module_btn, style_module_white),
                              onClick: onRedirectInvite,
                              children: chrome.i18n.getMessage("get_more")
                          }), (0, jsx_runtime.jsx)("button", {
                              className: style_module_btn,
                              onClick: onRedirectPricing,
                              children: chrome.i18n.getMessage("buy")
                          }) ]
                      }) : (0, jsx_runtime.jsx)("button", {
                          className: style_module_btn,
                          onClick: onLogin,
                          children: chrome.i18n.getMessage("sign_in")
                      })
                  }) ]
              });
          };
          var willLimitedTips_Warning;
          const willLimitedTips_onLogin = () => {
              onLoginWithoutCheck();
          }, willLimitedTips_onRedirectPricing = () => {
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_control: "OpenPayLink"
              }), window.open(`${subtitleUrl}/pricing`);
          }, willLimitedTips = () => {
              const logined = useLogined(), limitCount = useLimitStore((({count}) => count));
              return void 0 === limitCount ? null : (0, jsx_runtime.jsxs)("div", {
                  className: style_module_toast,
                  children: [ (0, jsx_runtime.jsxs)("div", {
                      className: style_module_text,
                      children: [ willLimitedTips_Warning || (willLimitedTips_Warning = (0, jsx_runtime.jsx)(Warning, {})), chrome.i18n.getMessage("translate_time"), " ", formatSeconds(limitCount) ]
                  }), (0, jsx_runtime.jsx)("div", {
                      className: style_module_action,
                      children: logined ? (0, jsx_runtime.jsx)("button", {
                          className: style_module_btn,
                          onClick: willLimitedTips_onRedirectPricing,
                          children: chrome.i18n.getMessage("buy")
                      }) : (0, jsx_runtime.jsx)("button", {
                          className: style_module_btn,
                          onClick: willLimitedTips_onLogin,
                          children: chrome.i18n.getMessage("sign_in")
                      })
                  }) ]
              });
          };
          var noticeToast_Warning, _ConnectBlockedTips, _LimitedTips, _Warning2, _NoticeClose, _WillLimitedTips;
          const onReload = () => {
              window.postMessage({
                  type: "subtitle:reload"
              });
          }, onCloseMutedNotice = () => {
              uiConfig.setState({
                  mutedVisible: !1
              });
          };
          const noticeToast = function() {
              const limited = useLimited(), mutedVisible = useUIConfigStore((({mutedVisible}) => mutedVisible)), limitVisible = useUIConfigStore((({limitVisible}) => limitVisible)), connectBlocked = useUIConfigStore((({connectBlocked}) => connectBlocked)), [display, displayMsg] = hooks_useDisplayStatus();
              return "error" === display ? (0, jsx_runtime.jsxs)("div", {
                  className: style_module_toast,
                  children: [ (0, jsx_runtime.jsxs)("div", {
                      className: style_module_text,
                      children: [ noticeToast_Warning || (noticeToast_Warning = (0, jsx_runtime.jsx)(Warning, {})), displayMsg || "" ]
                  }), (0, jsx_runtime.jsx)("div", {
                      className: style_module_action,
                      children: (0, jsx_runtime.jsx)("button", {
                          className: style_module_btn,
                          onClick: onReload,
                          children: chrome.i18n.getMessage("retry")
                      })
                  }) ]
              }) : connectBlocked ? _ConnectBlockedTips || (_ConnectBlockedTips = (0, jsx_runtime.jsx)(connectBlockedTips, {})) : limitVisible && limited ? _LimitedTips || (_LimitedTips = (0, 
              jsx_runtime.jsx)(limitedTips, {})) : mutedVisible ? (0, jsx_runtime.jsxs)("div", {
                  className: style_module_toast,
                  children: [ (0, jsx_runtime.jsxs)("div", {
                      className: style_module_text,
                      children: [ _Warning2 || (_Warning2 = (0, jsx_runtime.jsx)(Warning, {})), chrome.i18n.getMessage("noAudioTips") ]
                  }), (0, jsx_runtime.jsx)("button", {
                      className: style_module_close,
                      onClick: onCloseMutedNotice,
                      children: _NoticeClose || (_NoticeClose = (0, jsx_runtime.jsx)(NoticeClose, {}))
                  }) ]
              }) : limitVisible ? _WillLimitedTips || (_WillLimitedTips = (0, jsx_runtime.jsx)(willLimitedTips, {})) : null;
          };
          function componentWillMount() {
              var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
              null != state && this.setState(state);
          }
          function componentWillReceiveProps(nextProps) {
              this.setState(function(prevState) {
                  var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
                  return null != state ? state : null;
              }.bind(this));
          }
          function componentWillUpdate(nextProps, nextState) {
              try {
                  var prevProps = this.props, prevState = this.state;
                  this.props = nextProps, this.state = nextState, this.__reactInternalSnapshotFlag = !0, 
                  this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(prevProps, prevState);
              } finally {
                  this.props = prevProps, this.state = prevState;
              }
          }
          function polyfill(Component) {
              var prototype = Component.prototype;
              if (!prototype || !prototype.isReactComponent) throw new Error("Can only polyfill class components");
              if ("function" != typeof Component.getDerivedStateFromProps && "function" != typeof prototype.getSnapshotBeforeUpdate) return Component;
              var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
              if ("function" == typeof prototype.componentWillMount ? foundWillMountName = "componentWillMount" : "function" == typeof prototype.UNSAFE_componentWillMount && (foundWillMountName = "UNSAFE_componentWillMount"), 
              "function" == typeof prototype.componentWillReceiveProps ? foundWillReceivePropsName = "componentWillReceiveProps" : "function" == typeof prototype.UNSAFE_componentWillReceiveProps && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), 
              "function" == typeof prototype.componentWillUpdate ? foundWillUpdateName = "componentWillUpdate" : "function" == typeof prototype.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), 
              null !== foundWillMountName || null !== foundWillReceivePropsName || null !== foundWillUpdateName) {
                  var componentName = Component.displayName || Component.name, newApiName = "function" == typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (null !== foundWillMountName ? "\n  " + foundWillMountName : "") + (null !== foundWillReceivePropsName ? "\n  " + foundWillReceivePropsName : "") + (null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks");
              }
              if ("function" == typeof Component.getDerivedStateFromProps && (prototype.componentWillMount = componentWillMount, 
              prototype.componentWillReceiveProps = componentWillReceiveProps), "function" == typeof prototype.getSnapshotBeforeUpdate) {
                  if ("function" != typeof prototype.componentDidUpdate) throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
                  prototype.componentWillUpdate = componentWillUpdate;
                  var componentDidUpdate = prototype.componentDidUpdate;
                  prototype.componentDidUpdate = function(prevProps, prevState, maybeSnapshot) {
                      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
                      componentDidUpdate.call(this, prevProps, prevState, snapshot);
                  };
              }
              return Component;
          }
          function clsx_m_r(e) {
              var t, f, n = "";
              if ("string" == typeof e || "number" == typeof e) n += e; else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = clsx_m_r(e[t])) && (n && (n += " "), 
              n += f); else for (t in e) e[t] && (n && (n += " "), n += t);
              return n;
          }
          componentWillMount.__suppressDeprecationWarning = !0, componentWillReceiveProps.__suppressDeprecationWarning = !0, 
          componentWillUpdate.__suppressDeprecationWarning = !0;
          const clsx_m = function() {
              for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = clsx_m_r(e)) && (n && (n += " "), 
              n += t);
              return n;
          };
          function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
              var cellCount = _ref.cellCount, cellSize = _ref.cellSize, computeMetadataCallback = _ref.computeMetadataCallback, computeMetadataCallbackProps = _ref.computeMetadataCallbackProps, nextCellsCount = _ref.nextCellsCount, nextCellSize = _ref.nextCellSize, nextScrollToIndex = _ref.nextScrollToIndex, scrollToIndex = _ref.scrollToIndex, updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
              cellCount === nextCellsCount && ("number" != typeof cellSize && "number" != typeof nextCellSize || cellSize === nextCellSize) || (computeMetadataCallback(computeMetadataCallbackProps), 
              scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex && updateScrollOffsetForScrollToIndex());
          }
          var CellSizeAndPositionManager = function() {
              function CellSizeAndPositionManager(_ref) {
                  var cellCount = _ref.cellCount, cellSizeGetter = _ref.cellSizeGetter, estimatedCellSize = _ref.estimatedCellSize;
                  _classCallCheck(this, CellSizeAndPositionManager), defineProperty_defineProperty(this, "_cellSizeAndPositionData", {}), 
                  defineProperty_defineProperty(this, "_lastMeasuredIndex", -1), defineProperty_defineProperty(this, "_lastBatchedIndex", -1), 
                  defineProperty_defineProperty(this, "_cellCount", void 0), defineProperty_defineProperty(this, "_cellSizeGetter", void 0), 
                  defineProperty_defineProperty(this, "_estimatedCellSize", void 0), this._cellSizeGetter = cellSizeGetter, 
                  this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize;
              }
              return _createClass(CellSizeAndPositionManager, [ {
                  key: "areOffsetsAdjusted",
                  value: function() {
                      return !1;
                  }
              }, {
                  key: "configure",
                  value: function(_ref2) {
                      var cellCount = _ref2.cellCount, estimatedCellSize = _ref2.estimatedCellSize, cellSizeGetter = _ref2.cellSizeGetter;
                      this._cellCount = cellCount, this._estimatedCellSize = estimatedCellSize, this._cellSizeGetter = cellSizeGetter;
                  }
              }, {
                  key: "getCellCount",
                  value: function() {
                      return this._cellCount;
                  }
              }, {
                  key: "getEstimatedCellSize",
                  value: function() {
                      return this._estimatedCellSize;
                  }
              }, {
                  key: "getLastMeasuredIndex",
                  value: function() {
                      return this._lastMeasuredIndex;
                  }
              }, {
                  key: "getOffsetAdjustment",
                  value: function() {
                      return 0;
                  }
              }, {
                  key: "getSizeAndPositionOfCell",
                  value: function(index) {
                      if (index < 0 || index >= this._cellCount) throw Error("Requested index ".concat(index, " is outside of range 0..").concat(this._cellCount));
                      if (index > this._lastMeasuredIndex) for (var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size, i = this._lastMeasuredIndex + 1; i <= index; i++) {
                          var size = this._cellSizeGetter({
                              index: i
                          });
                          if (void 0 === size || isNaN(size)) throw Error("Invalid size returned for cell ".concat(i, " of value ").concat(size));
                          null === size ? (this._cellSizeAndPositionData[i] = {
                              offset,
                              size: 0
                          }, this._lastBatchedIndex = index) : (this._cellSizeAndPositionData[i] = {
                              offset,
                              size
                          }, offset += size, this._lastMeasuredIndex = index);
                      }
                      return this._cellSizeAndPositionData[index];
                  }
              }, {
                  key: "getSizeAndPositionOfLastMeasuredCell",
                  value: function() {
                      return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
                          offset: 0,
                          size: 0
                      };
                  }
              }, {
                  key: "getTotalSize",
                  value: function() {
                      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
                      return lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size + (this._cellCount - this._lastMeasuredIndex - 1) * this._estimatedCellSize;
                  }
              }, {
                  key: "getUpdatedOffsetForIndex",
                  value: function(_ref3) {
                      var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                      if (containerSize <= 0) return 0;
                      var idealOffset, datum = this.getSizeAndPositionOfCell(targetIndex), maxOffset = datum.offset, minOffset = maxOffset - containerSize + datum.size;
                      switch (align) {
                        case "start":
                          idealOffset = maxOffset;
                          break;

                        case "end":
                          idealOffset = minOffset;
                          break;

                        case "center":
                          idealOffset = maxOffset - (containerSize - datum.size) / 2;
                          break;

                        default:
                          idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
                      }
                      var totalSize = this.getTotalSize();
                      return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
                  }
              }, {
                  key: "getVisibleCellRange",
                  value: function(params) {
                      var containerSize = params.containerSize, offset = params.offset;
                      if (0 === this.getTotalSize()) return {};
                      var maxOffset = offset + containerSize, start = this._findNearestCell(offset), datum = this.getSizeAndPositionOfCell(start);
                      offset = datum.offset + datum.size;
                      for (var stop = start; offset < maxOffset && stop < this._cellCount - 1; ) stop++, 
                      offset += this.getSizeAndPositionOfCell(stop).size;
                      return {
                          start,
                          stop
                      };
                  }
              }, {
                  key: "resetCell",
                  value: function(index) {
                      this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
                  }
              }, {
                  key: "_binarySearch",
                  value: function(high, low, offset) {
                      for (;low <= high; ) {
                          var middle = low + Math.floor((high - low) / 2), currentOffset = this.getSizeAndPositionOfCell(middle).offset;
                          if (currentOffset === offset) return middle;
                          currentOffset < offset ? low = middle + 1 : currentOffset > offset && (high = middle - 1);
                      }
                      return low > 0 ? low - 1 : 0;
                  }
              }, {
                  key: "_exponentialSearch",
                  value: function(index, offset) {
                      for (var interval = 1; index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset; ) index += interval, 
                      interval *= 2;
                      return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
                  }
              }, {
                  key: "_findNearestCell",
                  value: function(offset) {
                      if (isNaN(offset)) throw Error("Invalid offset ".concat(offset, " specified"));
                      offset = Math.max(0, offset);
                      var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell(), lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
                      return lastMeasuredCellSizeAndPosition.offset >= offset ? this._binarySearch(lastMeasuredIndex, 0, offset) : this._exponentialSearch(lastMeasuredIndex, offset);
                  }
              } ]), CellSizeAndPositionManager;
          }(), getMaxElementSize = function() {
              return "undefined" != typeof window && window.chrome ? 16777100 : 15e5;
          }, ScalingCellSizeAndPositionManager = function() {
              function ScalingCellSizeAndPositionManager(_ref) {
                  var _ref$maxScrollSize = _ref.maxScrollSize, maxScrollSize = void 0 === _ref$maxScrollSize ? getMaxElementSize() : _ref$maxScrollSize, params = objectWithoutProperties_objectWithoutProperties(_ref, [ "maxScrollSize" ]);
                  _classCallCheck(this, ScalingCellSizeAndPositionManager), defineProperty_defineProperty(this, "_cellSizeAndPositionManager", void 0), 
                  defineProperty_defineProperty(this, "_maxScrollSize", void 0), this._cellSizeAndPositionManager = new CellSizeAndPositionManager(params), 
                  this._maxScrollSize = maxScrollSize;
              }
              return _createClass(ScalingCellSizeAndPositionManager, [ {
                  key: "areOffsetsAdjusted",
                  value: function() {
                      return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
                  }
              }, {
                  key: "configure",
                  value: function(params) {
                      this._cellSizeAndPositionManager.configure(params);
                  }
              }, {
                  key: "getCellCount",
                  value: function() {
                      return this._cellSizeAndPositionManager.getCellCount();
                  }
              }, {
                  key: "getEstimatedCellSize",
                  value: function() {
                      return this._cellSizeAndPositionManager.getEstimatedCellSize();
                  }
              }, {
                  key: "getLastMeasuredIndex",
                  value: function() {
                      return this._cellSizeAndPositionManager.getLastMeasuredIndex();
                  }
              }, {
                  key: "getOffsetAdjustment",
                  value: function(_ref2) {
                      var containerSize = _ref2.containerSize, offset = _ref2.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize(), offsetPercentage = this._getOffsetPercentage({
                          containerSize,
                          offset,
                          totalSize: safeTotalSize
                      });
                      return Math.round(offsetPercentage * (safeTotalSize - totalSize));
                  }
              }, {
                  key: "getSizeAndPositionOfCell",
                  value: function(index) {
                      return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
                  }
              }, {
                  key: "getSizeAndPositionOfLastMeasuredCell",
                  value: function() {
                      return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
                  }
              }, {
                  key: "getTotalSize",
                  value: function() {
                      return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
                  }
              }, {
                  key: "getUpdatedOffsetForIndex",
                  value: function(_ref3) {
                      var _ref3$align = _ref3.align, align = void 0 === _ref3$align ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
                      currentOffset = this._safeOffsetToOffset({
                          containerSize,
                          offset: currentOffset
                      });
                      var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
                          align,
                          containerSize,
                          currentOffset,
                          targetIndex
                      });
                      return this._offsetToSafeOffset({
                          containerSize,
                          offset
                      });
                  }
              }, {
                  key: "getVisibleCellRange",
                  value: function(_ref4) {
                      var containerSize = _ref4.containerSize, offset = _ref4.offset;
                      return offset = this._safeOffsetToOffset({
                          containerSize,
                          offset
                      }), this._cellSizeAndPositionManager.getVisibleCellRange({
                          containerSize,
                          offset
                      });
                  }
              }, {
                  key: "resetCell",
                  value: function(index) {
                      this._cellSizeAndPositionManager.resetCell(index);
                  }
              }, {
                  key: "_getOffsetPercentage",
                  value: function(_ref5) {
                      var containerSize = _ref5.containerSize, offset = _ref5.offset, totalSize = _ref5.totalSize;
                      return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
                  }
              }, {
                  key: "_offsetToSafeOffset",
                  value: function(_ref6) {
                      var containerSize = _ref6.containerSize, offset = _ref6.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                      if (totalSize === safeTotalSize) return offset;
                      var offsetPercentage = this._getOffsetPercentage({
                          containerSize,
                          offset,
                          totalSize
                      });
                      return Math.round(offsetPercentage * (safeTotalSize - containerSize));
                  }
              }, {
                  key: "_safeOffsetToOffset",
                  value: function(_ref7) {
                      var containerSize = _ref7.containerSize, offset = _ref7.offset, totalSize = this._cellSizeAndPositionManager.getTotalSize(), safeTotalSize = this.getTotalSize();
                      if (totalSize === safeTotalSize) return offset;
                      var offsetPercentage = this._getOffsetPercentage({
                          containerSize,
                          offset,
                          totalSize: safeTotalSize
                      });
                      return Math.round(offsetPercentage * (totalSize - containerSize));
                  }
              } ]), ScalingCellSizeAndPositionManager;
          }();
          function createCallbackMemoizer() {
              var requireAllKeys = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], cachedIndices = {};
              return function(_ref) {
                  var callback = _ref.callback, indices = _ref.indices, keys = Object.keys(indices), allInitialized = !requireAllKeys || keys.every((function(key) {
                      var value = indices[key];
                      return Array.isArray(value) ? value.length > 0 : value >= 0;
                  })), indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some((function(key) {
                      var cachedValue = cachedIndices[key], value = indices[key];
                      return Array.isArray(value) ? cachedValue.join(",") !== value.join(",") : cachedValue !== value;
                  }));
                  cachedIndices = indices, allInitialized && indexChanged && callback(indices);
              };
          }
          function updateScrollIndexHelper(_ref) {
              var cellSize = _ref.cellSize, cellSizeAndPositionManager = _ref.cellSizeAndPositionManager, previousCellsCount = _ref.previousCellsCount, previousCellSize = _ref.previousCellSize, previousScrollToAlignment = _ref.previousScrollToAlignment, previousScrollToIndex = _ref.previousScrollToIndex, previousSize = _ref.previousSize, scrollOffset = _ref.scrollOffset, scrollToAlignment = _ref.scrollToAlignment, scrollToIndex = _ref.scrollToIndex, size = _ref.size, sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero, updateScrollIndexCallback = _ref.updateScrollIndexCallback, cellCount = cellSizeAndPositionManager.getCellCount(), hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;
              hasScrollToIndex && (size !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || "number" == typeof cellSize && cellSize !== previousCellSize || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex) ? updateScrollIndexCallback(scrollToIndex) : !hasScrollToIndex && cellCount > 0 && (size < previousSize || cellCount < previousCellsCount) && scrollOffset > cellSizeAndPositionManager.getTotalSize() - size && updateScrollIndexCallback(cellCount - 1);
          }
          const canUseDOM = !("undefined" == typeof window || !window.document || !window.document.createElement);
          var size, animationFrame_win;
          function scrollbarSize(recalc) {
              if ((!size && 0 !== size || recalc) && canUseDOM) {
                  var scrollDiv = document.createElement("div");
                  scrollDiv.style.position = "absolute", scrollDiv.style.top = "-9999px", scrollDiv.style.width = "50px", 
                  scrollDiv.style.height = "50px", scrollDiv.style.overflow = "scroll", document.body.appendChild(scrollDiv), 
                  size = scrollDiv.offsetWidth - scrollDiv.clientWidth, document.body.removeChild(scrollDiv);
              }
              return size;
          }
          var _class, _temp, request = (animationFrame_win = "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}).requestAnimationFrame || animationFrame_win.webkitRequestAnimationFrame || animationFrame_win.mozRequestAnimationFrame || animationFrame_win.oRequestAnimationFrame || animationFrame_win.msRequestAnimationFrame || function(callback) {
              return animationFrame_win.setTimeout(callback, 1e3 / 60);
          }, cancel = animationFrame_win.cancelAnimationFrame || animationFrame_win.webkitCancelAnimationFrame || animationFrame_win.mozCancelAnimationFrame || animationFrame_win.oCancelAnimationFrame || animationFrame_win.msCancelAnimationFrame || function(id) {
              animationFrame_win.clearTimeout(id);
          }, animationFrame_raf = request, animationFrame_caf = cancel, cancelAnimationTimeout = function(frame) {
              return animationFrame_caf(frame.id);
          }, requestAnimationTimeout = function(callback, delay) {
              var start;
              Promise.resolve().then((function() {
                  start = Date.now();
              }));
              var frame = {
                  id: animationFrame_raf((function timeout() {
                      Date.now() - start >= delay ? callback.call() : frame.id = animationFrame_raf(timeout);
                  }))
              };
              return frame;
          };
          function Grid_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function Grid_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? Grid_ownKeys(source, !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Grid_ownKeys(source).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          var SCROLL_POSITION_CHANGE_REASONS_OBSERVED = "observed", SCROLL_POSITION_CHANGE_REASONS_REQUESTED = "requested", Grid = (_temp = _class = function(_React$PureComponent) {
              function Grid(props) {
                  var _this;
                  _classCallCheck(this, Grid), defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, _getPrototypeOf(Grid).call(this, props))), "_onGridRenderedMemoizer", createCallbackMemoizer()), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_onScrollMemoizer", createCallbackMemoizer(!1)), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_deferredInvalidateColumnIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_deferredInvalidateRowIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_recomputeScrollLeftFlag", !1), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_recomputeScrollTopFlag", !1), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_horizontalScrollBarSize", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_verticalScrollBarSize", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_scrollbarPresenceChanged", !1), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_scrollingContainer", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_childrenToDisplay", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_columnStartIndex", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_columnStopIndex", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_rowStartIndex", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_rowStopIndex", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_renderedColumnStartIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_renderedColumnStopIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_renderedRowStartIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_renderedRowStopIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_initialScrollTop", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_initialScrollLeft", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_disablePointerEventsTimeoutId", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_styleCache", {}), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_cellCache", {}), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_debounceScrollEndedCallback", (function() {
                      _this._disablePointerEventsTimeoutId = null, _this.setState({
                          isScrolling: !1,
                          needToResetStyleCache: !1
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_invokeOnGridRenderedHelper", (function() {
                      var onSectionRendered = _this.props.onSectionRendered;
                      _this._onGridRenderedMemoizer({
                          callback: onSectionRendered,
                          indices: {
                              columnOverscanStartIndex: _this._columnStartIndex,
                              columnOverscanStopIndex: _this._columnStopIndex,
                              columnStartIndex: _this._renderedColumnStartIndex,
                              columnStopIndex: _this._renderedColumnStopIndex,
                              rowOverscanStartIndex: _this._rowStartIndex,
                              rowOverscanStopIndex: _this._rowStopIndex,
                              rowStartIndex: _this._renderedRowStartIndex,
                              rowStopIndex: _this._renderedRowStopIndex
                          }
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_setScrollingContainerRef", (function(ref) {
                      _this._scrollingContainer = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScroll", (function(event) {
                      event.target === _this._scrollingContainer && _this.handleScrollEvent(event.target);
                  }));
                  var columnSizeAndPositionManager = new ScalingCellSizeAndPositionManager({
                      cellCount: props.columnCount,
                      cellSizeGetter: function(params) {
                          return Grid._wrapSizeGetter(props.columnWidth)(params);
                      },
                      estimatedCellSize: Grid._getEstimatedColumnSize(props)
                  }), rowSizeAndPositionManager = new ScalingCellSizeAndPositionManager({
                      cellCount: props.rowCount,
                      cellSizeGetter: function(params) {
                          return Grid._wrapSizeGetter(props.rowHeight)(params);
                      },
                      estimatedCellSize: Grid._getEstimatedRowSize(props)
                  });
                  return _this.state = {
                      instanceProps: {
                          columnSizeAndPositionManager,
                          rowSizeAndPositionManager,
                          prevColumnWidth: props.columnWidth,
                          prevRowHeight: props.rowHeight,
                          prevColumnCount: props.columnCount,
                          prevRowCount: props.rowCount,
                          prevIsScrolling: !0 === props.isScrolling,
                          prevScrollToColumn: props.scrollToColumn,
                          prevScrollToRow: props.scrollToRow,
                          scrollbarSize: 0,
                          scrollbarSizeMeasured: !1
                      },
                      isScrolling: !1,
                      scrollDirectionHorizontal: 1,
                      scrollDirectionVertical: 1,
                      scrollLeft: 0,
                      scrollTop: 0,
                      scrollPositionChangeReason: null,
                      needToResetStyleCache: !1
                  }, props.scrollToRow > 0 && (_this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state)), 
                  props.scrollToColumn > 0 && (_this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state)), 
                  _this;
              }
              return _inherits(Grid, _React$PureComponent), _createClass(Grid, [ {
                  key: "getOffsetForCell",
                  value: function() {
                      var _ref = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref$alignment = _ref.alignment, alignment = void 0 === _ref$alignment ? this.props.scrollToAlignment : _ref$alignment, _ref$columnIndex = _ref.columnIndex, columnIndex = void 0 === _ref$columnIndex ? this.props.scrollToColumn : _ref$columnIndex, _ref$rowIndex = _ref.rowIndex, rowIndex = void 0 === _ref$rowIndex ? this.props.scrollToRow : _ref$rowIndex, offsetProps = Grid_objectSpread({}, this.props, {
                          scrollToAlignment: alignment,
                          scrollToColumn: columnIndex,
                          scrollToRow: rowIndex
                      });
                      return {
                          scrollLeft: this._getCalculatedScrollLeft(offsetProps),
                          scrollTop: this._getCalculatedScrollTop(offsetProps)
                      };
                  }
              }, {
                  key: "getTotalRowsHeight",
                  value: function() {
                      return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();
                  }
              }, {
                  key: "getTotalColumnsWidth",
                  value: function() {
                      return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();
                  }
              }, {
                  key: "handleScrollEvent",
                  value: function(_ref2) {
                      var _ref2$scrollLeft = _ref2.scrollLeft, scrollLeftParam = void 0 === _ref2$scrollLeft ? 0 : _ref2$scrollLeft, _ref2$scrollTop = _ref2.scrollTop, scrollTopParam = void 0 === _ref2$scrollTop ? 0 : _ref2$scrollTop;
                      if (!(scrollTopParam < 0)) {
                          this._debounceScrollEnded();
                          var _this$props = this.props, autoHeight = _this$props.autoHeight, autoWidth = _this$props.autoWidth, height = _this$props.height, width = _this$props.width, instanceProps = this.state.instanceProps, scrollbarSize = instanceProps.scrollbarSize, totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize(), scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize), scrollLeftParam), scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize), scrollTopParam);
                          if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
                              var newState = {
                                  isScrolling: !0,
                                  scrollDirectionHorizontal: scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? 1 : -1 : this.state.scrollDirectionHorizontal,
                                  scrollDirectionVertical: scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? 1 : -1 : this.state.scrollDirectionVertical,
                                  scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS_OBSERVED
                              };
                              autoHeight || (newState.scrollTop = scrollTop), autoWidth || (newState.scrollLeft = scrollLeft), 
                              newState.needToResetStyleCache = !1, this.setState(newState);
                          }
                          this._invokeOnScrollMemoizer({
                              scrollLeft,
                              scrollTop,
                              totalColumnsWidth,
                              totalRowsHeight
                          });
                      }
                  }
              }, {
                  key: "invalidateCellSizeAfterRender",
                  value: function(_ref3) {
                      var columnIndex = _ref3.columnIndex, rowIndex = _ref3.rowIndex;
                      this._deferredInvalidateColumnIndex = "number" == typeof this._deferredInvalidateColumnIndex ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex, 
                      this._deferredInvalidateRowIndex = "number" == typeof this._deferredInvalidateRowIndex ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
                  }
              }, {
                  key: "measureAllCells",
                  value: function() {
                      var _this$props2 = this.props, columnCount = _this$props2.columnCount, rowCount = _this$props2.rowCount, instanceProps = this.state.instanceProps;
                      instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1), 
                      instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
                  }
              }, {
                  key: "recomputeGridSize",
                  value: function() {
                      var _ref4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref4$columnIndex = _ref4.columnIndex, columnIndex = void 0 === _ref4$columnIndex ? 0 : _ref4$columnIndex, _ref4$rowIndex = _ref4.rowIndex, rowIndex = void 0 === _ref4$rowIndex ? 0 : _ref4$rowIndex, _this$props3 = this.props, scrollToColumn = _this$props3.scrollToColumn, scrollToRow = _this$props3.scrollToRow, instanceProps = this.state.instanceProps;
                      instanceProps.columnSizeAndPositionManager.resetCell(columnIndex), instanceProps.rowSizeAndPositionManager.resetCell(rowIndex), 
                      this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (1 === this.state.scrollDirectionHorizontal ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn), 
                      this._recomputeScrollTopFlag = scrollToRow >= 0 && (1 === this.state.scrollDirectionVertical ? rowIndex <= scrollToRow : rowIndex >= scrollToRow), 
                      this._styleCache = {}, this._cellCache = {}, this.forceUpdate();
                  }
              }, {
                  key: "scrollToCell",
                  value: function(_ref5) {
                      var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex, columnCount = this.props.columnCount, props = this.props;
                      columnCount > 1 && void 0 !== columnIndex && this._updateScrollLeftForScrollToColumn(Grid_objectSpread({}, props, {
                          scrollToColumn: columnIndex
                      })), void 0 !== rowIndex && this._updateScrollTopForScrollToRow(Grid_objectSpread({}, props, {
                          scrollToRow: rowIndex
                      }));
                  }
              }, {
                  key: "componentDidMount",
                  value: function() {
                      var _this$props4 = this.props, getScrollbarSize = _this$props4.getScrollbarSize, height = _this$props4.height, scrollLeft = _this$props4.scrollLeft, scrollToColumn = _this$props4.scrollToColumn, scrollTop = _this$props4.scrollTop, scrollToRow = _this$props4.scrollToRow, width = _this$props4.width, instanceProps = this.state.instanceProps;
                      if (this._initialScrollTop = 0, this._initialScrollLeft = 0, this._handleInvalidatedGridSize(), 
                      instanceProps.scrollbarSizeMeasured || this.setState((function(prevState) {
                          var stateUpdate = Grid_objectSpread({}, prevState, {
                              needToResetStyleCache: !1
                          });
                          return stateUpdate.instanceProps.scrollbarSize = getScrollbarSize(), stateUpdate.instanceProps.scrollbarSizeMeasured = !0, 
                          stateUpdate;
                      })), "number" == typeof scrollLeft && scrollLeft >= 0 || "number" == typeof scrollTop && scrollTop >= 0) {
                          var stateUpdate = Grid._getScrollToPositionStateUpdate({
                              prevState: this.state,
                              scrollLeft,
                              scrollTop
                          });
                          stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                      }
                      this._scrollingContainer && (this._scrollingContainer.scrollLeft !== this.state.scrollLeft && (this._scrollingContainer.scrollLeft = this.state.scrollLeft), 
                      this._scrollingContainer.scrollTop !== this.state.scrollTop && (this._scrollingContainer.scrollTop = this.state.scrollTop));
                      var sizeIsBiggerThanZero = height > 0 && width > 0;
                      scrollToColumn >= 0 && sizeIsBiggerThanZero && this._updateScrollLeftForScrollToColumn(), 
                      scrollToRow >= 0 && sizeIsBiggerThanZero && this._updateScrollTopForScrollToRow(), 
                      this._invokeOnGridRenderedHelper(), this._invokeOnScrollMemoizer({
                          scrollLeft: scrollLeft || 0,
                          scrollTop: scrollTop || 0,
                          totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),
                          totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()
                      }), this._maybeCallOnScrollbarPresenceChange();
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function(prevProps, prevState) {
                      var _this2 = this, _this$props5 = this.props, autoHeight = _this$props5.autoHeight, autoWidth = _this$props5.autoWidth, columnCount = _this$props5.columnCount, height = _this$props5.height, rowCount = _this$props5.rowCount, scrollToAlignment = _this$props5.scrollToAlignment, scrollToColumn = _this$props5.scrollToColumn, scrollToRow = _this$props5.scrollToRow, width = _this$props5.width, _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollPositionChangeReason = _this$state.scrollPositionChangeReason, scrollTop = _this$state.scrollTop, instanceProps = _this$state.instanceProps;
                      this._handleInvalidatedGridSize();
                      var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && 0 === prevProps.columnCount || rowCount > 0 && 0 === prevProps.rowCount;
                      scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS_REQUESTED && (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollLeft = scrollLeft), 
                      !autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero) && (this._scrollingContainer.scrollTop = scrollTop));
                      var sizeJustIncreasedFromZero = (0 === prevProps.width || 0 === prevProps.height) && height > 0 && width > 0;
                      if (this._recomputeScrollLeftFlag ? (this._recomputeScrollLeftFlag = !1, this._updateScrollLeftForScrollToColumn(this.props)) : updateScrollIndexHelper({
                          cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
                          previousCellsCount: prevProps.columnCount,
                          previousCellSize: prevProps.columnWidth,
                          previousScrollToAlignment: prevProps.scrollToAlignment,
                          previousScrollToIndex: prevProps.scrollToColumn,
                          previousSize: prevProps.width,
                          scrollOffset: scrollLeft,
                          scrollToAlignment,
                          scrollToIndex: scrollToColumn,
                          size: width,
                          sizeJustIncreasedFromZero,
                          updateScrollIndexCallback: function() {
                              return _this2._updateScrollLeftForScrollToColumn(_this2.props);
                          }
                      }), this._recomputeScrollTopFlag ? (this._recomputeScrollTopFlag = !1, this._updateScrollTopForScrollToRow(this.props)) : updateScrollIndexHelper({
                          cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
                          previousCellsCount: prevProps.rowCount,
                          previousCellSize: prevProps.rowHeight,
                          previousScrollToAlignment: prevProps.scrollToAlignment,
                          previousScrollToIndex: prevProps.scrollToRow,
                          previousSize: prevProps.height,
                          scrollOffset: scrollTop,
                          scrollToAlignment,
                          scrollToIndex: scrollToRow,
                          size: height,
                          sizeJustIncreasedFromZero,
                          updateScrollIndexCallback: function() {
                              return _this2._updateScrollTopForScrollToRow(_this2.props);
                          }
                      }), this._invokeOnGridRenderedHelper(), scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
                          var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
                          this._invokeOnScrollMemoizer({
                              scrollLeft,
                              scrollTop,
                              totalColumnsWidth,
                              totalRowsHeight
                          });
                      }
                      this._maybeCallOnScrollbarPresenceChange();
                  }
              }, {
                  key: "componentWillUnmount",
                  value: function() {
                      this._disablePointerEventsTimeoutId && cancelAnimationTimeout(this._disablePointerEventsTimeoutId);
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props6 = this.props, autoContainerWidth = _this$props6.autoContainerWidth, autoHeight = _this$props6.autoHeight, autoWidth = _this$props6.autoWidth, className = _this$props6.className, containerProps = _this$props6.containerProps, containerRole = _this$props6.containerRole, containerStyle = _this$props6.containerStyle, height = _this$props6.height, id = _this$props6.id, noContentRenderer = _this$props6.noContentRenderer, role = _this$props6.role, style = _this$props6.style, tabIndex = _this$props6.tabIndex, width = _this$props6.width, _this$state2 = this.state, instanceProps = _this$state2.instanceProps, needToResetStyleCache = _this$state2.needToResetStyleCache, isScrolling = this._isScrolling(), gridStyle = {
                          boxSizing: "border-box",
                          direction: "ltr",
                          height: autoHeight ? "auto" : height,
                          position: "relative",
                          width: autoWidth ? "auto" : width,
                          WebkitOverflowScrolling: "touch",
                          willChange: "transform"
                      };
                      needToResetStyleCache && (this._styleCache = {}), this.state.isScrolling || this._resetStyleCache(), 
                      this._calculateChildrenToRender(this.props, this.state);
                      var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize(), totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0, horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
                      horizontalScrollBarSize === this._horizontalScrollBarSize && verticalScrollBarSize === this._verticalScrollBarSize || (this._horizontalScrollBarSize = horizontalScrollBarSize, 
                      this._verticalScrollBarSize = verticalScrollBarSize, this._scrollbarPresenceChanged = !0), 
                      gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? "hidden" : "auto", 
                      gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
                      var childrenToDisplay = this._childrenToDisplay, showNoContentRenderer = 0 === childrenToDisplay.length && height > 0 && width > 0;
                      return react.createElement("div", _extends({
                          ref: this._setScrollingContainerRef
                      }, containerProps, {
                          "aria-label": this.props["aria-label"],
                          "aria-readonly": this.props["aria-readonly"],
                          className: clsx_m("ReactVirtualized__Grid", className),
                          id,
                          onScroll: this._onScroll,
                          role,
                          style: Grid_objectSpread({}, gridStyle, {}, style),
                          tabIndex
                      }), childrenToDisplay.length > 0 && react.createElement("div", {
                          className: "ReactVirtualized__Grid__innerScrollContainer",
                          role: containerRole,
                          style: Grid_objectSpread({
                              width: autoContainerWidth ? "auto" : totalColumnsWidth,
                              height: totalRowsHeight,
                              maxWidth: totalColumnsWidth,
                              maxHeight: totalRowsHeight,
                              overflow: "hidden",
                              pointerEvents: isScrolling ? "none" : "",
                              position: "relative"
                          }, containerStyle)
                      }, childrenToDisplay), showNoContentRenderer && noContentRenderer());
                  }
              }, {
                  key: "_calculateChildrenToRender",
                  value: function() {
                      var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, cellRenderer = props.cellRenderer, cellRangeRenderer = props.cellRangeRenderer, columnCount = props.columnCount, deferredMeasurementCache = props.deferredMeasurementCache, height = props.height, overscanColumnCount = props.overscanColumnCount, overscanIndicesGetter = props.overscanIndicesGetter, overscanRowCount = props.overscanRowCount, rowCount = props.rowCount, width = props.width, isScrollingOptOut = props.isScrollingOptOut, scrollDirectionHorizontal = state.scrollDirectionHorizontal, scrollDirectionVertical = state.scrollDirectionVertical, instanceProps = state.instanceProps, scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop, scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft, isScrolling = this._isScrolling(props, state);
                      if (this._childrenToDisplay = [], height > 0 && width > 0) {
                          var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({
                              containerSize: width,
                              offset: scrollLeft
                          }), visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({
                              containerSize: height,
                              offset: scrollTop
                          }), horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({
                              containerSize: width,
                              offset: scrollLeft
                          }), verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({
                              containerSize: height,
                              offset: scrollTop
                          });
                          this._renderedColumnStartIndex = visibleColumnIndices.start, this._renderedColumnStopIndex = visibleColumnIndices.stop, 
                          this._renderedRowStartIndex = visibleRowIndices.start, this._renderedRowStopIndex = visibleRowIndices.stop;
                          var overscanColumnIndices = overscanIndicesGetter({
                              direction: "horizontal",
                              cellCount: columnCount,
                              overscanCellsCount: overscanColumnCount,
                              scrollDirection: scrollDirectionHorizontal,
                              startIndex: "number" == typeof visibleColumnIndices.start ? visibleColumnIndices.start : 0,
                              stopIndex: "number" == typeof visibleColumnIndices.stop ? visibleColumnIndices.stop : -1
                          }), overscanRowIndices = overscanIndicesGetter({
                              direction: "vertical",
                              cellCount: rowCount,
                              overscanCellsCount: overscanRowCount,
                              scrollDirection: scrollDirectionVertical,
                              startIndex: "number" == typeof visibleRowIndices.start ? visibleRowIndices.start : 0,
                              stopIndex: "number" == typeof visibleRowIndices.stop ? visibleRowIndices.stop : -1
                          }), columnStartIndex = overscanColumnIndices.overscanStartIndex, columnStopIndex = overscanColumnIndices.overscanStopIndex, rowStartIndex = overscanRowIndices.overscanStartIndex, rowStopIndex = overscanRowIndices.overscanStopIndex;
                          if (deferredMeasurementCache) {
                              if (!deferredMeasurementCache.hasFixedHeight()) for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) if (!deferredMeasurementCache.has(rowIndex, 0)) {
                                  columnStartIndex = 0, columnStopIndex = columnCount - 1;
                                  break;
                              }
                              if (!deferredMeasurementCache.hasFixedWidth()) for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) if (!deferredMeasurementCache.has(0, columnIndex)) {
                                  rowStartIndex = 0, rowStopIndex = rowCount - 1;
                                  break;
                              }
                          }
                          this._childrenToDisplay = cellRangeRenderer({
                              cellCache: this._cellCache,
                              cellRenderer,
                              columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
                              columnStartIndex,
                              columnStopIndex,
                              deferredMeasurementCache,
                              horizontalOffsetAdjustment,
                              isScrolling,
                              isScrollingOptOut,
                              parent: this,
                              rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
                              rowStartIndex,
                              rowStopIndex,
                              scrollLeft,
                              scrollTop,
                              styleCache: this._styleCache,
                              verticalOffsetAdjustment,
                              visibleColumnIndices,
                              visibleRowIndices
                          }), this._columnStartIndex = columnStartIndex, this._columnStopIndex = columnStopIndex, 
                          this._rowStartIndex = rowStartIndex, this._rowStopIndex = rowStopIndex;
                      }
                  }
              }, {
                  key: "_debounceScrollEnded",
                  value: function() {
                      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
                      this._disablePointerEventsTimeoutId && cancelAnimationTimeout(this._disablePointerEventsTimeoutId), 
                      this._disablePointerEventsTimeoutId = requestAnimationTimeout(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
                  }
              }, {
                  key: "_handleInvalidatedGridSize",
                  value: function() {
                      if ("number" == typeof this._deferredInvalidateColumnIndex && "number" == typeof this._deferredInvalidateRowIndex) {
                          var columnIndex = this._deferredInvalidateColumnIndex, rowIndex = this._deferredInvalidateRowIndex;
                          this._deferredInvalidateColumnIndex = null, this._deferredInvalidateRowIndex = null, 
                          this.recomputeGridSize({
                              columnIndex,
                              rowIndex
                          });
                      }
                  }
              }, {
                  key: "_invokeOnScrollMemoizer",
                  value: function(_ref6) {
                      var _this3 = this, scrollLeft = _ref6.scrollLeft, scrollTop = _ref6.scrollTop, totalColumnsWidth = _ref6.totalColumnsWidth, totalRowsHeight = _ref6.totalRowsHeight;
                      this._onScrollMemoizer({
                          callback: function(_ref7) {
                              var scrollLeft = _ref7.scrollLeft, scrollTop = _ref7.scrollTop, _this3$props = _this3.props, height = _this3$props.height;
                              (0, _this3$props.onScroll)({
                                  clientHeight: height,
                                  clientWidth: _this3$props.width,
                                  scrollHeight: totalRowsHeight,
                                  scrollLeft,
                                  scrollTop,
                                  scrollWidth: totalColumnsWidth
                              });
                          },
                          indices: {
                              scrollLeft,
                              scrollTop
                          }
                      });
                  }
              }, {
                  key: "_isScrolling",
                  value: function() {
                      var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                      return Object.hasOwnProperty.call(props, "isScrolling") ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
                  }
              }, {
                  key: "_maybeCallOnScrollbarPresenceChange",
                  value: function() {
                      if (this._scrollbarPresenceChanged) {
                          var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;
                          this._scrollbarPresenceChanged = !1, onScrollbarPresenceChange({
                              horizontal: this._horizontalScrollBarSize > 0,
                              size: this.state.instanceProps.scrollbarSize,
                              vertical: this._verticalScrollBarSize > 0
                          });
                      }
                  }
              }, {
                  key: "scrollToPosition",
                  value: function(_ref8) {
                      var scrollLeft = _ref8.scrollLeft, scrollTop = _ref8.scrollTop, stateUpdate = Grid._getScrollToPositionStateUpdate({
                          prevState: this.state,
                          scrollLeft,
                          scrollTop
                      });
                      stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                  }
              }, {
                  key: "_getCalculatedScrollLeft",
                  value: function() {
                      var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                      return Grid._getCalculatedScrollLeft(props, state);
                  }
              }, {
                  key: "_updateScrollLeftForScrollToColumn",
                  value: function() {
                      var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, stateUpdate = Grid._getScrollLeftForScrollToColumnStateUpdate(props, state);
                      stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                  }
              }, {
                  key: "_getCalculatedScrollTop",
                  value: function() {
                      var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state;
                      return Grid._getCalculatedScrollTop(props, state);
                  }
              }, {
                  key: "_resetStyleCache",
                  value: function() {
                      var styleCache = this._styleCache, cellCache = this._cellCache, isScrollingOptOut = this.props.isScrollingOptOut;
                      this._cellCache = {}, this._styleCache = {};
                      for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
                          var key = "".concat(rowIndex, "-").concat(columnIndex);
                          this._styleCache[key] = styleCache[key], isScrollingOptOut && (this._cellCache[key] = cellCache[key]);
                      }
                  }
              }, {
                  key: "_updateScrollTopForScrollToRow",
                  value: function() {
                      var props = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props, state = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state, stateUpdate = Grid._getScrollTopForScrollToRowStateUpdate(props, state);
                      stateUpdate && (stateUpdate.needToResetStyleCache = !1, this.setState(stateUpdate));
                  }
              } ], [ {
                  key: "getDerivedStateFromProps",
                  value: function(nextProps, prevState) {
                      var newState = {};
                      0 === nextProps.columnCount && 0 !== prevState.scrollLeft || 0 === nextProps.rowCount && 0 !== prevState.scrollTop ? (newState.scrollLeft = 0, 
                      newState.scrollTop = 0) : (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) && Object.assign(newState, Grid._getScrollToPositionStateUpdate({
                          prevState,
                          scrollLeft: nextProps.scrollLeft,
                          scrollTop: nextProps.scrollTop
                      }));
                      var maybeStateA, maybeStateB, instanceProps = prevState.instanceProps;
                      return newState.needToResetStyleCache = !1, nextProps.columnWidth === instanceProps.prevColumnWidth && nextProps.rowHeight === instanceProps.prevRowHeight || (newState.needToResetStyleCache = !0), 
                      instanceProps.columnSizeAndPositionManager.configure({
                          cellCount: nextProps.columnCount,
                          estimatedCellSize: Grid._getEstimatedColumnSize(nextProps),
                          cellSizeGetter: Grid._wrapSizeGetter(nextProps.columnWidth)
                      }), instanceProps.rowSizeAndPositionManager.configure({
                          cellCount: nextProps.rowCount,
                          estimatedCellSize: Grid._getEstimatedRowSize(nextProps),
                          cellSizeGetter: Grid._wrapSizeGetter(nextProps.rowHeight)
                      }), 0 !== instanceProps.prevColumnCount && 0 !== instanceProps.prevRowCount || (instanceProps.prevColumnCount = 0, 
                      instanceProps.prevRowCount = 0), nextProps.autoHeight && !1 === nextProps.isScrolling && !0 === instanceProps.prevIsScrolling && Object.assign(newState, {
                          isScrolling: !1
                      }), calculateSizeAndPositionDataAndUpdateScrollOffset({
                          cellCount: instanceProps.prevColumnCount,
                          cellSize: "number" == typeof instanceProps.prevColumnWidth ? instanceProps.prevColumnWidth : null,
                          computeMetadataCallback: function() {
                              return instanceProps.columnSizeAndPositionManager.resetCell(0);
                          },
                          computeMetadataCallbackProps: nextProps,
                          nextCellsCount: nextProps.columnCount,
                          nextCellSize: "number" == typeof nextProps.columnWidth ? nextProps.columnWidth : null,
                          nextScrollToIndex: nextProps.scrollToColumn,
                          scrollToIndex: instanceProps.prevScrollToColumn,
                          updateScrollOffsetForScrollToIndex: function() {
                              maybeStateA = Grid._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);
                          }
                      }), calculateSizeAndPositionDataAndUpdateScrollOffset({
                          cellCount: instanceProps.prevRowCount,
                          cellSize: "number" == typeof instanceProps.prevRowHeight ? instanceProps.prevRowHeight : null,
                          computeMetadataCallback: function() {
                              return instanceProps.rowSizeAndPositionManager.resetCell(0);
                          },
                          computeMetadataCallbackProps: nextProps,
                          nextCellsCount: nextProps.rowCount,
                          nextCellSize: "number" == typeof nextProps.rowHeight ? nextProps.rowHeight : null,
                          nextScrollToIndex: nextProps.scrollToRow,
                          scrollToIndex: instanceProps.prevScrollToRow,
                          updateScrollOffsetForScrollToIndex: function() {
                              maybeStateB = Grid._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);
                          }
                      }), instanceProps.prevColumnCount = nextProps.columnCount, instanceProps.prevColumnWidth = nextProps.columnWidth, 
                      instanceProps.prevIsScrolling = !0 === nextProps.isScrolling, instanceProps.prevRowCount = nextProps.rowCount, 
                      instanceProps.prevRowHeight = nextProps.rowHeight, instanceProps.prevScrollToColumn = nextProps.scrollToColumn, 
                      instanceProps.prevScrollToRow = nextProps.scrollToRow, instanceProps.scrollbarSize = nextProps.getScrollbarSize(), 
                      void 0 === instanceProps.scrollbarSize ? (instanceProps.scrollbarSizeMeasured = !1, 
                      instanceProps.scrollbarSize = 0) : instanceProps.scrollbarSizeMeasured = !0, newState.instanceProps = instanceProps, 
                      Grid_objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);
                  }
              }, {
                  key: "_getEstimatedColumnSize",
                  value: function(props) {
                      return "number" == typeof props.columnWidth ? props.columnWidth : props.estimatedColumnSize;
                  }
              }, {
                  key: "_getEstimatedRowSize",
                  value: function(props) {
                      return "number" == typeof props.rowHeight ? props.rowHeight : props.estimatedRowSize;
                  }
              }, {
                  key: "_getScrollToPositionStateUpdate",
                  value: function(_ref9) {
                      var prevState = _ref9.prevState, scrollLeft = _ref9.scrollLeft, scrollTop = _ref9.scrollTop, newState = {
                          scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS_REQUESTED
                      };
                      return "number" == typeof scrollLeft && scrollLeft >= 0 && (newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? 1 : -1, 
                      newState.scrollLeft = scrollLeft), "number" == typeof scrollTop && scrollTop >= 0 && (newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? 1 : -1, 
                      newState.scrollTop = scrollTop), "number" == typeof scrollLeft && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || "number" == typeof scrollTop && scrollTop >= 0 && scrollTop !== prevState.scrollTop ? newState : {};
                  }
              }, {
                  key: "_wrapSizeGetter",
                  value: function(value) {
                      return "function" == typeof value ? value : function() {
                          return value;
                      };
                  }
              }, {
                  key: "_getCalculatedScrollLeft",
                  value: function(nextProps, prevState) {
                      var columnCount = nextProps.columnCount, height = nextProps.height, scrollToAlignment = nextProps.scrollToAlignment, scrollToColumn = nextProps.scrollToColumn, width = nextProps.width, scrollLeft = prevState.scrollLeft, instanceProps = prevState.instanceProps;
                      if (columnCount > 0) {
                          var finalColumn = columnCount - 1, targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn), totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize(), scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
                          return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({
                              align: scrollToAlignment,
                              containerSize: width - scrollBarSize,
                              currentOffset: scrollLeft,
                              targetIndex
                          });
                      }
                      return 0;
                  }
              }, {
                  key: "_getScrollLeftForScrollToColumnStateUpdate",
                  value: function(nextProps, prevState) {
                      var scrollLeft = prevState.scrollLeft, calculatedScrollLeft = Grid._getCalculatedScrollLeft(nextProps, prevState);
                      return "number" == typeof calculatedScrollLeft && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft ? Grid._getScrollToPositionStateUpdate({
                          prevState,
                          scrollLeft: calculatedScrollLeft,
                          scrollTop: -1
                      }) : {};
                  }
              }, {
                  key: "_getCalculatedScrollTop",
                  value: function(nextProps, prevState) {
                      var height = nextProps.height, rowCount = nextProps.rowCount, scrollToAlignment = nextProps.scrollToAlignment, scrollToRow = nextProps.scrollToRow, width = nextProps.width, scrollTop = prevState.scrollTop, instanceProps = prevState.instanceProps;
                      if (rowCount > 0) {
                          var finalRow = rowCount - 1, targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow), totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize(), scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
                          return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({
                              align: scrollToAlignment,
                              containerSize: height - scrollBarSize,
                              currentOffset: scrollTop,
                              targetIndex
                          });
                      }
                      return 0;
                  }
              }, {
                  key: "_getScrollTopForScrollToRowStateUpdate",
                  value: function(nextProps, prevState) {
                      var scrollTop = prevState.scrollTop, calculatedScrollTop = Grid._getCalculatedScrollTop(nextProps, prevState);
                      return "number" == typeof calculatedScrollTop && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop ? Grid._getScrollToPositionStateUpdate({
                          prevState,
                          scrollLeft: -1,
                          scrollTop: calculatedScrollTop
                      }) : {};
                  }
              } ]), Grid;
          }(react.PureComponent), defineProperty_defineProperty(_class, "propTypes", null), 
          _temp);
          defineProperty_defineProperty(Grid, "defaultProps", {
              "aria-label": "grid",
              "aria-readonly": !0,
              autoContainerWidth: !1,
              autoHeight: !1,
              autoWidth: !1,
              cellRangeRenderer: function(_ref) {
                  for (var cellCache = _ref.cellCache, cellRenderer = _ref.cellRenderer, columnSizeAndPositionManager = _ref.columnSizeAndPositionManager, columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, deferredMeasurementCache = _ref.deferredMeasurementCache, horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment, isScrolling = _ref.isScrolling, isScrollingOptOut = _ref.isScrollingOptOut, parent = _ref.parent, rowSizeAndPositionManager = _ref.rowSizeAndPositionManager, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex, styleCache = _ref.styleCache, verticalOffsetAdjustment = _ref.verticalOffsetAdjustment, visibleColumnIndices = _ref.visibleColumnIndices, visibleRowIndices = _ref.visibleRowIndices, renderedCells = [], areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted(), canCacheStyle = !isScrolling && !areOffsetsAdjusted, rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) for (var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex), columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
                      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex), isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop, key = "".concat(rowIndex, "-").concat(columnIndex), style = void 0;
                      canCacheStyle && styleCache[key] ? style = styleCache[key] : deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex) ? style = {
                          height: "auto",
                          left: 0,
                          position: "absolute",
                          top: 0,
                          width: "auto"
                      } : (style = {
                          height: rowDatum.size,
                          left: columnDatum.offset + horizontalOffsetAdjustment,
                          position: "absolute",
                          top: rowDatum.offset + verticalOffsetAdjustment,
                          width: columnDatum.size
                      }, styleCache[key] = style);
                      var cellRendererParams = {
                          columnIndex,
                          isScrolling,
                          isVisible,
                          key,
                          parent,
                          rowIndex,
                          style
                      }, renderedCell = void 0;
                      !isScrollingOptOut && !isScrolling || horizontalOffsetAdjustment || verticalOffsetAdjustment ? renderedCell = cellRenderer(cellRendererParams) : (cellCache[key] || (cellCache[key] = cellRenderer(cellRendererParams)), 
                      renderedCell = cellCache[key]), null != renderedCell && !1 !== renderedCell && renderedCells.push(renderedCell);
                  }
                  return renderedCells;
              },
              containerRole: "rowgroup",
              containerStyle: {},
              estimatedColumnSize: 100,
              estimatedRowSize: 30,
              getScrollbarSize: scrollbarSize,
              noContentRenderer: function() {
                  return null;
              },
              onScroll: function() {},
              onScrollbarPresenceChange: function() {},
              onSectionRendered: function() {},
              overscanColumnCount: 0,
              overscanIndicesGetter: function(_ref) {
                  var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
                  return 1 === scrollDirection ? {
                      overscanStartIndex: Math.max(0, startIndex),
                      overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
                  } : {
                      overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
                      overscanStopIndex: Math.min(cellCount - 1, stopIndex)
                  };
              },
              overscanRowCount: 10,
              role: "grid",
              scrollingResetTimeInterval: 150,
              scrollToAlignment: "auto",
              scrollToColumn: -1,
              scrollToRow: -1,
              style: {},
              tabIndex: 0,
              isScrollingOptOut: !1
          }), polyfill(Grid);
          const Grid_Grid = Grid;
          function accessibilityOverscanIndicesGetter_defaultOverscanIndicesGetter(_ref) {
              var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
              return overscanCellsCount = Math.max(1, overscanCellsCount), 1 === scrollDirection ? {
                  overscanStartIndex: Math.max(0, startIndex - 1),
                  overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
              } : {
                  overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
                  overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
              };
          }
          var ArrowKeyStepper_class, ArrowKeyStepper_temp;
          function ArrowKeyStepper_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          var ArrowKeyStepper = (ArrowKeyStepper_temp = ArrowKeyStepper_class = function(_React$PureComponent) {
              function ArrowKeyStepper() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, ArrowKeyStepper);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ArrowKeyStepper)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "state", {
                      scrollToColumn: 0,
                      scrollToRow: 0,
                      instanceProps: {
                          prevScrollToColumn: 0,
                          prevScrollToRow: 0
                      }
                  }), defineProperty_defineProperty(_assertThisInitialized(_this), "_columnStartIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_columnStopIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_rowStartIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_rowStopIndex", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_onKeyDown", (function(event) {
                      var _this$props = _this.props, columnCount = _this$props.columnCount, disabled = _this$props.disabled, mode = _this$props.mode, rowCount = _this$props.rowCount;
                      if (!disabled) {
                          var _this$_getScrollState = _this._getScrollState(), scrollToColumnPrevious = _this$_getScrollState.scrollToColumn, scrollToRowPrevious = _this$_getScrollState.scrollToRow, _this$_getScrollState2 = _this._getScrollState(), scrollToColumn = _this$_getScrollState2.scrollToColumn, scrollToRow = _this$_getScrollState2.scrollToRow;
                          switch (event.key) {
                            case "ArrowDown":
                              scrollToRow = "cells" === mode ? Math.min(scrollToRow + 1, rowCount - 1) : Math.min(_this._rowStopIndex + 1, rowCount - 1);
                              break;

                            case "ArrowLeft":
                              scrollToColumn = "cells" === mode ? Math.max(scrollToColumn - 1, 0) : Math.max(_this._columnStartIndex - 1, 0);
                              break;

                            case "ArrowRight":
                              scrollToColumn = "cells" === mode ? Math.min(scrollToColumn + 1, columnCount - 1) : Math.min(_this._columnStopIndex + 1, columnCount - 1);
                              break;

                            case "ArrowUp":
                              scrollToRow = "cells" === mode ? Math.max(scrollToRow - 1, 0) : Math.max(_this._rowStartIndex - 1, 0);
                          }
                          scrollToColumn === scrollToColumnPrevious && scrollToRow === scrollToRowPrevious || (event.preventDefault(), 
                          _this._updateScrollState({
                              scrollToColumn,
                              scrollToRow
                          }));
                      }
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onSectionRendered", (function(_ref) {
                      var columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex;
                      _this._columnStartIndex = columnStartIndex, _this._columnStopIndex = columnStopIndex, 
                      _this._rowStartIndex = rowStartIndex, _this._rowStopIndex = rowStopIndex;
                  })), _this;
              }
              return _inherits(ArrowKeyStepper, _React$PureComponent), _createClass(ArrowKeyStepper, [ {
                  key: "setScrollIndexes",
                  value: function(_ref2) {
                      var scrollToColumn = _ref2.scrollToColumn, scrollToRow = _ref2.scrollToRow;
                      this.setState({
                          scrollToRow,
                          scrollToColumn
                      });
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props2 = this.props, className = _this$props2.className, children = _this$props2.children, _this$_getScrollState3 = this._getScrollState(), scrollToColumn = _this$_getScrollState3.scrollToColumn, scrollToRow = _this$_getScrollState3.scrollToRow;
                      return react.createElement("div", {
                          className,
                          onKeyDown: this._onKeyDown
                      }, children({
                          onSectionRendered: this._onSectionRendered,
                          scrollToColumn,
                          scrollToRow
                      }));
                  }
              }, {
                  key: "_getScrollState",
                  value: function() {
                      return this.props.isControlled ? this.props : this.state;
                  }
              }, {
                  key: "_updateScrollState",
                  value: function(_ref3) {
                      var scrollToColumn = _ref3.scrollToColumn, scrollToRow = _ref3.scrollToRow, _this$props3 = this.props, isControlled = _this$props3.isControlled, onScrollToChange = _this$props3.onScrollToChange;
                      "function" == typeof onScrollToChange && onScrollToChange({
                          scrollToColumn,
                          scrollToRow
                      }), isControlled || this.setState({
                          scrollToColumn,
                          scrollToRow
                      });
                  }
              } ], [ {
                  key: "getDerivedStateFromProps",
                  value: function(nextProps, prevState) {
                      return nextProps.isControlled ? {} : nextProps.scrollToColumn !== prevState.instanceProps.prevScrollToColumn || nextProps.scrollToRow !== prevState.instanceProps.prevScrollToRow ? function(target) {
                          for (var i = 1; i < arguments.length; i++) {
                              var source = null != arguments[i] ? arguments[i] : {};
                              i % 2 ? ArrowKeyStepper_ownKeys(source, !0).forEach((function(key) {
                                  defineProperty_defineProperty(target, key, source[key]);
                              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ArrowKeyStepper_ownKeys(source).forEach((function(key) {
                                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                              }));
                          }
                          return target;
                      }({}, prevState, {
                          scrollToColumn: nextProps.scrollToColumn,
                          scrollToRow: nextProps.scrollToRow,
                          instanceProps: {
                              prevScrollToColumn: nextProps.scrollToColumn,
                              prevScrollToRow: nextProps.scrollToRow
                          }
                      }) : {};
                  }
              } ]), ArrowKeyStepper;
          }(react.PureComponent), defineProperty_defineProperty(ArrowKeyStepper_class, "propTypes", null), 
          ArrowKeyStepper_temp);
          defineProperty_defineProperty(ArrowKeyStepper, "defaultProps", {
              disabled: !1,
              isControlled: !1,
              mode: "edges",
              scrollToColumn: 0,
              scrollToRow: 0
          }), polyfill(ArrowKeyStepper);
          function createDetectElementResize(nonce, hostWindow) {
              var _window, attachEvent = void 0 !== (_window = void 0 !== hostWindow ? hostWindow : "undefined" != typeof window ? window : "undefined" != typeof self ? self : __webpack_require__.g).document && _window.document.attachEvent;
              if (!attachEvent) {
                  var requestFrame = function() {
                      var raf = _window.requestAnimationFrame || _window.mozRequestAnimationFrame || _window.webkitRequestAnimationFrame || function(fn) {
                          return _window.setTimeout(fn, 20);
                      };
                      return function(fn) {
                          return raf(fn);
                      };
                  }(), cancelFrame = function() {
                      var cancel = _window.cancelAnimationFrame || _window.mozCancelAnimationFrame || _window.webkitCancelAnimationFrame || _window.clearTimeout;
                      return function(id) {
                          return cancel(id);
                      };
                  }(), resetTriggers = function(element) {
                      var triggers = element.__resizeTriggers__, expand = triggers.firstElementChild, contract = triggers.lastElementChild, expandChild = expand.firstElementChild;
                      contract.scrollLeft = contract.scrollWidth, contract.scrollTop = contract.scrollHeight, 
                      expandChild.style.width = expand.offsetWidth + 1 + "px", expandChild.style.height = expand.offsetHeight + 1 + "px", 
                      expand.scrollLeft = expand.scrollWidth, expand.scrollTop = expand.scrollHeight;
                  }, scrollListener = function(e) {
                      if (!(e.target.className && "function" == typeof e.target.className.indexOf && e.target.className.indexOf("contract-trigger") < 0 && e.target.className.indexOf("expand-trigger") < 0)) {
                          var element = this;
                          resetTriggers(this), this.__resizeRAF__ && cancelFrame(this.__resizeRAF__), this.__resizeRAF__ = requestFrame((function() {
                              (function(element) {
                                  return element.offsetWidth != element.__resizeLast__.width || element.offsetHeight != element.__resizeLast__.height;
                              })(element) && (element.__resizeLast__.width = element.offsetWidth, element.__resizeLast__.height = element.offsetHeight, 
                              element.__resizeListeners__.forEach((function(fn) {
                                  fn.call(element, e);
                              })));
                          }));
                      }
                  }, animation = !1, keyframeprefix = "", animationstartevent = "animationstart", domPrefixes = "Webkit Moz O ms".split(" "), startEvents = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "), elm = _window.document.createElement("fakeelement");
                  if (void 0 !== elm.style.animationName && (animation = !0), !1 === animation) for (var i = 0; i < domPrefixes.length; i++) if (void 0 !== elm.style[domPrefixes[i] + "AnimationName"]) {
                      keyframeprefix = "-" + domPrefixes[i].toLowerCase() + "-", animationstartevent = startEvents[i], 
                      animation = !0;
                      break;
                  }
                  var animationName = "resizeanim", animationKeyframes = "@" + keyframeprefix + "keyframes " + animationName + " { from { opacity: 0; } to { opacity: 0; } } ", animationStyle = keyframeprefix + "animation: 1ms " + animationName + "; ";
              }
              return {
                  addResizeListener: function(element, fn) {
                      if (attachEvent) element.attachEvent("onresize", fn); else {
                          if (!element.__resizeTriggers__) {
                              var doc = element.ownerDocument, elementStyle = _window.getComputedStyle(element);
                              elementStyle && "static" == elementStyle.position && (element.style.position = "relative"), 
                              function(doc) {
                                  if (!doc.getElementById("detectElementResize")) {
                                      var css = (animationKeyframes || "") + ".resize-triggers { " + (animationStyle || "") + 'visibility: hidden; opacity: 0; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: " "; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; z-index: -1; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }', head = doc.head || doc.getElementsByTagName("head")[0], style = doc.createElement("style");
                                      style.id = "detectElementResize", style.type = "text/css", null != nonce && style.setAttribute("nonce", nonce), 
                                      style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(doc.createTextNode(css)), 
                                      head.appendChild(style);
                                  }
                              }(doc), element.__resizeLast__ = {}, element.__resizeListeners__ = [], (element.__resizeTriggers__ = doc.createElement("div")).className = "resize-triggers";
                              var resizeTriggersHtml = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>';
                              if (window.trustedTypes) {
                                  var staticPolicy = trustedTypes.createPolicy("react-virtualized-auto-sizer", {
                                      createHTML: function() {
                                          return resizeTriggersHtml;
                                      }
                                  });
                                  element.__resizeTriggers__.innerHTML = staticPolicy.createHTML("");
                              } else element.__resizeTriggers__.innerHTML = resizeTriggersHtml;
                              element.appendChild(element.__resizeTriggers__), resetTriggers(element), element.addEventListener("scroll", scrollListener, !0), 
                              animationstartevent && (element.__resizeTriggers__.__animationListener__ = function(e) {
                                  e.animationName == animationName && resetTriggers(element);
                              }, element.__resizeTriggers__.addEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__));
                          }
                          element.__resizeListeners__.push(fn);
                      }
                  },
                  removeResizeListener: function(element, fn) {
                      if (attachEvent) element.detachEvent("onresize", fn); else if (element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1), 
                      !element.__resizeListeners__.length) {
                          element.removeEventListener("scroll", scrollListener, !0), element.__resizeTriggers__.__animationListener__ && (element.__resizeTriggers__.removeEventListener(animationstartevent, element.__resizeTriggers__.__animationListener__), 
                          element.__resizeTriggers__.__animationListener__ = null);
                          try {
                              element.__resizeTriggers__ = !element.removeChild(element.__resizeTriggers__);
                          } catch (e) {}
                      }
                  }
              };
          }
          var AutoSizer_class, AutoSizer_temp;
          function AutoSizer_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function AutoSizer_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? AutoSizer_ownKeys(source, !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AutoSizer_ownKeys(source).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          var AutoSizer = (AutoSizer_temp = AutoSizer_class = function(_React$Component) {
              function AutoSizer() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, AutoSizer);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AutoSizer)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "state", {
                      height: _this.props.defaultHeight || 0,
                      width: _this.props.defaultWidth || 0
                  }), defineProperty_defineProperty(_assertThisInitialized(_this), "_parentNode", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_autoSizer", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_window", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_detectElementResize", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_onResize", (function() {
                      var _this$props = _this.props, disableHeight = _this$props.disableHeight, disableWidth = _this$props.disableWidth, onResize = _this$props.onResize;
                      if (_this._parentNode) {
                          var height = _this._parentNode.offsetHeight || 0, width = _this._parentNode.offsetWidth || 0, style = (_this._window || window).getComputedStyle(_this._parentNode) || {}, paddingLeft = parseInt(style.paddingLeft, 10) || 0, paddingRight = parseInt(style.paddingRight, 10) || 0, paddingTop = parseInt(style.paddingTop, 10) || 0, paddingBottom = parseInt(style.paddingBottom, 10) || 0, newHeight = height - paddingTop - paddingBottom, newWidth = width - paddingLeft - paddingRight;
                          (!disableHeight && _this.state.height !== newHeight || !disableWidth && _this.state.width !== newWidth) && (_this.setState({
                              height: height - paddingTop - paddingBottom,
                              width: width - paddingLeft - paddingRight
                          }), onResize({
                              height,
                              width
                          }));
                      }
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_setRef", (function(autoSizer) {
                      _this._autoSizer = autoSizer;
                  })), _this;
              }
              return _inherits(AutoSizer, _React$Component), _createClass(AutoSizer, [ {
                  key: "componentDidMount",
                  value: function() {
                      var nonce = this.props.nonce;
                      this._autoSizer && this._autoSizer.parentNode && this._autoSizer.parentNode.ownerDocument && this._autoSizer.parentNode.ownerDocument.defaultView && this._autoSizer.parentNode instanceof this._autoSizer.parentNode.ownerDocument.defaultView.HTMLElement && (this._parentNode = this._autoSizer.parentNode, 
                      this._window = this._autoSizer.parentNode.ownerDocument.defaultView, this._detectElementResize = createDetectElementResize(nonce, this._window), 
                      this._detectElementResize.addResizeListener(this._parentNode, this._onResize), this._onResize());
                  }
              }, {
                  key: "componentWillUnmount",
                  value: function() {
                      this._detectElementResize && this._parentNode && this._detectElementResize.removeResizeListener(this._parentNode, this._onResize);
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props2 = this.props, children = _this$props2.children, className = _this$props2.className, disableHeight = _this$props2.disableHeight, disableWidth = _this$props2.disableWidth, style = _this$props2.style, _this$state = this.state, height = _this$state.height, width = _this$state.width, outerStyle = {
                          overflow: "visible"
                      }, childParams = {};
                      return disableHeight || (outerStyle.height = 0, childParams.height = height), disableWidth || (outerStyle.width = 0, 
                      childParams.width = width), react.createElement("div", {
                          className,
                          ref: this._setRef,
                          style: AutoSizer_objectSpread({}, outerStyle, {}, style)
                      }, children(childParams));
                  }
              } ]), AutoSizer;
          }(react.Component), defineProperty_defineProperty(AutoSizer_class, "propTypes", null), 
          AutoSizer_temp);
          defineProperty_defineProperty(AutoSizer, "defaultProps", {
              onResize: function() {},
              disableHeight: !1,
              disableWidth: !1,
              style: {}
          });
          var CellMeasurer_class, CellMeasurer_temp, CellMeasurer_CellMeasurer = (CellMeasurer_temp = CellMeasurer_class = function(_React$PureComponent) {
              function CellMeasurer() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, CellMeasurer);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CellMeasurer)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "_child", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_measure", (function() {
                      var _this$props = _this.props, cache = _this$props.cache, _this$props$columnInd = _this$props.columnIndex, columnIndex = void 0 === _this$props$columnInd ? 0 : _this$props$columnInd, parent = _this$props.parent, _this$props$rowIndex = _this$props.rowIndex, rowIndex = void 0 === _this$props$rowIndex ? _this.props.index || 0 : _this$props$rowIndex, _this$_getCellMeasure = _this._getCellMeasurements(), height = _this$_getCellMeasure.height, width = _this$_getCellMeasure.width;
                      height === cache.getHeight(rowIndex, columnIndex) && width === cache.getWidth(rowIndex, columnIndex) || (cache.set(rowIndex, columnIndex, width, height), 
                      parent && "function" == typeof parent.recomputeGridSize && parent.recomputeGridSize({
                          columnIndex,
                          rowIndex
                      }));
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_registerChild", (function(element) {
                      !element || element instanceof Element || console.warn("CellMeasurer registerChild expects to be passed Element or null"), 
                      _this._child = element, element && _this._maybeMeasureCell();
                  })), _this;
              }
              return _inherits(CellMeasurer, _React$PureComponent), _createClass(CellMeasurer, [ {
                  key: "componentDidMount",
                  value: function() {
                      this._maybeMeasureCell();
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function() {
                      this._maybeMeasureCell();
                  }
              }, {
                  key: "render",
                  value: function() {
                      var children = this.props.children;
                      return "function" == typeof children ? children({
                          measure: this._measure,
                          registerChild: this._registerChild
                      }) : children;
                  }
              }, {
                  key: "_getCellMeasurements",
                  value: function() {
                      var cache = this.props.cache, node = this._child || (0, react_dom.findDOMNode)(this);
                      if (node && node.ownerDocument && node.ownerDocument.defaultView && node instanceof node.ownerDocument.defaultView.HTMLElement) {
                          var styleWidth = node.style.width, styleHeight = node.style.height;
                          cache.hasFixedWidth() || (node.style.width = "auto"), cache.hasFixedHeight() || (node.style.height = "auto");
                          var height = Math.ceil(node.offsetHeight), width = Math.ceil(node.offsetWidth);
                          return styleWidth && (node.style.width = styleWidth), styleHeight && (node.style.height = styleHeight), 
                          {
                              height,
                              width
                          };
                      }
                      return {
                          height: 0,
                          width: 0
                      };
                  }
              }, {
                  key: "_maybeMeasureCell",
                  value: function() {
                      var _this$props2 = this.props, cache = _this$props2.cache, _this$props2$columnIn = _this$props2.columnIndex, columnIndex = void 0 === _this$props2$columnIn ? 0 : _this$props2$columnIn, parent = _this$props2.parent, _this$props2$rowIndex = _this$props2.rowIndex, rowIndex = void 0 === _this$props2$rowIndex ? this.props.index || 0 : _this$props2$rowIndex;
                      if (!cache.has(rowIndex, columnIndex)) {
                          var _this$_getCellMeasure2 = this._getCellMeasurements(), height = _this$_getCellMeasure2.height, width = _this$_getCellMeasure2.width;
                          cache.set(rowIndex, columnIndex, width, height), parent && "function" == typeof parent.invalidateCellSizeAfterRender && parent.invalidateCellSizeAfterRender({
                              columnIndex,
                              rowIndex
                          });
                      }
                  }
              } ]), CellMeasurer;
          }(react.PureComponent), defineProperty_defineProperty(CellMeasurer_class, "propTypes", null), 
          CellMeasurer_temp);
          defineProperty_defineProperty(CellMeasurer_CellMeasurer, "__internalCellMeasurerFlag", !1);
          var CellMeasurerCache = function() {
              function CellMeasurerCache() {
                  var _this = this, params = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                  _classCallCheck(this, CellMeasurerCache), defineProperty_defineProperty(this, "_cellHeightCache", {}), 
                  defineProperty_defineProperty(this, "_cellWidthCache", {}), defineProperty_defineProperty(this, "_columnWidthCache", {}), 
                  defineProperty_defineProperty(this, "_rowHeightCache", {}), defineProperty_defineProperty(this, "_defaultHeight", void 0), 
                  defineProperty_defineProperty(this, "_defaultWidth", void 0), defineProperty_defineProperty(this, "_minHeight", void 0), 
                  defineProperty_defineProperty(this, "_minWidth", void 0), defineProperty_defineProperty(this, "_keyMapper", void 0), 
                  defineProperty_defineProperty(this, "_hasFixedHeight", void 0), defineProperty_defineProperty(this, "_hasFixedWidth", void 0), 
                  defineProperty_defineProperty(this, "_columnCount", 0), defineProperty_defineProperty(this, "_rowCount", 0), 
                  defineProperty_defineProperty(this, "columnWidth", (function(_ref) {
                      var index = _ref.index, key = _this._keyMapper(0, index);
                      return void 0 !== _this._columnWidthCache[key] ? _this._columnWidthCache[key] : _this._defaultWidth;
                  })), defineProperty_defineProperty(this, "rowHeight", (function(_ref2) {
                      var index = _ref2.index, key = _this._keyMapper(index, 0);
                      return void 0 !== _this._rowHeightCache[key] ? _this._rowHeightCache[key] : _this._defaultHeight;
                  }));
                  var defaultHeight = params.defaultHeight, defaultWidth = params.defaultWidth, fixedHeight = params.fixedHeight, fixedWidth = params.fixedWidth, keyMapper = params.keyMapper, minHeight = params.minHeight, minWidth = params.minWidth;
                  this._hasFixedHeight = !0 === fixedHeight, this._hasFixedWidth = !0 === fixedWidth, 
                  this._minHeight = minHeight || 0, this._minWidth = minWidth || 0, this._keyMapper = keyMapper || defaultKeyMapper, 
                  this._defaultHeight = Math.max(this._minHeight, "number" == typeof defaultHeight ? defaultHeight : 30), 
                  this._defaultWidth = Math.max(this._minWidth, "number" == typeof defaultWidth ? defaultWidth : 100);
              }
              return _createClass(CellMeasurerCache, [ {
                  key: "clear",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, key = this._keyMapper(rowIndex, columnIndex);
                      delete this._cellHeightCache[key], delete this._cellWidthCache[key], this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
                  }
              }, {
                  key: "clearAll",
                  value: function() {
                      this._cellHeightCache = {}, this._cellWidthCache = {}, this._columnWidthCache = {}, 
                      this._rowHeightCache = {}, this._rowCount = 0, this._columnCount = 0;
                  }
              }, {
                  key: "hasFixedHeight",
                  value: function() {
                      return this._hasFixedHeight;
                  }
              }, {
                  key: "hasFixedWidth",
                  value: function() {
                      return this._hasFixedWidth;
                  }
              }, {
                  key: "getHeight",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                      if (this._hasFixedHeight) return this._defaultHeight;
                      var _key = this._keyMapper(rowIndex, columnIndex);
                      return void 0 !== this._cellHeightCache[_key] ? Math.max(this._minHeight, this._cellHeightCache[_key]) : this._defaultHeight;
                  }
              }, {
                  key: "getWidth",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                      if (this._hasFixedWidth) return this._defaultWidth;
                      var _key2 = this._keyMapper(rowIndex, columnIndex);
                      return void 0 !== this._cellWidthCache[_key2] ? Math.max(this._minWidth, this._cellWidthCache[_key2]) : this._defaultWidth;
                  }
              }, {
                  key: "has",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, key = this._keyMapper(rowIndex, columnIndex);
                      return void 0 !== this._cellHeightCache[key];
                  }
              }, {
                  key: "set",
                  value: function(rowIndex, columnIndex, width, height) {
                      var key = this._keyMapper(rowIndex, columnIndex);
                      columnIndex >= this._columnCount && (this._columnCount = columnIndex + 1), rowIndex >= this._rowCount && (this._rowCount = rowIndex + 1), 
                      this._cellHeightCache[key] = height, this._cellWidthCache[key] = width, this._updateCachedColumnAndRowSizes(rowIndex, columnIndex);
                  }
              }, {
                  key: "_updateCachedColumnAndRowSizes",
                  value: function(rowIndex, columnIndex) {
                      if (!this._hasFixedWidth) {
                          for (var columnWidth = 0, i = 0; i < this._rowCount; i++) columnWidth = Math.max(columnWidth, this.getWidth(i, columnIndex));
                          var columnKey = this._keyMapper(0, columnIndex);
                          this._columnWidthCache[columnKey] = columnWidth;
                      }
                      if (!this._hasFixedHeight) {
                          for (var rowHeight = 0, _i = 0; _i < this._columnCount; _i++) rowHeight = Math.max(rowHeight, this.getHeight(rowIndex, _i));
                          var rowKey = this._keyMapper(rowIndex, 0);
                          this._rowHeightCache[rowKey] = rowHeight;
                      }
                  }
              }, {
                  key: "defaultHeight",
                  get: function() {
                      return this._defaultHeight;
                  }
              }, {
                  key: "defaultWidth",
                  get: function() {
                      return this._defaultWidth;
                  }
              } ]), CellMeasurerCache;
          }();
          function defaultKeyMapper(rowIndex, columnIndex) {
              return "".concat(rowIndex, "-").concat(columnIndex);
          }
          function CollectionView_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function CollectionView_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? CollectionView_ownKeys(source, !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : CollectionView_ownKeys(source).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          var CollectionView_SCROLL_POSITION_CHANGE_REASONS_OBSERVED = "observed", CollectionView_SCROLL_POSITION_CHANGE_REASONS_REQUESTED = "requested", CollectionView = function(_React$PureComponent) {
              function CollectionView() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, CollectionView);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(CollectionView)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "state", {
                      isScrolling: !1,
                      scrollLeft: 0,
                      scrollTop: 0
                  }), defineProperty_defineProperty(_assertThisInitialized(_this), "_calculateSizeAndPositionDataOnNextUpdate", !1), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_onSectionRenderedMemoizer", createCallbackMemoizer()), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_onScrollMemoizer", createCallbackMemoizer(!1)), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_invokeOnSectionRenderedHelper", (function() {
                      var _this$props = _this.props, cellLayoutManager = _this$props.cellLayoutManager, onSectionRendered = _this$props.onSectionRendered;
                      _this._onSectionRenderedMemoizer({
                          callback: onSectionRendered,
                          indices: {
                              indices: cellLayoutManager.getLastRenderedIndices()
                          }
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_setScrollingContainerRef", (function(ref) {
                      _this._scrollingContainer = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_updateScrollPositionForScrollToCell", (function() {
                      var _this$props2 = _this.props, cellLayoutManager = _this$props2.cellLayoutManager, height = _this$props2.height, scrollToAlignment = _this$props2.scrollToAlignment, scrollToCell = _this$props2.scrollToCell, width = _this$props2.width, _this$state = _this.state, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop;
                      if (scrollToCell >= 0) {
                          var scrollPosition = cellLayoutManager.getScrollPositionForCell({
                              align: scrollToAlignment,
                              cellIndex: scrollToCell,
                              height,
                              scrollLeft,
                              scrollTop,
                              width
                          });
                          scrollPosition.scrollLeft === scrollLeft && scrollPosition.scrollTop === scrollTop || _this._setScrollPosition(scrollPosition);
                      }
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScroll", (function(event) {
                      if (event.target === _this._scrollingContainer) {
                          _this._enablePointerEventsAfterDelay();
                          var _this$props3 = _this.props, cellLayoutManager = _this$props3.cellLayoutManager, height = _this$props3.height, isScrollingChange = _this$props3.isScrollingChange, width = _this$props3.width, scrollbarSize = _this._scrollbarSize, _cellLayoutManager$ge = cellLayoutManager.getTotalSize(), totalHeight = _cellLayoutManager$ge.height, totalWidth = _cellLayoutManager$ge.width, scrollLeft = Math.max(0, Math.min(totalWidth - width + scrollbarSize, event.target.scrollLeft)), scrollTop = Math.max(0, Math.min(totalHeight - height + scrollbarSize, event.target.scrollTop));
                          if (_this.state.scrollLeft !== scrollLeft || _this.state.scrollTop !== scrollTop) {
                              var scrollPositionChangeReason = event.cancelable ? CollectionView_SCROLL_POSITION_CHANGE_REASONS_OBSERVED : CollectionView_SCROLL_POSITION_CHANGE_REASONS_REQUESTED;
                              _this.state.isScrolling || isScrollingChange(!0), _this.setState({
                                  isScrolling: !0,
                                  scrollLeft,
                                  scrollPositionChangeReason,
                                  scrollTop
                              });
                          }
                          _this._invokeOnScrollMemoizer({
                              scrollLeft,
                              scrollTop,
                              totalWidth,
                              totalHeight
                          });
                      }
                  })), _this._scrollbarSize = scrollbarSize(), void 0 === _this._scrollbarSize ? (_this._scrollbarSizeMeasured = !1, 
                  _this._scrollbarSize = 0) : _this._scrollbarSizeMeasured = !0, _this;
              }
              return _inherits(CollectionView, _React$PureComponent), _createClass(CollectionView, [ {
                  key: "recomputeCellSizesAndPositions",
                  value: function() {
                      this._calculateSizeAndPositionDataOnNextUpdate = !0, this.forceUpdate();
                  }
              }, {
                  key: "componentDidMount",
                  value: function() {
                      var _this$props4 = this.props, cellLayoutManager = _this$props4.cellLayoutManager, scrollLeft = _this$props4.scrollLeft, scrollToCell = _this$props4.scrollToCell, scrollTop = _this$props4.scrollTop;
                      this._scrollbarSizeMeasured || (this._scrollbarSize = scrollbarSize(), this._scrollbarSizeMeasured = !0, 
                      this.setState({})), scrollToCell >= 0 ? this._updateScrollPositionForScrollToCell() : (scrollLeft >= 0 || scrollTop >= 0) && this._setScrollPosition({
                          scrollLeft,
                          scrollTop
                      }), this._invokeOnSectionRenderedHelper();
                      var _cellLayoutManager$ge2 = cellLayoutManager.getTotalSize(), totalHeight = _cellLayoutManager$ge2.height, totalWidth = _cellLayoutManager$ge2.width;
                      this._invokeOnScrollMemoizer({
                          scrollLeft: scrollLeft || 0,
                          scrollTop: scrollTop || 0,
                          totalHeight,
                          totalWidth
                      });
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function(prevProps, prevState) {
                      var _this$props5 = this.props, height = _this$props5.height, scrollToAlignment = _this$props5.scrollToAlignment, scrollToCell = _this$props5.scrollToCell, width = _this$props5.width, _this$state2 = this.state, scrollLeft = _this$state2.scrollLeft, scrollPositionChangeReason = _this$state2.scrollPositionChangeReason, scrollTop = _this$state2.scrollTop;
                      scrollPositionChangeReason === CollectionView_SCROLL_POSITION_CHANGE_REASONS_REQUESTED && (scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft && scrollLeft !== this._scrollingContainer.scrollLeft && (this._scrollingContainer.scrollLeft = scrollLeft), 
                      scrollTop >= 0 && scrollTop !== prevState.scrollTop && scrollTop !== this._scrollingContainer.scrollTop && (this._scrollingContainer.scrollTop = scrollTop)), 
                      height === prevProps.height && scrollToAlignment === prevProps.scrollToAlignment && scrollToCell === prevProps.scrollToCell && width === prevProps.width || this._updateScrollPositionForScrollToCell(), 
                      this._invokeOnSectionRenderedHelper();
                  }
              }, {
                  key: "componentWillUnmount",
                  value: function() {
                      this._disablePointerEventsTimeoutId && clearTimeout(this._disablePointerEventsTimeoutId);
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props6 = this.props, autoHeight = _this$props6.autoHeight, cellCount = _this$props6.cellCount, cellLayoutManager = _this$props6.cellLayoutManager, className = _this$props6.className, height = _this$props6.height, horizontalOverscanSize = _this$props6.horizontalOverscanSize, id = _this$props6.id, noContentRenderer = _this$props6.noContentRenderer, style = _this$props6.style, verticalOverscanSize = _this$props6.verticalOverscanSize, width = _this$props6.width, _this$state3 = this.state, isScrolling = _this$state3.isScrolling, scrollLeft = _this$state3.scrollLeft, scrollTop = _this$state3.scrollTop;
                      (this._lastRenderedCellCount !== cellCount || this._lastRenderedCellLayoutManager !== cellLayoutManager || this._calculateSizeAndPositionDataOnNextUpdate) && (this._lastRenderedCellCount = cellCount, 
                      this._lastRenderedCellLayoutManager = cellLayoutManager, this._calculateSizeAndPositionDataOnNextUpdate = !1, 
                      cellLayoutManager.calculateSizeAndPositionData());
                      var _cellLayoutManager$ge3 = cellLayoutManager.getTotalSize(), totalHeight = _cellLayoutManager$ge3.height, totalWidth = _cellLayoutManager$ge3.width, left = Math.max(0, scrollLeft - horizontalOverscanSize), top = Math.max(0, scrollTop - verticalOverscanSize), right = Math.min(totalWidth, scrollLeft + width + horizontalOverscanSize), bottom = Math.min(totalHeight, scrollTop + height + verticalOverscanSize), childrenToDisplay = height > 0 && width > 0 ? cellLayoutManager.cellRenderers({
                          height: bottom - top,
                          isScrolling,
                          width: right - left,
                          x: left,
                          y: top
                      }) : [], collectionStyle = {
                          boxSizing: "border-box",
                          direction: "ltr",
                          height: autoHeight ? "auto" : height,
                          position: "relative",
                          WebkitOverflowScrolling: "touch",
                          width,
                          willChange: "transform"
                      }, verticalScrollBarSize = totalHeight > height ? this._scrollbarSize : 0, horizontalScrollBarSize = totalWidth > width ? this._scrollbarSize : 0;
                      return collectionStyle.overflowX = totalWidth + verticalScrollBarSize <= width ? "hidden" : "auto", 
                      collectionStyle.overflowY = totalHeight + horizontalScrollBarSize <= height ? "hidden" : "auto", 
                      react.createElement("div", {
                          ref: this._setScrollingContainerRef,
                          "aria-label": this.props["aria-label"],
                          className: clsx_m("ReactVirtualized__Collection", className),
                          id,
                          onScroll: this._onScroll,
                          role: "grid",
                          style: CollectionView_objectSpread({}, collectionStyle, {}, style),
                          tabIndex: 0
                      }, cellCount > 0 && react.createElement("div", {
                          className: "ReactVirtualized__Collection__innerScrollContainer",
                          style: {
                              height: totalHeight,
                              maxHeight: totalHeight,
                              maxWidth: totalWidth,
                              overflow: "hidden",
                              pointerEvents: isScrolling ? "none" : "",
                              width: totalWidth
                          }
                      }, childrenToDisplay), 0 === cellCount && noContentRenderer());
                  }
              }, {
                  key: "_enablePointerEventsAfterDelay",
                  value: function() {
                      var _this2 = this;
                      this._disablePointerEventsTimeoutId && clearTimeout(this._disablePointerEventsTimeoutId), 
                      this._disablePointerEventsTimeoutId = setTimeout((function() {
                          (0, _this2.props.isScrollingChange)(!1), _this2._disablePointerEventsTimeoutId = null, 
                          _this2.setState({
                              isScrolling: !1
                          });
                      }), 150);
                  }
              }, {
                  key: "_invokeOnScrollMemoizer",
                  value: function(_ref) {
                      var _this3 = this, scrollLeft = _ref.scrollLeft, scrollTop = _ref.scrollTop, totalHeight = _ref.totalHeight, totalWidth = _ref.totalWidth;
                      this._onScrollMemoizer({
                          callback: function(_ref2) {
                              var scrollLeft = _ref2.scrollLeft, scrollTop = _ref2.scrollTop, _this3$props = _this3.props, height = _this3$props.height;
                              (0, _this3$props.onScroll)({
                                  clientHeight: height,
                                  clientWidth: _this3$props.width,
                                  scrollHeight: totalHeight,
                                  scrollLeft,
                                  scrollTop,
                                  scrollWidth: totalWidth
                              });
                          },
                          indices: {
                              scrollLeft,
                              scrollTop
                          }
                      });
                  }
              }, {
                  key: "_setScrollPosition",
                  value: function(_ref3) {
                      var scrollLeft = _ref3.scrollLeft, scrollTop = _ref3.scrollTop, newState = {
                          scrollPositionChangeReason: CollectionView_SCROLL_POSITION_CHANGE_REASONS_REQUESTED
                      };
                      scrollLeft >= 0 && (newState.scrollLeft = scrollLeft), scrollTop >= 0 && (newState.scrollTop = scrollTop), 
                      (scrollLeft >= 0 && scrollLeft !== this.state.scrollLeft || scrollTop >= 0 && scrollTop !== this.state.scrollTop) && this.setState(newState);
                  }
              } ], [ {
                  key: "getDerivedStateFromProps",
                  value: function(nextProps, prevState) {
                      return 0 !== nextProps.cellCount || 0 === prevState.scrollLeft && 0 === prevState.scrollTop ? nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop ? {
                          scrollLeft: null != nextProps.scrollLeft ? nextProps.scrollLeft : prevState.scrollLeft,
                          scrollTop: null != nextProps.scrollTop ? nextProps.scrollTop : prevState.scrollTop,
                          scrollPositionChangeReason: CollectionView_SCROLL_POSITION_CHANGE_REASONS_REQUESTED
                      } : null : {
                          scrollLeft: 0,
                          scrollTop: 0,
                          scrollPositionChangeReason: CollectionView_SCROLL_POSITION_CHANGE_REASONS_REQUESTED
                      };
                  }
              } ]), CollectionView;
          }(react.PureComponent);
          defineProperty_defineProperty(CollectionView, "defaultProps", {
              "aria-label": "grid",
              horizontalOverscanSize: 0,
              noContentRenderer: function() {
                  return null;
              },
              onScroll: function() {
                  return null;
              },
              onSectionRendered: function() {
                  return null;
              },
              scrollToAlignment: "auto",
              scrollToCell: -1,
              style: {},
              verticalOverscanSize: 0
          }), CollectionView.propTypes = {}, polyfill(CollectionView);
          const Collection_CollectionView = CollectionView;
          var Section = function() {
              function Section(_ref) {
                  var height = _ref.height, width = _ref.width, x = _ref.x, y = _ref.y;
                  _classCallCheck(this, Section), this.height = height, this.width = width, this.x = x, 
                  this.y = y, this._indexMap = {}, this._indices = [];
              }
              return _createClass(Section, [ {
                  key: "addCellIndex",
                  value: function(_ref2) {
                      var index = _ref2.index;
                      this._indexMap[index] || (this._indexMap[index] = !0, this._indices.push(index));
                  }
              }, {
                  key: "getCellIndices",
                  value: function() {
                      return this._indices;
                  }
              }, {
                  key: "toString",
                  value: function() {
                      return "".concat(this.x, ",").concat(this.y, " ").concat(this.width, "x").concat(this.height);
                  }
              } ]), Section;
          }(), SectionManager = function() {
              function SectionManager() {
                  var sectionSize = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 100;
                  _classCallCheck(this, SectionManager), this._sectionSize = sectionSize, this._cellMetadata = [], 
                  this._sections = {};
              }
              return _createClass(SectionManager, [ {
                  key: "getCellIndices",
                  value: function(_ref) {
                      var height = _ref.height, width = _ref.width, x = _ref.x, y = _ref.y, indices = {};
                      return this.getSections({
                          height,
                          width,
                          x,
                          y
                      }).forEach((function(section) {
                          return section.getCellIndices().forEach((function(index) {
                              indices[index] = index;
                          }));
                      })), Object.keys(indices).map((function(index) {
                          return indices[index];
                      }));
                  }
              }, {
                  key: "getCellMetadata",
                  value: function(_ref2) {
                      var index = _ref2.index;
                      return this._cellMetadata[index];
                  }
              }, {
                  key: "getSections",
                  value: function(_ref3) {
                      for (var height = _ref3.height, width = _ref3.width, x = _ref3.x, y = _ref3.y, sectionXStart = Math.floor(x / this._sectionSize), sectionXStop = Math.floor((x + width - 1) / this._sectionSize), sectionYStart = Math.floor(y / this._sectionSize), sectionYStop = Math.floor((y + height - 1) / this._sectionSize), sections = [], sectionX = sectionXStart; sectionX <= sectionXStop; sectionX++) for (var sectionY = sectionYStart; sectionY <= sectionYStop; sectionY++) {
                          var key = "".concat(sectionX, ".").concat(sectionY);
                          this._sections[key] || (this._sections[key] = new Section({
                              height: this._sectionSize,
                              width: this._sectionSize,
                              x: sectionX * this._sectionSize,
                              y: sectionY * this._sectionSize
                          })), sections.push(this._sections[key]);
                      }
                      return sections;
                  }
              }, {
                  key: "getTotalSectionCount",
                  value: function() {
                      return Object.keys(this._sections).length;
                  }
              }, {
                  key: "toString",
                  value: function() {
                      var _this = this;
                      return Object.keys(this._sections).map((function(index) {
                          return _this._sections[index].toString();
                      }));
                  }
              }, {
                  key: "registerCell",
                  value: function(_ref4) {
                      var cellMetadatum = _ref4.cellMetadatum, index = _ref4.index;
                      this._cellMetadata[index] = cellMetadatum, this.getSections(cellMetadatum).forEach((function(section) {
                          return section.addCellIndex({
                              index
                          });
                      }));
                  }
              } ]), SectionManager;
          }();
          function getUpdatedOffsetForIndex(_ref) {
              var _ref$align = _ref.align, align = void 0 === _ref$align ? "auto" : _ref$align, cellOffset = _ref.cellOffset, cellSize = _ref.cellSize, containerSize = _ref.containerSize, currentOffset = _ref.currentOffset, maxOffset = cellOffset, minOffset = maxOffset - containerSize + cellSize;
              switch (align) {
                case "start":
                  return maxOffset;

                case "end":
                  return minOffset;

                case "center":
                  return maxOffset - (containerSize - cellSize) / 2;

                default:
                  return Math.max(minOffset, Math.min(maxOffset, currentOffset));
              }
          }
          var Collection_Collection = function(_React$PureComponent) {
              function Collection(props, context) {
                  var _this;
                  return _classCallCheck(this, Collection), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Collection).call(this, props, context)))._cellMetadata = [], 
                  _this._lastRenderedCellIndices = [], _this._cellCache = [], _this._isScrollingChange = _this._isScrollingChange.bind(_assertThisInitialized(_this)), 
                  _this._setCollectionViewRef = _this._setCollectionViewRef.bind(_assertThisInitialized(_this)), 
                  _this;
              }
              return _inherits(Collection, _React$PureComponent), _createClass(Collection, [ {
                  key: "forceUpdate",
                  value: function() {
                      void 0 !== this._collectionView && this._collectionView.forceUpdate();
                  }
              }, {
                  key: "recomputeCellSizesAndPositions",
                  value: function() {
                      this._cellCache = [], this._collectionView.recomputeCellSizesAndPositions();
                  }
              }, {
                  key: "render",
                  value: function() {
                      var props = _extends({}, this.props);
                      return react.createElement(Collection_CollectionView, _extends({
                          cellLayoutManager: this,
                          isScrollingChange: this._isScrollingChange,
                          ref: this._setCollectionViewRef
                      }, props));
                  }
              }, {
                  key: "calculateSizeAndPositionData",
                  value: function() {
                      var _this$props = this.props, data = function(_ref) {
                          for (var cellCount = _ref.cellCount, cellSizeAndPositionGetter = _ref.cellSizeAndPositionGetter, sectionSize = _ref.sectionSize, cellMetadata = [], sectionManager = new SectionManager(sectionSize), height = 0, width = 0, index = 0; index < cellCount; index++) {
                              var cellMetadatum = cellSizeAndPositionGetter({
                                  index
                              });
                              if (null == cellMetadatum.height || isNaN(cellMetadatum.height) || null == cellMetadatum.width || isNaN(cellMetadatum.width) || null == cellMetadatum.x || isNaN(cellMetadatum.x) || null == cellMetadatum.y || isNaN(cellMetadatum.y)) throw Error("Invalid metadata returned for cell ".concat(index, ":\n        x:").concat(cellMetadatum.x, ", y:").concat(cellMetadatum.y, ", width:").concat(cellMetadatum.width, ", height:").concat(cellMetadatum.height));
                              height = Math.max(height, cellMetadatum.y + cellMetadatum.height), width = Math.max(width, cellMetadatum.x + cellMetadatum.width), 
                              cellMetadata[index] = cellMetadatum, sectionManager.registerCell({
                                  cellMetadatum,
                                  index
                              });
                          }
                          return {
                              cellMetadata,
                              height,
                              sectionManager,
                              width
                          };
                      }({
                          cellCount: _this$props.cellCount,
                          cellSizeAndPositionGetter: _this$props.cellSizeAndPositionGetter,
                          sectionSize: _this$props.sectionSize
                      });
                      this._cellMetadata = data.cellMetadata, this._sectionManager = data.sectionManager, 
                      this._height = data.height, this._width = data.width;
                  }
              }, {
                  key: "getLastRenderedIndices",
                  value: function() {
                      return this._lastRenderedCellIndices;
                  }
              }, {
                  key: "getScrollPositionForCell",
                  value: function(_ref) {
                      var align = _ref.align, cellIndex = _ref.cellIndex, height = _ref.height, scrollLeft = _ref.scrollLeft, scrollTop = _ref.scrollTop, width = _ref.width, cellCount = this.props.cellCount;
                      if (cellIndex >= 0 && cellIndex < cellCount) {
                          var cellMetadata = this._cellMetadata[cellIndex];
                          scrollLeft = getUpdatedOffsetForIndex({
                              align,
                              cellOffset: cellMetadata.x,
                              cellSize: cellMetadata.width,
                              containerSize: width,
                              currentOffset: scrollLeft,
                              targetIndex: cellIndex
                          }), scrollTop = getUpdatedOffsetForIndex({
                              align,
                              cellOffset: cellMetadata.y,
                              cellSize: cellMetadata.height,
                              containerSize: height,
                              currentOffset: scrollTop,
                              targetIndex: cellIndex
                          });
                      }
                      return {
                          scrollLeft,
                          scrollTop
                      };
                  }
              }, {
                  key: "getTotalSize",
                  value: function() {
                      return {
                          height: this._height,
                          width: this._width
                      };
                  }
              }, {
                  key: "cellRenderers",
                  value: function(_ref2) {
                      var _this2 = this, height = _ref2.height, isScrolling = _ref2.isScrolling, width = _ref2.width, x = _ref2.x, y = _ref2.y, _this$props2 = this.props, cellGroupRenderer = _this$props2.cellGroupRenderer, cellRenderer = _this$props2.cellRenderer;
                      return this._lastRenderedCellIndices = this._sectionManager.getCellIndices({
                          height,
                          width,
                          x,
                          y
                      }), cellGroupRenderer({
                          cellCache: this._cellCache,
                          cellRenderer,
                          cellSizeAndPositionGetter: function(_ref3) {
                              var index = _ref3.index;
                              return _this2._sectionManager.getCellMetadata({
                                  index
                              });
                          },
                          indices: this._lastRenderedCellIndices,
                          isScrolling
                      });
                  }
              }, {
                  key: "_isScrollingChange",
                  value: function(isScrolling) {
                      isScrolling || (this._cellCache = []);
                  }
              }, {
                  key: "_setCollectionViewRef",
                  value: function(ref) {
                      this._collectionView = ref;
                  }
              } ]), Collection;
          }(react.PureComponent);
          defineProperty_defineProperty(Collection_Collection, "defaultProps", {
              "aria-label": "grid",
              cellGroupRenderer: function(_ref4) {
                  var cellCache = _ref4.cellCache, cellRenderer = _ref4.cellRenderer, cellSizeAndPositionGetter = _ref4.cellSizeAndPositionGetter, indices = _ref4.indices, isScrolling = _ref4.isScrolling;
                  return indices.map((function(index) {
                      var cellMetadata = cellSizeAndPositionGetter({
                          index
                      }), cellRendererProps = {
                          index,
                          isScrolling,
                          key: index,
                          style: {
                              height: cellMetadata.height,
                              left: cellMetadata.x,
                              position: "absolute",
                              top: cellMetadata.y,
                              width: cellMetadata.width
                          }
                      };
                      return isScrolling ? (index in cellCache || (cellCache[index] = cellRenderer(cellRendererProps)), 
                      cellCache[index]) : cellRenderer(cellRendererProps);
                  })).filter((function(renderedCell) {
                      return !!renderedCell;
                  }));
              }
          }), Collection_Collection.propTypes = {};
          var ColumnSizer_ColumnSizer = function(_React$PureComponent) {
              function ColumnSizer(props, context) {
                  var _this;
                  return _classCallCheck(this, ColumnSizer), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ColumnSizer).call(this, props, context)))._registerChild = _this._registerChild.bind(_assertThisInitialized(_this)), 
                  _this;
              }
              return _inherits(ColumnSizer, _React$PureComponent), _createClass(ColumnSizer, [ {
                  key: "componentDidUpdate",
                  value: function(prevProps) {
                      var _this$props = this.props, columnMaxWidth = _this$props.columnMaxWidth, columnMinWidth = _this$props.columnMinWidth, columnCount = _this$props.columnCount, width = _this$props.width;
                      columnMaxWidth === prevProps.columnMaxWidth && columnMinWidth === prevProps.columnMinWidth && columnCount === prevProps.columnCount && width === prevProps.width || this._registeredChild && this._registeredChild.recomputeGridSize();
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props2 = this.props, children = _this$props2.children, columnMaxWidth = _this$props2.columnMaxWidth, columnMinWidth = _this$props2.columnMinWidth, columnCount = _this$props2.columnCount, width = _this$props2.width, safeColumnMinWidth = columnMinWidth || 1, safeColumnMaxWidth = columnMaxWidth ? Math.min(columnMaxWidth, width) : width, columnWidth = width / columnCount;
                      return columnWidth = Math.max(safeColumnMinWidth, columnWidth), columnWidth = Math.min(safeColumnMaxWidth, columnWidth), 
                      columnWidth = Math.floor(columnWidth), children({
                          adjustedWidth: Math.min(width, columnWidth * columnCount),
                          columnWidth,
                          getColumnWidth: function() {
                              return columnWidth;
                          },
                          registerChild: this._registerChild
                      });
                  }
              }, {
                  key: "_registerChild",
                  value: function(child) {
                      if (child && "function" != typeof child.recomputeGridSize) throw Error("Unexpected child type registered; only Grid/MultiGrid children are supported.");
                      this._registeredChild = child, this._registeredChild && this._registeredChild.recomputeGridSize();
                  }
              } ]), ColumnSizer;
          }(react.PureComponent);
          ColumnSizer_ColumnSizer.propTypes = {};
          var InfiniteLoader_InfiniteLoader = function(_React$PureComponent) {
              function InfiniteLoader(props, context) {
                  var _this;
                  return _classCallCheck(this, InfiniteLoader), (_this = _possibleConstructorReturn(this, _getPrototypeOf(InfiniteLoader).call(this, props, context)))._loadMoreRowsMemoizer = createCallbackMemoizer(), 
                  _this._onRowsRendered = _this._onRowsRendered.bind(_assertThisInitialized(_this)), 
                  _this._registerChild = _this._registerChild.bind(_assertThisInitialized(_this)), 
                  _this;
              }
              return _inherits(InfiniteLoader, _React$PureComponent), _createClass(InfiniteLoader, [ {
                  key: "resetLoadMoreRowsCache",
                  value: function(autoReload) {
                      this._loadMoreRowsMemoizer = createCallbackMemoizer(), autoReload && this._doStuff(this._lastRenderedStartIndex, this._lastRenderedStopIndex);
                  }
              }, {
                  key: "render",
                  value: function() {
                      return (0, this.props.children)({
                          onRowsRendered: this._onRowsRendered,
                          registerChild: this._registerChild
                      });
                  }
              }, {
                  key: "_loadUnloadedRanges",
                  value: function(unloadedRanges) {
                      var _this2 = this, loadMoreRows = this.props.loadMoreRows;
                      unloadedRanges.forEach((function(unloadedRange) {
                          var promise = loadMoreRows(unloadedRange);
                          promise && promise.then((function() {
                              var _ref4, lastRenderedStartIndex, lastRenderedStopIndex, startIndex, stopIndex;
                              _ref4 = {
                                  lastRenderedStartIndex: _this2._lastRenderedStartIndex,
                                  lastRenderedStopIndex: _this2._lastRenderedStopIndex,
                                  startIndex: unloadedRange.startIndex,
                                  stopIndex: unloadedRange.stopIndex
                              }, lastRenderedStartIndex = _ref4.lastRenderedStartIndex, lastRenderedStopIndex = _ref4.lastRenderedStopIndex, 
                              startIndex = _ref4.startIndex, stopIndex = _ref4.stopIndex, startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex || _this2._registeredChild && function(component) {
                                  var currentIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, recomputeSize = "function" == typeof component.recomputeGridSize ? component.recomputeGridSize : component.recomputeRowHeights;
                                  recomputeSize ? recomputeSize.call(component, currentIndex) : component.forceUpdate();
                              }(_this2._registeredChild, _this2._lastRenderedStartIndex);
                          }));
                      }));
                  }
              }, {
                  key: "_onRowsRendered",
                  value: function(_ref) {
                      var startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
                      this._lastRenderedStartIndex = startIndex, this._lastRenderedStopIndex = stopIndex, 
                      this._doStuff(startIndex, stopIndex);
                  }
              }, {
                  key: "_doStuff",
                  value: function(startIndex, stopIndex) {
                      var _ref2, _this3 = this, _this$props = this.props, isRowLoaded = _this$props.isRowLoaded, minimumBatchSize = _this$props.minimumBatchSize, rowCount = _this$props.rowCount, threshold = _this$props.threshold, unloadedRanges = function(_ref5) {
                          for (var isRowLoaded = _ref5.isRowLoaded, minimumBatchSize = _ref5.minimumBatchSize, rowCount = _ref5.rowCount, startIndex = _ref5.startIndex, stopIndex = _ref5.stopIndex, unloadedRanges = [], rangeStartIndex = null, rangeStopIndex = null, index = startIndex; index <= stopIndex; index++) {
                              isRowLoaded({
                                  index
                              }) ? null !== rangeStopIndex && (unloadedRanges.push({
                                  startIndex: rangeStartIndex,
                                  stopIndex: rangeStopIndex
                              }), rangeStartIndex = rangeStopIndex = null) : (rangeStopIndex = index, null === rangeStartIndex && (rangeStartIndex = index));
                          }
                          if (null !== rangeStopIndex) {
                              for (var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1), _index = rangeStopIndex + 1; _index <= potentialStopIndex && !isRowLoaded({
                                  index: _index
                              }); _index++) rangeStopIndex = _index;
                              unloadedRanges.push({
                                  startIndex: rangeStartIndex,
                                  stopIndex: rangeStopIndex
                              });
                          }
                          if (unloadedRanges.length) for (var firstUnloadedRange = unloadedRanges[0]; firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0; ) {
                              var _index2 = firstUnloadedRange.startIndex - 1;
                              if (isRowLoaded({
                                  index: _index2
                              })) break;
                              firstUnloadedRange.startIndex = _index2;
                          }
                          return unloadedRanges;
                      }({
                          isRowLoaded,
                          minimumBatchSize,
                          rowCount,
                          startIndex: Math.max(0, startIndex - threshold),
                          stopIndex: Math.min(rowCount - 1, stopIndex + threshold)
                      }), squashedUnloadedRanges = (_ref2 = []).concat.apply(_ref2, _toConsumableArray(unloadedRanges.map((function(_ref3) {
                          return [ _ref3.startIndex, _ref3.stopIndex ];
                      }))));
                      this._loadMoreRowsMemoizer({
                          callback: function() {
                              _this3._loadUnloadedRanges(unloadedRanges);
                          },
                          indices: {
                              squashedUnloadedRanges
                          }
                      });
                  }
              }, {
                  key: "_registerChild",
                  value: function(registeredChild) {
                      this._registeredChild = registeredChild;
                  }
              } ]), InfiniteLoader;
          }(react.PureComponent);
          defineProperty_defineProperty(InfiniteLoader_InfiniteLoader, "defaultProps", {
              minimumBatchSize: 10,
              rowCount: 0,
              threshold: 15
          }), InfiniteLoader_InfiniteLoader.propTypes = {};
          var List_class, List_temp, List_List_List = (List_temp = List_class = function(_React$PureComponent) {
              function List() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, List);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(List)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "Grid", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_cellRenderer", (function(_ref) {
                      var parent = _ref.parent, rowIndex = _ref.rowIndex, style = _ref.style, isScrolling = _ref.isScrolling, isVisible = _ref.isVisible, key = _ref.key, rowRenderer = _this.props.rowRenderer, widthDescriptor = Object.getOwnPropertyDescriptor(style, "width");
                      return widthDescriptor && widthDescriptor.writable && (style.width = "100%"), rowRenderer({
                          index: rowIndex,
                          style,
                          isScrolling,
                          isVisible,
                          key,
                          parent
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_setRef", (function(ref) {
                      _this.Grid = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScroll", (function(_ref2) {
                      var clientHeight = _ref2.clientHeight, scrollHeight = _ref2.scrollHeight, scrollTop = _ref2.scrollTop;
                      (0, _this.props.onScroll)({
                          clientHeight,
                          scrollHeight,
                          scrollTop
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onSectionRendered", (function(_ref3) {
                      var rowOverscanStartIndex = _ref3.rowOverscanStartIndex, rowOverscanStopIndex = _ref3.rowOverscanStopIndex, rowStartIndex = _ref3.rowStartIndex, rowStopIndex = _ref3.rowStopIndex;
                      (0, _this.props.onRowsRendered)({
                          overscanStartIndex: rowOverscanStartIndex,
                          overscanStopIndex: rowOverscanStopIndex,
                          startIndex: rowStartIndex,
                          stopIndex: rowStopIndex
                      });
                  })), _this;
              }
              return _inherits(List, _React$PureComponent), _createClass(List, [ {
                  key: "forceUpdateGrid",
                  value: function() {
                      this.Grid && this.Grid.forceUpdate();
                  }
              }, {
                  key: "getOffsetForRow",
                  value: function(_ref4) {
                      var alignment = _ref4.alignment, index = _ref4.index;
                      return this.Grid ? this.Grid.getOffsetForCell({
                          alignment,
                          rowIndex: index,
                          columnIndex: 0
                      }).scrollTop : 0;
                  }
              }, {
                  key: "invalidateCellSizeAfterRender",
                  value: function(_ref5) {
                      var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex;
                      this.Grid && this.Grid.invalidateCellSizeAfterRender({
                          rowIndex,
                          columnIndex
                      });
                  }
              }, {
                  key: "measureAllRows",
                  value: function() {
                      this.Grid && this.Grid.measureAllCells();
                  }
              }, {
                  key: "recomputeGridSize",
                  value: function() {
                      var _ref6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref6$columnIndex = _ref6.columnIndex, columnIndex = void 0 === _ref6$columnIndex ? 0 : _ref6$columnIndex, _ref6$rowIndex = _ref6.rowIndex, rowIndex = void 0 === _ref6$rowIndex ? 0 : _ref6$rowIndex;
                      this.Grid && this.Grid.recomputeGridSize({
                          rowIndex,
                          columnIndex
                      });
                  }
              }, {
                  key: "recomputeRowHeights",
                  value: function() {
                      var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                      this.Grid && this.Grid.recomputeGridSize({
                          rowIndex: index,
                          columnIndex: 0
                      });
                  }
              }, {
                  key: "scrollToPosition",
                  value: function() {
                      var scrollTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                      this.Grid && this.Grid.scrollToPosition({
                          scrollTop
                      });
                  }
              }, {
                  key: "scrollToRow",
                  value: function() {
                      var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                      this.Grid && this.Grid.scrollToCell({
                          columnIndex: 0,
                          rowIndex: index
                      });
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props = this.props, className = _this$props.className, noRowsRenderer = _this$props.noRowsRenderer, scrollToIndex = _this$props.scrollToIndex, width = _this$props.width, classNames = clsx_m("ReactVirtualized__List", className);
                      return react.createElement(Grid_Grid, _extends({}, this.props, {
                          autoContainerWidth: !0,
                          cellRenderer: this._cellRenderer,
                          className: classNames,
                          columnWidth: width,
                          columnCount: 1,
                          noContentRenderer: noRowsRenderer,
                          onScroll: this._onScroll,
                          onSectionRendered: this._onSectionRendered,
                          ref: this._setRef,
                          scrollToRow: scrollToIndex
                      }));
                  }
              } ]), List;
          }(react.PureComponent), defineProperty_defineProperty(List_class, "propTypes", null), 
          List_temp);
          defineProperty_defineProperty(List_List_List, "defaultProps", {
              autoHeight: !1,
              estimatedRowSize: 30,
              onScroll: function() {},
              noRowsRenderer: function() {
                  return null;
              },
              onRowsRendered: function() {},
              overscanIndicesGetter: accessibilityOverscanIndicesGetter_defaultOverscanIndicesGetter,
              overscanRowCount: 10,
              scrollToAlignment: "auto",
              scrollToIndex: -1,
              style: {}
          });
          const binarySearchBounds = {
              ge: function(a, y, c, l, h) {
                  return "function" == typeof c ? function(a, l, h, y, c) {
                      for (var i = h + 1; l <= h; ) {
                          var m = l + h >>> 1;
                          c(a[m], y) >= 0 ? (i = m, h = m - 1) : l = m + 1;
                      }
                      return i;
                  }(a, void 0 === l ? 0 : 0 | l, void 0 === h ? a.length - 1 : 0 | h, y, c) : function(a, l, h, y) {
                      for (var i = h + 1; l <= h; ) {
                          var m = l + h >>> 1;
                          a[m] >= y ? (i = m, h = m - 1) : l = m + 1;
                      }
                      return i;
                  }(a, void 0 === c ? 0 : 0 | c, void 0 === l ? a.length - 1 : 0 | l, y);
              },
              gt: function(a, y, c, l, h) {
                  return "function" == typeof c ? function(a, l, h, y, c) {
                      for (var i = h + 1; l <= h; ) {
                          var m = l + h >>> 1;
                          c(a[m], y) > 0 ? (i = m, h = m - 1) : l = m + 1;
                      }
                      return i;
                  }(a, void 0 === l ? 0 : 0 | l, void 0 === h ? a.length - 1 : 0 | h, y, c) : function(a, l, h, y) {
                      for (var i = h + 1; l <= h; ) {
                          var m = l + h >>> 1;
                          a[m] > y ? (i = m, h = m - 1) : l = m + 1;
                      }
                      return i;
                  }(a, void 0 === c ? 0 : 0 | c, void 0 === l ? a.length - 1 : 0 | l, y);
              },
              lt: function(a, y, c, l, h) {
                  return "function" == typeof c ? function(a, l, h, y, c) {
                      for (var i = l - 1; l <= h; ) {
                          var m = l + h >>> 1;
                          c(a[m], y) < 0 ? (i = m, l = m + 1) : h = m - 1;
                      }
                      return i;
                  }(a, void 0 === l ? 0 : 0 | l, void 0 === h ? a.length - 1 : 0 | h, y, c) : function(a, l, h, y) {
                      for (var i = l - 1; l <= h; ) {
                          var m = l + h >>> 1;
                          a[m] < y ? (i = m, l = m + 1) : h = m - 1;
                      }
                      return i;
                  }(a, void 0 === c ? 0 : 0 | c, void 0 === l ? a.length - 1 : 0 | l, y);
              },
              le: function(a, y, c, l, h) {
                  return "function" == typeof c ? function(a, l, h, y, c) {
                      for (var i = l - 1; l <= h; ) {
                          var m = l + h >>> 1;
                          c(a[m], y) <= 0 ? (i = m, l = m + 1) : h = m - 1;
                      }
                      return i;
                  }(a, void 0 === l ? 0 : 0 | l, void 0 === h ? a.length - 1 : 0 | h, y, c) : function(a, l, h, y) {
                      for (var i = l - 1; l <= h; ) {
                          var m = l + h >>> 1;
                          a[m] <= y ? (i = m, l = m + 1) : h = m - 1;
                      }
                      return i;
                  }(a, void 0 === c ? 0 : 0 | c, void 0 === l ? a.length - 1 : 0 | l, y);
              },
              eq: function(a, y, c, l, h) {
                  return "function" == typeof c ? function(a, l, h, y, c) {
                      for (;l <= h; ) {
                          var m = l + h >>> 1, p = c(a[m], y);
                          if (0 === p) return m;
                          p <= 0 ? l = m + 1 : h = m - 1;
                      }
                      return -1;
                  }(a, void 0 === l ? 0 : 0 | l, void 0 === h ? a.length - 1 : 0 | h, y, c) : function(a, l, h, y) {
                      for (;l <= h; ) {
                          var m = l + h >>> 1, x = a[m];
                          if (x === y) return m;
                          x <= y ? l = m + 1 : h = m - 1;
                      }
                      return -1;
                  }(a, void 0 === c ? 0 : 0 | c, void 0 === l ? a.length - 1 : 0 | l, y);
              }
          };
          function IntervalTreeNode(mid, left, right, leftPoints, rightPoints) {
              this.mid = mid, this.left = left, this.right = right, this.leftPoints = leftPoints, 
              this.rightPoints = rightPoints, this.count = (left ? left.count : 0) + (right ? right.count : 0) + leftPoints.length;
          }
          var proto = IntervalTreeNode.prototype;
          function intervalTree_copy(a, b) {
              a.mid = b.mid, a.left = b.left, a.right = b.right, a.leftPoints = b.leftPoints, 
              a.rightPoints = b.rightPoints, a.count = b.count;
          }
          function rebuild(node, intervals) {
              var ntree = createIntervalTree(intervals);
              node.mid = ntree.mid, node.left = ntree.left, node.right = ntree.right, node.leftPoints = ntree.leftPoints, 
              node.rightPoints = ntree.rightPoints, node.count = ntree.count;
          }
          function rebuildWithInterval(node, interval) {
              var intervals = node.intervals([]);
              intervals.push(interval), rebuild(node, intervals);
          }
          function rebuildWithoutInterval(node, interval) {
              var intervals = node.intervals([]), idx = intervals.indexOf(interval);
              return idx < 0 ? 0 : (intervals.splice(idx, 1), rebuild(node, intervals), 1);
          }
          function reportLeftRange(arr, hi, cb) {
              for (var i = 0; i < arr.length && arr[i][0] <= hi; ++i) {
                  var r = cb(arr[i]);
                  if (r) return r;
              }
          }
          function reportRightRange(arr, lo, cb) {
              for (var i = arr.length - 1; i >= 0 && arr[i][1] >= lo; --i) {
                  var r = cb(arr[i]);
                  if (r) return r;
              }
          }
          function reportRange(arr, cb) {
              for (var i = 0; i < arr.length; ++i) {
                  var r = cb(arr[i]);
                  if (r) return r;
              }
          }
          function compareNumbers(a, b) {
              return a - b;
          }
          function compareBegin(a, b) {
              var d = a[0] - b[0];
              return d || a[1] - b[1];
          }
          function compareEnd(a, b) {
              var d = a[1] - b[1];
              return d || a[0] - b[0];
          }
          function createIntervalTree(intervals) {
              if (0 === intervals.length) return null;
              for (var pts = [], i = 0; i < intervals.length; ++i) pts.push(intervals[i][0], intervals[i][1]);
              pts.sort(compareNumbers);
              var mid = pts[pts.length >> 1], leftIntervals = [], rightIntervals = [], centerIntervals = [];
              for (i = 0; i < intervals.length; ++i) {
                  var s = intervals[i];
                  s[1] < mid ? leftIntervals.push(s) : mid < s[0] ? rightIntervals.push(s) : centerIntervals.push(s);
              }
              var leftPoints = centerIntervals, rightPoints = centerIntervals.slice();
              return leftPoints.sort(compareBegin), rightPoints.sort(compareEnd), new IntervalTreeNode(mid, createIntervalTree(leftIntervals), createIntervalTree(rightIntervals), leftPoints, rightPoints);
          }
          function IntervalTree(root) {
              this.root = root;
          }
          proto.intervals = function(result) {
              return result.push.apply(result, this.leftPoints), this.left && this.left.intervals(result), 
              this.right && this.right.intervals(result), result;
          }, proto.insert = function(interval) {
              var weight = this.count - this.leftPoints.length;
              if (this.count += 1, interval[1] < this.mid) this.left ? 4 * (this.left.count + 1) > 3 * (weight + 1) ? rebuildWithInterval(this, interval) : this.left.insert(interval) : this.left = createIntervalTree([ interval ]); else if (interval[0] > this.mid) this.right ? 4 * (this.right.count + 1) > 3 * (weight + 1) ? rebuildWithInterval(this, interval) : this.right.insert(interval) : this.right = createIntervalTree([ interval ]); else {
                  var l = binarySearchBounds.ge(this.leftPoints, interval, compareBegin), r = binarySearchBounds.ge(this.rightPoints, interval, compareEnd);
                  this.leftPoints.splice(l, 0, interval), this.rightPoints.splice(r, 0, interval);
              }
          }, proto.remove = function(interval) {
              var weight = this.count - this.leftPoints;
              if (interval[1] < this.mid) return this.left ? 4 * (this.right ? this.right.count : 0) > 3 * (weight - 1) ? rebuildWithoutInterval(this, interval) : 2 === (r = this.left.remove(interval)) ? (this.left = null, 
              this.count -= 1, 1) : (1 === r && (this.count -= 1), r) : 0;
              if (interval[0] > this.mid) return this.right ? 4 * (this.left ? this.left.count : 0) > 3 * (weight - 1) ? rebuildWithoutInterval(this, interval) : 2 === (r = this.right.remove(interval)) ? (this.right = null, 
              this.count -= 1, 1) : (1 === r && (this.count -= 1), r) : 0;
              if (1 === this.count) return this.leftPoints[0] === interval ? 2 : 0;
              if (1 === this.leftPoints.length && this.leftPoints[0] === interval) {
                  if (this.left && this.right) {
                      for (var p = this, n = this.left; n.right; ) p = n, n = n.right;
                      if (p === this) n.right = this.right; else {
                          var l = this.left, r = this.right;
                          p.count -= n.count, p.right = n.left, n.left = l, n.right = r;
                      }
                      intervalTree_copy(this, n), this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
                  } else this.left ? intervalTree_copy(this, this.left) : intervalTree_copy(this, this.right);
                  return 1;
              }
              for (l = binarySearchBounds.ge(this.leftPoints, interval, compareBegin); l < this.leftPoints.length && this.leftPoints[l][0] === interval[0]; ++l) if (this.leftPoints[l] === interval) {
                  this.count -= 1, this.leftPoints.splice(l, 1);
                  for (r = binarySearchBounds.ge(this.rightPoints, interval, compareEnd); r < this.rightPoints.length && this.rightPoints[r][1] === interval[1]; ++r) if (this.rightPoints[r] === interval) return this.rightPoints.splice(r, 1), 
                  1;
              }
              return 0;
          }, proto.queryPoint = function(x, cb) {
              if (x < this.mid) {
                  if (this.left) if (r = this.left.queryPoint(x, cb)) return r;
                  return reportLeftRange(this.leftPoints, x, cb);
              }
              if (x > this.mid) {
                  var r;
                  if (this.right) if (r = this.right.queryPoint(x, cb)) return r;
                  return reportRightRange(this.rightPoints, x, cb);
              }
              return reportRange(this.leftPoints, cb);
          }, proto.queryInterval = function(lo, hi, cb) {
              var r;
              if (lo < this.mid && this.left && (r = this.left.queryInterval(lo, hi, cb))) return r;
              if (hi > this.mid && this.right && (r = this.right.queryInterval(lo, hi, cb))) return r;
              return hi < this.mid ? reportLeftRange(this.leftPoints, hi, cb) : lo > this.mid ? reportRightRange(this.rightPoints, lo, cb) : reportRange(this.leftPoints, cb);
          };
          var tproto = IntervalTree.prototype;
          tproto.insert = function(interval) {
              this.root ? this.root.insert(interval) : this.root = new IntervalTreeNode(interval[0], null, null, [ interval ], [ interval ]);
          }, tproto.remove = function(interval) {
              if (this.root) {
                  var r = this.root.remove(interval);
                  return 2 === r && (this.root = null), 0 !== r;
              }
              return !1;
          }, tproto.queryPoint = function(p, cb) {
              if (this.root) return this.root.queryPoint(p, cb);
          }, tproto.queryInterval = function(lo, hi, cb) {
              if (lo <= hi && this.root) return this.root.queryInterval(lo, hi, cb);
          }, Object.defineProperty(tproto, "count", {
              get: function() {
                  return this.root ? this.root.count : 0;
              }
          }), Object.defineProperty(tproto, "intervals", {
              get: function() {
                  return this.root ? this.root.intervals([]) : [];
              }
          });
          var Masonry_class, Masonry_temp, PositionCache = function() {
              function PositionCache() {
                  var intervals;
                  _classCallCheck(this, PositionCache), defineProperty_defineProperty(this, "_columnSizeMap", {}), 
                  defineProperty_defineProperty(this, "_intervalTree", intervals && 0 !== intervals.length ? new IntervalTree(createIntervalTree(intervals)) : new IntervalTree(null)), 
                  defineProperty_defineProperty(this, "_leftMap", {});
              }
              return _createClass(PositionCache, [ {
                  key: "estimateTotalHeight",
                  value: function(cellCount, columnCount, defaultCellHeight) {
                      var unmeasuredCellCount = cellCount - this.count;
                      return this.tallestColumnSize + Math.ceil(unmeasuredCellCount / columnCount) * defaultCellHeight;
                  }
              }, {
                  key: "range",
                  value: function(scrollTop, clientHeight, renderCallback) {
                      var _this = this;
                      this._intervalTree.queryInterval(scrollTop, scrollTop + clientHeight, (function(_ref) {
                          var _ref2 = slicedToArray_slicedToArray(_ref, 3), top = _ref2[0], index = (_ref2[1], 
                          _ref2[2]);
                          return renderCallback(index, _this._leftMap[index], top);
                      }));
                  }
              }, {
                  key: "setPosition",
                  value: function(index, left, top, height) {
                      this._intervalTree.insert([ top, top + height, index ]), this._leftMap[index] = left;
                      var columnSizeMap = this._columnSizeMap, columnHeight = columnSizeMap[left];
                      columnSizeMap[left] = void 0 === columnHeight ? top + height : Math.max(columnHeight, top + height);
                  }
              }, {
                  key: "count",
                  get: function() {
                      return this._intervalTree.count;
                  }
              }, {
                  key: "shortestColumnSize",
                  get: function() {
                      var columnSizeMap = this._columnSizeMap, size = 0;
                      for (var i in columnSizeMap) {
                          var height = columnSizeMap[i];
                          size = 0 === size ? height : Math.min(size, height);
                      }
                      return size;
                  }
              }, {
                  key: "tallestColumnSize",
                  get: function() {
                      var columnSizeMap = this._columnSizeMap, size = 0;
                      for (var i in columnSizeMap) {
                          var height = columnSizeMap[i];
                          size = Math.max(size, height);
                      }
                      return size;
                  }
              } ]), PositionCache;
          }();
          function Masonry_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function Masonry_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? Masonry_ownKeys(source, !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Masonry_ownKeys(source).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          var Masonry_Masonry = (Masonry_temp = Masonry_class = function(_React$PureComponent) {
              function Masonry() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, Masonry);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Masonry)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "state", {
                      isScrolling: !1,
                      scrollTop: 0
                  }), defineProperty_defineProperty(_assertThisInitialized(_this), "_debounceResetIsScrollingId", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_invalidateOnUpdateStartIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_invalidateOnUpdateStopIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_positionCache", new PositionCache), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_startIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_startIndexMemoized", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_stopIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_stopIndexMemoized", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_debounceResetIsScrollingCallback", (function() {
                      _this.setState({
                          isScrolling: !1
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_setScrollingContainerRef", (function(ref) {
                      _this._scrollingContainer = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScroll", (function(event) {
                      var height = _this.props.height, eventScrollTop = event.currentTarget.scrollTop, scrollTop = Math.min(Math.max(0, _this._getEstimatedTotalHeight() - height), eventScrollTop);
                      eventScrollTop === scrollTop && (_this._debounceResetIsScrolling(), _this.state.scrollTop !== scrollTop && _this.setState({
                          isScrolling: !0,
                          scrollTop
                      }));
                  })), _this;
              }
              return _inherits(Masonry, _React$PureComponent), _createClass(Masonry, [ {
                  key: "clearCellPositions",
                  value: function() {
                      this._positionCache = new PositionCache, this.forceUpdate();
                  }
              }, {
                  key: "invalidateCellSizeAfterRender",
                  value: function(_ref) {
                      var index = _ref.rowIndex;
                      null === this._invalidateOnUpdateStartIndex ? (this._invalidateOnUpdateStartIndex = index, 
                      this._invalidateOnUpdateStopIndex = index) : (this._invalidateOnUpdateStartIndex = Math.min(this._invalidateOnUpdateStartIndex, index), 
                      this._invalidateOnUpdateStopIndex = Math.max(this._invalidateOnUpdateStopIndex, index));
                  }
              }, {
                  key: "recomputeCellPositions",
                  value: function() {
                      var stopIndex = this._positionCache.count - 1;
                      this._positionCache = new PositionCache, this._populatePositionCache(0, stopIndex), 
                      this.forceUpdate();
                  }
              }, {
                  key: "componentDidMount",
                  value: function() {
                      this._checkInvalidateOnUpdate(), this._invokeOnScrollCallback(), this._invokeOnCellsRenderedCallback();
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function(prevProps, prevState) {
                      this._checkInvalidateOnUpdate(), this._invokeOnScrollCallback(), this._invokeOnCellsRenderedCallback(), 
                      this.props.scrollTop !== prevProps.scrollTop && this._debounceResetIsScrolling();
                  }
              }, {
                  key: "componentWillUnmount",
                  value: function() {
                      this._debounceResetIsScrollingId && cancelAnimationTimeout(this._debounceResetIsScrollingId);
                  }
              }, {
                  key: "render",
                  value: function() {
                      var stopIndex, _this2 = this, _this$props = this.props, autoHeight = _this$props.autoHeight, cellCount = _this$props.cellCount, cellMeasurerCache = _this$props.cellMeasurerCache, cellRenderer = _this$props.cellRenderer, className = _this$props.className, height = _this$props.height, id = _this$props.id, keyMapper = _this$props.keyMapper, overscanByPixels = _this$props.overscanByPixels, role = _this$props.role, style = _this$props.style, tabIndex = _this$props.tabIndex, width = _this$props.width, rowDirection = _this$props.rowDirection, _this$state = this.state, isScrolling = _this$state.isScrolling, scrollTop = _this$state.scrollTop, children = [], estimateTotalHeight = this._getEstimatedTotalHeight(), shortestColumnSize = this._positionCache.shortestColumnSize, measuredCellCount = this._positionCache.count, startIndex = 0;
                      if (this._positionCache.range(Math.max(0, scrollTop - overscanByPixels), height + 2 * overscanByPixels, (function(index, left, top) {
                          var _style;
                          void 0 === stopIndex ? (startIndex = index, stopIndex = index) : (startIndex = Math.min(startIndex, index), 
                          stopIndex = Math.max(stopIndex, index)), children.push(cellRenderer({
                              index,
                              isScrolling,
                              key: keyMapper(index),
                              parent: _this2,
                              style: (_style = {
                                  height: cellMeasurerCache.getHeight(index)
                              }, defineProperty_defineProperty(_style, "ltr" === rowDirection ? "left" : "right", left), 
                              defineProperty_defineProperty(_style, "position", "absolute"), defineProperty_defineProperty(_style, "top", top), 
                              defineProperty_defineProperty(_style, "width", cellMeasurerCache.getWidth(index)), 
                              _style)
                          }));
                      })), shortestColumnSize < scrollTop + height + overscanByPixels && measuredCellCount < cellCount) for (var batchSize = Math.min(cellCount - measuredCellCount, Math.ceil((scrollTop + height + overscanByPixels - shortestColumnSize) / cellMeasurerCache.defaultHeight * width / cellMeasurerCache.defaultWidth)), _index = measuredCellCount; _index < measuredCellCount + batchSize; _index++) stopIndex = _index, 
                      children.push(cellRenderer({
                          index: _index,
                          isScrolling,
                          key: keyMapper(_index),
                          parent: this,
                          style: {
                              width: cellMeasurerCache.getWidth(_index)
                          }
                      }));
                      return this._startIndex = startIndex, this._stopIndex = stopIndex, react.createElement("div", {
                          ref: this._setScrollingContainerRef,
                          "aria-label": this.props["aria-label"],
                          className: clsx_m("ReactVirtualized__Masonry", className),
                          id,
                          onScroll: this._onScroll,
                          role,
                          style: Masonry_objectSpread({
                              boxSizing: "border-box",
                              direction: "ltr",
                              height: autoHeight ? "auto" : height,
                              overflowX: "hidden",
                              overflowY: estimateTotalHeight < height ? "hidden" : "auto",
                              position: "relative",
                              width,
                              WebkitOverflowScrolling: "touch",
                              willChange: "transform"
                          }, style),
                          tabIndex
                      }, react.createElement("div", {
                          className: "ReactVirtualized__Masonry__innerScrollContainer",
                          style: {
                              width: "100%",
                              height: estimateTotalHeight,
                              maxWidth: "100%",
                              maxHeight: estimateTotalHeight,
                              overflow: "hidden",
                              pointerEvents: isScrolling ? "none" : "",
                              position: "relative"
                          }
                      }, children));
                  }
              }, {
                  key: "_checkInvalidateOnUpdate",
                  value: function() {
                      if ("number" == typeof this._invalidateOnUpdateStartIndex) {
                          var startIndex = this._invalidateOnUpdateStartIndex, stopIndex = this._invalidateOnUpdateStopIndex;
                          this._invalidateOnUpdateStartIndex = null, this._invalidateOnUpdateStopIndex = null, 
                          this._populatePositionCache(startIndex, stopIndex), this.forceUpdate();
                      }
                  }
              }, {
                  key: "_debounceResetIsScrolling",
                  value: function() {
                      var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
                      this._debounceResetIsScrollingId && cancelAnimationTimeout(this._debounceResetIsScrollingId), 
                      this._debounceResetIsScrollingId = requestAnimationTimeout(this._debounceResetIsScrollingCallback, scrollingResetTimeInterval);
                  }
              }, {
                  key: "_getEstimatedTotalHeight",
                  value: function() {
                      var _this$props2 = this.props, cellCount = _this$props2.cellCount, cellMeasurerCache = _this$props2.cellMeasurerCache, width = _this$props2.width, estimatedColumnCount = Math.max(1, Math.floor(width / cellMeasurerCache.defaultWidth));
                      return this._positionCache.estimateTotalHeight(cellCount, estimatedColumnCount, cellMeasurerCache.defaultHeight);
                  }
              }, {
                  key: "_invokeOnScrollCallback",
                  value: function() {
                      var _this$props3 = this.props, height = _this$props3.height, onScroll = _this$props3.onScroll, scrollTop = this.state.scrollTop;
                      this._onScrollMemoized !== scrollTop && (onScroll({
                          clientHeight: height,
                          scrollHeight: this._getEstimatedTotalHeight(),
                          scrollTop
                      }), this._onScrollMemoized = scrollTop);
                  }
              }, {
                  key: "_invokeOnCellsRenderedCallback",
                  value: function() {
                      this._startIndexMemoized === this._startIndex && this._stopIndexMemoized === this._stopIndex || ((0, 
                      this.props.onCellsRendered)({
                          startIndex: this._startIndex,
                          stopIndex: this._stopIndex
                      }), this._startIndexMemoized = this._startIndex, this._stopIndexMemoized = this._stopIndex);
                  }
              }, {
                  key: "_populatePositionCache",
                  value: function(startIndex, stopIndex) {
                      for (var _this$props4 = this.props, cellMeasurerCache = _this$props4.cellMeasurerCache, cellPositioner = _this$props4.cellPositioner, _index2 = startIndex; _index2 <= stopIndex; _index2++) {
                          var _cellPositioner = cellPositioner(_index2), left = _cellPositioner.left, top = _cellPositioner.top;
                          this._positionCache.setPosition(_index2, left, top, cellMeasurerCache.getHeight(_index2));
                      }
                  }
              } ], [ {
                  key: "getDerivedStateFromProps",
                  value: function(nextProps, prevState) {
                      return void 0 !== nextProps.scrollTop && prevState.scrollTop !== nextProps.scrollTop ? {
                          isScrolling: !0,
                          scrollTop: nextProps.scrollTop
                      } : null;
                  }
              } ]), Masonry;
          }(react.PureComponent), defineProperty_defineProperty(Masonry_class, "propTypes", null), 
          Masonry_temp);
          function Masonry_noop() {}
          defineProperty_defineProperty(Masonry_Masonry, "defaultProps", {
              autoHeight: !1,
              keyMapper: function(value) {
                  return value;
              },
              onCellsRendered: Masonry_noop,
              onScroll: Masonry_noop,
              overscanByPixels: 20,
              role: "grid",
              scrollingResetTimeInterval: 150,
              style: {},
              tabIndex: 0,
              rowDirection: "ltr"
          });
          polyfill(Masonry_Masonry);
          var CellMeasurerCacheDecorator = function() {
              function CellMeasurerCacheDecorator() {
                  var _this = this, params = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                  _classCallCheck(this, CellMeasurerCacheDecorator), defineProperty_defineProperty(this, "_cellMeasurerCache", void 0), 
                  defineProperty_defineProperty(this, "_columnIndexOffset", void 0), defineProperty_defineProperty(this, "_rowIndexOffset", void 0), 
                  defineProperty_defineProperty(this, "columnWidth", (function(_ref) {
                      var index = _ref.index;
                      _this._cellMeasurerCache.columnWidth({
                          index: index + _this._columnIndexOffset
                      });
                  })), defineProperty_defineProperty(this, "rowHeight", (function(_ref2) {
                      var index = _ref2.index;
                      _this._cellMeasurerCache.rowHeight({
                          index: index + _this._rowIndexOffset
                      });
                  }));
                  var cellMeasurerCache = params.cellMeasurerCache, _params$columnIndexOf = params.columnIndexOffset, columnIndexOffset = void 0 === _params$columnIndexOf ? 0 : _params$columnIndexOf, _params$rowIndexOffse = params.rowIndexOffset, rowIndexOffset = void 0 === _params$rowIndexOffse ? 0 : _params$rowIndexOffse;
                  this._cellMeasurerCache = cellMeasurerCache, this._columnIndexOffset = columnIndexOffset, 
                  this._rowIndexOffset = rowIndexOffset;
              }
              return _createClass(CellMeasurerCacheDecorator, [ {
                  key: "clear",
                  value: function(rowIndex, columnIndex) {
                      this._cellMeasurerCache.clear(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
                  }
              }, {
                  key: "clearAll",
                  value: function() {
                      this._cellMeasurerCache.clearAll();
                  }
              }, {
                  key: "hasFixedHeight",
                  value: function() {
                      return this._cellMeasurerCache.hasFixedHeight();
                  }
              }, {
                  key: "hasFixedWidth",
                  value: function() {
                      return this._cellMeasurerCache.hasFixedWidth();
                  }
              }, {
                  key: "getHeight",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                      return this._cellMeasurerCache.getHeight(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
                  }
              }, {
                  key: "getWidth",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                      return this._cellMeasurerCache.getWidth(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
                  }
              }, {
                  key: "has",
                  value: function(rowIndex) {
                      var columnIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                      return this._cellMeasurerCache.has(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset);
                  }
              }, {
                  key: "set",
                  value: function(rowIndex, columnIndex, width, height) {
                      this._cellMeasurerCache.set(rowIndex + this._rowIndexOffset, columnIndex + this._columnIndexOffset, width, height);
                  }
              }, {
                  key: "defaultHeight",
                  get: function() {
                      return this._cellMeasurerCache.defaultHeight;
                  }
              }, {
                  key: "defaultWidth",
                  get: function() {
                      return this._cellMeasurerCache.defaultWidth;
                  }
              } ]), CellMeasurerCacheDecorator;
          }();
          function MultiGrid_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function MultiGrid_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? MultiGrid_ownKeys(source, !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : MultiGrid_ownKeys(source).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          var MultiGrid_MultiGrid = function(_React$PureComponent) {
              function MultiGrid(props, context) {
                  var _this;
                  _classCallCheck(this, MultiGrid), defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, _getPrototypeOf(MultiGrid).call(this, props, context))), "state", {
                      scrollLeft: 0,
                      scrollTop: 0,
                      scrollbarSize: 0,
                      showHorizontalScrollbar: !1,
                      showVerticalScrollbar: !1
                  }), defineProperty_defineProperty(_assertThisInitialized(_this), "_deferredInvalidateColumnIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_deferredInvalidateRowIndex", null), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_bottomLeftGridRef", (function(ref) {
                      _this._bottomLeftGrid = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_bottomRightGridRef", (function(ref) {
                      _this._bottomRightGrid = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_cellRendererBottomLeftGrid", (function(_ref) {
                      var rowIndex = _ref.rowIndex, rest = objectWithoutProperties_objectWithoutProperties(_ref, [ "rowIndex" ]), _this$props = _this.props, cellRenderer = _this$props.cellRenderer, fixedRowCount = _this$props.fixedRowCount;
                      return rowIndex === _this$props.rowCount - fixedRowCount ? react.createElement("div", {
                          key: rest.key,
                          style: MultiGrid_objectSpread({}, rest.style, {
                              height: 20
                          })
                      }) : cellRenderer(MultiGrid_objectSpread({}, rest, {
                          parent: _assertThisInitialized(_this),
                          rowIndex: rowIndex + fixedRowCount
                      }));
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_cellRendererBottomRightGrid", (function(_ref2) {
                      var columnIndex = _ref2.columnIndex, rowIndex = _ref2.rowIndex, rest = objectWithoutProperties_objectWithoutProperties(_ref2, [ "columnIndex", "rowIndex" ]), _this$props2 = _this.props, cellRenderer = _this$props2.cellRenderer, fixedColumnCount = _this$props2.fixedColumnCount, fixedRowCount = _this$props2.fixedRowCount;
                      return cellRenderer(MultiGrid_objectSpread({}, rest, {
                          columnIndex: columnIndex + fixedColumnCount,
                          parent: _assertThisInitialized(_this),
                          rowIndex: rowIndex + fixedRowCount
                      }));
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_cellRendererTopRightGrid", (function(_ref3) {
                      var columnIndex = _ref3.columnIndex, rest = objectWithoutProperties_objectWithoutProperties(_ref3, [ "columnIndex" ]), _this$props3 = _this.props, cellRenderer = _this$props3.cellRenderer, columnCount = _this$props3.columnCount, fixedColumnCount = _this$props3.fixedColumnCount;
                      return columnIndex === columnCount - fixedColumnCount ? react.createElement("div", {
                          key: rest.key,
                          style: MultiGrid_objectSpread({}, rest.style, {
                              width: 20
                          })
                      }) : cellRenderer(MultiGrid_objectSpread({}, rest, {
                          columnIndex: columnIndex + fixedColumnCount,
                          parent: _assertThisInitialized(_this)
                      }));
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_columnWidthRightGrid", (function(_ref4) {
                      var index = _ref4.index, _this$props4 = _this.props, columnCount = _this$props4.columnCount, fixedColumnCount = _this$props4.fixedColumnCount, columnWidth = _this$props4.columnWidth, _this$state = _this.state, scrollbarSize = _this$state.scrollbarSize;
                      return _this$state.showHorizontalScrollbar && index === columnCount - fixedColumnCount ? scrollbarSize : "function" == typeof columnWidth ? columnWidth({
                          index: index + fixedColumnCount
                      }) : columnWidth;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScroll", (function(scrollInfo) {
                      var scrollLeft = scrollInfo.scrollLeft, scrollTop = scrollInfo.scrollTop;
                      _this.setState({
                          scrollLeft,
                          scrollTop
                      });
                      var onScroll = _this.props.onScroll;
                      onScroll && onScroll(scrollInfo);
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScrollbarPresenceChange", (function(_ref5) {
                      var horizontal = _ref5.horizontal, size = _ref5.size, vertical = _ref5.vertical, _this$state2 = _this.state, showHorizontalScrollbar = _this$state2.showHorizontalScrollbar, showVerticalScrollbar = _this$state2.showVerticalScrollbar;
                      if (horizontal !== showHorizontalScrollbar || vertical !== showVerticalScrollbar) {
                          _this.setState({
                              scrollbarSize: size,
                              showHorizontalScrollbar: horizontal,
                              showVerticalScrollbar: vertical
                          });
                          var onScrollbarPresenceChange = _this.props.onScrollbarPresenceChange;
                          "function" == typeof onScrollbarPresenceChange && onScrollbarPresenceChange({
                              horizontal,
                              size,
                              vertical
                          });
                      }
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScrollLeft", (function(scrollInfo) {
                      var scrollLeft = scrollInfo.scrollLeft;
                      _this._onScroll({
                          scrollLeft,
                          scrollTop: _this.state.scrollTop
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onScrollTop", (function(scrollInfo) {
                      var scrollTop = scrollInfo.scrollTop;
                      _this._onScroll({
                          scrollTop,
                          scrollLeft: _this.state.scrollLeft
                      });
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_rowHeightBottomGrid", (function(_ref6) {
                      var index = _ref6.index, _this$props5 = _this.props, fixedRowCount = _this$props5.fixedRowCount, rowCount = _this$props5.rowCount, rowHeight = _this$props5.rowHeight, _this$state3 = _this.state, scrollbarSize = _this$state3.scrollbarSize;
                      return _this$state3.showVerticalScrollbar && index === rowCount - fixedRowCount ? scrollbarSize : "function" == typeof rowHeight ? rowHeight({
                          index: index + fixedRowCount
                      }) : rowHeight;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_topLeftGridRef", (function(ref) {
                      _this._topLeftGrid = ref;
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_topRightGridRef", (function(ref) {
                      _this._topRightGrid = ref;
                  }));
                  var deferredMeasurementCache = props.deferredMeasurementCache, _fixedColumnCount = props.fixedColumnCount, _fixedRowCount = props.fixedRowCount;
                  return _this._maybeCalculateCachedStyles(!0), deferredMeasurementCache && (_this._deferredMeasurementCacheBottomLeftGrid = _fixedRowCount > 0 ? new CellMeasurerCacheDecorator({
                      cellMeasurerCache: deferredMeasurementCache,
                      columnIndexOffset: 0,
                      rowIndexOffset: _fixedRowCount
                  }) : deferredMeasurementCache, _this._deferredMeasurementCacheBottomRightGrid = _fixedColumnCount > 0 || _fixedRowCount > 0 ? new CellMeasurerCacheDecorator({
                      cellMeasurerCache: deferredMeasurementCache,
                      columnIndexOffset: _fixedColumnCount,
                      rowIndexOffset: _fixedRowCount
                  }) : deferredMeasurementCache, _this._deferredMeasurementCacheTopRightGrid = _fixedColumnCount > 0 ? new CellMeasurerCacheDecorator({
                      cellMeasurerCache: deferredMeasurementCache,
                      columnIndexOffset: _fixedColumnCount,
                      rowIndexOffset: 0
                  }) : deferredMeasurementCache), _this;
              }
              return _inherits(MultiGrid, _React$PureComponent), _createClass(MultiGrid, [ {
                  key: "forceUpdateGrids",
                  value: function() {
                      this._bottomLeftGrid && this._bottomLeftGrid.forceUpdate(), this._bottomRightGrid && this._bottomRightGrid.forceUpdate(), 
                      this._topLeftGrid && this._topLeftGrid.forceUpdate(), this._topRightGrid && this._topRightGrid.forceUpdate();
                  }
              }, {
                  key: "invalidateCellSizeAfterRender",
                  value: function() {
                      var _ref7 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref7$columnIndex = _ref7.columnIndex, columnIndex = void 0 === _ref7$columnIndex ? 0 : _ref7$columnIndex, _ref7$rowIndex = _ref7.rowIndex, rowIndex = void 0 === _ref7$rowIndex ? 0 : _ref7$rowIndex;
                      this._deferredInvalidateColumnIndex = "number" == typeof this._deferredInvalidateColumnIndex ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex, 
                      this._deferredInvalidateRowIndex = "number" == typeof this._deferredInvalidateRowIndex ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
                  }
              }, {
                  key: "measureAllCells",
                  value: function() {
                      this._bottomLeftGrid && this._bottomLeftGrid.measureAllCells(), this._bottomRightGrid && this._bottomRightGrid.measureAllCells(), 
                      this._topLeftGrid && this._topLeftGrid.measureAllCells(), this._topRightGrid && this._topRightGrid.measureAllCells();
                  }
              }, {
                  key: "recomputeGridSize",
                  value: function() {
                      var _ref8 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref8$columnIndex = _ref8.columnIndex, columnIndex = void 0 === _ref8$columnIndex ? 0 : _ref8$columnIndex, _ref8$rowIndex = _ref8.rowIndex, rowIndex = void 0 === _ref8$rowIndex ? 0 : _ref8$rowIndex, _this$props6 = this.props, fixedColumnCount = _this$props6.fixedColumnCount, fixedRowCount = _this$props6.fixedRowCount, adjustedColumnIndex = Math.max(0, columnIndex - fixedColumnCount), adjustedRowIndex = Math.max(0, rowIndex - fixedRowCount);
                      this._bottomLeftGrid && this._bottomLeftGrid.recomputeGridSize({
                          columnIndex,
                          rowIndex: adjustedRowIndex
                      }), this._bottomRightGrid && this._bottomRightGrid.recomputeGridSize({
                          columnIndex: adjustedColumnIndex,
                          rowIndex: adjustedRowIndex
                      }), this._topLeftGrid && this._topLeftGrid.recomputeGridSize({
                          columnIndex,
                          rowIndex
                      }), this._topRightGrid && this._topRightGrid.recomputeGridSize({
                          columnIndex: adjustedColumnIndex,
                          rowIndex
                      }), this._leftGridWidth = null, this._topGridHeight = null, this._maybeCalculateCachedStyles(!0);
                  }
              }, {
                  key: "componentDidMount",
                  value: function() {
                      var _this$props7 = this.props, scrollLeft = _this$props7.scrollLeft, scrollTop = _this$props7.scrollTop;
                      if (scrollLeft > 0 || scrollTop > 0) {
                          var newState = {};
                          scrollLeft > 0 && (newState.scrollLeft = scrollLeft), scrollTop > 0 && (newState.scrollTop = scrollTop), 
                          this.setState(newState);
                      }
                      this._handleInvalidatedGridSize();
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function() {
                      this._handleInvalidatedGridSize();
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this$props8 = this.props, onScroll = _this$props8.onScroll, onSectionRendered = _this$props8.onSectionRendered, scrollToColumn = (_this$props8.onScrollbarPresenceChange, 
                      _this$props8.scrollLeft, _this$props8.scrollToColumn), scrollToRow = (_this$props8.scrollTop, 
                      _this$props8.scrollToRow), rest = objectWithoutProperties_objectWithoutProperties(_this$props8, [ "onScroll", "onSectionRendered", "onScrollbarPresenceChange", "scrollLeft", "scrollToColumn", "scrollTop", "scrollToRow" ]);
                      if (this._prepareForRender(), 0 === this.props.width || 0 === this.props.height) return null;
                      var _this$state4 = this.state, scrollLeft = _this$state4.scrollLeft, scrollTop = _this$state4.scrollTop;
                      return react.createElement("div", {
                          style: this._containerOuterStyle
                      }, react.createElement("div", {
                          style: this._containerTopStyle
                      }, this._renderTopLeftGrid(rest), this._renderTopRightGrid(MultiGrid_objectSpread({}, rest, {
                          onScroll,
                          scrollLeft
                      }))), react.createElement("div", {
                          style: this._containerBottomStyle
                      }, this._renderBottomLeftGrid(MultiGrid_objectSpread({}, rest, {
                          onScroll,
                          scrollTop
                      })), this._renderBottomRightGrid(MultiGrid_objectSpread({}, rest, {
                          onScroll,
                          onSectionRendered,
                          scrollLeft,
                          scrollToColumn,
                          scrollToRow,
                          scrollTop
                      }))));
                  }
              }, {
                  key: "_getBottomGridHeight",
                  value: function(props) {
                      return props.height - this._getTopGridHeight(props);
                  }
              }, {
                  key: "_getLeftGridWidth",
                  value: function(props) {
                      var fixedColumnCount = props.fixedColumnCount, columnWidth = props.columnWidth;
                      if (null == this._leftGridWidth) if ("function" == typeof columnWidth) {
                          for (var leftGridWidth = 0, index = 0; index < fixedColumnCount; index++) leftGridWidth += columnWidth({
                              index
                          });
                          this._leftGridWidth = leftGridWidth;
                      } else this._leftGridWidth = columnWidth * fixedColumnCount;
                      return this._leftGridWidth;
                  }
              }, {
                  key: "_getRightGridWidth",
                  value: function(props) {
                      return props.width - this._getLeftGridWidth(props);
                  }
              }, {
                  key: "_getTopGridHeight",
                  value: function(props) {
                      var fixedRowCount = props.fixedRowCount, rowHeight = props.rowHeight;
                      if (null == this._topGridHeight) if ("function" == typeof rowHeight) {
                          for (var topGridHeight = 0, index = 0; index < fixedRowCount; index++) topGridHeight += rowHeight({
                              index
                          });
                          this._topGridHeight = topGridHeight;
                      } else this._topGridHeight = rowHeight * fixedRowCount;
                      return this._topGridHeight;
                  }
              }, {
                  key: "_handleInvalidatedGridSize",
                  value: function() {
                      if ("number" == typeof this._deferredInvalidateColumnIndex) {
                          var columnIndex = this._deferredInvalidateColumnIndex, rowIndex = this._deferredInvalidateRowIndex;
                          this._deferredInvalidateColumnIndex = null, this._deferredInvalidateRowIndex = null, 
                          this.recomputeGridSize({
                              columnIndex,
                              rowIndex
                          }), this.forceUpdate();
                      }
                  }
              }, {
                  key: "_maybeCalculateCachedStyles",
                  value: function(resetAll) {
                      var _this$props9 = this.props, columnWidth = _this$props9.columnWidth, enableFixedColumnScroll = _this$props9.enableFixedColumnScroll, enableFixedRowScroll = _this$props9.enableFixedRowScroll, height = _this$props9.height, fixedColumnCount = _this$props9.fixedColumnCount, fixedRowCount = _this$props9.fixedRowCount, rowHeight = _this$props9.rowHeight, style = _this$props9.style, styleBottomLeftGrid = _this$props9.styleBottomLeftGrid, styleBottomRightGrid = _this$props9.styleBottomRightGrid, styleTopLeftGrid = _this$props9.styleTopLeftGrid, styleTopRightGrid = _this$props9.styleTopRightGrid, width = _this$props9.width, sizeChange = resetAll || height !== this._lastRenderedHeight || width !== this._lastRenderedWidth, leftSizeChange = resetAll || columnWidth !== this._lastRenderedColumnWidth || fixedColumnCount !== this._lastRenderedFixedColumnCount, topSizeChange = resetAll || fixedRowCount !== this._lastRenderedFixedRowCount || rowHeight !== this._lastRenderedRowHeight;
                      (resetAll || sizeChange || style !== this._lastRenderedStyle) && (this._containerOuterStyle = MultiGrid_objectSpread({
                          height,
                          overflow: "visible",
                          width
                      }, style)), (resetAll || sizeChange || topSizeChange) && (this._containerTopStyle = {
                          height: this._getTopGridHeight(this.props),
                          position: "relative",
                          width
                      }, this._containerBottomStyle = {
                          height: height - this._getTopGridHeight(this.props),
                          overflow: "visible",
                          position: "relative",
                          width
                      }), (resetAll || styleBottomLeftGrid !== this._lastRenderedStyleBottomLeftGrid) && (this._bottomLeftGridStyle = MultiGrid_objectSpread({
                          left: 0,
                          overflowX: "hidden",
                          overflowY: enableFixedColumnScroll ? "auto" : "hidden",
                          position: "absolute"
                      }, styleBottomLeftGrid)), (resetAll || leftSizeChange || styleBottomRightGrid !== this._lastRenderedStyleBottomRightGrid) && (this._bottomRightGridStyle = MultiGrid_objectSpread({
                          left: this._getLeftGridWidth(this.props),
                          position: "absolute"
                      }, styleBottomRightGrid)), (resetAll || styleTopLeftGrid !== this._lastRenderedStyleTopLeftGrid) && (this._topLeftGridStyle = MultiGrid_objectSpread({
                          left: 0,
                          overflowX: "hidden",
                          overflowY: "hidden",
                          position: "absolute",
                          top: 0
                      }, styleTopLeftGrid)), (resetAll || leftSizeChange || styleTopRightGrid !== this._lastRenderedStyleTopRightGrid) && (this._topRightGridStyle = MultiGrid_objectSpread({
                          left: this._getLeftGridWidth(this.props),
                          overflowX: enableFixedRowScroll ? "auto" : "hidden",
                          overflowY: "hidden",
                          position: "absolute",
                          top: 0
                      }, styleTopRightGrid)), this._lastRenderedColumnWidth = columnWidth, this._lastRenderedFixedColumnCount = fixedColumnCount, 
                      this._lastRenderedFixedRowCount = fixedRowCount, this._lastRenderedHeight = height, 
                      this._lastRenderedRowHeight = rowHeight, this._lastRenderedStyle = style, this._lastRenderedStyleBottomLeftGrid = styleBottomLeftGrid, 
                      this._lastRenderedStyleBottomRightGrid = styleBottomRightGrid, this._lastRenderedStyleTopLeftGrid = styleTopLeftGrid, 
                      this._lastRenderedStyleTopRightGrid = styleTopRightGrid, this._lastRenderedWidth = width;
                  }
              }, {
                  key: "_prepareForRender",
                  value: function() {
                      this._lastRenderedColumnWidth === this.props.columnWidth && this._lastRenderedFixedColumnCount === this.props.fixedColumnCount || (this._leftGridWidth = null), 
                      this._lastRenderedFixedRowCount === this.props.fixedRowCount && this._lastRenderedRowHeight === this.props.rowHeight || (this._topGridHeight = null), 
                      this._maybeCalculateCachedStyles(), this._lastRenderedColumnWidth = this.props.columnWidth, 
                      this._lastRenderedFixedColumnCount = this.props.fixedColumnCount, this._lastRenderedFixedRowCount = this.props.fixedRowCount, 
                      this._lastRenderedRowHeight = this.props.rowHeight;
                  }
              }, {
                  key: "_renderBottomLeftGrid",
                  value: function(props) {
                      var enableFixedColumnScroll = props.enableFixedColumnScroll, fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount, rowCount = props.rowCount, hideBottomLeftGridScrollbar = props.hideBottomLeftGridScrollbar, showVerticalScrollbar = this.state.showVerticalScrollbar;
                      if (!fixedColumnCount) return null;
                      var additionalRowCount = showVerticalScrollbar ? 1 : 0, height = this._getBottomGridHeight(props), width = this._getLeftGridWidth(props), scrollbarSize = this.state.showVerticalScrollbar ? this.state.scrollbarSize : 0, gridWidth = hideBottomLeftGridScrollbar ? width + scrollbarSize : width, bottomLeftGrid = react.createElement(Grid_Grid, _extends({}, props, {
                          cellRenderer: this._cellRendererBottomLeftGrid,
                          className: this.props.classNameBottomLeftGrid,
                          columnCount: fixedColumnCount,
                          deferredMeasurementCache: this._deferredMeasurementCacheBottomLeftGrid,
                          height,
                          onScroll: enableFixedColumnScroll ? this._onScrollTop : void 0,
                          ref: this._bottomLeftGridRef,
                          rowCount: Math.max(0, rowCount - fixedRowCount) + additionalRowCount,
                          rowHeight: this._rowHeightBottomGrid,
                          style: this._bottomLeftGridStyle,
                          tabIndex: null,
                          width: gridWidth
                      }));
                      return hideBottomLeftGridScrollbar ? react.createElement("div", {
                          className: "BottomLeftGrid_ScrollWrapper",
                          style: MultiGrid_objectSpread({}, this._bottomLeftGridStyle, {
                              height,
                              width,
                              overflowY: "hidden"
                          })
                      }, bottomLeftGrid) : bottomLeftGrid;
                  }
              }, {
                  key: "_renderBottomRightGrid",
                  value: function(props) {
                      var columnCount = props.columnCount, fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount, rowCount = props.rowCount, scrollToColumn = props.scrollToColumn, scrollToRow = props.scrollToRow;
                      return react.createElement(Grid_Grid, _extends({}, props, {
                          cellRenderer: this._cellRendererBottomRightGrid,
                          className: this.props.classNameBottomRightGrid,
                          columnCount: Math.max(0, columnCount - fixedColumnCount),
                          columnWidth: this._columnWidthRightGrid,
                          deferredMeasurementCache: this._deferredMeasurementCacheBottomRightGrid,
                          height: this._getBottomGridHeight(props),
                          onScroll: this._onScroll,
                          onScrollbarPresenceChange: this._onScrollbarPresenceChange,
                          ref: this._bottomRightGridRef,
                          rowCount: Math.max(0, rowCount - fixedRowCount),
                          rowHeight: this._rowHeightBottomGrid,
                          scrollToColumn: scrollToColumn - fixedColumnCount,
                          scrollToRow: scrollToRow - fixedRowCount,
                          style: this._bottomRightGridStyle,
                          width: this._getRightGridWidth(props)
                      }));
                  }
              }, {
                  key: "_renderTopLeftGrid",
                  value: function(props) {
                      var fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount;
                      return fixedColumnCount && fixedRowCount ? react.createElement(Grid_Grid, _extends({}, props, {
                          className: this.props.classNameTopLeftGrid,
                          columnCount: fixedColumnCount,
                          height: this._getTopGridHeight(props),
                          ref: this._topLeftGridRef,
                          rowCount: fixedRowCount,
                          style: this._topLeftGridStyle,
                          tabIndex: null,
                          width: this._getLeftGridWidth(props)
                      })) : null;
                  }
              }, {
                  key: "_renderTopRightGrid",
                  value: function(props) {
                      var columnCount = props.columnCount, enableFixedRowScroll = props.enableFixedRowScroll, fixedColumnCount = props.fixedColumnCount, fixedRowCount = props.fixedRowCount, scrollLeft = props.scrollLeft, hideTopRightGridScrollbar = props.hideTopRightGridScrollbar, _this$state5 = this.state, showHorizontalScrollbar = _this$state5.showHorizontalScrollbar, scrollbarSize = _this$state5.scrollbarSize;
                      if (!fixedRowCount) return null;
                      var additionalColumnCount = showHorizontalScrollbar ? 1 : 0, height = this._getTopGridHeight(props), width = this._getRightGridWidth(props), additionalHeight = showHorizontalScrollbar ? scrollbarSize : 0, gridHeight = height, style = this._topRightGridStyle;
                      hideTopRightGridScrollbar && (gridHeight = height + additionalHeight, style = MultiGrid_objectSpread({}, this._topRightGridStyle, {
                          left: 0
                      }));
                      var topRightGrid = react.createElement(Grid_Grid, _extends({}, props, {
                          cellRenderer: this._cellRendererTopRightGrid,
                          className: this.props.classNameTopRightGrid,
                          columnCount: Math.max(0, columnCount - fixedColumnCount) + additionalColumnCount,
                          columnWidth: this._columnWidthRightGrid,
                          deferredMeasurementCache: this._deferredMeasurementCacheTopRightGrid,
                          height: gridHeight,
                          onScroll: enableFixedRowScroll ? this._onScrollLeft : void 0,
                          ref: this._topRightGridRef,
                          rowCount: fixedRowCount,
                          scrollLeft,
                          style,
                          tabIndex: null,
                          width
                      }));
                      return hideTopRightGridScrollbar ? react.createElement("div", {
                          className: "TopRightGrid_ScrollWrapper",
                          style: MultiGrid_objectSpread({}, this._topRightGridStyle, {
                              height,
                              width,
                              overflowX: "hidden"
                          })
                      }, topRightGrid) : topRightGrid;
                  }
              } ], [ {
                  key: "getDerivedStateFromProps",
                  value: function(nextProps, prevState) {
                      return nextProps.scrollLeft !== prevState.scrollLeft || nextProps.scrollTop !== prevState.scrollTop ? {
                          scrollLeft: null != nextProps.scrollLeft && nextProps.scrollLeft >= 0 ? nextProps.scrollLeft : prevState.scrollLeft,
                          scrollTop: null != nextProps.scrollTop && nextProps.scrollTop >= 0 ? nextProps.scrollTop : prevState.scrollTop
                      } : null;
                  }
              } ]), MultiGrid;
          }(react.PureComponent);
          defineProperty_defineProperty(MultiGrid_MultiGrid, "defaultProps", {
              classNameBottomLeftGrid: "",
              classNameBottomRightGrid: "",
              classNameTopLeftGrid: "",
              classNameTopRightGrid: "",
              enableFixedColumnScroll: !1,
              enableFixedRowScroll: !1,
              fixedColumnCount: 0,
              fixedRowCount: 0,
              scrollToColumn: -1,
              scrollToRow: -1,
              style: {},
              styleBottomLeftGrid: {},
              styleBottomRightGrid: {},
              styleTopLeftGrid: {},
              styleTopRightGrid: {},
              hideTopRightGridScrollbar: !1,
              hideBottomLeftGridScrollbar: !1
          }), MultiGrid_MultiGrid.propTypes = {}, polyfill(MultiGrid_MultiGrid);
          var ScrollSync_ScrollSync = function(_React$PureComponent) {
              function ScrollSync(props, context) {
                  var _this;
                  return _classCallCheck(this, ScrollSync), (_this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollSync).call(this, props, context))).state = {
                      clientHeight: 0,
                      clientWidth: 0,
                      scrollHeight: 0,
                      scrollLeft: 0,
                      scrollTop: 0,
                      scrollWidth: 0
                  }, _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this)), _this;
              }
              return _inherits(ScrollSync, _React$PureComponent), _createClass(ScrollSync, [ {
                  key: "render",
                  value: function() {
                      var children = this.props.children, _this$state = this.state, clientHeight = _this$state.clientHeight, clientWidth = _this$state.clientWidth, scrollHeight = _this$state.scrollHeight, scrollLeft = _this$state.scrollLeft, scrollTop = _this$state.scrollTop, scrollWidth = _this$state.scrollWidth;
                      return children({
                          clientHeight,
                          clientWidth,
                          onScroll: this._onScroll,
                          scrollHeight,
                          scrollLeft,
                          scrollTop,
                          scrollWidth
                      });
                  }
              }, {
                  key: "_onScroll",
                  value: function(_ref) {
                      var clientHeight = _ref.clientHeight, clientWidth = _ref.clientWidth, scrollHeight = _ref.scrollHeight, scrollLeft = _ref.scrollLeft, scrollTop = _ref.scrollTop, scrollWidth = _ref.scrollWidth;
                      this.setState({
                          clientHeight,
                          clientWidth,
                          scrollHeight,
                          scrollLeft,
                          scrollTop,
                          scrollWidth
                      });
                  }
              } ]), ScrollSync;
          }(react.PureComponent);
          ScrollSync_ScrollSync.propTypes = {};
          function defaultHeaderRowRenderer(_ref) {
              var className = _ref.className, columns = _ref.columns, style = _ref.style;
              return react.createElement("div", {
                  className,
                  role: "row",
                  style
              }, columns);
          }
          defaultHeaderRowRenderer.propTypes = null;
          const Table_SortDirection = {
              ASC: "ASC",
              DESC: "DESC"
          };
          function SortIndicator(_ref) {
              var sortDirection = _ref.sortDirection, classNames = clsx_m("ReactVirtualized__Table__sortableHeaderIcon", {
                  "ReactVirtualized__Table__sortableHeaderIcon--ASC": sortDirection === Table_SortDirection.ASC,
                  "ReactVirtualized__Table__sortableHeaderIcon--DESC": sortDirection === Table_SortDirection.DESC
              });
              return react.createElement("svg", {
                  className: classNames,
                  width: 18,
                  height: 18,
                  viewBox: "0 0 24 24"
              }, sortDirection === Table_SortDirection.ASC ? react.createElement("path", {
                  d: "M7 14l5-5 5 5z"
              }) : react.createElement("path", {
                  d: "M7 10l5 5 5-5z"
              }), react.createElement("path", {
                  d: "M0 0h24v24H0z",
                  fill: "none"
              }));
          }
          function defaultHeaderRenderer(_ref) {
              var dataKey = _ref.dataKey, label = _ref.label, sortBy = _ref.sortBy, sortDirection = _ref.sortDirection, showSortIndicator = sortBy === dataKey, children = [ react.createElement("span", {
                  className: "ReactVirtualized__Table__headerTruncatedText",
                  key: "label",
                  title: "string" == typeof label ? label : null
              }, label) ];
              return showSortIndicator && children.push(react.createElement(SortIndicator, {
                  key: "SortIndicator",
                  sortDirection
              })), children;
          }
          function defaultRowRenderer(_ref) {
              var className = _ref.className, columns = _ref.columns, index = _ref.index, key = _ref.key, onRowClick = _ref.onRowClick, onRowDoubleClick = _ref.onRowDoubleClick, onRowMouseOut = _ref.onRowMouseOut, onRowMouseOver = _ref.onRowMouseOver, onRowRightClick = _ref.onRowRightClick, rowData = _ref.rowData, style = _ref.style, a11yProps = {
                  "aria-rowindex": index + 1
              };
              return (onRowClick || onRowDoubleClick || onRowMouseOut || onRowMouseOver || onRowRightClick) && (a11yProps["aria-label"] = "row", 
              a11yProps.tabIndex = 0, onRowClick && (a11yProps.onClick = function(event) {
                  return onRowClick({
                      event,
                      index,
                      rowData
                  });
              }), onRowDoubleClick && (a11yProps.onDoubleClick = function(event) {
                  return onRowDoubleClick({
                      event,
                      index,
                      rowData
                  });
              }), onRowMouseOut && (a11yProps.onMouseOut = function(event) {
                  return onRowMouseOut({
                      event,
                      index,
                      rowData
                  });
              }), onRowMouseOver && (a11yProps.onMouseOver = function(event) {
                  return onRowMouseOver({
                      event,
                      index,
                      rowData
                  });
              }), onRowRightClick && (a11yProps.onContextMenu = function(event) {
                  return onRowRightClick({
                      event,
                      index,
                      rowData
                  });
              })), react.createElement("div", _extends({}, a11yProps, {
                  className,
                  key,
                  role: "row",
                  style
              }), columns);
          }
          SortIndicator.propTypes = {}, defaultHeaderRenderer.propTypes = null, defaultRowRenderer.propTypes = null;
          var Column = function(_React$Component) {
              function Column() {
                  return _classCallCheck(this, Column), _possibleConstructorReturn(this, _getPrototypeOf(Column).apply(this, arguments));
              }
              return _inherits(Column, _React$Component), Column;
          }(react.Component);
          function Table_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          function Table_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                  var source = null != arguments[i] ? arguments[i] : {};
                  i % 2 ? Table_ownKeys(source, !0).forEach((function(key) {
                      defineProperty_defineProperty(target, key, source[key]);
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Table_ownKeys(source).forEach((function(key) {
                      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  }));
              }
              return target;
          }
          defineProperty_defineProperty(Column, "defaultProps", {
              cellDataGetter: function(_ref) {
                  var dataKey = _ref.dataKey, rowData = _ref.rowData;
                  return "function" == typeof rowData.get ? rowData.get(dataKey) : rowData[dataKey];
              },
              cellRenderer: function(_ref) {
                  var cellData = _ref.cellData;
                  return null == cellData ? "" : String(cellData);
              },
              defaultSortDirection: Table_SortDirection.ASC,
              flexGrow: 0,
              flexShrink: 1,
              headerRenderer: defaultHeaderRenderer,
              style: {}
          }), Column.propTypes = {};
          var Table_Table = function(_React$PureComponent) {
              function Table(props) {
                  var _this;
                  return _classCallCheck(this, Table), (_this = _possibleConstructorReturn(this, _getPrototypeOf(Table).call(this, props))).state = {
                      scrollbarWidth: 0
                  }, _this._createColumn = _this._createColumn.bind(_assertThisInitialized(_this)), 
                  _this._createRow = _this._createRow.bind(_assertThisInitialized(_this)), _this._onScroll = _this._onScroll.bind(_assertThisInitialized(_this)), 
                  _this._onSectionRendered = _this._onSectionRendered.bind(_assertThisInitialized(_this)), 
                  _this._setRef = _this._setRef.bind(_assertThisInitialized(_this)), _this;
              }
              return _inherits(Table, _React$PureComponent), _createClass(Table, [ {
                  key: "forceUpdateGrid",
                  value: function() {
                      this.Grid && this.Grid.forceUpdate();
                  }
              }, {
                  key: "getOffsetForRow",
                  value: function(_ref) {
                      var alignment = _ref.alignment, index = _ref.index;
                      return this.Grid ? this.Grid.getOffsetForCell({
                          alignment,
                          rowIndex: index
                      }).scrollTop : 0;
                  }
              }, {
                  key: "invalidateCellSizeAfterRender",
                  value: function(_ref2) {
                      var columnIndex = _ref2.columnIndex, rowIndex = _ref2.rowIndex;
                      this.Grid && this.Grid.invalidateCellSizeAfterRender({
                          rowIndex,
                          columnIndex
                      });
                  }
              }, {
                  key: "measureAllRows",
                  value: function() {
                      this.Grid && this.Grid.measureAllCells();
                  }
              }, {
                  key: "recomputeGridSize",
                  value: function() {
                      var _ref3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, _ref3$columnIndex = _ref3.columnIndex, columnIndex = void 0 === _ref3$columnIndex ? 0 : _ref3$columnIndex, _ref3$rowIndex = _ref3.rowIndex, rowIndex = void 0 === _ref3$rowIndex ? 0 : _ref3$rowIndex;
                      this.Grid && this.Grid.recomputeGridSize({
                          rowIndex,
                          columnIndex
                      });
                  }
              }, {
                  key: "recomputeRowHeights",
                  value: function() {
                      var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                      this.Grid && this.Grid.recomputeGridSize({
                          rowIndex: index
                      });
                  }
              }, {
                  key: "scrollToPosition",
                  value: function() {
                      var scrollTop = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                      this.Grid && this.Grid.scrollToPosition({
                          scrollTop
                      });
                  }
              }, {
                  key: "scrollToRow",
                  value: function() {
                      var index = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                      this.Grid && this.Grid.scrollToCell({
                          columnIndex: 0,
                          rowIndex: index
                      });
                  }
              }, {
                  key: "getScrollbarWidth",
                  value: function() {
                      if (this.Grid) {
                          var _Grid = (0, react_dom.findDOMNode)(this.Grid), clientWidth = _Grid.clientWidth || 0;
                          return (_Grid.offsetWidth || 0) - clientWidth;
                      }
                      return 0;
                  }
              }, {
                  key: "componentDidMount",
                  value: function() {
                      this._setScrollbarWidth();
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function() {
                      this._setScrollbarWidth();
                  }
              }, {
                  key: "render",
                  value: function() {
                      var _this2 = this, _this$props = this.props, children = _this$props.children, className = _this$props.className, disableHeader = _this$props.disableHeader, gridClassName = _this$props.gridClassName, gridStyle = _this$props.gridStyle, headerHeight = _this$props.headerHeight, headerRowRenderer = _this$props.headerRowRenderer, height = _this$props.height, id = _this$props.id, noRowsRenderer = _this$props.noRowsRenderer, rowClassName = _this$props.rowClassName, rowStyle = _this$props.rowStyle, scrollToIndex = _this$props.scrollToIndex, style = _this$props.style, width = _this$props.width, scrollbarWidth = this.state.scrollbarWidth, availableRowsHeight = disableHeader ? height : height - headerHeight, rowClass = "function" == typeof rowClassName ? rowClassName({
                          index: -1
                      }) : rowClassName, rowStyleObject = "function" == typeof rowStyle ? rowStyle({
                          index: -1
                      }) : rowStyle;
                      return this._cachedColumnStyles = [], react.Children.toArray(children).forEach((function(column, index) {
                          var flexStyles = _this2._getFlexStyleForColumn(column, column.props.style);
                          _this2._cachedColumnStyles[index] = Table_objectSpread({
                              overflow: "hidden"
                          }, flexStyles);
                      })), react.createElement("div", {
                          "aria-label": this.props["aria-label"],
                          "aria-labelledby": this.props["aria-labelledby"],
                          "aria-colcount": react.Children.toArray(children).length,
                          "aria-rowcount": this.props.rowCount,
                          className: clsx_m("ReactVirtualized__Table", className),
                          id,
                          role: "grid",
                          style
                      }, !disableHeader && headerRowRenderer({
                          className: clsx_m("ReactVirtualized__Table__headerRow", rowClass),
                          columns: this._getHeaderColumns(),
                          style: Table_objectSpread({
                              height: headerHeight,
                              overflow: "hidden",
                              paddingRight: scrollbarWidth,
                              width
                          }, rowStyleObject)
                      }), react.createElement(Grid_Grid, _extends({}, this.props, {
                          "aria-readonly": null,
                          autoContainerWidth: !0,
                          className: clsx_m("ReactVirtualized__Table__Grid", gridClassName),
                          cellRenderer: this._createRow,
                          columnWidth: width,
                          columnCount: 1,
                          height: availableRowsHeight,
                          id: void 0,
                          noContentRenderer: noRowsRenderer,
                          onScroll: this._onScroll,
                          onSectionRendered: this._onSectionRendered,
                          ref: this._setRef,
                          role: "rowgroup",
                          scrollbarWidth,
                          scrollToRow: scrollToIndex,
                          style: Table_objectSpread({}, gridStyle, {
                              overflowX: "hidden"
                          })
                      })));
                  }
              }, {
                  key: "_createColumn",
                  value: function(_ref4) {
                      var column = _ref4.column, columnIndex = _ref4.columnIndex, isScrolling = _ref4.isScrolling, parent = _ref4.parent, rowData = _ref4.rowData, rowIndex = _ref4.rowIndex, onColumnClick = this.props.onColumnClick, _column$props = column.props, cellDataGetter = _column$props.cellDataGetter, cellRenderer = _column$props.cellRenderer, className = _column$props.className, columnData = _column$props.columnData, dataKey = _column$props.dataKey, id = _column$props.id, renderedCell = cellRenderer({
                          cellData: cellDataGetter({
                              columnData,
                              dataKey,
                              rowData
                          }),
                          columnData,
                          columnIndex,
                          dataKey,
                          isScrolling,
                          parent,
                          rowData,
                          rowIndex
                      }), style = this._cachedColumnStyles[columnIndex], title = "string" == typeof renderedCell ? renderedCell : null;
                      return react.createElement("div", {
                          "aria-colindex": columnIndex + 1,
                          "aria-describedby": id,
                          className: clsx_m("ReactVirtualized__Table__rowColumn", className),
                          key: "Row" + rowIndex + "-Col" + columnIndex,
                          onClick: function(event) {
                              onColumnClick && onColumnClick({
                                  columnData,
                                  dataKey,
                                  event
                              });
                          },
                          role: "gridcell",
                          style,
                          title
                      }, renderedCell);
                  }
              }, {
                  key: "_createHeader",
                  value: function(_ref5) {
                      var headerOnClick, headerOnKeyDown, headerTabIndex, headerAriaSort, headerAriaLabel, column = _ref5.column, index = _ref5.index, _this$props2 = this.props, headerClassName = _this$props2.headerClassName, headerStyle = _this$props2.headerStyle, onHeaderClick = _this$props2.onHeaderClick, sort = _this$props2.sort, sortBy = _this$props2.sortBy, sortDirection = _this$props2.sortDirection, _column$props2 = column.props, columnData = _column$props2.columnData, dataKey = _column$props2.dataKey, defaultSortDirection = _column$props2.defaultSortDirection, disableSort = _column$props2.disableSort, headerRenderer = _column$props2.headerRenderer, id = _column$props2.id, label = _column$props2.label, sortEnabled = !disableSort && sort, classNames = clsx_m("ReactVirtualized__Table__headerColumn", headerClassName, column.props.headerClassName, {
                          ReactVirtualized__Table__sortableHeaderColumn: sortEnabled
                      }), style = this._getFlexStyleForColumn(column, Table_objectSpread({}, headerStyle, {}, column.props.headerStyle)), renderedHeader = headerRenderer({
                          columnData,
                          dataKey,
                          disableSort,
                          label,
                          sortBy,
                          sortDirection
                      });
                      if (sortEnabled || onHeaderClick) {
                          var newSortDirection = sortBy !== dataKey ? defaultSortDirection : sortDirection === Table_SortDirection.DESC ? Table_SortDirection.ASC : Table_SortDirection.DESC, onClick = function(event) {
                              sortEnabled && sort({
                                  defaultSortDirection,
                                  event,
                                  sortBy: dataKey,
                                  sortDirection: newSortDirection
                              }), onHeaderClick && onHeaderClick({
                                  columnData,
                                  dataKey,
                                  event
                              });
                          };
                          headerAriaLabel = column.props["aria-label"] || label || dataKey, headerAriaSort = "none", 
                          headerTabIndex = 0, headerOnClick = onClick, headerOnKeyDown = function(event) {
                              "Enter" !== event.key && " " !== event.key || onClick(event);
                          };
                      }
                      return sortBy === dataKey && (headerAriaSort = sortDirection === Table_SortDirection.ASC ? "ascending" : "descending"), 
                      react.createElement("div", {
                          "aria-label": headerAriaLabel,
                          "aria-sort": headerAriaSort,
                          className: classNames,
                          id,
                          key: "Header-Col" + index,
                          onClick: headerOnClick,
                          onKeyDown: headerOnKeyDown,
                          role: "columnheader",
                          style,
                          tabIndex: headerTabIndex
                      }, renderedHeader);
                  }
              }, {
                  key: "_createRow",
                  value: function(_ref6) {
                      var _this3 = this, index = _ref6.rowIndex, isScrolling = _ref6.isScrolling, key = _ref6.key, parent = _ref6.parent, style = _ref6.style, _this$props3 = this.props, children = _this$props3.children, onRowClick = _this$props3.onRowClick, onRowDoubleClick = _this$props3.onRowDoubleClick, onRowRightClick = _this$props3.onRowRightClick, onRowMouseOver = _this$props3.onRowMouseOver, onRowMouseOut = _this$props3.onRowMouseOut, rowClassName = _this$props3.rowClassName, rowGetter = _this$props3.rowGetter, rowRenderer = _this$props3.rowRenderer, rowStyle = _this$props3.rowStyle, scrollbarWidth = this.state.scrollbarWidth, rowClass = "function" == typeof rowClassName ? rowClassName({
                          index
                      }) : rowClassName, rowStyleObject = "function" == typeof rowStyle ? rowStyle({
                          index
                      }) : rowStyle, rowData = rowGetter({
                          index
                      }), columns = react.Children.toArray(children).map((function(column, columnIndex) {
                          return _this3._createColumn({
                              column,
                              columnIndex,
                              isScrolling,
                              parent,
                              rowData,
                              rowIndex: index,
                              scrollbarWidth
                          });
                      })), className = clsx_m("ReactVirtualized__Table__row", rowClass), flattenedStyle = Table_objectSpread({}, style, {
                          height: this._getRowHeight(index),
                          overflow: "hidden",
                          paddingRight: scrollbarWidth
                      }, rowStyleObject);
                      return rowRenderer({
                          className,
                          columns,
                          index,
                          isScrolling,
                          key,
                          onRowClick,
                          onRowDoubleClick,
                          onRowRightClick,
                          onRowMouseOver,
                          onRowMouseOut,
                          rowData,
                          style: flattenedStyle
                      });
                  }
              }, {
                  key: "_getFlexStyleForColumn",
                  value: function(column) {
                      var customStyle = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, flexValue = "".concat(column.props.flexGrow, " ").concat(column.props.flexShrink, " ").concat(column.props.width, "px"), style = Table_objectSpread({}, customStyle, {
                          flex: flexValue,
                          msFlex: flexValue,
                          WebkitFlex: flexValue
                      });
                      return column.props.maxWidth && (style.maxWidth = column.props.maxWidth), column.props.minWidth && (style.minWidth = column.props.minWidth), 
                      style;
                  }
              }, {
                  key: "_getHeaderColumns",
                  value: function() {
                      var _this4 = this, _this$props4 = this.props, children = _this$props4.children;
                      return (_this$props4.disableHeader ? [] : react.Children.toArray(children)).map((function(column, index) {
                          return _this4._createHeader({
                              column,
                              index
                          });
                      }));
                  }
              }, {
                  key: "_getRowHeight",
                  value: function(rowIndex) {
                      var rowHeight = this.props.rowHeight;
                      return "function" == typeof rowHeight ? rowHeight({
                          index: rowIndex
                      }) : rowHeight;
                  }
              }, {
                  key: "_onScroll",
                  value: function(_ref7) {
                      var clientHeight = _ref7.clientHeight, scrollHeight = _ref7.scrollHeight, scrollTop = _ref7.scrollTop;
                      (0, this.props.onScroll)({
                          clientHeight,
                          scrollHeight,
                          scrollTop
                      });
                  }
              }, {
                  key: "_onSectionRendered",
                  value: function(_ref8) {
                      var rowOverscanStartIndex = _ref8.rowOverscanStartIndex, rowOverscanStopIndex = _ref8.rowOverscanStopIndex, rowStartIndex = _ref8.rowStartIndex, rowStopIndex = _ref8.rowStopIndex;
                      (0, this.props.onRowsRendered)({
                          overscanStartIndex: rowOverscanStartIndex,
                          overscanStopIndex: rowOverscanStopIndex,
                          startIndex: rowStartIndex,
                          stopIndex: rowStopIndex
                      });
                  }
              }, {
                  key: "_setRef",
                  value: function(ref) {
                      this.Grid = ref;
                  }
              }, {
                  key: "_setScrollbarWidth",
                  value: function() {
                      var scrollbarWidth = this.getScrollbarWidth();
                      this.setState({
                          scrollbarWidth
                      });
                  }
              } ]), Table;
          }(react.PureComponent);
          defineProperty_defineProperty(Table_Table, "defaultProps", {
              disableHeader: !1,
              estimatedRowSize: 30,
              headerHeight: 0,
              headerStyle: {},
              noRowsRenderer: function() {
                  return null;
              },
              onRowsRendered: function() {
                  return null;
              },
              onScroll: function() {
                  return null;
              },
              overscanIndicesGetter: accessibilityOverscanIndicesGetter_defaultOverscanIndicesGetter,
              overscanRowCount: 10,
              rowRenderer: defaultRowRenderer,
              headerRowRenderer: defaultHeaderRowRenderer,
              rowStyle: {},
              scrollToAlignment: "auto",
              scrollToIndex: -1,
              style: {}
          }), Table_Table.propTypes = {};
          var mountedInstances = [], originalBodyPointerEvents = null, disablePointerEventsTimeoutId = null;
          function enablePointerEventsIfDisabled() {
              disablePointerEventsTimeoutId && (disablePointerEventsTimeoutId = null, document.body && null != originalBodyPointerEvents && (document.body.style.pointerEvents = originalBodyPointerEvents), 
              originalBodyPointerEvents = null);
          }
          function enablePointerEventsAfterDelayCallback() {
              enablePointerEventsIfDisabled(), mountedInstances.forEach((function(instance) {
                  return instance.__resetIsScrolling();
              }));
          }
          function onScrollWindow(event) {
              event.currentTarget === window && null == originalBodyPointerEvents && document.body && (originalBodyPointerEvents = document.body.style.pointerEvents, 
              document.body.style.pointerEvents = "none"), function() {
                  disablePointerEventsTimeoutId && cancelAnimationTimeout(disablePointerEventsTimeoutId);
                  var maximumTimeout = 0;
                  mountedInstances.forEach((function(instance) {
                      maximumTimeout = Math.max(maximumTimeout, instance.props.scrollingResetTimeInterval);
                  })), disablePointerEventsTimeoutId = requestAnimationTimeout(enablePointerEventsAfterDelayCallback, maximumTimeout);
              }(), mountedInstances.forEach((function(instance) {
                  instance.props.scrollElement === event.currentTarget && instance.__handleWindowScrollEvent();
              }));
          }
          function registerScrollListener(component, element) {
              mountedInstances.some((function(instance) {
                  return instance.props.scrollElement === element;
              })) || element.addEventListener("scroll", onScrollWindow), mountedInstances.push(component);
          }
          function unregisterScrollListener(component, element) {
              (mountedInstances = mountedInstances.filter((function(instance) {
                  return instance !== component;
              }))).length || (element.removeEventListener("scroll", onScrollWindow), disablePointerEventsTimeoutId && (cancelAnimationTimeout(disablePointerEventsTimeoutId), 
              enablePointerEventsIfDisabled()));
          }
          var WindowScroller_class, WindowScroller_temp, isWindow = function(element) {
              return element === window;
          }, getBoundingBox = function(element) {
              return element.getBoundingClientRect();
          };
          function getDimensions(scrollElement, props) {
              if (scrollElement) {
                  if (isWindow(scrollElement)) {
                      var _window = window, innerHeight = _window.innerHeight, innerWidth = _window.innerWidth;
                      return {
                          height: "number" == typeof innerHeight ? innerHeight : 0,
                          width: "number" == typeof innerWidth ? innerWidth : 0
                      };
                  }
                  return getBoundingBox(scrollElement);
              }
              return {
                  height: props.serverHeight,
                  width: props.serverWidth
              };
          }
          function getScrollOffset(element) {
              return isWindow(element) && document.documentElement ? {
                  top: "scrollY" in window ? window.scrollY : document.documentElement.scrollTop,
                  left: "scrollX" in window ? window.scrollX : document.documentElement.scrollLeft
              } : {
                  top: element.scrollTop,
                  left: element.scrollLeft
              };
          }
          function WindowScroller_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                  var symbols = Object.getOwnPropertySymbols(object);
                  enumerableOnly && (symbols = symbols.filter((function(sym) {
                      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  }))), keys.push.apply(keys, symbols);
              }
              return keys;
          }
          var getWindow = function() {
              return "undefined" != typeof window ? window : void 0;
          }, WindowScroller_WindowScroller = (WindowScroller_temp = WindowScroller_class = function(_React$PureComponent) {
              function WindowScroller() {
                  var _getPrototypeOf2, _this;
                  _classCallCheck(this, WindowScroller);
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                  return defineProperty_defineProperty(_assertThisInitialized(_this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(WindowScroller)).call.apply(_getPrototypeOf2, [ this ].concat(args)))), "_window", getWindow()), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_isMounted", !1), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_positionFromTop", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_positionFromLeft", 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_detectElementResize", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "_child", void 0), 
                  defineProperty_defineProperty(_assertThisInitialized(_this), "state", function(target) {
                      for (var i = 1; i < arguments.length; i++) {
                          var source = null != arguments[i] ? arguments[i] : {};
                          i % 2 ? WindowScroller_ownKeys(source, !0).forEach((function(key) {
                              defineProperty_defineProperty(target, key, source[key]);
                          })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : WindowScroller_ownKeys(source).forEach((function(key) {
                              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                          }));
                      }
                      return target;
                  }({}, getDimensions(_this.props.scrollElement, _this.props), {
                      isScrolling: !1,
                      scrollLeft: 0,
                      scrollTop: 0
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_registerChild", (function(element) {
                      !element || element instanceof Element || console.warn("WindowScroller registerChild expects to be passed Element or null"), 
                      _this._child = element, _this.updatePosition();
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onChildScroll", (function(_ref) {
                      var scrollTop = _ref.scrollTop;
                      if (_this.state.scrollTop !== scrollTop) {
                          var scrollElement = _this.props.scrollElement;
                          scrollElement && ("function" == typeof scrollElement.scrollTo ? scrollElement.scrollTo(0, scrollTop + _this._positionFromTop) : scrollElement.scrollTop = scrollTop + _this._positionFromTop);
                      }
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_registerResizeListener", (function(element) {
                      element === window ? window.addEventListener("resize", _this._onResize, !1) : _this._detectElementResize.addResizeListener(element, _this._onResize);
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_unregisterResizeListener", (function(element) {
                      element === window ? window.removeEventListener("resize", _this._onResize, !1) : element && _this._detectElementResize.removeResizeListener(element, _this._onResize);
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "_onResize", (function() {
                      _this.updatePosition();
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "__handleWindowScrollEvent", (function() {
                      if (_this._isMounted) {
                          var onScroll = _this.props.onScroll, scrollElement = _this.props.scrollElement;
                          if (scrollElement) {
                              var scrollOffset = getScrollOffset(scrollElement), scrollLeft = Math.max(0, scrollOffset.left - _this._positionFromLeft), scrollTop = Math.max(0, scrollOffset.top - _this._positionFromTop);
                              _this.setState({
                                  isScrolling: !0,
                                  scrollLeft,
                                  scrollTop
                              }), onScroll({
                                  scrollLeft,
                                  scrollTop
                              });
                          }
                      }
                  })), defineProperty_defineProperty(_assertThisInitialized(_this), "__resetIsScrolling", (function() {
                      _this.setState({
                          isScrolling: !1
                      });
                  })), _this;
              }
              return _inherits(WindowScroller, _React$PureComponent), _createClass(WindowScroller, [ {
                  key: "updatePosition",
                  value: function() {
                      var scrollElement = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.props.scrollElement, onResize = this.props.onResize, _this$state = this.state, height = _this$state.height, width = _this$state.width, thisNode = this._child || react_dom.findDOMNode(this);
                      if (thisNode instanceof Element && scrollElement) {
                          var offset = function(element, container) {
                              if (isWindow(container) && document.documentElement) {
                                  var containerElement = document.documentElement, elementRect = getBoundingBox(element), containerRect = getBoundingBox(containerElement);
                                  return {
                                      top: elementRect.top - containerRect.top,
                                      left: elementRect.left - containerRect.left
                                  };
                              }
                              var scrollOffset = getScrollOffset(container), _elementRect = getBoundingBox(element), _containerRect = getBoundingBox(container);
                              return {
                                  top: _elementRect.top + scrollOffset.top - _containerRect.top,
                                  left: _elementRect.left + scrollOffset.left - _containerRect.left
                              };
                          }(thisNode, scrollElement);
                          this._positionFromTop = offset.top, this._positionFromLeft = offset.left;
                      }
                      var dimensions = getDimensions(scrollElement, this.props);
                      height === dimensions.height && width === dimensions.width || (this.setState({
                          height: dimensions.height,
                          width: dimensions.width
                      }), onResize({
                          height: dimensions.height,
                          width: dimensions.width
                      }));
                  }
              }, {
                  key: "componentDidMount",
                  value: function() {
                      var scrollElement = this.props.scrollElement;
                      this._detectElementResize = createDetectElementResize(), this.updatePosition(scrollElement), 
                      scrollElement && (registerScrollListener(this, scrollElement), this._registerResizeListener(scrollElement)), 
                      this._isMounted = !0;
                  }
              }, {
                  key: "componentDidUpdate",
                  value: function(prevProps, prevState) {
                      var scrollElement = this.props.scrollElement, prevScrollElement = prevProps.scrollElement;
                      prevScrollElement !== scrollElement && null != prevScrollElement && null != scrollElement && (this.updatePosition(scrollElement), 
                      unregisterScrollListener(this, prevScrollElement), registerScrollListener(this, scrollElement), 
                      this._unregisterResizeListener(prevScrollElement), this._registerResizeListener(scrollElement));
                  }
              }, {
                  key: "componentWillUnmount",
                  value: function() {
                      var scrollElement = this.props.scrollElement;
                      scrollElement && (unregisterScrollListener(this, scrollElement), this._unregisterResizeListener(scrollElement)), 
                      this._isMounted = !1;
                  }
              }, {
                  key: "render",
                  value: function() {
                      var children = this.props.children, _this$state2 = this.state, isScrolling = _this$state2.isScrolling, scrollTop = _this$state2.scrollTop, scrollLeft = _this$state2.scrollLeft, height = _this$state2.height, width = _this$state2.width;
                      return children({
                          onChildScroll: this._onChildScroll,
                          registerChild: this._registerChild,
                          height,
                          isScrolling,
                          scrollLeft,
                          scrollTop,
                          width
                      });
                  }
              } ]), WindowScroller;
          }(react.PureComponent), defineProperty_defineProperty(WindowScroller_class, "propTypes", null), 
          WindowScroller_temp);
          defineProperty_defineProperty(WindowScroller_WindowScroller, "defaultProps", {
              onResize: function() {},
              onScroll: function() {},
              scrollingResetTimeInterval: 150,
              scrollElement: getWindow(),
              serverHeight: 0,
              serverWidth: 0
          });
          var _SubtitleContinue, placeholderItem_div;
          const placeholderItem = function({measure, isLastItemCompleted}) {
              const clickLimit = (0, react.useRef)(Date.now()), paused = usePaused(), onClickContinue = () => {
                  const now = Date.now();
                  if (now - 3e3 > clickLimit.current) {
                      const {bizId} = stores_info.getState(), {noCapture, connectBlocked} = uiConfig.getState();
                      if (!limit.getState().count || !bizId || noCapture || connectBlocked) return;
                      clickLimit.current = now, window.postMessage({
                          type: "subtitle:continue"
                      });
                  }
              };
              return (0, react.useEffect)((() => {
                  measure();
              }), [ paused ]), (0, react.useEffect)((() => {
                  isLastItemCompleted && measure();
              }), [ isLastItemCompleted ]), paused ? (0, jsx_runtime.jsx)("div", {
                  className: "message",
                  onClick: onClickContinue,
                  children: (0, jsx_runtime.jsxs)("span", {
                      className: "continue",
                      children: [ _SubtitleContinue || (_SubtitleContinue = (0, jsx_runtime.jsx)(SubtitleContinue, {})), chrome.i18n.getMessage("continueTranslate") ]
                  })
              }) : isLastItemCompleted ? placeholderItem_div || (placeholderItem_div = (0, jsx_runtime.jsx)("div", {
                  className: "message",
                  children: (0, jsx_runtime.jsx)("div", {
                      className: "loading-span"
                  })
              })) : null;
          };
          var _SubtitleRetranslate, messageItem_div, _span, _span2;
          const translatedInfo = message => {
              if (void 0 === message.translateText) return null;
              const timeDifferenceInMilliseconds = Date.now() - (message.endTime || message.startTime);
              return Math.abs(timeDifferenceInMilliseconds / 1e3) > 23 ? (0, jsx_runtime.jsxs)("div", {
                  className: "translated-loading-info",
                  onClick: () => (message => {
                      const {paused} = uiConfig.getState();
                      paused || subtitle.getState().retranslation(message);
                  })(message),
                  children: [ _SubtitleRetranslate || (_SubtitleRetranslate = (0, jsx_runtime.jsx)(SubtitleRetranslate, {})), (0, 
                  jsx_runtime.jsx)("div", {
                      className: "translated-loading-text",
                      children: chrome.i18n.getMessage("retranslation")
                  }) ]
              }) : messageItem_div || (messageItem_div = (0, jsx_runtime.jsx)("div", {
                  className: "loading-span"
              }));
          }, messageItem = ({message, isMeetPage, isShowOriginText, measure, width, fontSize}) => {
              (0, react.useEffect)((() => {
                  measure && measure();
              }), [ measure, message, isMeetPage, isShowOriginText, width, fontSize ]);
              return (0, jsx_runtime.jsxs)("div", {
                  className: "message",
                  children: [ isMeetPage && message.user ? (0, jsx_runtime.jsxs)("p", {
                      className: "notranslate felo-user",
                      children: [ message.user, ":" ]
                  }) : null, void 0 === message.translateText ? (0, jsx_runtime.jsxs)("p", {
                      className: "notranslate felo-translate " + (message.isComplete ? "Complete" : "noComplete"),
                      children: [ message.text, !message.isComplete && (_span || (_span = (0, jsx_runtime.jsx)("span", {
                          className: "loading-span"
                      }))) ]
                  }) : (0, jsx_runtime.jsxs)(jsx_runtime.Fragment, {
                      children: [ isShowOriginText && message.text ? (0, jsx_runtime.jsx)("p", {
                          className: "notranslate felo-text",
                          children: message.text
                      }) : null, message.translateText ? (0, jsx_runtime.jsxs)("p", {
                          className: "notranslate felo-translate " + (message.isComplete ? "Complete" : "noComplete"),
                          children: [ message.translateText, !message.isComplete && (_span2 || (_span2 = (0, 
                          jsx_runtime.jsx)("span", {
                              className: "loading-span"
                          }))) ]
                      }) : translatedInfo(message) ]
                  }) ]
              });
          }, cache = new CellMeasurerCache({
              defaultHeight: 50,
              defaultWidth: 50
          });
          let initHeight = 0, initWidth = 0;
          const virtualList = ({messages, isMeetPage, isShowOriginText, srollState, setScrollState, bottomState}) => {
              const {fontSize} = useFontSize(), messagesRef = (0, react.useRef)(null), messagesContentRef = (0, 
              react.useRef)(null), oldEvent = (0, react.useRef)({
                  clientHeight: 0,
                  scrollHeight: 0,
                  scrollTop: 0
              }), [height, setHeight] = (0, react.useState)((() => {
                  if (0 !== initHeight) return initHeight;
                  const messageContainer = messagesContentRef.current;
                  return messageContainer ? messageContainer.clientHeight : 0;
              })()), [width, setWidth] = (0, react.useState)((() => {
                  if (0 !== initWidth) return initWidth;
                  const messageContainer = messagesContentRef.current;
                  return messageContainer ? messageContainer.clientWidth : 0;
              })());
              (0, react.useEffect)((() => {
                  messagesRef.current && srollState && scrollToBottomEvent();
              }), [ messages ]), (0, react.useEffect)((() => {
                  messagesRef.current && srollState && scrollToBottomEvent();
              }), [ height ]), (0, react.useEffect)((() => {
                  messagesRef.current && bottomState && scrollToBottomEvent();
              }), [ bottomState ]);
              const paused = usePaused();
              (0, react.useEffect)((() => {
                  messagesRef.current && paused && scrollToBottomEvent();
              }), [ paused ]);
              const scrollToBottomEvent = (0, react.useCallback)((() => {
                  const listContent = messagesRef.current, {props} = listContent;
                  props.rowCount && (listContent.scrollToRow(props.rowCount), setTimeout((() => listContent.scrollToRow(props.rowCount)), 100));
              }), [ messagesRef.current ]);
              (0, react.useEffect)((() => {
                  const interval = setInterval((async () => {
                      const $subtitle = document.querySelector(".felo-subtitle"), boxWrap = document.querySelector(".felo-content-box")?.getBoundingClientRect(), boxContent = $subtitle?.getBoundingClientRect();
                      boxContent && boxWrap && boxContent.y > boxWrap.y ? $subtitle && ($subtitle.style.height = boxWrap?.height - (boxContent?.y - boxWrap.y) + "px") : $subtitle && ($subtitle.style.height = "100%");
                      const messageContainer = messagesContentRef.current;
                      messageContainer && (initHeight = messageContainer.clientHeight, initWidth = messageContainer.clientWidth, 
                      setHeight(messageContainer.clientHeight), setWidth(messageContainer.clientWidth));
                  }), 500);
                  return () => {
                      clearInterval(interval);
                  };
              }), []);
              const onScroll = (0, react.useCallback)((e => {
                  oldEvent.current = e, 0 !== e.scrollHeight && 0 !== e.clientHeight ? e.clientHeight > e.scrollTop + e.scrollHeight ? setScrollState(!0) : setScrollState(e.scrollTop >= Math.floor(e.scrollHeight - e.clientHeight - 20)) : setScrollState(!0);
              }), [ setScrollState ]);
              return (0, react.useEffect)((() => {
                  const fn = ({data}) => {
                      if ("scrollToBottom" === data.type) {
                          if (!messagesRef.current) return;
                          messagesRef.current.scrollToPosition(oldEvent.current.scrollTop + 1);
                      }
                  };
                  return window.addEventListener("message", fn), () => {
                      window.removeEventListener("message", fn);
                  };
              }), []), (0, jsx_runtime.jsx)("div", {
                  ref: messagesContentRef,
                  className: "messages-Content-div",
                  style: {
                      fontSize: `${fontSize}px`
                  },
                  children: (0, jsx_runtime.jsx)(List_List_List, {
                      ref: messagesRef,
                      width,
                      height,
                      rowCount: messages.length + 1,
                      rowHeight: cache.rowHeight,
                      rowRenderer: ({index, key, parent, style}) => {
                          const message = messages[index];
                          return (0, jsx_runtime.jsx)(CellMeasurer_CellMeasurer, {
                              cache,
                              parent,
                              rowIndex: index,
                              children: ({measure}) => (0, jsx_runtime.jsx)("div", {
                                  style: {
                                      ...style
                                  },
                                  children: message ? (0, jsx_runtime.jsx)(messageItem, {
                                      measure,
                                      message,
                                      isMeetPage,
                                      isShowOriginText,
                                      width,
                                      fontSize
                                  }) : (0, jsx_runtime.jsx)(placeholderItem, {
                                      measure,
                                      isLastItemCompleted: messages.at(-1)?.isComplete || !1
                                  })
                              })
                          }, key);
                      },
                      onScroll
                  })
              });
          };
          var _RecognizingTip, _img;
          const subtitleList = function() {
              const isMeetPage = useInfoStore((({isMeet}) => isMeet)), {color} = useColor(), {textShadow} = useTextShadow(), isShowOriginText = useBothSubtitles(), [scrollState, setScrollState] = (0, 
              react.useState)(!0), [bottomState, setBottomState] = (0, react.useState)(!0);
              (0, react.useEffect)((() => {
                  scrollState || setBottomState(!1);
              }), [ scrollState ]);
              const messages = useSubtitleStore((({messages}) => messages));
              return (0, jsx_runtime.jsx)(jsx_runtime.Fragment, {
                  children: 0 === messages.length ? _RecognizingTip || (_RecognizingTip = (0, jsx_runtime.jsx)(RecognizingTip, {})) : (0, 
                  jsx_runtime.jsxs)("div", {
                      className: "felo-subtitle",
                      children: [ (0, jsx_runtime.jsx)("div", {
                          className: dist_clsx("message-container", `color-${color}`, `shadow-${textShadow}`),
                          children: (0, jsx_runtime.jsx)(virtualList, {
                              messages,
                              isMeetPage,
                              isShowOriginText,
                              srollState: scrollState,
                              setScrollState,
                              bottomState
                          })
                      }), (0, jsx_runtime.jsx)("div", {
                          className: "arrowdown-content",
                          onClick: () => {
                              setBottomState(!0);
                          },
                          hidden: scrollState,
                          children: _img || (_img = (0, jsx_runtime.jsx)("img", {
                              alt: "",
                              src: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjgiIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIxIDdMMTQgMTRMNyA3IiBzdHJva2U9IiNmZmYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPgo8cGF0aCBkPSJNMjEgMTRMMTQgMjFMNyAxNCIgc3Ryb2tlPSIjZmZmIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cg==",
                              className: "arrowIcon"
                          }))
                      }) ]
                  })
              });
          };
          var KeyCode = {
              MAC_ENTER: 3,
              BACKSPACE: 8,
              TAB: 9,
              NUM_CENTER: 12,
              ENTER: 13,
              SHIFT: 16,
              CTRL: 17,
              ALT: 18,
              PAUSE: 19,
              CAPS_LOCK: 20,
              ESC: 27,
              SPACE: 32,
              PAGE_UP: 33,
              PAGE_DOWN: 34,
              END: 35,
              HOME: 36,
              LEFT: 37,
              UP: 38,
              RIGHT: 39,
              DOWN: 40,
              PRINT_SCREEN: 44,
              INSERT: 45,
              DELETE: 46,
              ZERO: 48,
              ONE: 49,
              TWO: 50,
              THREE: 51,
              FOUR: 52,
              FIVE: 53,
              SIX: 54,
              SEVEN: 55,
              EIGHT: 56,
              NINE: 57,
              QUESTION_MARK: 63,
              A: 65,
              B: 66,
              C: 67,
              D: 68,
              E: 69,
              F: 70,
              G: 71,
              H: 72,
              I: 73,
              J: 74,
              K: 75,
              L: 76,
              M: 77,
              N: 78,
              O: 79,
              P: 80,
              Q: 81,
              R: 82,
              S: 83,
              T: 84,
              U: 85,
              V: 86,
              W: 87,
              X: 88,
              Y: 89,
              Z: 90,
              META: 91,
              WIN_KEY_RIGHT: 92,
              CONTEXT_MENU: 93,
              NUM_ZERO: 96,
              NUM_ONE: 97,
              NUM_TWO: 98,
              NUM_THREE: 99,
              NUM_FOUR: 100,
              NUM_FIVE: 101,
              NUM_SIX: 102,
              NUM_SEVEN: 103,
              NUM_EIGHT: 104,
              NUM_NINE: 105,
              NUM_MULTIPLY: 106,
              NUM_PLUS: 107,
              NUM_MINUS: 109,
              NUM_PERIOD: 110,
              NUM_DIVISION: 111,
              F1: 112,
              F2: 113,
              F3: 114,
              F4: 115,
              F5: 116,
              F6: 117,
              F7: 118,
              F8: 119,
              F9: 120,
              F10: 121,
              F11: 122,
              F12: 123,
              NUMLOCK: 144,
              SEMICOLON: 186,
              DASH: 189,
              EQUALS: 187,
              COMMA: 188,
              PERIOD: 190,
              SLASH: 191,
              APOSTROPHE: 192,
              SINGLE_QUOTE: 222,
              OPEN_SQUARE_BRACKET: 219,
              BACKSLASH: 220,
              CLOSE_SQUARE_BRACKET: 221,
              WIN_KEY: 224,
              MAC_FF_META: 224,
              WIN_IME: 229,
              isTextModifyingKeyEvent: function(e) {
                  var keyCode = e.keyCode;
                  if (e.altKey && !e.ctrlKey || e.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) return !1;
                  switch (keyCode) {
                    case KeyCode.ALT:
                    case KeyCode.CAPS_LOCK:
                    case KeyCode.CONTEXT_MENU:
                    case KeyCode.CTRL:
                    case KeyCode.DOWN:
                    case KeyCode.END:
                    case KeyCode.ESC:
                    case KeyCode.HOME:
                    case KeyCode.INSERT:
                    case KeyCode.LEFT:
                    case KeyCode.MAC_FF_META:
                    case KeyCode.META:
                    case KeyCode.NUMLOCK:
                    case KeyCode.NUM_CENTER:
                    case KeyCode.PAGE_DOWN:
                    case KeyCode.PAGE_UP:
                    case KeyCode.PAUSE:
                    case KeyCode.PRINT_SCREEN:
                    case KeyCode.RIGHT:
                    case KeyCode.SHIFT:
                    case KeyCode.UP:
                    case KeyCode.WIN_KEY:
                    case KeyCode.WIN_KEY_RIGHT:
                      return !1;

                    default:
                      return !0;
                  }
              },
              isCharacterKey: function(keyCode) {
                  if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) return !0;
                  if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) return !0;
                  if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) return !0;
                  if (-1 !== window.navigator.userAgent.indexOf("WebKit") && 0 === keyCode) return !0;
                  switch (keyCode) {
                    case KeyCode.SPACE:
                    case KeyCode.QUESTION_MARK:
                    case KeyCode.NUM_PLUS:
                    case KeyCode.NUM_MINUS:
                    case KeyCode.NUM_PERIOD:
                    case KeyCode.NUM_DIVISION:
                    case KeyCode.SEMICOLON:
                    case KeyCode.DASH:
                    case KeyCode.EQUALS:
                    case KeyCode.COMMA:
                    case KeyCode.PERIOD:
                    case KeyCode.SLASH:
                    case KeyCode.APOSTROPHE:
                    case KeyCode.SINGLE_QUOTE:
                    case KeyCode.OPEN_SQUARE_BRACKET:
                    case KeyCode.BACKSLASH:
                    case KeyCode.CLOSE_SQUARE_BRACKET:
                      return !0;

                    default:
                      return !1;
                  }
              }
          };
          const es_KeyCode = KeyCode;
          var rc_switch_es_excluded = [ "prefixCls", "className", "checked", "defaultChecked", "disabled", "loadingIcon", "checkedChildren", "unCheckedChildren", "onClick", "onChange", "onKeyDown" ], Switch = react.forwardRef((function(_ref, ref) {
              var _classNames, _ref$prefixCls = _ref.prefixCls, prefixCls = void 0 === _ref$prefixCls ? "rc-switch" : _ref$prefixCls, className = _ref.className, checked = _ref.checked, defaultChecked = _ref.defaultChecked, disabled = _ref.disabled, loadingIcon = _ref.loadingIcon, checkedChildren = _ref.checkedChildren, unCheckedChildren = _ref.unCheckedChildren, onClick = _ref.onClick, onChange = _ref.onChange, onKeyDown = _ref.onKeyDown, restProps = objectWithoutProperties_objectWithoutProperties(_ref, rc_switch_es_excluded), _useMergedState2 = slicedToArray_slicedToArray(useMergedState(!1, {
                  value: checked,
                  defaultValue: defaultChecked
              }), 2), innerChecked = _useMergedState2[0], setInnerChecked = _useMergedState2[1];
              function triggerChange(newChecked, event) {
                  var mergedChecked = innerChecked;
                  return disabled || (setInnerChecked(mergedChecked = newChecked), null == onChange || onChange(mergedChecked, event)), 
                  mergedChecked;
              }
              var switchClassName = classnames_default()(prefixCls, className, (defineProperty_defineProperty(_classNames = {}, "".concat(prefixCls, "-checked"), innerChecked), 
              defineProperty_defineProperty(_classNames, "".concat(prefixCls, "-disabled"), disabled), 
              _classNames));
              return react.createElement("button", _extends({}, restProps, {
                  type: "button",
                  role: "switch",
                  "aria-checked": innerChecked,
                  disabled,
                  className: switchClassName,
                  ref,
                  onKeyDown: function(e) {
                      e.which === es_KeyCode.LEFT ? triggerChange(!1, e) : e.which === es_KeyCode.RIGHT && triggerChange(!0, e), 
                      null == onKeyDown || onKeyDown(e);
                  },
                  onClick: function(e) {
                      var ret = triggerChange(!innerChecked, e);
                      null == onClick || onClick(ret, e);
                  }
              }), loadingIcon, react.createElement("span", {
                  className: "".concat(prefixCls, "-inner")
              }, react.createElement("span", {
                  className: "".concat(prefixCls, "-inner-checked")
              }, checkedChildren), react.createElement("span", {
                  className: "".concat(prefixCls, "-inner-unchecked")
              }, unCheckedChildren)));
          }));
          Switch.displayName = "Switch";
          const rc_switch_es = Switch, genSwitchSmallStyle = token => {
              const {componentCls, trackHeightSM, trackPadding, trackMinWidthSM, innerMinMarginSM, innerMaxMarginSM, handleSizeSM} = token, switchInnerCls = `${componentCls}-inner`;
              return {
                  [componentCls]: {
                      [`&${componentCls}-small`]: {
                          minWidth: trackMinWidthSM,
                          height: trackHeightSM,
                          lineHeight: `${trackHeightSM}px`,
                          [`${componentCls}-inner`]: {
                              paddingInlineStart: innerMaxMarginSM,
                              paddingInlineEnd: innerMinMarginSM,
                              [`${switchInnerCls}-checked`]: {
                                  marginInlineStart: `calc(-100% + ${handleSizeSM + 2 * trackPadding}px - ${2 * innerMaxMarginSM}px)`,
                                  marginInlineEnd: `calc(100% - ${handleSizeSM + 2 * trackPadding}px + ${2 * innerMaxMarginSM}px)`
                              },
                              [`${switchInnerCls}-unchecked`]: {
                                  marginTop: -trackHeightSM,
                                  marginInlineStart: 0,
                                  marginInlineEnd: 0
                              }
                          },
                          [`${componentCls}-handle`]: {
                              width: handleSizeSM,
                              height: handleSizeSM
                          },
                          [`${componentCls}-loading-icon`]: {
                              top: (handleSizeSM - token.switchLoadingIconSize) / 2,
                              fontSize: token.switchLoadingIconSize
                          },
                          [`&${componentCls}-checked`]: {
                              [`${componentCls}-inner`]: {
                                  paddingInlineStart: innerMinMarginSM,
                                  paddingInlineEnd: innerMaxMarginSM,
                                  [`${switchInnerCls}-checked`]: {
                                      marginInlineStart: 0,
                                      marginInlineEnd: 0
                                  },
                                  [`${switchInnerCls}-unchecked`]: {
                                      marginInlineStart: `calc(100% - ${handleSizeSM + 2 * trackPadding}px + ${2 * innerMaxMarginSM}px)`,
                                      marginInlineEnd: `calc(-100% + ${handleSizeSM + 2 * trackPadding}px - ${2 * innerMaxMarginSM}px)`
                                  }
                              },
                              [`${componentCls}-handle`]: {
                                  insetInlineStart: `calc(100% - ${handleSizeSM + trackPadding}px)`
                              }
                          },
                          [`&:not(${componentCls}-disabled):active`]: {
                              [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
                                  [`${switchInnerCls}-unchecked`]: {
                                      marginInlineStart: token.marginXXS / 2,
                                      marginInlineEnd: -token.marginXXS / 2
                                  }
                              },
                              [`&${componentCls}-checked ${switchInnerCls}`]: {
                                  [`${switchInnerCls}-checked`]: {
                                      marginInlineStart: -token.marginXXS / 2,
                                      marginInlineEnd: token.marginXXS / 2
                                  }
                              }
                          }
                      }
                  }
              };
          }, genSwitchLoadingStyle = token => {
              const {componentCls, handleSize} = token;
              return {
                  [componentCls]: {
                      [`${componentCls}-loading-icon${token.iconCls}`]: {
                          position: "relative",
                          top: (handleSize - token.fontSize) / 2,
                          color: token.switchLoadingIconColor,
                          verticalAlign: "top"
                      },
                      [`&${componentCls}-checked ${componentCls}-loading-icon`]: {
                          color: token.switchColor
                      }
                  }
              };
          }, genSwitchHandleStyle = token => {
              const {componentCls, motion, trackPadding, handleBg, handleShadow, handleSize} = token, switchHandleCls = `${componentCls}-handle`;
              return {
                  [componentCls]: {
                      [switchHandleCls]: {
                          position: "absolute",
                          top: trackPadding,
                          insetInlineStart: trackPadding,
                          width: handleSize,
                          height: handleSize,
                          transition: `all ${token.switchDuration} ease-in-out`,
                          "&::before": {
                              position: "absolute",
                              top: 0,
                              insetInlineEnd: 0,
                              bottom: 0,
                              insetInlineStart: 0,
                              backgroundColor: handleBg,
                              borderRadius: handleSize / 2,
                              boxShadow: handleShadow,
                              transition: `all ${token.switchDuration} ease-in-out`,
                              content: '""'
                          }
                      },
                      [`&${componentCls}-checked ${switchHandleCls}`]: {
                          insetInlineStart: `calc(100% - ${handleSize + trackPadding}px)`
                      },
                      [`&:not(${componentCls}-disabled):active`]: motion ? {
                          [`${switchHandleCls}::before`]: {
                              insetInlineEnd: token.switchHandleActiveInset,
                              insetInlineStart: 0
                          },
                          [`&${componentCls}-checked ${switchHandleCls}::before`]: {
                              insetInlineEnd: 0,
                              insetInlineStart: token.switchHandleActiveInset
                          }
                      } : {}
                  }
              };
          }, genSwitchInnerStyle = token => {
              const {componentCls, trackHeight, trackPadding, innerMinMargin, innerMaxMargin, handleSize} = token, switchInnerCls = `${componentCls}-inner`;
              return {
                  [componentCls]: {
                      [switchInnerCls]: {
                          display: "block",
                          overflow: "hidden",
                          borderRadius: 100,
                          height: "100%",
                          paddingInlineStart: innerMaxMargin,
                          paddingInlineEnd: innerMinMargin,
                          transition: `padding-inline-start ${token.switchDuration} ease-in-out, padding-inline-end ${token.switchDuration} ease-in-out`,
                          [`${switchInnerCls}-checked, ${switchInnerCls}-unchecked`]: {
                              display: "block",
                              color: token.colorTextLightSolid,
                              fontSize: token.fontSizeSM,
                              transition: `margin-inline-start ${token.switchDuration} ease-in-out, margin-inline-end ${token.switchDuration} ease-in-out`,
                              pointerEvents: "none"
                          },
                          [`${switchInnerCls}-checked`]: {
                              marginInlineStart: `calc(-100% + ${handleSize + 2 * trackPadding}px - ${2 * innerMaxMargin}px)`,
                              marginInlineEnd: `calc(100% - ${handleSize + 2 * trackPadding}px + ${2 * innerMaxMargin}px)`
                          },
                          [`${switchInnerCls}-unchecked`]: {
                              marginTop: -trackHeight,
                              marginInlineStart: 0,
                              marginInlineEnd: 0
                          }
                      },
                      [`&${componentCls}-checked ${switchInnerCls}`]: {
                          paddingInlineStart: innerMinMargin,
                          paddingInlineEnd: innerMaxMargin,
                          [`${switchInnerCls}-checked`]: {
                              marginInlineStart: 0,
                              marginInlineEnd: 0
                          },
                          [`${switchInnerCls}-unchecked`]: {
                              marginInlineStart: `calc(100% - ${handleSize + 2 * trackPadding}px + ${2 * innerMaxMargin}px)`,
                              marginInlineEnd: `calc(-100% + ${handleSize + 2 * trackPadding}px - ${2 * innerMaxMargin}px)`
                          }
                      },
                      [`&:not(${componentCls}-disabled):active`]: {
                          [`&:not(${componentCls}-checked) ${switchInnerCls}`]: {
                              [`${switchInnerCls}-unchecked`]: {
                                  marginInlineStart: 2 * trackPadding,
                                  marginInlineEnd: 2 * -trackPadding
                              }
                          },
                          [`&${componentCls}-checked ${switchInnerCls}`]: {
                              [`${switchInnerCls}-checked`]: {
                                  marginInlineStart: 2 * -trackPadding,
                                  marginInlineEnd: 2 * trackPadding
                              }
                          }
                      }
                  }
              };
          }, genSwitchStyle = token => {
              const {componentCls, trackHeight, trackMinWidth} = token;
              return {
                  [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token)), {
                      position: "relative",
                      display: "inline-block",
                      boxSizing: "border-box",
                      minWidth: trackMinWidth,
                      height: trackHeight,
                      lineHeight: `${trackHeight}px`,
                      verticalAlign: "middle",
                      background: token.colorTextQuaternary,
                      border: "0",
                      borderRadius: 100,
                      cursor: "pointer",
                      transition: `all ${token.motionDurationMid}`,
                      userSelect: "none",
                      [`&:hover:not(${componentCls}-disabled)`]: {
                          background: token.colorTextTertiary
                      }
                  }), genFocusStyle(token)), {
                      [`&${componentCls}-checked`]: {
                          background: token.switchColor,
                          [`&:hover:not(${componentCls}-disabled)`]: {
                              background: token.colorPrimaryHover
                          }
                      },
                      [`&${componentCls}-loading, &${componentCls}-disabled`]: {
                          cursor: "not-allowed",
                          opacity: token.switchDisabledOpacity,
                          "*": {
                              boxShadow: "none",
                              cursor: "not-allowed"
                          }
                      },
                      [`&${componentCls}-rtl`]: {
                          direction: "rtl"
                      }
                  })
              };
          }, switch_style = genComponentStyleHook("Switch", (token => {
              const switchToken = statistic_merge(token, {
                  switchDuration: token.motionDurationMid,
                  switchColor: token.colorPrimary,
                  switchDisabledOpacity: token.opacityLoading,
                  switchLoadingIconSize: .75 * token.fontSizeIcon,
                  switchLoadingIconColor: `rgba(0, 0, 0, ${token.opacityLoading})`,
                  switchHandleActiveInset: "-30%"
              });
              return [ genSwitchStyle(switchToken), genSwitchInnerStyle(switchToken), genSwitchHandleStyle(switchToken), genSwitchLoadingStyle(switchToken), genSwitchSmallStyle(switchToken) ];
          }), (token => {
              const {fontSize, lineHeight, controlHeight, colorWhite} = token, height = fontSize * lineHeight, heightSM = controlHeight / 2, handleSize = height - 4, handleSizeSM = heightSM - 4;
              return {
                  trackHeight: height,
                  trackHeightSM: heightSM,
                  trackMinWidth: 2 * handleSize + 8,
                  trackMinWidthSM: 2 * handleSizeSM + 4,
                  trackPadding: 2,
                  handleBg: colorWhite,
                  handleSize,
                  handleSizeSM,
                  handleShadow: `0 2px 4px 0 ${new TinyColor("#00230b").setAlpha(.2).toRgbString()}`,
                  innerMinMargin: handleSize / 2,
                  innerMaxMargin: handleSize + 2 + 4,
                  innerMinMarginSM: handleSizeSM / 2,
                  innerMaxMarginSM: handleSizeSM + 2 + 4
              };
          }));
          var switch_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const switch_Switch = react.forwardRef(((props, ref) => {
              const {prefixCls: customizePrefixCls, size: customizeSize, disabled: customDisabled, loading, className, rootClassName, style} = props, restProps = switch_rest(props, [ "prefixCls", "size", "disabled", "loading", "className", "rootClassName", "style" ]);
              const {getPrefixCls, direction, switch: SWITCH} = react.useContext(context_ConfigContext), disabled = react.useContext(config_provider_DisabledContext), mergedDisabled = (null != customDisabled ? customDisabled : disabled) || loading, prefixCls = getPrefixCls("switch", customizePrefixCls), loadingIcon = react.createElement("div", {
                  className: `${prefixCls}-handle`
              }, loading && react.createElement(icons_LoadingOutlined, {
                  className: `${prefixCls}-loading-icon`
              })), [wrapSSR, hashId] = switch_style(prefixCls), mergedSize = hooks_useSize(customizeSize), classes = classnames_default()(null == SWITCH ? void 0 : SWITCH.className, {
                  [`${prefixCls}-small`]: "small" === mergedSize,
                  [`${prefixCls}-loading`]: loading,
                  [`${prefixCls}-rtl`]: "rtl" === direction
              }, className, rootClassName, hashId), mergedStyle = Object.assign(Object.assign({}, null == SWITCH ? void 0 : SWITCH.style), style);
              return wrapSSR(react.createElement(wave, {
                  component: "Switch"
              }, react.createElement(rc_switch_es, Object.assign({}, restProps, {
                  prefixCls,
                  className: classes,
                  style: mergedStyle,
                  disabled: mergedDisabled,
                  ref,
                  loadingIcon
              }))));
          }));
          switch_Switch.__ANT_SWITCH = !0;
          const es_switch = switch_Switch, uiConfigPopUp_index_module_popup = "dtgqYVSFHxPk8JKvZqFS", uiConfigPopUp_index_module_top = "AfcLHQ4ghFAlv_FmcHzB", uiConfigPopUp_index_module_secondly = "aTsZ5JVPZoz5eyKWumCZ", uiConfigPopUp_index_module_header = "e0K2RIFdkfQo1yNl4E0S", uiConfigPopUp_index_module_back = "obyD7NomxRc1vLSxlcz7", uiConfigPopUp_index_module_content = "w0ds71zoseWHRBUJvGcZ", uiConfigPopUp_index_module_menu = "U1fzsNISlSgmwiJcVkY4", uiConfigPopUp_index_module_item = "P4xINdgeY_8GakLrvFiP", uiConfigPopUp_index_module_checked = "evNjUu40m8imAIExwOQO", uiConfigPopUp_index_module_action = "vDqxnkU0RFkzc20iC1cO", uiConfigPopUp_index_module_label = "H1WPJh0R5N9QYXZ1o0yb", user_module_user = "DmeRueUWdISHItR_6cEq", user_module_avatar = "seQbuwKR1xnL8JiCysiK", user_module_info = "GotpCxbAmD5uanIswBIz", user_module_name = "f6yIGPg8yxDA3AsYtbLD", user_module_count = "YLQXsDCsr8NP1GlyXE7r", onClickUser = () => {
              const {logined} = user.getState();
              logined ? (() => {
                  const url = `${userUrl}/account`;
                  trackEvent({
                      event_type: "SubtitleClick",
                      trigger_type: "Manual",
                      trigger_control: "ToAccount",
                      Data: {
                          user_url: url
                      }
                  }), window.open(url);
              })() : onLoginWithoutCheck();
          };
          const uiConfigPopUp_user = function() {
              const isLogin = useLogined(), userInfo = useUserStore((({info}) => info)), count = useLimitStore((({count}) => formatSeconds(count || 0))), name = isLogin ? userInfo?.name || userInfo?.email || "" : chrome.i18n.getMessage("not_login");
              return (0, jsx_runtime.jsx)("div", {
                  className: uiConfigPopUp_index_module_menu,
                  children: (0, jsx_runtime.jsxs)("div", {
                      className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action, user_module_user),
                      onClick: onClickUser,
                      children: [ (0, jsx_runtime.jsx)("div", {
                          className: user_module_avatar,
                          children: name.slice(0, 1).toLocaleUpperCase()
                      }), (0, jsx_runtime.jsxs)("div", {
                          className: user_module_info,
                          children: [ (0, jsx_runtime.jsx)("p", {
                              className: user_module_name,
                              children: name
                          }), (0, jsx_runtime.jsx)("p", {
                              className: user_module_count,
                              children: `${chrome.i18n.getMessage("limit")}: ${count}`
                          }) ]
                      }) ]
                  })
              });
          }, languages = [ {
              value: "en",
              label: chrome.i18n.getMessage("English")
          }, {
              value: "ja",
              label: chrome.i18n.getMessage("Japanese")
          }, {
              value: "zh_hans",
              label: chrome.i18n.getMessage("Chinese")
          }, {
              value: "zh_hant",
              label: chrome.i18n.getMessage("zh_TW")
          }, {
              value: "th",
              label: chrome.i18n.getMessage("th_TH")
          }, {
              value: "es",
              label: chrome.i18n.getMessage("es_ES")
          }, {
              value: "de",
              label: chrome.i18n.getMessage("de_DE")
          }, {
              value: "fr",
              label: chrome.i18n.getMessage("fr_FR")
          }, {
              value: "ru",
              label: chrome.i18n.getMessage("ru_RU")
          }, {
              value: "ko",
              label: chrome.i18n.getMessage("ko_KR")
          }, {
              value: "pt",
              label: chrome.i18n.getMessage("pt_PT")
          }, {
              value: "hi",
              label: chrome.i18n.getMessage("hi_IN")
          } ];
          const uiConfigPopUp_language = function({value, onChange, onBack}) {
              return (0, jsx_runtime.jsxs)("div", {
                  className: uiConfigPopUp_index_module_secondly,
                  children: [ (0, jsx_runtime.jsxs)("header", {
                      className: uiConfigPopUp_index_module_header,
                      children: [ (0, jsx_runtime.jsx)("span", {
                          className: uiConfigPopUp_index_module_back,
                          onClick: e => onBack(e)
                      }), (0, jsx_runtime.jsx)("span", {
                          children: chrome.i18n.getMessage("translation")
                      }) ]
                  }), (0, jsx_runtime.jsx)("main", {
                      className: uiConfigPopUp_index_module_content,
                      children: (0, jsx_runtime.jsx)("div", {
                          className: uiConfigPopUp_index_module_menu,
                          children: languages.map((item => (0, jsx_runtime.jsx)("span", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, item.value === value && uiConfigPopUp_index_module_checked),
                              role: "radio",
                              "aria-checked": !1,
                              onClick: ev => ((ev, value) => {
                                  ev.stopPropagation(), onChange(value);
                              })(ev, item.value),
                              children: item.label
                          }, item.value)))
                      })
                  }) ]
              });
          };
          const es_context = react.createContext({
              min: 0,
              max: 0,
              direction: "ltr",
              step: 1,
              includedStart: 0,
              includedEnd: 0,
              tabIndex: 0,
              keyboard: !0,
              styles: {},
              classNames: {}
          });
          function getOffset(value, min, max) {
              return (value - min) / (max - min);
          }
          function getDirectionStyle(direction, value, min, max) {
              var offset = getOffset(value, min, max), positionStyle = {};
              switch (direction) {
                case "rtl":
                  positionStyle.right = "".concat(100 * offset, "%"), positionStyle.transform = "translateX(50%)";
                  break;

                case "btt":
                  positionStyle.bottom = "".concat(100 * offset, "%"), positionStyle.transform = "translateY(50%)";
                  break;

                case "ttb":
                  positionStyle.top = "".concat(100 * offset, "%"), positionStyle.transform = "translateY(-50%)";
                  break;

                default:
                  positionStyle.left = "".concat(100 * offset, "%"), positionStyle.transform = "translateX(-50%)";
              }
              return positionStyle;
          }
          function getIndex(value, index) {
              return Array.isArray(value) ? value[index] : value;
          }
          var Handle_excluded = [ "prefixCls", "value", "valueIndex", "onStartMove", "style", "render", "dragging", "onOffsetChange" ], Handle = react.forwardRef((function(props, ref) {
              var _cls, _getIndex, prefixCls = props.prefixCls, value = props.value, valueIndex = props.valueIndex, onStartMove = props.onStartMove, style = props.style, render = props.render, dragging = props.dragging, onOffsetChange = props.onOffsetChange, restProps = objectWithoutProperties_objectWithoutProperties(props, Handle_excluded), _React$useContext = react.useContext(es_context), min = _React$useContext.min, max = _React$useContext.max, direction = _React$useContext.direction, disabled = _React$useContext.disabled, keyboard = _React$useContext.keyboard, range = _React$useContext.range, tabIndex = _React$useContext.tabIndex, ariaLabelForHandle = _React$useContext.ariaLabelForHandle, ariaLabelledByForHandle = _React$useContext.ariaLabelledByForHandle, ariaValueTextFormatterForHandle = _React$useContext.ariaValueTextFormatterForHandle, styles = _React$useContext.styles, classNames = _React$useContext.classNames, handlePrefixCls = "".concat(prefixCls, "-handle"), onInternalStartMove = function(e) {
                  disabled || onStartMove(e, valueIndex);
              }, positionStyle = getDirectionStyle(direction, value, min, max), handleNode = react.createElement("div", _extends({
                  ref,
                  className: classnames_default()(handlePrefixCls, (_cls = {}, defineProperty_defineProperty(_cls, "".concat(handlePrefixCls, "-").concat(valueIndex + 1), range), 
                  defineProperty_defineProperty(_cls, "".concat(handlePrefixCls, "-dragging"), dragging), 
                  _cls), classNames.handle),
                  style: _objectSpread2(_objectSpread2(_objectSpread2({}, positionStyle), style), styles.handle),
                  onMouseDown: onInternalStartMove,
                  onTouchStart: onInternalStartMove,
                  onKeyDown: function(e) {
                      if (!disabled && keyboard) {
                          var offset = null;
                          switch (e.which || e.keyCode) {
                            case es_KeyCode.LEFT:
                              offset = "ltr" === direction || "btt" === direction ? -1 : 1;
                              break;

                            case es_KeyCode.RIGHT:
                              offset = "ltr" === direction || "btt" === direction ? 1 : -1;
                              break;

                            case es_KeyCode.UP:
                              offset = "ttb" !== direction ? 1 : -1;
                              break;

                            case es_KeyCode.DOWN:
                              offset = "ttb" !== direction ? -1 : 1;
                              break;

                            case es_KeyCode.HOME:
                              offset = "min";
                              break;

                            case es_KeyCode.END:
                              offset = "max";
                              break;

                            case es_KeyCode.PAGE_UP:
                              offset = 2;
                              break;

                            case es_KeyCode.PAGE_DOWN:
                              offset = -2;
                          }
                          null !== offset && (e.preventDefault(), onOffsetChange(offset, valueIndex));
                      }
                  },
                  tabIndex: disabled ? null : getIndex(tabIndex, valueIndex),
                  role: "slider",
                  "aria-valuemin": min,
                  "aria-valuemax": max,
                  "aria-valuenow": value,
                  "aria-disabled": disabled,
                  "aria-label": getIndex(ariaLabelForHandle, valueIndex),
                  "aria-labelledby": getIndex(ariaLabelledByForHandle, valueIndex),
                  "aria-valuetext": null === (_getIndex = getIndex(ariaValueTextFormatterForHandle, valueIndex)) || void 0 === _getIndex ? void 0 : _getIndex(value),
                  "aria-orientation": "ltr" === direction || "rtl" === direction ? "horizontal" : "vertical"
              }, restProps));
              return render && (handleNode = render(handleNode, {
                  index: valueIndex,
                  prefixCls,
                  value,
                  dragging
              })), handleNode;
          }));
          const Handles_Handle = Handle;
          var Handles_excluded = [ "prefixCls", "style", "onStartMove", "onOffsetChange", "values", "handleRender", "draggingIndex" ], Handles = react.forwardRef((function(props, ref) {
              var prefixCls = props.prefixCls, style = props.style, onStartMove = props.onStartMove, onOffsetChange = props.onOffsetChange, values = props.values, handleRender = props.handleRender, draggingIndex = props.draggingIndex, restProps = objectWithoutProperties_objectWithoutProperties(props, Handles_excluded), handlesRef = react.useRef({});
              return react.useImperativeHandle(ref, (function() {
                  return {
                      focus: function(index) {
                          var _handlesRef$current$i;
                          null === (_handlesRef$current$i = handlesRef.current[index]) || void 0 === _handlesRef$current$i || _handlesRef$current$i.focus();
                      }
                  };
              })), react.createElement(react.Fragment, null, values.map((function(value, index) {
                  return react.createElement(Handles_Handle, _extends({
                      ref: function(node) {
                          node ? handlesRef.current[index] = node : delete handlesRef.current[index];
                      },
                      dragging: draggingIndex === index,
                      prefixCls,
                      style: getIndex(style, index),
                      key: index,
                      value,
                      valueIndex: index,
                      onStartMove,
                      onOffsetChange,
                      render: handleRender
                  }, restProps));
              })));
          }));
          const es_Handles = Handles;
          function getPosition(e) {
              var obj = "touches" in e ? e.touches[0] : e;
              return {
                  pageX: obj.pageX,
                  pageY: obj.pageY
              };
          }
          function Mark(props) {
              var prefixCls = props.prefixCls, style = props.style, children = props.children, value = props.value, _onClick = props.onClick, _React$useContext = react.useContext(es_context), min = _React$useContext.min, max = _React$useContext.max, direction = _React$useContext.direction, includedStart = _React$useContext.includedStart, includedEnd = _React$useContext.includedEnd, included = _React$useContext.included, textCls = "".concat(prefixCls, "-text"), positionStyle = getDirectionStyle(direction, value, min, max);
              return react.createElement("span", {
                  className: classnames_default()(textCls, defineProperty_defineProperty({}, "".concat(textCls, "-active"), included && includedStart <= value && value <= includedEnd)),
                  style: _objectSpread2(_objectSpread2({}, positionStyle), style),
                  onMouseDown: function(e) {
                      e.stopPropagation();
                  },
                  onClick: function() {
                      _onClick(value);
                  }
              }, children);
          }
          function Marks(props) {
              var prefixCls = props.prefixCls, marks = props.marks, onClick = props.onClick, markPrefixCls = "".concat(prefixCls, "-mark");
              return marks.length ? react.createElement("div", {
                  className: markPrefixCls
              }, marks.map((function(_ref) {
                  var value = _ref.value, style = _ref.style, label = _ref.label;
                  return react.createElement(Mark, {
                      key: value,
                      prefixCls: markPrefixCls,
                      style,
                      value,
                      onClick
                  }, label);
              }))) : null;
          }
          function Dot(props) {
              var prefixCls = props.prefixCls, value = props.value, style = props.style, activeStyle = props.activeStyle, _React$useContext = react.useContext(es_context), min = _React$useContext.min, max = _React$useContext.max, direction = _React$useContext.direction, included = _React$useContext.included, includedStart = _React$useContext.includedStart, includedEnd = _React$useContext.includedEnd, dotClassName = "".concat(prefixCls,"-dot"), active = included && includedStart <= value && value <= includedEnd, mergedStyle = _objectSpread2(_objectSpread2({}, getDirectionStyle(direction, value, min, max)), "function" == typeof style ? style(value) : style);
              return active && (mergedStyle = _objectSpread2(_objectSpread2({}, mergedStyle), "function" == typeof activeStyle ? activeStyle(value) : activeStyle)), 
              react.createElement("span", {
                  className: classnames_default()(dotClassName, defineProperty_defineProperty({}, "".concat(dotClassName, "-active"), active)),
                  style: mergedStyle
              });
          }
          function Steps(props) {
              var prefixCls = props.prefixCls, marks = props.marks, dots = props.dots, style = props.style, activeStyle = props.activeStyle, _React$useContext = react.useContext(es_context), min = _React$useContext.min, max = _React$useContext.max, step = _React$useContext.step, stepDots = react.useMemo((function() {
                  var dotSet = new Set;
                  if (marks.forEach((function(mark) {
                      dotSet.add(mark.value);
                  })), dots && null !== step) for (var current = min; current <= max; ) dotSet.add(current), 
                  current += step;
                  return Array.from(dotSet);
              }), [ min, max, step, dots, marks ]);
              return react.createElement("div", {
                  className: "".concat(prefixCls, "-step")
              }, stepDots.map((function(dotValue) {
                  return react.createElement(Dot, {
                      prefixCls,
                      key: dotValue,
                      value: dotValue,
                      style,
                      activeStyle
                  });
              })));
          }
          function Track(props) {
              var _cls, prefixCls = props.prefixCls, style = props.style, start = props.start, end = props.end, index = props.index, onStartMove = props.onStartMove, replaceCls = props.replaceCls, _React$useContext = react.useContext(es_context), direction = _React$useContext.direction, min = _React$useContext.min, max = _React$useContext.max, disabled = _React$useContext.disabled, range = _React$useContext.range, classNames = _React$useContext.classNames, trackPrefixCls = "".concat(prefixCls, "-track"), offsetStart = getOffset(start, min, max), offsetEnd = getOffset(end, min, max), onInternalStartMove = function(e) {
                  !disabled && onStartMove && onStartMove(e, -1);
              }, positionStyle = {};
              switch (direction) {
                case "rtl":
                  positionStyle.right = "".concat(100 * offsetStart, "%"), positionStyle.width = "".concat(100 * offsetEnd - 100 * offsetStart, "%");
                  break;

                case "btt":
                  positionStyle.bottom = "".concat(100 * offsetStart, "%"), positionStyle.height = "".concat(100 * offsetEnd - 100 * offsetStart, "%");
                  break;

                case "ttb":
                  positionStyle.top = "".concat(100 * offsetStart, "%"), positionStyle.height = "".concat(100 * offsetEnd - 100 * offsetStart, "%");
                  break;

                default:
                  positionStyle.left = "".concat(100 * offsetStart, "%"), positionStyle.width = "".concat(100 * offsetEnd - 100 * offsetStart, "%");
              }
              var className = replaceCls || classnames_default()(trackPrefixCls, (defineProperty_defineProperty(_cls = {}, "".concat(trackPrefixCls, "-").concat(index + 1), null !== index && range), 
              defineProperty_defineProperty(_cls, "".concat(prefixCls, "-track-draggable"), onStartMove), 
              _cls), classNames.track);
              return react.createElement("div", {
                  className,
                  style: _objectSpread2(_objectSpread2({}, positionStyle), style),
                  onMouseDown: onInternalStartMove,
                  onTouchStart: onInternalStartMove
              });
          }
          function Tracks(props) {
              var prefixCls = props.prefixCls, style = props.style, values = props.values, startPoint = props.startPoint, onStartMove = props.onStartMove, _React$useContext = react.useContext(es_context), included = _React$useContext.included, range = _React$useContext.range, min = _React$useContext.min, styles = _React$useContext.styles, classNames = _React$useContext.classNames, trackList = react.useMemo((function() {
                  if (!range) {
                      if (0 === values.length) return [];
                      var startValue = null != startPoint ? startPoint : min, endValue = values[0];
                      return [ {
                          start: Math.min(startValue, endValue),
                          end: Math.max(startValue, endValue)
                      } ];
                  }
                  for (var list = [], i = 0; i < values.length - 1; i += 1) list.push({
                      start: values[i],
                      end: values[i + 1]
                  });
                  return list;
              }), [ values, range, startPoint, min ]), tracksNode = null;
              return (classNames.tracks || styles.tracks) && (tracksNode = react.createElement(Track, {
                  index: null,
                  prefixCls,
                  start: trackList[0].start,
                  end: trackList[trackList.length - 1].end,
                  replaceCls: classnames_default()(classNames.tracks, "".concat(prefixCls, "-tracks")),
                  style: styles.tracks
              })), included ? react.createElement(react.Fragment, null, tracksNode, trackList.map((function(_ref, index) {
                  var start = _ref.start, end = _ref.end;
                  return react.createElement(Track, {
                      index,
                      prefixCls,
                      style: _objectSpread2(_objectSpread2({}, getIndex(style, index)), styles.track),
                      start,
                      end,
                      key: index,
                      onStartMove
                  });
              }))) : null;
          }
          var Slider = react.forwardRef((function(props, ref) {
              var _cls, _props$prefixCls = props.prefixCls, prefixCls = void 0 === _props$prefixCls ? "rc-slider" : _props$prefixCls, className = props.className, style = props.style, classNames = props.classNames, styles = props.styles, _props$disabled = props.disabled, disabled = void 0 !== _props$disabled && _props$disabled, _props$keyboard = props.keyboard, keyboard = void 0 === _props$keyboard || _props$keyboard, autoFocus = props.autoFocus, onFocus = props.onFocus, onBlur = props.onBlur, _props$min = props.min, min = void 0 === _props$min ? 0 : _props$min, _props$max = props.max, max = void 0 === _props$max ? 100 : _props$max, _props$step = props.step, step = void 0 === _props$step ? 1 : _props$step, value = props.value, defaultValue = props.defaultValue, range = props.range, count = props.count, onChange = props.onChange, onBeforeChange = props.onBeforeChange, onAfterChange = props.onAfterChange, _props$allowCross = props.allowCross, allowCross = void 0 === _props$allowCross || _props$allowCross, _props$pushable = props.pushable, pushable = void 0 !== _props$pushable && _props$pushable, draggableTrack = props.draggableTrack, reverse = props.reverse, vertical = props.vertical, _props$included = props.included, included = void 0 === _props$included || _props$included, startPoint = props.startPoint, trackStyle = props.trackStyle, handleStyle = props.handleStyle, railStyle = props.railStyle, dotStyle = props.dotStyle, activeDotStyle = props.activeDotStyle, marks = props.marks, dots = props.dots, handleRender = props.handleRender, _props$tabIndex = props.tabIndex, tabIndex = void 0 === _props$tabIndex ? 0 : _props$tabIndex, ariaLabelForHandle = props.ariaLabelForHandle, ariaLabelledByForHandle = props.ariaLabelledByForHandle, ariaValueTextFormatterForHandle = props.ariaValueTextFormatterForHandle, handlesRef = react.useRef(), containerRef = react.useRef(), direction = react.useMemo((function() {
                  return vertical ? reverse ? "ttb" : "btt" : reverse ? "rtl" : "ltr";
              }), [ reverse, vertical ]), mergedMin = react.useMemo((function() {
                  return isFinite(min) ? min : 0;
              }), [ min ]), mergedMax = react.useMemo((function() {
                  return isFinite(max) ? max : 100;
              }), [ max ]), mergedStep = react.useMemo((function() {
                  return null !== step && step <= 0 ? 1 : step;
              }), [ step ]), mergedPush = react.useMemo((function() {
                  return "boolean" == typeof pushable ? !!pushable && mergedStep : pushable >= 0 && pushable;
              }), [ pushable, mergedStep ]), markList = react.useMemo((function() {
                  return Object.keys(marks || {}).map((function(key) {
                      var mark = marks[key], markObj = {
                          value: Number(key)
                      };
                      return mark && "object" === _typeof(mark) && !react.isValidElement(mark) && ("label" in mark || "style" in mark) ? (markObj.style = mark.style, 
                      markObj.label = mark.label) : markObj.label = mark, markObj;
                  })).filter((function(_ref) {
                      var label = _ref.label;
                      return label || "number" == typeof label;
                  })).sort((function(a, b) {
                      return a.value - b.value;
                  }));
              }), [ marks ]), _useOffset = function(min, max, step, markList, allowCross, pushable) {
                  var formatRangeValue = react.useCallback((function(val) {
                      var formatNextValue = isFinite(val) ? val : min;
                      return formatNextValue = Math.min(max, val), Math.max(min, formatNextValue);
                  }), [ min, max ]), formatStepValue = react.useCallback((function(val) {
                      if (null !== step) {
                          var stepValue = min + Math.round((formatRangeValue(val) - min) / step) * step, getDecimal = function(num) {
                              return (String(num).split(".")[1] || "").length;
                          }, maxDecimal = Math.max(getDecimal(step), getDecimal(max), getDecimal(min)), fixedValue = Number(stepValue.toFixed(maxDecimal));
                          return min <= fixedValue && fixedValue <= max ? fixedValue : null;
                      }
                      return null;
                  }), [ step, min, max, formatRangeValue ]), formatValue = react.useCallback((function(val) {
                      var formatNextValue = formatRangeValue(val), alignValues = markList.map((function(mark) {
                          return mark.value;
                      }));
                      null !== step && alignValues.push(formatStepValue(val)), alignValues.push(min, max);
                      var closeValue = alignValues[0], closeDist = max - min;
                      return alignValues.forEach((function(alignValue) {
                          var dist = Math.abs(formatNextValue - alignValue);
                          dist <= closeDist && (closeValue = alignValue, closeDist = dist);
                      })), closeValue;
                  }), [ min, max, markList, step, formatRangeValue, formatStepValue ]), offsetValue = function offsetValue(values, offset, valueIndex) {
                      var mode = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "unit";
                      if ("number" == typeof offset) {
                          var nextValue, originValue = values[valueIndex], targetDistValue = originValue + offset, potentialValues = [];
                          markList.forEach((function(mark) {
                              potentialValues.push(mark.value);
                          })), potentialValues.push(min, max), potentialValues.push(formatStepValue(originValue));
                          var sign = offset > 0 ? 1 : -1;
                          "unit" === mode ? potentialValues.push(formatStepValue(originValue + sign * step)) : potentialValues.push(formatStepValue(targetDistValue)), 
                          potentialValues = potentialValues.filter((function(val) {
                              return null !== val;
                          })).filter((function(val) {
                              return offset < 0 ? val <= originValue : val >= originValue;
                          })), "unit" === mode && (potentialValues = potentialValues.filter((function(val) {
                              return val !== originValue;
                          })));
                          var compareValue = "unit" === mode ? originValue : targetDistValue;
                          nextValue = potentialValues[0];
                          var valueDist = Math.abs(nextValue - compareValue);
                          if (potentialValues.forEach((function(potentialValue) {
                              var dist = Math.abs(potentialValue - compareValue);
                              dist < valueDist && (nextValue = potentialValue, valueDist = dist);
                          })), void 0 === nextValue) return offset < 0 ? min : max;
                          if ("dist" === mode) return nextValue;
                          if (Math.abs(offset) > 1) {
                              var cloneValues = _toConsumableArray(values);
                              return cloneValues[valueIndex] = nextValue, offsetValue(cloneValues, offset - sign, valueIndex, mode);
                          }
                          return nextValue;
                      }
                      return "min" === offset ? min : "max" === offset ? max : void 0;
                  }, offsetChangedValue = function(values, offset, valueIndex) {
                      var mode = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "unit", originValue = values[valueIndex], nextValue = offsetValue(values, offset, valueIndex, mode);
                      return {
                          value: nextValue,
                          changed: nextValue !== originValue
                      };
                  }, needPush = function(dist) {
                      return null === pushable && 0 === dist || "number" == typeof pushable && dist < pushable;
                  };
                  return [ formatValue, function(values, offset, valueIndex) {
                      var mode = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "unit", nextValues = values.map(formatValue), originValue = nextValues[valueIndex], nextValue = offsetValue(nextValues, offset, valueIndex, mode);
                      if (nextValues[valueIndex] = nextValue, !1 === allowCross) {
                          var pushNum = pushable || 0;
                          valueIndex > 0 && nextValues[valueIndex - 1] !== originValue && (nextValues[valueIndex] = Math.max(nextValues[valueIndex], nextValues[valueIndex - 1] + pushNum)), 
                          valueIndex < nextValues.length - 1 && nextValues[valueIndex + 1] !== originValue && (nextValues[valueIndex] = Math.min(nextValues[valueIndex], nextValues[valueIndex + 1] - pushNum));
                      } else if ("number" == typeof pushable || null === pushable) {
                          for (var i = valueIndex + 1; i < nextValues.length; i += 1) for (var changed = !0; needPush(nextValues[i] - nextValues[i - 1]) && changed; ) {
                              var _offsetChangedValue = offsetChangedValue(nextValues, 1, i);
                              nextValues[i] = _offsetChangedValue.value, changed = _offsetChangedValue.changed;
                          }
                          for (var _i = valueIndex; _i > 0; _i -= 1) for (var _changed = !0; needPush(nextValues[_i] - nextValues[_i - 1]) && _changed; ) {
                              var _offsetChangedValue2 = offsetChangedValue(nextValues, -1, _i - 1);
                              nextValues[_i - 1] = _offsetChangedValue2.value, _changed = _offsetChangedValue2.changed;
                          }
                          for (var _i2 = nextValues.length - 1; _i2 > 0; _i2 -= 1) for (var _changed2 = !0; needPush(nextValues[_i2] - nextValues[_i2 - 1]) && _changed2; ) {
                              var _offsetChangedValue3 = offsetChangedValue(nextValues, -1, _i2 - 1);
                              nextValues[_i2 - 1] = _offsetChangedValue3.value, _changed2 = _offsetChangedValue3.changed;
                          }
                          for (var _i3 = 0; _i3 < nextValues.length - 1; _i3 += 1) for (var _changed3 = !0; needPush(nextValues[_i3 + 1] - nextValues[_i3]) && _changed3; ) {
                              var _offsetChangedValue4 = offsetChangedValue(nextValues, 1, _i3 + 1);
                              nextValues[_i3 + 1] = _offsetChangedValue4.value, _changed3 = _offsetChangedValue4.changed;
                          }
                      }
                      return {
                          value: nextValues[valueIndex],
                          values: nextValues
                      };
                  } ];
              }(mergedMin, mergedMax, mergedStep, markList, allowCross, mergedPush), _useOffset2 = slicedToArray_slicedToArray(_useOffset, 2), formatValue = _useOffset2[0], offsetValues = _useOffset2[1], _useMergedState2 = slicedToArray_slicedToArray(useMergedState(defaultValue, {
                  value
              }), 2), mergedValue = _useMergedState2[0], setValue = _useMergedState2[1], rawValues = react.useMemo((function() {
                  var valueList = null == mergedValue ? [] : Array.isArray(mergedValue) ? mergedValue : [ mergedValue ], _valueList$ = slicedToArray_slicedToArray(valueList, 1)[0], returnValues = null === mergedValue ? [] : [ void 0 === _valueList$ ? mergedMin : _valueList$ ];
                  if (range) {
                      if (returnValues = _toConsumableArray(valueList), count || void 0 === mergedValue) {
                          var pointCount = count >= 0 ? count + 1 : 2;
                          for (returnValues = returnValues.slice(0, pointCount); returnValues.length < pointCount; ) {
                              var _returnValues;
                              returnValues.push(null !== (_returnValues = returnValues[returnValues.length - 1]) && void 0 !== _returnValues ? _returnValues : mergedMin);
                          }
                      }
                      returnValues.sort((function(a, b) {
                          return a - b;
                      }));
                  }
                  return returnValues.forEach((function(val, index) {
                      returnValues[index] = formatValue(val);
                  })), returnValues;
              }), [ mergedValue, range, mergedMin, count, formatValue ]), rawValuesRef = react.useRef(rawValues);
              rawValuesRef.current = rawValues;
              var getTriggerValue = function(triggerValues) {
                  return range ? triggerValues : triggerValues[0];
              }, triggerChange = function(nextValues) {
                  var cloneNextValues = _toConsumableArray(nextValues).sort((function(a, b) {
                      return a - b;
                  }));
                  onChange && !es_isEqual(cloneNextValues, rawValuesRef.current, !0) && onChange(getTriggerValue(cloneNextValues)), 
                  setValue(cloneNextValues);
              }, changeToCloseValue = function(newValue) {
                  if (!disabled) {
                      var valueIndex = 0, valueDist = mergedMax - mergedMin;
                      rawValues.forEach((function(val, index) {
                          var dist = Math.abs(newValue - val);
                          dist <= valueDist && (valueDist = dist, valueIndex = index);
                      }));
                      var cloneNextValues = _toConsumableArray(rawValues);
                      cloneNextValues[valueIndex] = newValue, range && !rawValues.length && void 0 === count && cloneNextValues.push(newValue), 
                      null == onBeforeChange || onBeforeChange(getTriggerValue(cloneNextValues)), triggerChange(cloneNextValues), 
                      null == onAfterChange || onAfterChange(getTriggerValue(cloneNextValues));
                  }
              }, _React$useState2 = slicedToArray_slicedToArray(react.useState(null), 2), keyboardValue = _React$useState2[0], setKeyboardValue = _React$useState2[1];
              react.useEffect((function() {
                  if (null !== keyboardValue) {
                      var valueIndex = rawValues.indexOf(keyboardValue);
                      valueIndex >= 0 && handlesRef.current.focus(valueIndex);
                  }
                  setKeyboardValue(null);
              }), [ keyboardValue ]);
              var mergedDraggableTrack = react.useMemo((function() {
                  return (!draggableTrack || null !== mergedStep) && draggableTrack;
              }), [ draggableTrack, mergedStep ]), _useDrag = function(containerRef, direction, rawValues, min, max, formatValue, triggerChange, finishChange, offsetValues) {
                  var _React$useState2 = slicedToArray_slicedToArray(react.useState(null), 2), draggingValue = _React$useState2[0], setDraggingValue = _React$useState2[1], _React$useState4 = slicedToArray_slicedToArray(react.useState(-1), 2), draggingIndex = _React$useState4[0], setDraggingIndex = _React$useState4[1], _React$useState6 = slicedToArray_slicedToArray(react.useState(rawValues), 2), cacheValues = _React$useState6[0], setCacheValues = _React$useState6[1], _React$useState8 = slicedToArray_slicedToArray(react.useState(rawValues), 2), originValues = _React$useState8[0], setOriginValues = _React$useState8[1], mouseMoveEventRef = react.useRef(null), mouseUpEventRef = react.useRef(null);
                  react.useEffect((function() {
                      -1 === draggingIndex && setCacheValues(rawValues);
                  }), [ rawValues, draggingIndex ]), react.useEffect((function() {
                      return function() {
                          document.removeEventListener("mousemove", mouseMoveEventRef.current), document.removeEventListener("mouseup", mouseUpEventRef.current), 
                          document.removeEventListener("touchmove", mouseMoveEventRef.current), document.removeEventListener("touchend", mouseUpEventRef.current);
                      };
                  }), []);
                  var flushValues = function(nextValues, nextValue) {
                      cacheValues.some((function(val, i) {
                          return val !== nextValues[i];
                      })) && (void 0 !== nextValue && setDraggingValue(nextValue), setCacheValues(nextValues), 
                      triggerChange(nextValues));
                  }, updateCacheValue = function(valueIndex, offsetPercent) {
                      if (-1 === valueIndex) {
                          var startValue = originValues[0], endValue = originValues[originValues.length - 1], maxStartOffset = min - startValue, maxEndOffset = max - endValue, offset = offsetPercent * (max - min);
                          offset = Math.max(offset, maxStartOffset), offset = Math.min(offset, maxEndOffset);
                          var formatStartValue = formatValue(startValue + offset);
                          offset = formatStartValue - startValue;
                          var cloneCacheValues = originValues.map((function(val) {
                              return val + offset;
                          }));
                          flushValues(cloneCacheValues);
                      } else {
                          var offsetDist = (max - min) * offsetPercent, cloneValues = _toConsumableArray(cacheValues);
                          cloneValues[valueIndex] = originValues[valueIndex];
                          var next = offsetValues(cloneValues, offsetDist, valueIndex, "dist");
                          flushValues(next.values, next.value);
                      }
                  }, updateCacheValueRef = react.useRef(updateCacheValue);
                  updateCacheValueRef.current = updateCacheValue;
                  var returnValues = react.useMemo((function() {
                      var sourceValues = _toConsumableArray(rawValues).sort((function(a, b) {
                          return a - b;
                      })), targetValues = _toConsumableArray(cacheValues).sort((function(a, b) {
                          return a - b;
                      }));
                      return sourceValues.every((function(val, index) {
                          return val === targetValues[index];
                      })) ? cacheValues : rawValues;
                  }), [ rawValues, cacheValues ]);
                  return [ draggingIndex, draggingValue, returnValues, function(e, valueIndex) {
                      e.stopPropagation();
                      var originValue = rawValues[valueIndex];
                      setDraggingIndex(valueIndex), setDraggingValue(originValue), setOriginValues(rawValues);
                      var _getPosition = getPosition(e), startX = _getPosition.pageX, startY = _getPosition.pageY, onMouseMove = function(event) {
                          event.preventDefault();
                          var offSetPercent, _getPosition2 = getPosition(event), moveX = _getPosition2.pageX, moveY = _getPosition2.pageY, offsetX = moveX - startX, offsetY = moveY - startY, _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height;
                          switch (direction) {
                            case "btt":
                              offSetPercent = -offsetY / height;
                              break;

                            case "ttb":
                              offSetPercent = offsetY / height;
                              break;

                            case "rtl":
                              offSetPercent = -offsetX / width;
                              break;

                            default:
                              offSetPercent = offsetX / width;
                          }
                          updateCacheValueRef.current(valueIndex, offSetPercent);
                      }, onMouseUp = function onMouseUp(event) {
                          event.preventDefault(), document.removeEventListener("mouseup", onMouseUp), document.removeEventListener("mousemove", onMouseMove), 
                          document.removeEventListener("touchend", onMouseUp), document.removeEventListener("touchmove", onMouseMove), 
                          mouseMoveEventRef.current = null, mouseUpEventRef.current = null, setDraggingIndex(-1), 
                          finishChange();
                      };
                      document.addEventListener("mouseup", onMouseUp), document.addEventListener("mousemove", onMouseMove), 
                      document.addEventListener("touchend", onMouseUp), document.addEventListener("touchmove", onMouseMove), 
                      mouseMoveEventRef.current = onMouseMove, mouseUpEventRef.current = onMouseUp;
                  } ];
              }(containerRef, direction, rawValues, mergedMin, mergedMax, formatValue, triggerChange, (function() {
                  null == onAfterChange || onAfterChange(getTriggerValue(rawValuesRef.current));
              }), offsetValues), _useDrag2 = slicedToArray_slicedToArray(_useDrag, 4), draggingIndex = _useDrag2[0], draggingValue = _useDrag2[1], cacheValues = _useDrag2[2], onStartDrag = _useDrag2[3], onStartMove = function(e, valueIndex) {
                  onStartDrag(e, valueIndex), null == onBeforeChange || onBeforeChange(getTriggerValue(rawValuesRef.current));
              }, dragging = -1 !== draggingIndex;
              react.useEffect((function() {
                  if (!dragging) {
                      var valueIndex = rawValues.lastIndexOf(draggingValue);
                      handlesRef.current.focus(valueIndex);
                  }
              }), [ dragging ]);
              var sortedCacheValues = react.useMemo((function() {
                  return _toConsumableArray(cacheValues).sort((function(a, b) {
                      return a - b;
                  }));
              }), [ cacheValues ]), _React$useMemo2 = slicedToArray_slicedToArray(react.useMemo((function() {
                  return range ? [ sortedCacheValues[0], sortedCacheValues[sortedCacheValues.length - 1] ] : [ mergedMin, sortedCacheValues[0] ];
              }), [ sortedCacheValues, range, mergedMin ]), 2), includedStart = _React$useMemo2[0], includedEnd = _React$useMemo2[1];
              react.useImperativeHandle(ref, (function() {
                  return {
                      focus: function() {
                          handlesRef.current.focus(0);
                      },
                      blur: function() {
                          var activeElement = document.activeElement;
                          containerRef.current.contains(activeElement) && (null == activeElement || activeElement.blur());
                      }
                  };
              })), react.useEffect((function() {
                  autoFocus && handlesRef.current.focus(0);
              }), []);
              var context = react.useMemo((function() {
                  return {
                      min: mergedMin,
                      max: mergedMax,
                      direction,
                      disabled,
                      keyboard,
                      step: mergedStep,
                      included,
                      includedStart,
                      includedEnd,
                      range,
                      tabIndex,
                      ariaLabelForHandle,
                      ariaLabelledByForHandle,
                      ariaValueTextFormatterForHandle,
                      styles: styles || {},
                      classNames: classNames || {}
                  };
              }), [ mergedMin, mergedMax, direction, disabled, keyboard, mergedStep, included, includedStart, includedEnd, range, tabIndex, ariaLabelForHandle, ariaLabelledByForHandle, ariaValueTextFormatterForHandle, styles, classNames ]);
              return react.createElement(es_context.Provider, {
                  value: context
              }, react.createElement("div", {
                  ref: containerRef,
                  className: classnames_default()(prefixCls, className, (_cls = {}, defineProperty_defineProperty(_cls, "".concat(prefixCls, "-disabled"), disabled), 
                  defineProperty_defineProperty(_cls, "".concat(prefixCls, "-vertical"), vertical), 
                  defineProperty_defineProperty(_cls, "".concat(prefixCls, "-horizontal"), !vertical), 
                  defineProperty_defineProperty(_cls, "".concat(prefixCls, "-with-marks"), markList.length), 
                  _cls)),
                  style,
                  onMouseDown: function(e) {
                      e.preventDefault();
                      var percent, _containerRef$current = containerRef.current.getBoundingClientRect(), width = _containerRef$current.width, height = _containerRef$current.height, left = _containerRef$current.left, top = _containerRef$current.top, bottom = _containerRef$current.bottom, right = _containerRef$current.right, clientX = e.clientX, clientY = e.clientY;
                      switch (direction) {
                        case "btt":
                          percent = (bottom - clientY) / height;
                          break;

                        case "ttb":
                          percent = (clientY - top) / height;
                          break;

                        case "rtl":
                          percent = (right - clientX) / width;
                          break;

                        default:
                          percent = (clientX - left) / width;
                      }
                      changeToCloseValue(formatValue(mergedMin + percent * (mergedMax - mergedMin)));
                  }
              }, react.createElement("div", {
                  className: classnames_default()("".concat(prefixCls, "-rail"), null == classNames ? void 0 : classNames.rail),
                  style: _objectSpread2(_objectSpread2({}, railStyle), null == styles ? void 0 : styles.rail)
              }), react.createElement(Tracks, {
                  prefixCls,
                  style: trackStyle,
                  values: sortedCacheValues,
                  startPoint,
                  onStartMove: mergedDraggableTrack ? onStartMove : null
              }), react.createElement(Steps, {
                  prefixCls,
                  marks: markList,
                  dots,
                  style: dotStyle,
                  activeStyle: activeDotStyle
              }), react.createElement(es_Handles, {
                  ref: handlesRef,
                  prefixCls,
                  style: handleStyle,
                  values: cacheValues,
                  draggingIndex,
                  onStartMove,
                  onOffsetChange: function(offset, valueIndex) {
                      if (!disabled) {
                          var next = offsetValues(rawValues, offset, valueIndex);
                          null == onBeforeChange || onBeforeChange(getTriggerValue(rawValues)), triggerChange(next.values), 
                          null == onAfterChange || onAfterChange(getTriggerValue(next.values)), setKeyboardValue(next.value);
                      }
                  },
                  onFocus,
                  onBlur,
                  handleRender
              }), react.createElement(Marks, {
                  prefixCls,
                  marks: markList,
                  onClick: changeToCloseValue
              })));
          }));
          const rc_slider_es = Slider;
          function Popup(props) {
              var children = props.children, prefixCls = props.prefixCls, id = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style = props.style;
              return react.createElement("div", {
                  className: classnames_default()("".concat(prefixCls, "-content"), className),
                  style
              }, react.createElement("div", {
                  className: "".concat(prefixCls, "-inner"),
                  id,
                  role: "tooltip",
                  style: overlayInnerStyle
              }, "function" == typeof children ? children() : children));
          }
          function typeof_typeof(o) {
              return typeof_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
                  return typeof o;
              } : function(o) {
                  return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
              }, typeof_typeof(o);
          }
          function toPropertyKey_toPropertyKey(arg) {
              var key = function(input, hint) {
                  if ("object" !== typeof_typeof(input) || null === input) return input;
                  var prim = input[Symbol.toPrimitive];
                  if (void 0 !== prim) {
                      var res = prim.call(input, hint || "default");
                      if ("object" !== typeof_typeof(res)) return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                  }
                  return ("string" === hint ? String : Number)(input);
              }(arg, "string");
              return "symbol" === typeof_typeof(key) ? key : String(key);
          }
          function objectSpread2_ownKeys(e, r) {
              var t = Object.keys(e);
              if (Object.getOwnPropertySymbols) {
                  var o = Object.getOwnPropertySymbols(e);
                  r && (o = o.filter((function(r) {
                      return Object.getOwnPropertyDescriptor(e, r).enumerable;
                  }))), t.push.apply(t, o);
              }
              return t;
          }
          function objectSpread2_objectSpread2(e) {
              for (var r = 1; r < arguments.length; r++) {
                  var t = null != arguments[r] ? arguments[r] : {};
                  r % 2 ? objectSpread2_ownKeys(Object(t), !0).forEach((function(r) {
                      var obj, key, value;
                      obj = e, key = r, value = t[r], (key = toPropertyKey_toPropertyKey(key)) in obj ? Object.defineProperty(obj, key, {
                          value,
                          enumerable: !0,
                          configurable: !0,
                          writable: !0
                      }) : obj[key] = value;
                  })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : objectSpread2_ownKeys(Object(t)).forEach((function(r) {
                      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
                  }));
              }
              return e;
          }
          function arrayLikeToArray_arrayLikeToArray(arr, len) {
              (null == len || len > arr.length) && (len = arr.length);
              for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
              return arr2;
          }
          function unsupportedIterableToArray_unsupportedIterableToArray(o, minLen) {
              if (o) {
                  if ("string" == typeof o) return arrayLikeToArray_arrayLikeToArray(o, minLen);
                  var n = Object.prototype.toString.call(o).slice(8, -1);
                  return "Object" === n && o.constructor && (n = o.constructor.name), "Map" === n || "Set" === n ? Array.from(o) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? arrayLikeToArray_arrayLikeToArray(o, minLen) : void 0;
              }
          }
          function esm_slicedToArray_slicedToArray(arr, i) {
              return function(arr) {
                  if (Array.isArray(arr)) return arr;
              }(arr) || function(r, l) {
                  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
                  if (null != t) {
                      var e, n, i, u, a = [], f = !0, o = !1;
                      try {
                          if (i = (t = t.call(r)).next, 0 === l) {
                              if (Object(t) !== t) return;
                              f = !1;
                          } else for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0) ;
                      } catch (r) {
                          o = !0, n = r;
                      } finally {
                          try {
                              if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                          } finally {
                              if (o) throw n;
                          }
                      }
                      return a;
                  }
              }(arr, i) || unsupportedIterableToArray_unsupportedIterableToArray(arr, i) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }();
          }
          function esm_objectWithoutProperties_objectWithoutProperties(source, excluded) {
              if (null == source) return {};
              var key, i, target = function(source, excluded) {
                  if (null == source) return {};
                  var key, i, target = {}, sourceKeys = Object.keys(source);
                  for (i = 0; i < sourceKeys.length; i++) key = sourceKeys[i], excluded.indexOf(key) >= 0 || (target[key] = source[key]);
                  return target;
              }(source, excluded);
              if (Object.getOwnPropertySymbols) {
                  var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                  for (i = 0; i < sourceSymbolKeys.length; i++) key = sourceSymbolKeys[i], excluded.indexOf(key) >= 0 || Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
              }
              return target;
          }
          const es_Context = react.createContext(null);
          var cached, EMPTY_LIST = [];
          function ensureSize(str) {
              var match = str.match(/^(.*)px$/), value = Number(null == match ? void 0 : match[1]);
              return Number.isNaN(value) ? function(fresh) {
                  if ("undefined" == typeof document) return 0;
                  if (fresh || void 0 === cached) {
                      var inner = document.createElement("div");
                      inner.style.width = "100%", inner.style.height = "200px";
                      var outer = document.createElement("div"), outerStyle = outer.style;
                      outerStyle.position = "absolute", outerStyle.top = "0", outerStyle.left = "0", outerStyle.pointerEvents = "none", 
                      outerStyle.visibility = "hidden", outerStyle.width = "200px", outerStyle.height = "150px", 
                      outerStyle.overflow = "hidden", outer.appendChild(inner), document.body.appendChild(outer);
                      var widthContained = inner.offsetWidth;
                      outer.style.overflow = "scroll";
                      var widthScroll = inner.offsetWidth;
                      widthContained === widthScroll && (widthScroll = outer.clientWidth), document.body.removeChild(outer), 
                      cached = widthContained - widthScroll;
                  }
                  return cached;
              }() : value;
          }
          var UNIQUE_ID = "rc-util-locker-".concat(Date.now()), useScrollLocker_uuid = 0;
          function useScrollLocker(lock) {
              var mergedLock = !!lock, id = slicedToArray_slicedToArray(react.useState((function() {
                  return useScrollLocker_uuid += 1, "".concat(UNIQUE_ID, "_").concat(useScrollLocker_uuid);
              })), 1)[0];
              hooks_useLayoutEffect((function() {
                  if (mergedLock) {
                      var scrollbarSize = function(target) {
                          if (!("undefined" != typeof document && target && target instanceof Element)) return {
                              width: 0,
                              height: 0
                          };
                          var _getComputedStyle = getComputedStyle(target, "::-webkit-scrollbar"), width = _getComputedStyle.width, height = _getComputedStyle.height;
                          return {
                              width: ensureSize(width),
                              height: ensureSize(height)
                          };
                      }(document.body).width, isOverflow = document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
                      updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id);
                  } else removeCSS(id);
                  return function() {
                      removeCSS(id);
                  };
              }), [ mergedLock, id ]);
          }
          var inline = !1;
          var getPortalContainer = function(getContainer) {
              return !1 !== getContainer && (canUseDom() && getContainer ? "string" == typeof getContainer ? document.querySelector(getContainer) : "function" == typeof getContainer ? getContainer() : getContainer : null);
          }, Portal = react.forwardRef((function(props, ref) {
              var open = props.open, autoLock = props.autoLock, getContainer = props.getContainer, _props$autoDestroy = (props.debug, 
              props.autoDestroy), autoDestroy = void 0 === _props$autoDestroy || _props$autoDestroy, children = props.children, _React$useState2 = slicedToArray_slicedToArray(react.useState(open), 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1], mergedRender = shouldRender || open;
              react.useEffect((function() {
                  (autoDestroy || open) && setShouldRender(open);
              }), [ open, autoDestroy ]);
              var _React$useState4 = slicedToArray_slicedToArray(react.useState((function() {
                  return getPortalContainer(getContainer);
              })), 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
              react.useEffect((function() {
                  var customizeContainer = getPortalContainer(getContainer);
                  setInnerContainer(null != customizeContainer ? customizeContainer : null);
              }));
              var _useDom = function(render, debug) {
                  var ele = slicedToArray_slicedToArray(react.useState((function() {
                      return canUseDom() ? document.createElement("div") : null;
                  })), 1)[0], appendedRef = react.useRef(!1), queueCreate = react.useContext(es_Context), _React$useState4 = slicedToArray_slicedToArray(react.useState(EMPTY_LIST), 2), queue = _React$useState4[0], setQueue = _React$useState4[1], mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
                      setQueue((function(origin) {
                          return [ appendFn ].concat(_toConsumableArray(origin));
                      }));
                  });
                  function append() {
                      ele.parentElement || document.body.appendChild(ele), appendedRef.current = !0;
                  }
                  function cleanup() {
                      var _ele$parentElement;
                      null === (_ele$parentElement = ele.parentElement) || void 0 === _ele$parentElement || _ele$parentElement.removeChild(ele), 
                      appendedRef.current = !1;
                  }
                  return hooks_useLayoutEffect((function() {
                      return render ? queueCreate ? queueCreate(append) : append() : cleanup(), cleanup;
                  }), [ render ]), hooks_useLayoutEffect((function() {
                      queue.length && (queue.forEach((function(appendFn) {
                          return appendFn();
                      })), setQueue(EMPTY_LIST));
                  }), [ queue ]), [ ele, mergedQueueCreate ];
              }(mergedRender && !innerContainer), _useDom2 = slicedToArray_slicedToArray(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1], mergedContainer = null != innerContainer ? innerContainer : defaultContainer;
              useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
              var childRef = null;
              children && supportRef(children) && ref && (childRef = children.ref);
              var mergedRef = useComposeRef(childRef, ref);
              if (!mergedRender || !canUseDom() || void 0 === innerContainer) return null;
              var nextInline, renderInline = !1 === mergedContainer || ("boolean" == typeof nextInline && (inline = nextInline), 
              inline), reffedChildren = children;
              return ref && (reffedChildren = react.cloneElement(children, {
                  ref: mergedRef
              })), react.createElement(es_Context.Provider, {
                  value: queueCreate
              }, renderInline ? reffedChildren : (0, react_dom.createPortal)(reffedChildren, mergedContainer));
          }));
          const portal_es = Portal;
          var CollectionContext = react.createContext(null);
          var MapShim = function() {
              if ("undefined" != typeof Map) return Map;
              function getIndex(arr, key) {
                  var result = -1;
                  return arr.some((function(entry, index) {
                      return entry[0] === key && (result = index, !0);
                  })), result;
              }
              return function() {
                  function class_1() {
                      this.__entries__ = [];
                  }
                  return Object.defineProperty(class_1.prototype, "size", {
                      get: function() {
                          return this.__entries__.length;
                      },
                      enumerable: !0,
                      configurable: !0
                  }), class_1.prototype.get = function(key) {
                      var index = getIndex(this.__entries__, key), entry = this.__entries__[index];
                      return entry && entry[1];
                  }, class_1.prototype.set = function(key, value) {
                      var index = getIndex(this.__entries__, key);
                      ~index ? this.__entries__[index][1] = value : this.__entries__.push([ key, value ]);
                  }, class_1.prototype.delete = function(key) {
                      var entries = this.__entries__, index = getIndex(entries, key);
                      ~index && entries.splice(index, 1);
                  }, class_1.prototype.has = function(key) {
                      return !!~getIndex(this.__entries__, key);
                  }, class_1.prototype.clear = function() {
                      this.__entries__.splice(0);
                  }, class_1.prototype.forEach = function(callback, ctx) {
                      void 0 === ctx && (ctx = null);
                      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                          var entry = _a[_i];
                          callback.call(ctx, entry[1], entry[0]);
                      }
                  }, class_1;
              }();
          }(), ResizeObserver_es_isBrowser = "undefined" != typeof window && "undefined" != typeof document && window.document === document, global$1 = void 0 !== __webpack_require__.g && __webpack_require__.g.Math === Math ? __webpack_require__.g : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")(), requestAnimationFrame$1 = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(global$1) : function(callback) {
              return setTimeout((function() {
                  return callback(Date.now());
              }), 1e3 / 60);
          };
          var transitionKeys = [ "top", "right", "bottom", "left", "width", "height", "size", "weight" ], mutationObserverSupported = "undefined" != typeof MutationObserver, ResizeObserverController = function() {
              function ResizeObserverController() {
                  this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, 
                  this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), 
                  this.refresh = function(callback, delay) {
                      var leadingCall = !1, trailingCall = !1, lastCallTime = 0;
                      function resolvePending() {
                          leadingCall && (leadingCall = !1, callback()), trailingCall && proxy();
                      }
                      function timeoutCallback() {
                          requestAnimationFrame$1(resolvePending);
                      }
                      function proxy() {
                          var timeStamp = Date.now();
                          if (leadingCall) {
                              if (timeStamp - lastCallTime < 2) return;
                              trailingCall = !0;
                          } else leadingCall = !0, trailingCall = !1, setTimeout(timeoutCallback, delay);
                          lastCallTime = timeStamp;
                      }
                      return proxy;
                  }(this.refresh.bind(this), 20);
              }
              return ResizeObserverController.prototype.addObserver = function(observer) {
                  ~this.observers_.indexOf(observer) || this.observers_.push(observer), this.connected_ || this.connect_();
              }, ResizeObserverController.prototype.removeObserver = function(observer) {
                  var observers = this.observers_, index = observers.indexOf(observer);
                  ~index && observers.splice(index, 1), !observers.length && this.connected_ && this.disconnect_();
              }, ResizeObserverController.prototype.refresh = function() {
                  this.updateObservers_() && this.refresh();
              }, ResizeObserverController.prototype.updateObservers_ = function() {
                  var activeObservers = this.observers_.filter((function(observer) {
                      return observer.gatherActive(), observer.hasActive();
                  }));
                  return activeObservers.forEach((function(observer) {
                      return observer.broadcastActive();
                  })), activeObservers.length > 0;
              }, ResizeObserverController.prototype.connect_ = function() {
                  ResizeObserver_es_isBrowser && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), 
                  window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), 
                  this.mutationsObserver_.observe(document, {
                      attributes: !0,
                      childList: !0,
                      characterData: !0,
                      subtree: !0
                  })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), 
                  this.connected_ = !0);
              }, ResizeObserverController.prototype.disconnect_ = function() {
                  ResizeObserver_es_isBrowser && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), 
                  window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), 
                  this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), 
                  this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
              }, ResizeObserverController.prototype.onTransitionEnd_ = function(_a) {
                  var _b = _a.propertyName, propertyName = void 0 === _b ? "" : _b;
                  transitionKeys.some((function(key) {
                      return !!~propertyName.indexOf(key);
                  })) && this.refresh();
              }, ResizeObserverController.getInstance = function() {
                  return this.instance_ || (this.instance_ = new ResizeObserverController), this.instance_;
              }, ResizeObserverController.instance_ = null, ResizeObserverController;
          }(), defineConfigurable = function(target, props) {
              for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
                  var key = _a[_i];
                  Object.defineProperty(target, key, {
                      value: props[key],
                      enumerable: !1,
                      writable: !1,
                      configurable: !0
                  });
              }
              return target;
          }, getWindowOf = function(target) {
              return target && target.ownerDocument && target.ownerDocument.defaultView || global$1;
          }, emptyRect = createRectInit(0, 0, 0, 0);
          function toFloat(value) {
              return parseFloat(value) || 0;
          }
          function getBordersSize(styles) {
              for (var positions = [], _i = 1; _i < arguments.length; _i++) positions[_i - 1] = arguments[_i];
              return positions.reduce((function(size, position) {
                  return size + toFloat(styles["border-" + position + "-width"]);
              }), 0);
          }
          function getHTMLElementContentRect(target) {
              var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
              if (!clientWidth && !clientHeight) return emptyRect;
              var styles = getWindowOf(target).getComputedStyle(target), paddings = function(styles) {
                  for (var paddings = {}, _i = 0, positions_1 = [ "top", "right", "bottom", "left" ]; _i < positions_1.length; _i++) {
                      var position = positions_1[_i], value = styles["padding-" + position];
                      paddings[position] = toFloat(value);
                  }
                  return paddings;
              }(styles), horizPad = paddings.left + paddings.right, vertPad = paddings.top + paddings.bottom, width = toFloat(styles.width), height = toFloat(styles.height);
              if ("border-box" === styles.boxSizing && (Math.round(width + horizPad) !== clientWidth && (width -= getBordersSize(styles, "left", "right") + horizPad), 
              Math.round(height + vertPad) !== clientHeight && (height -= getBordersSize(styles, "top", "bottom") + vertPad)), 
              !function(target) {
                  return target === getWindowOf(target).document.documentElement;
              }(target)) {
                  var vertScrollbar = Math.round(width + horizPad) - clientWidth, horizScrollbar = Math.round(height + vertPad) - clientHeight;
                  1 !== Math.abs(vertScrollbar) && (width -= vertScrollbar), 1 !== Math.abs(horizScrollbar) && (height -= horizScrollbar);
              }
              return createRectInit(paddings.left, paddings.top, width, height);
          }
          var isSVGGraphicsElement = "undefined" != typeof SVGGraphicsElement ? function(target) {
              return target instanceof getWindowOf(target).SVGGraphicsElement;
          } : function(target) {
              return target instanceof getWindowOf(target).SVGElement && "function" == typeof target.getBBox;
          };
          function getContentRect(target) {
              return ResizeObserver_es_isBrowser ? isSVGGraphicsElement(target) ? function(target) {
                  var bbox = target.getBBox();
                  return createRectInit(0, 0, bbox.width, bbox.height);
              }(target) : getHTMLElementContentRect(target) : emptyRect;
          }
          function createRectInit(x, y, width, height) {
              return {
                  x,
                  y,
                  width,
                  height
              };
          }
          var ResizeObservation = function() {
              function ResizeObservation(target) {
                  this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), 
                  this.target = target;
              }
              return ResizeObservation.prototype.isActive = function() {
                  var rect = getContentRect(this.target);
                  return this.contentRect_ = rect, rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
              }, ResizeObservation.prototype.broadcastRect = function() {
                  var rect = this.contentRect_;
                  return this.broadcastWidth = rect.width, this.broadcastHeight = rect.height, rect;
              }, ResizeObservation;
          }(), ResizeObserverEntry = function(target, rectInit) {
              var contentRect = function(_a) {
                  var x = _a.x, y = _a.y, width = _a.width, height = _a.height, Constr = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object, rect = Object.create(Constr.prototype);
                  return defineConfigurable(rect, {
                      x,
                      y,
                      width,
                      height,
                      top: y,
                      right: x + width,
                      bottom: height + y,
                      left: x
                  }), rect;
              }(rectInit);
              defineConfigurable(this, {
                  target,
                  contentRect
              });
          }, ResizeObserverSPI = function() {
              function ResizeObserverSPI(callback, controller, callbackCtx) {
                  if (this.activeObservations_ = [], this.observations_ = new MapShim, "function" != typeof callback) throw new TypeError("The callback provided as parameter 1 is not a function.");
                  this.callback_ = callback, this.controller_ = controller, this.callbackCtx_ = callbackCtx;
              }
              return ResizeObserverSPI.prototype.observe = function(target) {
                  if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                  if ("undefined" != typeof Element && Element instanceof Object) {
                      if (!(target instanceof getWindowOf(target).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                      var observations = this.observations_;
                      observations.has(target) || (observations.set(target, new ResizeObservation(target)), 
                      this.controller_.addObserver(this), this.controller_.refresh());
                  }
              }, ResizeObserverSPI.prototype.unobserve = function(target) {
                  if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                  if ("undefined" != typeof Element && Element instanceof Object) {
                      if (!(target instanceof getWindowOf(target).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                      var observations = this.observations_;
                      observations.has(target) && (observations.delete(target), observations.size || this.controller_.removeObserver(this));
                  }
              }, ResizeObserverSPI.prototype.disconnect = function() {
                  this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
              }, ResizeObserverSPI.prototype.gatherActive = function() {
                  var _this = this;
                  this.clearActive(), this.observations_.forEach((function(observation) {
                      observation.isActive() && _this.activeObservations_.push(observation);
                  }));
              }, ResizeObserverSPI.prototype.broadcastActive = function() {
                  if (this.hasActive()) {
                      var ctx = this.callbackCtx_, entries = this.activeObservations_.map((function(observation) {
                          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
                      }));
                      this.callback_.call(ctx, entries, ctx), this.clearActive();
                  }
              }, ResizeObserverSPI.prototype.clearActive = function() {
                  this.activeObservations_.splice(0);
              }, ResizeObserverSPI.prototype.hasActive = function() {
                  return this.activeObservations_.length > 0;
              }, ResizeObserverSPI;
          }(), observers = "undefined" != typeof WeakMap ? new WeakMap : new MapShim, ResizeObserver_es_ResizeObserver = function ResizeObserver(callback) {
              if (!(this instanceof ResizeObserver)) throw new TypeError("Cannot call a class as a function.");
              if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
              var controller = ResizeObserverController.getInstance(), observer = new ResizeObserverSPI(callback, controller, this);
              observers.set(this, observer);
          };
          [ "observe", "unobserve", "disconnect" ].forEach((function(method) {
              ResizeObserver_es_ResizeObserver.prototype[method] = function() {
                  var _a;
                  return (_a = observers.get(this))[method].apply(_a, arguments);
              };
          }));
          const ResizeObserver_es = void 0 !== global$1.ResizeObserver ? global$1.ResizeObserver : ResizeObserver_es_ResizeObserver;
          var elementListeners = new Map;
          var resizeObserver = new ResizeObserver_es((function(entities) {
              entities.forEach((function(entity) {
                  var _elementListeners$get, target = entity.target;
                  null === (_elementListeners$get = elementListeners.get(target)) || void 0 === _elementListeners$get || _elementListeners$get.forEach((function(listener) {
                      return listener(target);
                  }));
              }));
          }));
          var DomWrapper_DomWrapper = function(_React$Component) {
              _inherits(DomWrapper, _React$Component);
              var _super = _createSuper(DomWrapper);
              function DomWrapper() {
                  return _classCallCheck(this, DomWrapper), _super.apply(this, arguments);
              }
              return _createClass(DomWrapper, [ {
                  key: "render",
                  value: function() {
                      return this.props.children;
                  }
              } ]), DomWrapper;
          }(react.Component);
          function SingleObserver(props, ref) {
              var children = props.children, disabled = props.disabled, elementRef = react.useRef(null), wrapperRef = react.useRef(null), onCollectionResize = react.useContext(CollectionContext), isRenderProps = "function" == typeof children, mergedChildren = isRenderProps ? children(elementRef) : children, sizeRef = react.useRef({
                  width: -1,
                  height: -1,
                  offsetWidth: -1,
                  offsetHeight: -1
              }), canRef = !isRenderProps && react.isValidElement(mergedChildren) && supportRef(mergedChildren), mergedRef = useComposeRef(canRef ? mergedChildren.ref : null, elementRef), getDom = function() {
                  var _elementRef$current;
                  return findDOMNode(elementRef.current) || (elementRef.current && "object" === _typeof(elementRef.current) ? findDOMNode(null === (_elementRef$current = elementRef.current) || void 0 === _elementRef$current ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
              };
              react.useImperativeHandle(ref, (function() {
                  return getDom();
              }));
              var propsRef = react.useRef(props);
              propsRef.current = props;
              var onInternalResize = react.useCallback((function(target) {
                  var _propsRef$current = propsRef.current, onResize = _propsRef$current.onResize, data = _propsRef$current.data, _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height, offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight, fixedWidth = Math.floor(width), fixedHeight = Math.floor(height);
                  if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
                      var size = {
                          width: fixedWidth,
                          height: fixedHeight,
                          offsetWidth,
                          offsetHeight
                      };
                      sizeRef.current = size;
                      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth, mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight, sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
                          offsetWidth: mergedOffsetWidth,
                          offsetHeight: mergedOffsetHeight
                      });
                      null == onCollectionResize || onCollectionResize(sizeInfo, target, data), onResize && Promise.resolve().then((function() {
                          onResize(sizeInfo, target);
                      }));
                  }
              }), []);
              return react.useEffect((function() {
                  var element, callback, currentElement = getDom();
                  return currentElement && !disabled && (element = currentElement, callback = onInternalResize, 
                  elementListeners.has(element) || (elementListeners.set(element, new Set), resizeObserver.observe(element)), 
                  elementListeners.get(element).add(callback)), function() {
                      return function(element, callback) {
                          elementListeners.has(element) && (elementListeners.get(element).delete(callback), 
                          elementListeners.get(element).size || (resizeObserver.unobserve(element), elementListeners.delete(element)));
                      }(currentElement, onInternalResize);
                  };
              }), [ elementRef.current, disabled ]), react.createElement(DomWrapper_DomWrapper, {
                  ref: wrapperRef
              }, canRef ? react.cloneElement(mergedChildren, {
                  ref: mergedRef
              }) : mergedChildren);
          }
          const es_SingleObserver = react.forwardRef(SingleObserver);
          function es_ResizeObserver(props, ref) {
              var children = props.children;
              return ("function" == typeof children ? [ children ] : toArray_toArray(children)).map((function(child, index) {
                  var key = (null == child ? void 0 : child.key) || "".concat("rc-observer-key", "-").concat(index);
                  return react.createElement(es_SingleObserver, _extends({}, props, {
                      key,
                      ref: 0 === index ? ref : void 0
                  }), child);
              }));
          }
          var RefResizeObserver = react.forwardRef(es_ResizeObserver);
          RefResizeObserver.Collection = function(_ref) {
              var children = _ref.children, onBatchResize = _ref.onBatchResize, resizeIdRef = react.useRef(0), resizeInfosRef = react.useRef([]), onCollectionResize = react.useContext(CollectionContext), onResize = react.useCallback((function(size, element, data) {
                  resizeIdRef.current += 1;
                  var currentId = resizeIdRef.current;
                  resizeInfosRef.current.push({
                      size,
                      element,
                      data
                  }), Promise.resolve().then((function() {
                      currentId === resizeIdRef.current && (null == onBatchResize || onBatchResize(resizeInfosRef.current), 
                      resizeInfosRef.current = []);
                  })), null == onCollectionResize || onCollectionResize(size, element, data);
              }), [ onBatchResize, onCollectionResize ]);
              return react.createElement(CollectionContext.Provider, {
                  value: onResize
              }, children);
          };
          const rc_resize_observer_es = RefResizeObserver;
          var useId_uuid = 0;
          var useOriginId = _objectSpread2({}, react_namespaceObject).useId;
          const useId = useOriginId ? function(id) {
              var reactId = useOriginId();
              return id || reactId;
          } : function(id) {
              var _React$useState2 = slicedToArray_slicedToArray(react.useState("ssr-id"), 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
              return react.useEffect((function() {
                  var nextId = useId_uuid;
                  useId_uuid += 1, setInnerId("rc_unique_".concat(nextId));
              }), []), id || innerId;
          };
          function extends_extends() {
              return extends_extends = Object.assign ? Object.assign.bind() : function(target) {
                  for (var i = 1; i < arguments.length; i++) {
                      var source = arguments[i];
                      for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                  }
                  return target;
              }, extends_extends.apply(this, arguments);
          }
          function Arrow(props) {
              var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos, _ref = arrow || {}, className = _ref.className, content = _ref.content, _arrowPos$x = arrowPos.x, x = void 0 === _arrowPos$x ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y = void 0 === _arrowPos$y ? 0 : _arrowPos$y, arrowRef = react.useRef();
              if (!align || !align.points) return null;
              var alignStyle = {
                  position: "absolute"
              };
              if (!1 !== align.autoArrow) {
                  var popupPoints = align.points[0], targetPoints = align.points[1], popupTB = popupPoints[0], popupLR = popupPoints[1], targetTB = targetPoints[0], targetLR = targetPoints[1];
                  popupTB !== targetTB && [ "t", "b" ].includes(popupTB) ? "t" === popupTB ? alignStyle.top = 0 : alignStyle.bottom = 0 : alignStyle.top = y, 
                  popupLR !== targetLR && [ "l", "r" ].includes(popupLR) ? "l" === popupLR ? alignStyle.left = 0 : alignStyle.right = 0 : alignStyle.left = x;
              }
              return react.createElement("div", {
                  ref: arrowRef,
                  className: classnames_default()("".concat(prefixCls, "-arrow"), className),
                  style: alignStyle
              }, content);
          }
          function Mask(props) {
              var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion = props.motion;
              return mask ? react.createElement(es, extends_extends({}, motion, {
                  motionAppear: !0,
                  visible: open,
                  removeOnLeave: !0
              }), (function(_ref) {
                  var className = _ref.className;
                  return react.createElement("div", {
                      style: {
                          zIndex
                      },
                      className: classnames_default()("".concat(prefixCls, "-mask"), className)
                  });
              })) : null;
          }
          var PopupContent = react.memo((function(_ref) {
              return _ref.children;
          }), (function(_, next) {
              return next.cache;
          }));
          const Popup_PopupContent = PopupContent;
          var Popup_Popup = react.forwardRef((function(props, ref) {
              var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, fresh = props.fresh, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onPointerEnter = props.onPointerEnter, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight, childNode = "function" == typeof popup ? popup() : popup, isNodeVisible = open || keepDom, getPopupContainerNeedParams = (null == getPopupContainer ? void 0 : getPopupContainer.length) > 0, _React$useState2 = esm_slicedToArray_slicedToArray(react.useState(!getPopupContainer || !getPopupContainerNeedParams), 2), show = _React$useState2[0], setShow = _React$useState2[1];
              if (hooks_useLayoutEffect((function() {
                  !show && getPopupContainerNeedParams && target && setShow(!0);
              }), [ show, getPopupContainerNeedParams, target ]), !show) return null;
              var offsetStyle = {
                  left: "-1000vw",
                  top: "-1000vh",
                  right: "auto",
                  bottom: "auto"
              };
              if (ready || !open) {
                  var _experimental, points = align.points, dynamicInset = align.dynamicInset || (null === (_experimental = align._experimental) || void 0 === _experimental ? void 0 : _experimental.dynamicInset), alignRight = dynamicInset && "r" === points[0][1], alignBottom = dynamicInset && "b" === points[0][0];
                  alignRight ? (offsetStyle.right = offsetR, offsetStyle.left = "auto") : (offsetStyle.left = offsetX, 
                  offsetStyle.right = "auto"), alignBottom ? (offsetStyle.bottom = offsetB, offsetStyle.top = "auto") : (offsetStyle.top = offsetY, 
                  offsetStyle.bottom = "auto");
              }
              var miscStyle = {};
              return stretch && (stretch.includes("height") && targetHeight ? miscStyle.height = targetHeight : stretch.includes("minHeight") && targetHeight && (miscStyle.minHeight = targetHeight), 
              stretch.includes("width") && targetWidth ? miscStyle.width = targetWidth : stretch.includes("minWidth") && targetWidth && (miscStyle.minWidth = targetWidth)), 
              open || (miscStyle.pointerEvents = "none"), react.createElement(Portal, {
                  open: forceRender || isNodeVisible,
                  getContainer: getPopupContainer && function() {
                      return getPopupContainer(target);
                  },
                  autoDestroy
              }, react.createElement(Mask, {
                  prefixCls,
                  open,
                  zIndex,
                  mask,
                  motion: maskMotion
              }), react.createElement(rc_resize_observer_es, {
                  onResize: onAlign,
                  disabled: !open
              }, (function(resizeObserverRef) {
                  return react.createElement(es, extends_extends({
                      motionAppear: !0,
                      motionEnter: !0,
                      motionLeave: !0,
                      removeOnLeave: !1,
                      forceRender,
                      leavedClassName: "".concat(prefixCls, "-hidden")
                  }, motion, {
                      onAppearPrepare: onPrepare,
                      onEnterPrepare: onPrepare,
                      visible: open,
                      onVisibleChanged: function(nextVisible) {
                          var _motion$onVisibleChan;
                          null == motion || null === (_motion$onVisibleChan = motion.onVisibleChanged) || void 0 === _motion$onVisibleChan || _motion$onVisibleChan.call(motion, nextVisible), 
                          _onVisibleChanged(nextVisible);
                      }
                  }), (function(_ref, motionRef) {
                      var motionClassName = _ref.className, motionStyle = _ref.style, cls = classnames_default()(prefixCls, motionClassName, className);
                      return react.createElement("div", {
                          ref: composeRef(resizeObserverRef, ref, motionRef),
                          className: cls,
                          style: objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2(objectSpread2_objectSpread2({
                              "--arrow-x": "".concat(arrowPos.x || 0, "px"),
                              "--arrow-y": "".concat(arrowPos.y || 0, "px")
                          }, offsetStyle), miscStyle), motionStyle), {}, {
                              boxSizing: "border-box",
                              zIndex
                          }, style),
                          onMouseEnter,
                          onMouseLeave,
                          onPointerEnter,
                          onClick
                      }, arrow && react.createElement(Arrow, {
                          prefixCls,
                          arrow,
                          arrowPos,
                          align
                      }), react.createElement(Popup_PopupContent, {
                          cache: !open && !fresh
                      }, childNode));
                  }));
              })));
          }));
          const es_Popup = Popup_Popup;
          const es_TriggerWrapper = react.forwardRef((function(props, ref) {
              var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode, canUseRef = supportRef(children), mergedRef = useComposeRef(react.useCallback((function(node) {
                  fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node) : node);
              }), [ getTriggerDOMNode ]), children.ref);
              return canUseRef ? react.cloneElement(children, {
                  ref: mergedRef
              }) : children;
          }));
          const trigger_es_context = react.createContext(null);
          function useAction_toArray(val) {
              return val ? Array.isArray(val) ? val : [ val ] : [];
          }
          function isPointsEq() {
              var a1 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], a2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
              return (arguments.length > 2 ? arguments[2] : void 0) ? a1[0] === a2[0] : a1[0] === a2[0] && a1[1] === a2[1];
          }
          function getMotion(prefixCls, motion, animation, transitionName) {
              return motion || (animation ? {
                  motionName: "".concat(prefixCls, "-").concat(animation)
              } : transitionName ? {
                  motionName: transitionName
              } : null);
          }
          function getWin(ele) {
              return ele.ownerDocument.defaultView;
          }
          function collectScroller(ele) {
              for (var scrollerList = [], current = null == ele ? void 0 : ele.parentElement, scrollStyle = [ "hidden", "scroll", "clip", "auto" ]; current; ) {
                  var _getWin$getComputedSt = getWin(current).getComputedStyle(current);
                  [ _getWin$getComputedSt.overflowX, _getWin$getComputedSt.overflowY, _getWin$getComputedSt.overflow ].some((function(o) {
                      return scrollStyle.includes(o);
                  })) && scrollerList.push(current), current = current.parentElement;
              }
              return scrollerList;
          }
          function toNum(num) {
              var defaultValue = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
              return Number.isNaN(num) ? defaultValue : num;
          }
          function getPxValue(val) {
              return toNum(parseFloat(val), 0);
          }
          function getVisibleArea(initArea, scrollerList) {
              var visibleArea = objectSpread2_objectSpread2({}, initArea);
              return (scrollerList || []).forEach((function(ele) {
                  if (!(ele instanceof HTMLBodyElement || ele instanceof HTMLHtmlElement)) {
                      var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth, eleRect = ele.getBoundingClientRect(), eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth, borderTopNum = getPxValue(borderTopWidth), borderBottomNum = getPxValue(borderBottomWidth), borderLeftNum = getPxValue(borderLeftWidth), borderRightNum = getPxValue(borderRightWidth), scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3), scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3), eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX, eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY, scaledBorderTopWidth = borderTopNum * scaleY, scaledBorderBottomWidth = borderBottomNum * scaleY, scaledBorderLeftWidth = borderLeftNum * scaleX, scaledBorderRightWidth = borderRightNum * scaleX, clipMarginWidth = 0, clipMarginHeight = 0;
                      if ("clip" === overflow) {
                          var clipNum = getPxValue(overflowClipMargin);
                          clipMarginWidth = clipNum * scaleX, clipMarginHeight = clipNum * scaleY;
                      }
                      var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth, eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight, eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth, eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
                      visibleArea.left = Math.max(visibleArea.left, eleLeft), visibleArea.top = Math.max(visibleArea.top, eleTop), 
                      visibleArea.right = Math.min(visibleArea.right, eleRight), visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
                  }
              })), visibleArea;
          }
          function getUnitOffset(size) {
              var offsetStr = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0), cells = offsetStr.match(/^(.*)\%$/);
              return cells ? size * (parseFloat(cells[1]) / 100) : parseFloat(offsetStr);
          }
          function getNumberOffset(rect, offset) {
              var _ref2 = esm_slicedToArray_slicedToArray(offset || [], 2), offsetX = _ref2[0], offsetY = _ref2[1];
              return [ getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY) ];
          }
          function splitPoints() {
              var points = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
              return [ points[0], points[1] ];
          }
          function getAlignPoint(rect, points) {
              var y, topBottom = points[0], leftRight = points[1];
              return y = "t" === topBottom ? rect.y : "b" === topBottom ? rect.y + rect.height : rect.y + rect.height / 2, 
              {
                  x: "l" === leftRight ? rect.x : "r" === leftRight ? rect.x + rect.width : rect.x + rect.width / 2,
                  y
              };
          }
          function reversePoints(points, index) {
              var reverseMap = {
                  t: "b",
                  b: "t",
                  l: "r",
                  r: "l"
              };
              return points.map((function(point, i) {
                  return i === index ? reverseMap[point] || "c" : point;
              })).join("");
          }
          function toConsumableArray_toConsumableArray(arr) {
              return function(arr) {
                  if (Array.isArray(arr)) return arrayLikeToArray_arrayLikeToArray(arr);
              }(arr) || function(iter) {
                  if ("undefined" != typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) return Array.from(iter);
              }(arr) || unsupportedIterableToArray_unsupportedIterableToArray(arr) || function() {
                  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }();
          }
          var trigger_es_excluded = [ "prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode" ];
          const trigger_es = function() {
              var PortalComponent = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : portal_es, Trigger = react.forwardRef((function(props, ref) {
                  var _props$prefixCls = props.prefixCls, prefixCls = void 0 === _props$prefixCls ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action = void 0 === _props$action ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = void 0 === _props$mouseLeaveDela ? .1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = void 0 === _props$maskClosable || _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = void 0 === _props$builtinPlaceme ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, fresh = props.fresh, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = esm_objectWithoutProperties_objectWithoutProperties(props, trigger_es_excluded), mergedAutoDestroy = autoDestroy || destroyPopupOnHide || !1, _React$useState2 = esm_slicedToArray_slicedToArray(react.useState(!1), 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
                  hooks_useLayoutEffect((function() {
                      setMobile(function() {
                          if ("undefined" == typeof navigator || "undefined" == typeof window) return !1;
                          var agent = navigator.userAgent || navigator.vendor || window.opera;
                          return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(null == agent ? void 0 : agent.substr(0, 4));
                      }());
                  }), []);
                  var subPopupElements = react.useRef({}), parentContext = react.useContext(trigger_es_context), context = react.useMemo((function() {
                      return {
                          registerSubPopup: function(id, subPopupEle) {
                              subPopupElements.current[id] = subPopupEle, null == parentContext || parentContext.registerSubPopup(id, subPopupEle);
                          }
                      };
                  }), [ parentContext ]), id = useId(), _React$useState4 = esm_slicedToArray_slicedToArray(react.useState(null), 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1], setPopupRef = useEvent((function(node) {
                      isDOM(node) && popupEle !== node && setPopupEle(node), null == parentContext || parentContext.registerSubPopup(id, node);
                  })), _React$useState6 = esm_slicedToArray_slicedToArray(react.useState(null), 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1], externalForwardRef = react.useRef(null), setTargetRef = useEvent((function(node) {
                      isDOM(node) && targetEle !== node && (setTargetEle(node), externalForwardRef.current = node);
                  })), child = react.Children.only(children), originChildProps = (null == child ? void 0 : child.props) || {}, cloneProps = {}, inPopupOrChild = useEvent((function(ele) {
                      var _getShadowRoot, _getShadowRoot2, childDOM = targetEle;
                      return (null == childDOM ? void 0 : childDOM.contains(ele)) || (null === (_getShadowRoot = getShadowRoot(childDOM)) || void 0 === _getShadowRoot ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (null == popupEle ? void 0 : popupEle.contains(ele)) || (null === (_getShadowRoot2 = getShadowRoot(popupEle)) || void 0 === _getShadowRoot2 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some((function(subPopupEle) {
                          return (null == subPopupEle ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
                      }));
                  })), mergePopupMotion = getMotion(prefixCls, popupMotion, popupAnimation, popupTransitionName), mergeMaskMotion = getMotion(prefixCls, maskMotion, maskAnimation, maskTransitionName), _React$useState8 = esm_slicedToArray_slicedToArray(react.useState(defaultPopupVisible || !1), 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1], mergedOpen = null != popupVisible ? popupVisible : internalOpen, setMergedOpen = useEvent((function(nextOpen) {
                      void 0 === popupVisible && setInternalOpen(nextOpen);
                  }));
                  hooks_useLayoutEffect((function() {
                      setInternalOpen(popupVisible || !1);
                  }), [ popupVisible ]);
                  var openRef = react.useRef(mergedOpen);
                  openRef.current = mergedOpen;
                  var internalTriggerOpen = useEvent((function(nextOpen) {
                      (0, react_dom.flushSync)((function() {
                          mergedOpen !== nextOpen && (setMergedOpen(nextOpen), null == onPopupVisibleChange || onPopupVisibleChange(nextOpen));
                      }));
                  })), delayRef = react.useRef(), clearDelay = function() {
                      clearTimeout(delayRef.current);
                  }, triggerOpen = function(nextOpen) {
                      var delay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                      clearDelay(), 0 === delay ? internalTriggerOpen(nextOpen) : delayRef.current = setTimeout((function() {
                          internalTriggerOpen(nextOpen);
                      }), 1e3 * delay);
                  };
                  react.useEffect((function() {
                      return clearDelay;
                  }), []);
                  var _React$useState10 = esm_slicedToArray_slicedToArray(react.useState(!1), 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
                  hooks_useLayoutEffect((function(firstMount) {
                      firstMount && !mergedOpen || setInMotion(!0);
                  }), [ mergedOpen ]);
                  var _React$useState12 = esm_slicedToArray_slicedToArray(react.useState(null), 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1], _React$useState14 = esm_slicedToArray_slicedToArray(react.useState([ 0, 0 ]), 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1], setMousePosByEvent = function(event) {
                      setMousePos([ event.clientX, event.clientY ]);
                  }, _useAlign = function(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
                      var _React$useState2 = esm_slicedToArray_slicedToArray(react.useState({
                          ready: !1,
                          offsetX: 0,
                          offsetY: 0,
                          offsetR: 0,
                          offsetB: 0,
                          arrowX: 0,
                          arrowY: 0,
                          scaleX: 1,
                          scaleY: 1,
                          align: builtinPlacements[placement] || {}
                      }), 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1], alignCountRef = react.useRef(0), scrollerList = react.useMemo((function() {
                          return popupEle ? collectScroller(popupEle) : [];
                      }), [ popupEle ]), prevFlipRef = react.useRef({});
                      open || (prevFlipRef.current = {});
                      var onAlign = useEvent((function() {
                          if (popupEle && target && open) {
                              var _popupElement$parentE, _popupElement$parentE2, targetRect, popupElement = popupEle, doc = popupElement.ownerDocument, _win$getComputedStyle = getWin(popupElement).getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height, popupPosition = _win$getComputedStyle.position, originLeft = popupElement.style.left, originTop = popupElement.style.top, originRight = popupElement.style.right, originBottom = popupElement.style.bottom, placementInfo = objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, builtinPlacements[placement]), popupAlign), placeholderElement = doc.createElement("div");
                              if (null === (_popupElement$parentE = popupElement.parentElement) || void 0 === _popupElement$parentE || _popupElement$parentE.appendChild(placeholderElement), 
                              placeholderElement.style.left = "".concat(popupElement.offsetLeft, "px"), placeholderElement.style.top = "".concat(popupElement.offsetTop, "px"), 
                              placeholderElement.style.position = popupPosition, placeholderElement.style.height = "".concat(popupElement.offsetHeight, "px"), 
                              placeholderElement.style.width = "".concat(popupElement.offsetWidth, "px"), popupElement.style.left = "0", 
                              popupElement.style.top = "0", popupElement.style.right = "auto", popupElement.style.bottom = "auto", 
                              Array.isArray(target)) targetRect = {
                                  x: target[0],
                                  y: target[1],
                                  width: 0,
                                  height: 0
                              }; else {
                                  var rect = target.getBoundingClientRect();
                                  targetRect = {
                                      x: rect.x,
                                      y: rect.y,
                                      width: rect.width,
                                      height: rect.height
                                  };
                              }
                              var popupRect = popupElement.getBoundingClientRect(), _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft, popupHeight = popupRect.height, popupWidth = popupRect.width, targetHeight = targetRect.height, targetWidth = targetRect.width, visibleRegion = {
                                  left: 0,
                                  top: 0,
                                  right: clientWidth,
                                  bottom: clientHeight
                              }, scrollRegion = {
                                  left: -scrollLeft,
                                  top: -scrollTop,
                                  right: scrollWidth - scrollLeft,
                                  bottom: scrollHeight - scrollTop
                              }, htmlRegion = placementInfo.htmlRegion;
                              "scroll" !== htmlRegion && "visibleFirst" !== htmlRegion && (htmlRegion = "visible");
                              var isVisibleFirst = "visibleFirst" === htmlRegion, scrollRegionArea = getVisibleArea(scrollRegion, scrollerList), visibleRegionArea = getVisibleArea(visibleRegion, scrollerList), visibleArea = "visible" === htmlRegion ? visibleRegionArea : scrollRegionArea, adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
                              popupElement.style.left = "auto", popupElement.style.top = "auto", popupElement.style.right = "0", 
                              popupElement.style.bottom = "0";
                              var popupMirrorRect = popupElement.getBoundingClientRect();
                              popupElement.style.left = originLeft, popupElement.style.top = originTop, popupElement.style.right = originRight, 
                              popupElement.style.bottom = originBottom, null === (_popupElement$parentE2 = popupElement.parentElement) || void 0 === _popupElement$parentE2 || _popupElement$parentE2.removeChild(placeholderElement);
                              var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3), _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
                              if (0 === _scaleX || 0 === _scaleY || isDOM(target) && !isVisible(target)) return;
                              var offset = placementInfo.offset, targetOffset = placementInfo.targetOffset, _getNumberOffset2 = esm_slicedToArray_slicedToArray(getNumberOffset(popupRect, offset), 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1], _getNumberOffset4 = esm_slicedToArray_slicedToArray(getNumberOffset(targetRect, targetOffset), 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
                              targetRect.x -= targetOffsetX, targetRect.y -= targetOffsetY;
                              var _ref4 = esm_slicedToArray_slicedToArray(placementInfo.points || [], 2), popupPoint = _ref4[0], targetPoints = splitPoints(_ref4[1]), popupPoints = splitPoints(popupPoint), targetAlignPoint = getAlignPoint(targetRect, targetPoints), popupAlignPoint = getAlignPoint(popupRect, popupPoints), nextAlignInfo = objectSpread2_objectSpread2({}, placementInfo), nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX, nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
                              function getIntersectionVisibleArea(offsetX, offsetY) {
                                  var area = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : visibleArea, l = popupRect.x + offsetX, t = popupRect.y + offsetY, r = l + popupWidth, b = t + popupHeight, visibleL = Math.max(l, area.left), visibleT = Math.max(t, area.top), visibleR = Math.min(r, area.right), visibleB = Math.min(b, area.bottom);
                                  return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
                              }
                              var nextPopupY, nextPopupBottom, nextPopupX, nextPopupRight, originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY), originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea), targetAlignPointTL = getAlignPoint(targetRect, [ "t", "l" ]), popupAlignPointTL = getAlignPoint(popupRect, [ "t", "l" ]), targetAlignPointBR = getAlignPoint(targetRect, [ "b", "r" ]), popupAlignPointBR = getAlignPoint(popupRect, [ "b", "r" ]), overflow = placementInfo.overflow || {}, adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY, supportAdjust = function(val) {
                                  return "boolean" == typeof val ? val : val >= 0;
                              };
                              function syncNextPopupPosition() {
                                  nextPopupY = popupRect.y + nextOffsetY, nextPopupBottom = nextPopupY + popupHeight, 
                                  nextPopupX = popupRect.x + nextOffsetX, nextPopupRight = nextPopupX + popupWidth;
                              }
                              syncNextPopupPosition();
                              var needAdjustY = supportAdjust(adjustY), sameTB = popupPoints[0] === targetPoints[0];
                              if (needAdjustY && "t" === popupPoints[0] && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
                                  var tmpNextOffsetY = nextOffsetY;
                                  sameTB ? tmpNextOffsetY -= popupHeight - targetHeight : tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
                                  var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY), newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
                                  newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || newVisibleRecommendArea >= originIntersectionRecommendArea) ? (prevFlipRef.current.bt = !0, 
                                  nextOffsetY = tmpNextOffsetY, popupOffsetY = -popupOffsetY, nextAlignInfo.points = [ reversePoints(popupPoints, 0), reversePoints(targetPoints, 0) ]) : prevFlipRef.current.bt = !1;
                              }
                              if (needAdjustY && "b" === popupPoints[0] && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
                                  var _tmpNextOffsetY = nextOffsetY;
                                  sameTB ? _tmpNextOffsetY += popupHeight - targetHeight : _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
                                  var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY), _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
                                  _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || _newVisibleRecommendArea >= originIntersectionRecommendArea) ? (prevFlipRef.current.tb = !0, 
                                  nextOffsetY = _tmpNextOffsetY, popupOffsetY = -popupOffsetY, nextAlignInfo.points = [ reversePoints(popupPoints, 0), reversePoints(targetPoints, 0) ]) : prevFlipRef.current.tb = !1;
                              }
                              var needAdjustX = supportAdjust(adjustX), sameLR = popupPoints[1] === targetPoints[1];
                              if (needAdjustX && "l" === popupPoints[1] && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
                                  var tmpNextOffsetX = nextOffsetX;
                                  sameLR ? tmpNextOffsetX -= popupWidth - targetWidth : tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
                                  var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY), _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
                                  _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || _newVisibleRecommendArea2 >= originIntersectionRecommendArea) ? (prevFlipRef.current.rl = !0, 
                                  nextOffsetX = tmpNextOffsetX, popupOffsetX = -popupOffsetX, nextAlignInfo.points = [ reversePoints(popupPoints, 1), reversePoints(targetPoints, 1) ]) : prevFlipRef.current.rl = !1;
                              }
                              if (needAdjustX && "r" === popupPoints[1] && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
                                  var _tmpNextOffsetX = nextOffsetX;
                                  sameLR ? _tmpNextOffsetX += popupWidth - targetWidth : _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
                                  var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY), _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
                                  _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || _newVisibleRecommendArea3 >= originIntersectionRecommendArea) ? (prevFlipRef.current.lr = !0, 
                                  nextOffsetX = _tmpNextOffsetX, popupOffsetX = -popupOffsetX, nextAlignInfo.points = [ reversePoints(popupPoints, 1), reversePoints(targetPoints, 1) ]) : prevFlipRef.current.lr = !1;
                              }
                              syncNextPopupPosition();
                              var numShiftX = !0 === shiftX ? 0 : shiftX;
                              "number" == typeof numShiftX && (nextPopupX < visibleRegionArea.left && (nextOffsetX -= nextPopupX - visibleRegionArea.left - popupOffsetX, 
                              targetRect.x + targetWidth < visibleRegionArea.left + numShiftX && (nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX)), 
                              nextPopupRight > visibleRegionArea.right && (nextOffsetX -= nextPopupRight - visibleRegionArea.right - popupOffsetX, 
                              targetRect.x > visibleRegionArea.right - numShiftX && (nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX)));
                              var numShiftY = !0 === shiftY ? 0 : shiftY;
                              "number" == typeof numShiftY && (nextPopupY < visibleRegionArea.top && (nextOffsetY -= nextPopupY - visibleRegionArea.top - popupOffsetY, 
                              targetRect.y + targetHeight < visibleRegionArea.top + numShiftY && (nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY)), 
                              nextPopupBottom > visibleRegionArea.bottom && (nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom - popupOffsetY, 
                              targetRect.y > visibleRegionArea.bottom - numShiftY && (nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY)));
                              var popupLeft = popupRect.x + nextOffsetX, popupRight = popupLeft + popupWidth, popupTop = popupRect.y + nextOffsetY, popupBottom = popupTop + popupHeight, targetLeft = targetRect.x, targetRight = targetLeft + targetWidth, targetTop = targetRect.y, targetBottom = targetTop + targetHeight, nextArrowX = (Math.max(popupLeft, targetLeft) + Math.min(popupRight, targetRight)) / 2 - popupLeft, nextArrowY = (Math.max(popupTop, targetTop) + Math.min(popupBottom, targetBottom)) / 2 - popupTop;
                              null == onPopupAlign || onPopupAlign(popupEle, nextAlignInfo);
                              var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width), offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
                              setOffsetInfo({
                                  ready: !0,
                                  offsetX: nextOffsetX / _scaleX,
                                  offsetY: nextOffsetY / _scaleY,
                                  offsetR: offsetX4Right / _scaleX,
                                  offsetB: offsetY4Bottom / _scaleY,
                                  arrowX: nextArrowX / _scaleX,
                                  arrowY: nextArrowY / _scaleY,
                                  scaleX: _scaleX,
                                  scaleY: _scaleY,
                                  align: nextAlignInfo
                              });
                          }
                      })), resetReady = function() {
                          setOffsetInfo((function(ori) {
                              return objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, ori), {}, {
                                  ready: !1
                              });
                          }));
                      };
                      return hooks_useLayoutEffect(resetReady, [ placement ]), hooks_useLayoutEffect((function() {
                          open || resetReady();
                      }), [ open ]), [ offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, function() {
                          alignCountRef.current += 1;
                          var id = alignCountRef.current;
                          Promise.resolve().then((function() {
                              alignCountRef.current === id && onAlign();
                          }));
                      } ];
                  }(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = esm_slicedToArray_slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10], _useAction = function(mobile, action, showAction, hideAction) {
                      return react.useMemo((function() {
                          var mergedShowAction = useAction_toArray(null != showAction ? showAction : action), mergedHideAction = useAction_toArray(null != hideAction ? hideAction : action), showActionSet = new Set(mergedShowAction), hideActionSet = new Set(mergedHideAction);
                          return mobile && (showActionSet.has("hover") && (showActionSet.delete("hover"), 
                          showActionSet.add("click")), hideActionSet.has("hover") && (hideActionSet.delete("hover"), 
                          hideActionSet.add("click"))), [ showActionSet, hideActionSet ];
                      }), [ mobile, action, showAction, hideAction ]);
                  }(mobile, action, showAction, hideAction), _useAction2 = esm_slicedToArray_slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1], clickToShow = showActions.has("click"), clickToHide = hideActions.has("click") || hideActions.has("contextMenu"), triggerAlign = useEvent((function() {
                      inMotion || onAlign();
                  }));
                  !function(open, target, popup, onAlign, onScroll) {
                      hooks_useLayoutEffect((function() {
                          if (open && target && popup) {
                              var popupElement = popup, targetScrollList = collectScroller(target), popupScrollList = collectScroller(popupElement), win = getWin(popupElement), mergedList = new Set([ win ].concat(toConsumableArray_toConsumableArray(targetScrollList), toConsumableArray_toConsumableArray(popupScrollList)));
                              function notifyScroll() {
                                  onAlign(), onScroll();
                              }
                              return mergedList.forEach((function(scroller) {
                                  scroller.addEventListener("scroll", notifyScroll, {
                                      passive: !0
                                  });
                              })), win.addEventListener("resize", notifyScroll, {
                                  passive: !0
                              }), onAlign(), function() {
                                  mergedList.forEach((function(scroller) {
                                      scroller.removeEventListener("scroll", notifyScroll), win.removeEventListener("resize", notifyScroll);
                                  }));
                              };
                          }
                      }), [ open, target, popup ]);
                  }(mergedOpen, targetEle, popupEle, triggerAlign, (function() {
                      openRef.current && alignPoint && clickToHide && triggerOpen(!1);
                  })), hooks_useLayoutEffect((function() {
                      triggerAlign();
                  }), [ mousePos, popupPlacement ]), hooks_useLayoutEffect((function() {
                      !mergedOpen || null != builtinPlacements && builtinPlacements[popupPlacement] || triggerAlign();
                  }), [ JSON.stringify(popupAlign) ]);
                  var alignedClassName = react.useMemo((function() {
                      var baseClassName = function(builtinPlacements, prefixCls, align, isAlignPoint) {
                          for (var points = align.points, placements = Object.keys(builtinPlacements), i = 0; i < placements.length; i += 1) {
                              var _builtinPlacements$pl, placement = placements[i];
                              if (isPointsEq(null === (_builtinPlacements$pl = builtinPlacements[placement]) || void 0 === _builtinPlacements$pl ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) return "".concat(prefixCls, "-placement-").concat(placement);
                          }
                          return "";
                      }(builtinPlacements, prefixCls, alignInfo, alignPoint);
                      return classnames_default()(baseClassName, null == getPopupClassNameFromAlign ? void 0 : getPopupClassNameFromAlign(alignInfo));
                  }), [ alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint ]);
                  react.useImperativeHandle(ref, (function() {
                      return {
                          nativeElement: externalForwardRef.current,
                          forceAlign: triggerAlign
                      };
                  }));
                  var _React$useState16 = esm_slicedToArray_slicedToArray(react.useState(0), 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1], _React$useState18 = esm_slicedToArray_slicedToArray(react.useState(0), 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1], syncTargetSize = function() {
                      if (stretch && targetEle) {
                          var rect = targetEle.getBoundingClientRect();
                          setTargetWidth(rect.width), setTargetHeight(rect.height);
                      }
                  };
                  function wrapperAction(eventName, nextOpen, delay, preEvent) {
                      cloneProps[eventName] = function(event) {
                          var _originChildProps$eve;
                          null == preEvent || preEvent(event), triggerOpen(nextOpen, delay);
                          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
                          null === (_originChildProps$eve = originChildProps[eventName]) || void 0 === _originChildProps$eve || _originChildProps$eve.call.apply(_originChildProps$eve, [ originChildProps, event ].concat(args));
                      };
                  }
                  hooks_useLayoutEffect((function() {
                      motionPrepareResolve && (onAlign(), motionPrepareResolve(), setMotionPrepareResolve(null));
                  }), [ motionPrepareResolve ]), (clickToShow || clickToHide) && (cloneProps.onClick = function(event) {
                      var _originChildProps$onC;
                      openRef.current && clickToHide ? triggerOpen(!1) : !openRef.current && clickToShow && (setMousePosByEvent(event), 
                      triggerOpen(!0));
                      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];
                      null === (_originChildProps$onC = originChildProps.onClick) || void 0 === _originChildProps$onC || _originChildProps$onC.call.apply(_originChildProps$onC, [ originChildProps, event ].concat(args));
                  }), function(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
                      var openRef = react.useRef(open), lockRef = react.useRef(!1);
                      openRef.current !== open && (lockRef.current = !0, openRef.current = open), react.useEffect((function() {
                          var id = es_raf((function() {
                              lockRef.current = !1;
                          }));
                          return function() {
                              es_raf.cancel(id);
                          };
                      }), [ open ]), react.useEffect((function() {
                          if (clickToHide && popupEle && (!mask || maskClosable)) {
                              var genClickEvents = function() {
                                  var clickInside = !1;
                                  return [ function(_ref) {
                                      var target = _ref.target;
                                      clickInside = inPopupOrChild(target);
                                  }, function(_ref2) {
                                      var target = _ref2.target;
                                      lockRef.current || !openRef.current || clickInside || inPopupOrChild(target) || triggerOpen(!1);
                                  } ];
                              }, _genClickEvents2 = esm_slicedToArray_slicedToArray(genClickEvents(), 2), onWinMouseDown = _genClickEvents2[0], onWinClick = _genClickEvents2[1], _genClickEvents4 = esm_slicedToArray_slicedToArray(genClickEvents(), 2), onShadowMouseDown = _genClickEvents4[0], onShadowClick = _genClickEvents4[1], win = getWin(popupEle);
                              win.addEventListener("mousedown", onWinMouseDown, !0), win.addEventListener("click", onWinClick, !0), 
                              win.addEventListener("contextmenu", onWinClick, !0);
                              var targetShadowRoot = getShadowRoot(targetEle);
                              return targetShadowRoot && (targetShadowRoot.addEventListener("mousedown", onShadowMouseDown, !0), 
                              targetShadowRoot.addEventListener("click", onShadowClick, !0), targetShadowRoot.addEventListener("contextmenu", onShadowClick, !0)), 
                              function() {
                                  win.removeEventListener("mousedown", onWinMouseDown, !0), win.removeEventListener("click", onWinClick, !0), 
                                  win.removeEventListener("contextmenu", onWinClick, !0), targetShadowRoot && (targetShadowRoot.removeEventListener("mousedown", onShadowMouseDown, !0), 
                                  targetShadowRoot.removeEventListener("click", onShadowClick, !0), targetShadowRoot.removeEventListener("contextmenu", onShadowClick, !0));
                              };
                          }
                      }), [ clickToHide, targetEle, popupEle, mask, maskClosable ]);
                  }(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
                  var onPopupMouseEnter, onPopupMouseLeave, hoverToShow = showActions.has("hover"), hoverToHide = hideActions.has("hover");
                  hoverToShow && (wrapperAction("onMouseEnter", !0, mouseEnterDelay, (function(event) {
                      setMousePosByEvent(event);
                  })), wrapperAction("onPointerEnter", !0, mouseEnterDelay, (function(event) {
                      setMousePosByEvent(event);
                  })), onPopupMouseEnter = function() {
                      (mergedOpen || inMotion) && triggerOpen(!0, mouseEnterDelay);
                  }, alignPoint && (cloneProps.onMouseMove = function(event) {
                      var _originChildProps$onM;
                      null === (_originChildProps$onM = originChildProps.onMouseMove) || void 0 === _originChildProps$onM || _originChildProps$onM.call(originChildProps, event);
                  })), hoverToHide && (wrapperAction("onMouseLeave", !1, mouseLeaveDelay), wrapperAction("onPointerLeave", !1, mouseLeaveDelay), 
                  onPopupMouseLeave = function() {
                      triggerOpen(!1, mouseLeaveDelay);
                  }), showActions.has("focus") && wrapperAction("onFocus", !0, focusDelay), hideActions.has("focus") && wrapperAction("onBlur", !1, blurDelay), 
                  showActions.has("contextMenu") && (cloneProps.onContextMenu = function(event) {
                      var _originChildProps$onC2;
                      openRef.current && hideActions.has("contextMenu") ? triggerOpen(!1) : (setMousePosByEvent(event), 
                      triggerOpen(!0)), event.preventDefault();
                      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) args[_key3 - 1] = arguments[_key3];
                      null === (_originChildProps$onC2 = originChildProps.onContextMenu) || void 0 === _originChildProps$onC2 || _originChildProps$onC2.call.apply(_originChildProps$onC2, [ originChildProps, event ].concat(args));
                  }), className && (cloneProps.className = classnames_default()(originChildProps.className, className));
                  var mergedChildrenProps = objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, originChildProps), cloneProps), passedProps = {};
                  [ "onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur" ].forEach((function(eventName) {
                      restProps[eventName] && (passedProps[eventName] = function() {
                          for (var _mergedChildrenProps$, _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                          null === (_mergedChildrenProps$ = mergedChildrenProps[eventName]) || void 0 === _mergedChildrenProps$ || _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [ mergedChildrenProps ].concat(args)), 
                          restProps[eventName].apply(restProps, args);
                      });
                  }));
                  var triggerNode = react.cloneElement(child, objectSpread2_objectSpread2(objectSpread2_objectSpread2({}, mergedChildrenProps), passedProps)), arrowPos = {
                      x: arrowX,
                      y: arrowY
                  }, innerArrow = arrow ? objectSpread2_objectSpread2({}, !0 !== arrow ? arrow : {}) : null;
                  return react.createElement(react.Fragment, null, react.createElement(rc_resize_observer_es, {
                      disabled: !mergedOpen,
                      ref: setTargetRef,
                      onResize: function() {
                          syncTargetSize(), triggerAlign();
                      }
                  }, react.createElement(es_TriggerWrapper, {
                      getTriggerDOMNode
                  }, triggerNode)), react.createElement(trigger_es_context.Provider, {
                      value: context
                  }, react.createElement(es_Popup, {
                      portal: PortalComponent,
                      ref: setPopupRef,
                      prefixCls,
                      popup,
                      className: classnames_default()(popupClassName, alignedClassName),
                      style: popupStyle,
                      target: targetEle,
                      onMouseEnter: onPopupMouseEnter,
                      onMouseLeave: onPopupMouseLeave,
                      onPointerEnter: onPopupMouseEnter,
                      zIndex,
                      open: mergedOpen,
                      keepDom: inMotion,
                      fresh,
                      onClick: onPopupClick,
                      mask,
                      motion: mergePopupMotion,
                      maskMotion: mergeMaskMotion,
                      onVisibleChanged: function(visible) {
                          setInMotion(!1), onAlign(), null == afterPopupVisibleChange || afterPopupVisibleChange(visible);
                      },
                      onPrepare: function() {
                          return new Promise((function(resolve) {
                              syncTargetSize(), setMotionPrepareResolve((function() {
                                  return resolve;
                              }));
                          }));
                      },
                      forceRender,
                      autoDestroy: mergedAutoDestroy,
                      getPopupContainer,
                      align: alignInfo,
                      arrow: innerArrow,
                      arrowPos,
                      ready,
                      offsetX,
                      offsetY,
                      offsetR,
                      offsetB,
                      onAlign: triggerAlign,
                      stretch,
                      targetWidth: targetWidth / scaleX,
                      targetHeight: targetHeight / scaleY
                  })));
              }));
              return Trigger;
          }(portal_es);
          var autoAdjustOverflowTopBottom = {
              shiftX: 64,
              adjustY: 1
          }, autoAdjustOverflowLeftRight = {
              adjustX: 1,
              shiftY: !0
          }, targetOffset = [ 0, 0 ], placements = {
              left: {
                  points: [ "cr", "cl" ],
                  overflow: autoAdjustOverflowLeftRight,
                  offset: [ -4, 0 ],
                  targetOffset
              },
              right: {
                  points: [ "cl", "cr" ],
                  overflow: autoAdjustOverflowLeftRight,
                  offset: [ 4, 0 ],
                  targetOffset
              },
              top: {
                  points: [ "bc", "tc" ],
                  overflow: autoAdjustOverflowTopBottom,
                  offset: [ 0, -4 ],
                  targetOffset
              },
              bottom: {
                  points: [ "tc", "bc" ],
                  overflow: autoAdjustOverflowTopBottom,
                  offset: [ 0, 4 ],
                  targetOffset
              },
              topLeft: {
                  points: [ "bl", "tl" ],
                  overflow: autoAdjustOverflowTopBottom,
                  offset: [ 0, -4 ],
                  targetOffset
              },
              leftTop: {
                  points: [ "tr", "tl" ],
                  overflow: autoAdjustOverflowLeftRight,
                  offset: [ -4, 0 ],
                  targetOffset
              },
              topRight: {
                  points: [ "br", "tr" ],
                  overflow: autoAdjustOverflowTopBottom,
                  offset: [ 0, -4 ],
                  targetOffset
              },
              rightTop: {
                  points: [ "tl", "tr" ],
                  overflow: autoAdjustOverflowLeftRight,
                  offset: [ 4, 0 ],
                  targetOffset
              },
              bottomRight: {
                  points: [ "tr", "br" ],
                  overflow: autoAdjustOverflowTopBottom,
                  offset: [ 0, 4 ],
                  targetOffset
              },
              rightBottom: {
                  points: [ "bl", "br" ],
                  overflow: autoAdjustOverflowLeftRight,
                  offset: [ 4, 0 ],
                  targetOffset
              },
              bottomLeft: {
                  points: [ "tl", "bl" ],
                  overflow: autoAdjustOverflowTopBottom,
                  offset: [ 0, 4 ],
                  targetOffset
              },
              leftBottom: {
                  points: [ "br", "bl" ],
                  overflow: autoAdjustOverflowLeftRight,
                  offset: [ -4, 0 ],
                  targetOffset
              }
          };
          var Tooltip_excluded = [ "overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow" ], Tooltip = function(props, ref) {
              var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = void 0 === _props$trigger ? [ "hover" ] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = void 0 === _props$mouseEnterDela ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = void 0 === _props$mouseLeaveDela ? .1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = void 0 === _props$prefixCls ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = void 0 === _props$placement ? "right" : _props$placement, _props$align = props.align, align = void 0 === _props$align ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = void 0 !== _props$destroyTooltip && _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle, overlay = (props.arrowContent, 
              props.overlay), id = props.id, _props$showArrow = props.showArrow, showArrow = void 0 === _props$showArrow || _props$showArrow, restProps = objectWithoutProperties_objectWithoutProperties(props, Tooltip_excluded), triggerRef = (0, 
              react.useRef)(null);
              (0, react.useImperativeHandle)(ref, (function() {
                  return triggerRef.current;
              }));
              var extraProps = _objectSpread2({}, restProps);
              "visible" in props && (extraProps.popupVisible = props.visible);
              return react.createElement(trigger_es, _extends({
                  popupClassName: overlayClassName,
                  prefixCls,
                  popup: function() {
                      return react.createElement(Popup, {
                          key: "content",
                          prefixCls,
                          id,
                          overlayInnerStyle
                      }, overlay);
                  },
                  action: trigger,
                  builtinPlacements: placements,
                  popupPlacement: placement,
                  ref: triggerRef,
                  popupAlign: align,
                  getPopupContainer: getTooltipContainer,
                  onPopupVisibleChange: onVisibleChange,
                  afterPopupVisibleChange: afterVisibleChange,
                  popupTransitionName: transitionName,
                  popupAnimation: animation,
                  popupMotion: motion,
                  defaultPopupVisible: defaultVisible,
                  autoDestroy: destroyTooltipOnHide,
                  mouseLeaveDelay,
                  popupStyle: overlayStyle,
                  mouseEnterDelay,
                  arrow: showArrow
              }, extraProps), children);
          };
          const rc_tooltip_es = (0, react.forwardRef)(Tooltip), motion_getTransitionName = (rootPrefixCls, motion, transitionName) => void 0 !== transitionName ? transitionName : `${rootPrefixCls}-${motion}`, roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
              const unitWidth = width / 2, ay = unitWidth, bx = 1 * outerRadius / Math.sqrt(2), by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2)), cx = unitWidth - innerRadius * (1 / Math.sqrt(2)), cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2)), dx = 2 * unitWidth - cx, dy = cy, ex = 2 * unitWidth - bx, ey = by, fx = 2 * unitWidth - 0, fy = ay, shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2), polygonOffset = outerRadius * (Math.sqrt(2) - 1);
              return {
                  pointerEvents: "none",
                  width,
                  height: width,
                  overflow: "hidden",
                  "&::before": {
                      position: "absolute",
                      bottom: 0,
                      insetInlineStart: 0,
                      width,
                      height: width / 2,
                      background: bgColor,
                      clipPath: {
                          _multi_value_: !0,
                          value: [ `polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M 0 ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')` ]
                      },
                      content: '""'
                  },
                  "&::after": {
                      content: '""',
                      position: "absolute",
                      width: shadowWidth,
                      height: shadowWidth,
                      bottom: 0,
                      insetInline: 0,
                      margin: "auto",
                      borderRadius: {
                          _skip_check_: !0,
                          value: `0 0 ${innerRadius}px 0`
                      },
                      transform: "translateY(50%) rotate(-135deg)",
                      boxShadow,
                      zIndex: 0,
                      background: "transparent"
                  }
              };
          }, MAX_VERTICAL_CONTENT_RADIUS = 8;
          function getArrowOffset(options) {
              const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS, {contentRadius, limitVerticalRadius} = options, dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
              return {
                  dropdownArrowOffset,
                  dropdownArrowOffsetVertical: limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset
              };
          }
          function isInject(valid, code) {
              return valid ? code : {};
          }
          function getArrowStyle(token, options) {
              const {componentCls, sizePopupArrow, borderRadiusXS, borderRadiusOuter, boxShadowPopoverArrow} = token, {colorBg, contentRadius = token.borderRadiusLG, limitVerticalRadius, arrowDistance = 0, arrowPlacement = {
                  left: !0,
                  right: !0,
                  top: !0,
                  bottom: !0
              }} = options, {dropdownArrowOffsetVertical, dropdownArrowOffset} = getArrowOffset({
                  contentRadius,
                  limitVerticalRadius
              });
              return {
                  [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
                      [`${componentCls}-arrow`]: [ Object.assign(Object.assign({
                          position: "absolute",
                          zIndex: 1,
                          display: "block"
                      }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
                          "&:before": {
                              background: colorBg
                          }
                      }) ]
                  }, isInject(!!arrowPlacement.top, {
                      [[ `&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow` ].join(",")]: {
                          bottom: arrowDistance,
                          transform: "translateY(100%) rotate(180deg)"
                      },
                      [`&-placement-top ${componentCls}-arrow`]: {
                          left: {
                              _skip_check_: !0,
                              value: "50%"
                          },
                          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
                      },
                      [`&-placement-topLeft ${componentCls}-arrow`]: {
                          left: {
                              _skip_check_: !0,
                              value: dropdownArrowOffset
                          }
                      },
                      [`&-placement-topRight ${componentCls}-arrow`]: {
                          right: {
                              _skip_check_: !0,
                              value: dropdownArrowOffset
                          }
                      }
                  })), isInject(!!arrowPlacement.bottom, {
                      [[ `&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow` ].join(",")]: {
                          top: arrowDistance,
                          transform: "translateY(-100%)"
                      },
                      [`&-placement-bottom ${componentCls}-arrow`]: {
                          left: {
                              _skip_check_: !0,
                              value: "50%"
                          },
                          transform: "translateX(-50%) translateY(-100%)"
                      },
                      [`&-placement-bottomLeft ${componentCls}-arrow`]: {
                          left: {
                              _skip_check_: !0,
                              value: dropdownArrowOffset
                          }
                      },
                      [`&-placement-bottomRight ${componentCls}-arrow`]: {
                          right: {
                              _skip_check_: !0,
                              value: dropdownArrowOffset
                          }
                      }
                  })), isInject(!!arrowPlacement.left, {
                      [[ `&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow` ].join(",")]: {
                          right: {
                              _skip_check_: !0,
                              value: arrowDistance
                          },
                          transform: "translateX(100%) rotate(90deg)"
                      },
                      [`&-placement-left ${componentCls}-arrow`]: {
                          top: {
                              _skip_check_: !0,
                              value: "50%"
                          },
                          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
                      },
                      [`&-placement-leftTop ${componentCls}-arrow`]: {
                          top: dropdownArrowOffsetVertical
                      },
                      [`&-placement-leftBottom ${componentCls}-arrow`]: {
                          bottom: dropdownArrowOffsetVertical
                      }
                  })), isInject(!!arrowPlacement.right, {
                      [[ `&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow` ].join(",")]: {
                          left: {
                              _skip_check_: !0,
                              value: arrowDistance
                          },
                          transform: "translateX(-100%) rotate(-90deg)"
                      },
                      [`&-placement-right ${componentCls}-arrow`]: {
                          top: {
                              _skip_check_: !0,
                              value: "50%"
                          },
                          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
                      },
                      [`&-placement-rightTop ${componentCls}-arrow`]: {
                          top: dropdownArrowOffsetVertical
                      },
                      [`&-placement-rightBottom ${componentCls}-arrow`]: {
                          bottom: dropdownArrowOffsetVertical
                      }
                  }))
              };
          }
          const PlacementAlignMap = {
              left: {
                  points: [ "cr", "cl" ]
              },
              right: {
                  points: [ "cl", "cr" ]
              },
              top: {
                  points: [ "bc", "tc" ]
              },
              bottom: {
                  points: [ "tc", "bc" ]
              },
              topLeft: {
                  points: [ "bl", "tl" ]
              },
              leftTop: {
                  points: [ "tr", "tl" ]
              },
              topRight: {
                  points: [ "br", "tr" ]
              },
              rightTop: {
                  points: [ "tl", "tr" ]
              },
              bottomRight: {
                  points: [ "tr", "br" ]
              },
              rightBottom: {
                  points: [ "bl", "br" ]
              },
              bottomLeft: {
                  points: [ "tl", "bl" ]
              },
              leftBottom: {
                  points: [ "br", "bl" ]
              }
          }, ArrowCenterPlacementAlignMap = {
              topLeft: {
                  points: [ "bl", "tc" ]
              },
              leftTop: {
                  points: [ "tr", "cl" ]
              },
              topRight: {
                  points: [ "br", "tc" ]
              },
              rightTop: {
                  points: [ "tl", "cr" ]
              },
              bottomRight: {
                  points: [ "tr", "bc" ]
              },
              rightBottom: {
                  points: [ "bl", "cr" ]
              },
              bottomLeft: {
                  points: [ "tl", "bc" ]
              },
              leftBottom: {
                  points: [ "br", "cl" ]
              }
          }, DisableAutoArrowList = new Set([ "topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom" ]);
          function getPlacements(config) {
              const {arrowWidth, autoAdjustOverflow, arrowPointAtCenter, offset, borderRadius, visibleFirst} = config, halfArrowWidth = arrowWidth / 2, placementMap = {};
              return Object.keys(PlacementAlignMap).forEach((key => {
                  const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key], placementInfo = Object.assign(Object.assign({}, template), {
                      offset: [ 0, 0 ],
                      dynamicInset: !0
                  });
                  switch (placementMap[key] = placementInfo, DisableAutoArrowList.has(key) && (placementInfo.autoArrow = !1), 
                  key) {
                    case "top":
                    case "topLeft":
                    case "topRight":
                      placementInfo.offset[1] = -halfArrowWidth - offset;
                      break;

                    case "bottom":
                    case "bottomLeft":
                    case "bottomRight":
                      placementInfo.offset[1] = halfArrowWidth + offset;
                      break;

                    case "left":
                    case "leftTop":
                    case "leftBottom":
                      placementInfo.offset[0] = -halfArrowWidth - offset;
                      break;

                    case "right":
                    case "rightTop":
                    case "rightBottom":
                      placementInfo.offset[0] = halfArrowWidth + offset;
                  }
                  const arrowOffset = getArrowOffset({
                      contentRadius: borderRadius,
                      limitVerticalRadius: !0
                  });
                  if (arrowPointAtCenter) switch (key) {
                    case "topLeft":
                    case "bottomLeft":
                      placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
                      break;

                    case "topRight":
                    case "bottomRight":
                      placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
                      break;

                    case "leftTop":
                    case "rightTop":
                      placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
                      break;

                    case "leftBottom":
                    case "rightBottom":
                      placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
                  }
                  placementInfo.overflow = function(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {
                      if (!1 === autoAdjustOverflow) return {
                          adjustX: !1,
                          adjustY: !1
                      };
                      const overflow = autoAdjustOverflow && "object" == typeof autoAdjustOverflow ? autoAdjustOverflow : {}, baseOverflow = {};
                      switch (placement) {
                        case "top":
                        case "bottom":
                          baseOverflow.shiftX = 2 * arrowOffset.dropdownArrowOffset + arrowWidth, baseOverflow.shiftY = !0, 
                          baseOverflow.adjustY = !0;
                          break;

                        case "left":
                        case "right":
                          baseOverflow.shiftY = 2 * arrowOffset.dropdownArrowOffsetVertical + arrowWidth, 
                          baseOverflow.shiftX = !0, baseOverflow.adjustX = !0;
                      }
                      const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
                      return mergedOverflow.shiftX || (mergedOverflow.adjustX = !0), mergedOverflow.shiftY || (mergedOverflow.adjustY = !0), 
                      mergedOverflow;
                  }(key, arrowOffset, arrowWidth, autoAdjustOverflow), visibleFirst && (placementInfo.htmlRegion = "visibleFirst");
              })), placementMap;
          }
          const initMotionCommon = duration => ({
              animationDuration: duration,
              animationFillMode: "both"
          }), initMotionCommonLeave = duration => ({
              animationDuration: duration,
              animationFillMode: "both"
          }), initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
              const sameLevelPrefix = arguments.length > 4 && void 0 !== arguments[4] && arguments[4] ? "&" : "";
              return {
                  [`\n      ${sameLevelPrefix}${motionCls}-enter,\n      ${sameLevelPrefix}${motionCls}-appear\n    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
                      animationPlayState: "paused"
                  }),
                  [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
                      animationPlayState: "paused"
                  }),
                  [`\n      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,\n      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active\n    `]: {
                      animationName: inKeyframes,
                      animationPlayState: "running"
                  },
                  [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
                      animationName: outKeyframes,
                      animationPlayState: "running",
                      pointerEvents: "none"
                  }
              };
          }, zoomIn = new Keyframes("antZoomIn", {
              "0%": {
                  transform: "scale(0.2)",
                  opacity: 0
              },
              "100%": {
                  transform: "scale(1)",
                  opacity: 1
              }
          }), zoomOut = new Keyframes("antZoomOut", {
              "0%": {
                  transform: "scale(1)"
              },
              "100%": {
                  transform: "scale(0.2)",
                  opacity: 0
              }
          }), zoomBigIn = new Keyframes("antZoomBigIn", {
              "0%": {
                  transform: "scale(0.8)",
                  opacity: 0
              },
              "100%": {
                  transform: "scale(1)",
                  opacity: 1
              }
          }), zoomBigOut = new Keyframes("antZoomBigOut", {
              "0%": {
                  transform: "scale(1)"
              },
              "100%": {
                  transform: "scale(0.8)",
                  opacity: 0
              }
          }), zoomUpIn = new Keyframes("antZoomUpIn", {
              "0%": {
                  transform: "scale(0.8)",
                  transformOrigin: "50% 0%",
                  opacity: 0
              },
              "100%": {
                  transform: "scale(1)",
                  transformOrigin: "50% 0%"
              }
          }), zoomUpOut = new Keyframes("antZoomUpOut", {
              "0%": {
                  transform: "scale(1)",
                  transformOrigin: "50% 0%"
              },
              "100%": {
                  transform: "scale(0.8)",
                  transformOrigin: "50% 0%",
                  opacity: 0
              }
          }), zoomMotion = {
              zoom: {
                  inKeyframes: zoomIn,
                  outKeyframes: zoomOut
              },
              "zoom-big": {
                  inKeyframes: zoomBigIn,
                  outKeyframes: zoomBigOut
              },
              "zoom-big-fast": {
                  inKeyframes: zoomBigIn,
                  outKeyframes: zoomBigOut
              },
              "zoom-left": {
                  inKeyframes: new Keyframes("antZoomLeftIn", {
                      "0%": {
                          transform: "scale(0.8)",
                          transformOrigin: "0% 50%",
                          opacity: 0
                      },
                      "100%": {
                          transform: "scale(1)",
                          transformOrigin: "0% 50%"
                      }
                  }),
                  outKeyframes: new Keyframes("antZoomLeftOut", {
                      "0%": {
                          transform: "scale(1)",
                          transformOrigin: "0% 50%"
                      },
                      "100%": {
                          transform: "scale(0.8)",
                          transformOrigin: "0% 50%",
                          opacity: 0
                      }
                  })
              },
              "zoom-right": {
                  inKeyframes: new Keyframes("antZoomRightIn", {
                      "0%": {
                          transform: "scale(0.8)",
                          transformOrigin: "100% 50%",
                          opacity: 0
                      },
                      "100%": {
                          transform: "scale(1)",
                          transformOrigin: "100% 50%"
                      }
                  }),
                  outKeyframes: new Keyframes("antZoomRightOut", {
                      "0%": {
                          transform: "scale(1)",
                          transformOrigin: "100% 50%"
                      },
                      "100%": {
                          transform: "scale(0.8)",
                          transformOrigin: "100% 50%",
                          opacity: 0
                      }
                  })
              },
              "zoom-up": {
                  inKeyframes: zoomUpIn,
                  outKeyframes: zoomUpOut
              },
              "zoom-down": {
                  inKeyframes: new Keyframes("antZoomDownIn", {
                      "0%": {
                          transform: "scale(0.8)",
                          transformOrigin: "50% 100%",
                          opacity: 0
                      },
                      "100%": {
                          transform: "scale(1)",
                          transformOrigin: "50% 100%"
                      }
                  }),
                  outKeyframes: new Keyframes("antZoomDownOut", {
                      "0%": {
                          transform: "scale(1)",
                          transformOrigin: "50% 100%"
                      },
                      "100%": {
                          transform: "scale(0.8)",
                          transformOrigin: "50% 100%",
                          opacity: 0
                      }
                  })
              }
          }, initZoomMotion = (token, motionName) => {
              const {antCls} = token, motionCls = `${antCls}-${motionName}`, {inKeyframes, outKeyframes} = zoomMotion[motionName];
              return [ initMotion(motionCls, inKeyframes, outKeyframes, "zoom-big-fast" === motionName ? token.motionDurationFast : token.motionDurationMid), {
                  [`\n        ${motionCls}-enter,\n        ${motionCls}-appear\n      `]: {
                      transform: "scale(0)",
                      opacity: 0,
                      animationTimingFunction: token.motionEaseOutCirc,
                      "&-prepare": {
                          transform: "none"
                      }
                  },
                  [`${motionCls}-leave`]: {
                      animationTimingFunction: token.motionEaseInOutCirc
                  }
              } ];
          }, PresetColors = [ "blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold" ];
          function genPresetColor(token, genCss) {
              return PresetColors.reduce(((prev, colorKey) => {
                  const lightColor = token[`${colorKey}1`], lightBorderColor = token[`${colorKey}3`], darkColor = token[`${colorKey}6`], textColor = token[`${colorKey}7`];
                  return Object.assign(Object.assign({}, prev), genCss(colorKey, {
                      lightColor,
                      lightBorderColor,
                      darkColor,
                      textColor
                  }));
              }), {});
          }
          const genTooltipStyle = token => {
              const {componentCls, tooltipMaxWidth, tooltipColor, tooltipBg, tooltipBorderRadius, zIndexPopup, controlHeight, boxShadowSecondary, paddingSM, paddingXS, tooltipRadiusOuter} = token;
              return [ {
                  [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token)), {
                      position: "absolute",
                      zIndex: zIndexPopup,
                      display: "block",
                      width: "max-content",
                      maxWidth: tooltipMaxWidth,
                      visibility: "visible",
                      transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
                      "&-hidden": {
                          display: "none"
                      },
                      "--antd-arrow-background-color": tooltipBg,
                      [`${componentCls}-inner`]: {
                          minWidth: controlHeight,
                          minHeight: controlHeight,
                          padding: `${paddingSM / 2}px ${paddingXS}px`,
                          color: tooltipColor,
                          textAlign: "start",
                          textDecoration: "none",
                          wordWrap: "break-word",
                          backgroundColor: tooltipBg,
                          borderRadius: tooltipBorderRadius,
                          boxShadow: boxShadowSecondary,
                          boxSizing: "border-box"
                      },
                      [[ "&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom" ].join(",")]: {
                          [`${componentCls}-inner`]: {
                              borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
                          }
                      },
                      [`${componentCls}-content`]: {
                          position: "relative"
                      }
                  }), genPresetColor(token, ((colorKey, _ref) => {
                      let {darkColor} = _ref;
                      return {
                          [`&${componentCls}-${colorKey}`]: {
                              [`${componentCls}-inner`]: {
                                  backgroundColor: darkColor
                              },
                              [`${componentCls}-arrow`]: {
                                  "--antd-arrow-background-color": darkColor
                              }
                          }
                      };
                  }))), {
                      "&-rtl": {
                          direction: "rtl"
                      }
                  })
              }, getArrowStyle(statistic_merge(token, {
                  borderRadiusOuter: tooltipRadiusOuter
              }), {
                  colorBg: "var(--antd-arrow-background-color)",
                  contentRadius: tooltipBorderRadius,
                  limitVerticalRadius: !0
              }), {
                  [`${componentCls}-pure`]: {
                      position: "relative",
                      maxWidth: "none",
                      margin: token.sizePopupArrow
                  }
              } ];
          }, tooltip_style = (prefixCls, injectStyle) => {
              const useOriginHook = genComponentStyleHook("Tooltip", (token => {
                  if (!1 === injectStyle) return [];
                  const {borderRadius, colorTextLightSolid, colorBgDefault, borderRadiusOuter} = token, TooltipToken = statistic_merge(token, {
                      tooltipMaxWidth: 250,
                      tooltipColor: colorTextLightSolid,
                      tooltipBorderRadius: borderRadius,
                      tooltipBg: colorBgDefault,
                      tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
                  });
                  return [ genTooltipStyle(TooltipToken), initZoomMotion(token, "zoom-big-fast") ];
              }), (_ref2 => {
                  let {zIndexPopupBase, colorBgSpotlight} = _ref2;
                  return {
                      zIndexPopup: zIndexPopupBase + 70,
                      colorBgDefault: colorBgSpotlight
                  };
              }), {
                  resetStyle: !1
              });
              return useOriginHook(prefixCls);
          }, inverseColors = PresetColors.map((color => `${color}-inverse`));
          function parseColor(prefixCls, color) {
              const isInternalColor = function(color) {
                  return arguments.length > 1 && void 0 !== arguments[1] && !arguments[1] ? PresetColors.includes(color) : [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
              }(color), className = classnames_default()({
                  [`${prefixCls}-${color}`]: color && isInternalColor
              }), overlayStyle = {}, arrowStyle = {};
              return color && !isInternalColor && (overlayStyle.background = color, arrowStyle["--antd-arrow-background-color"] = color), 
              {
                  className,
                  overlayStyle,
                  arrowStyle
              };
          }
          const tooltip_PurePanel = props => {
              const {prefixCls: customizePrefixCls, className, placement = "top", title, color, overlayInnerStyle} = props, {getPrefixCls} = react.useContext(context_ConfigContext), prefixCls = getPrefixCls("tooltip", customizePrefixCls), [wrapSSR, hashId] = tooltip_style(prefixCls, !0), colorInfo = parseColor(prefixCls, color), arrowContentStyle = colorInfo.arrowStyle, formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle), cls = classnames_default()(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className);
              return wrapSSR(react.createElement("div", {
                  className: cls,
                  style: arrowContentStyle
              }, react.createElement("div", {
                  className: `${prefixCls}-arrow`
              }), react.createElement(Popup, Object.assign({}, props, {
                  className: hashId,
                  prefixCls,
                  overlayInnerStyle: formattedOverlayInnerStyle
              }), title)));
          };
          var tooltip_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const tooltip_Tooltip = react.forwardRef(((props, ref) => {
              var _a, _b;
              const {prefixCls: customizePrefixCls, openClassName, getTooltipContainer, overlayClassName, color, overlayInnerStyle, children, afterOpenChange, afterVisibleChange, destroyTooltipOnHide, arrow = !0, title, overlay, builtinPlacements, arrowPointAtCenter = !1, autoAdjustOverflow = !0} = props, mergedShowArrow = !!arrow, [, token] = useToken(), {getPopupContainer: getContextPopupContainer, getPrefixCls, direction} = react.useContext(context_ConfigContext), warning = warning_devUseWarning("Tooltip"), tooltipRef = react.useRef(null), forceAlign = () => {
                  var _a;
                  null === (_a = tooltipRef.current) || void 0 === _a || _a.forceAlign();
              };
              react.useImperativeHandle(ref, (() => ({
                  forceAlign,
                  forcePopupAlign: () => {
                      warning.deprecated(!1, "forcePopupAlign", "forceAlign"), forceAlign();
                  }
              })));
              const [open, setOpen] = useMergedState(!1, {
                  value: null !== (_a = props.open) && void 0 !== _a ? _a : props.visible,
                  defaultValue: null !== (_b = props.defaultOpen) && void 0 !== _b ? _b : props.defaultVisible
              }), noTitle = !title && !overlay && 0 !== title, tooltipPlacements = react.useMemo((() => {
                  var _a, _b;
                  let mergedArrowPointAtCenter = arrowPointAtCenter;
                  return "object" == typeof arrow && (mergedArrowPointAtCenter = null !== (_b = null !== (_a = arrow.pointAtCenter) && void 0 !== _a ? _a : arrow.arrowPointAtCenter) && void 0 !== _b ? _b : arrowPointAtCenter), 
                  builtinPlacements || getPlacements({
                      arrowPointAtCenter: mergedArrowPointAtCenter,
                      autoAdjustOverflow,
                      arrowWidth: mergedShowArrow ? token.sizePopupArrow : 0,
                      borderRadius: token.borderRadius,
                      offset: token.marginXXS,
                      visibleFirst: !0
                  });
              }), [ arrowPointAtCenter, arrow, builtinPlacements, token ]), memoOverlay = react.useMemo((() => 0 === title ? title : overlay || title || ""), [ overlay, title ]), memoOverlayWrapper = react.createElement(NoCompactStyle, null, "function" == typeof memoOverlay ? memoOverlay() : memoOverlay), {getPopupContainer, placement = "top", mouseEnterDelay = .1, mouseLeaveDelay = .1, overlayStyle, rootClassName} = props, otherProps = tooltip_rest(props, [ "getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName" ]), prefixCls = getPrefixCls("tooltip", customizePrefixCls), rootPrefixCls = getPrefixCls(), injectFromPopover = props["data-popover-inject"];
              let tempOpen = open;
              "open" in props || "visible" in props || !noTitle || (tempOpen = !1);
              const child = reactNode_isValidElement(children) && !reactNode_isFragment(children) ? children : react.createElement("span", null, children), childProps = child.props, childCls = childProps.className && "string" != typeof childProps.className ? childProps.className : classnames_default()(childProps.className, openClassName || `${prefixCls}-open`), [wrapSSR, hashId] = tooltip_style(prefixCls, !injectFromPopover), colorInfo = parseColor(prefixCls, color), arrowContentStyle = colorInfo.arrowStyle, formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle), customOverlayClassName = classnames_default()(overlayClassName, {
                  [`${prefixCls}-rtl`]: "rtl" === direction
              }, colorInfo.className, rootClassName, hashId);
              return wrapSSR(react.createElement(rc_tooltip_es, Object.assign({}, otherProps, {
                  showArrow: mergedShowArrow,
                  placement,
                  mouseEnterDelay,
                  mouseLeaveDelay,
                  prefixCls,
                  overlayClassName: customOverlayClassName,
                  overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
                  getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
                  ref: tooltipRef,
                  builtinPlacements: tooltipPlacements,
                  overlay: memoOverlayWrapper,
                  visible: tempOpen,
                  onVisibleChange: vis => {
                      var _a, _b;
                      setOpen(!noTitle && vis), noTitle || (null === (_a = props.onOpenChange) || void 0 === _a || _a.call(props, vis), 
                      null === (_b = props.onVisibleChange) || void 0 === _b || _b.call(props, vis));
                  },
                  afterVisibleChange: null != afterOpenChange ? afterOpenChange : afterVisibleChange,
                  overlayInnerStyle: formattedOverlayInnerStyle,
                  arrowContent: react.createElement("span", {
                      className: `${prefixCls}-arrow-content`
                  }),
                  motion: {
                      motionName: motion_getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
                      motionDeadline: 1e3
                  },
                  destroyTooltipOnHide: !!destroyTooltipOnHide
              }), tempOpen ? cloneElement(child, {
                  className: childCls
              }) : child));
          }));
          tooltip_Tooltip._InternalPanelDoNotUseOrYouWillBeFired = tooltip_PurePanel;
          const tooltip = tooltip_Tooltip;
          const slider_SliderTooltip = react.forwardRef(((props, ref) => {
              const {open} = props, innerRef = (0, react.useRef)(null), rafRef = (0, react.useRef)(null);
              function cancelKeepAlign() {
                  es_raf.cancel(rafRef.current), rafRef.current = null;
              }
              return react.useEffect((() => (open ? rafRef.current = es_raf((() => {
                  var _a;
                  null === (_a = innerRef.current) || void 0 === _a || _a.forceAlign(), rafRef.current = null;
              })) : cancelKeepAlign(), cancelKeepAlign)), [ open, props.title ]), react.createElement(tooltip, Object.assign({
                  ref: composeRef(innerRef, ref)
              }, props));
          })), genBaseStyle = token => {
              const {componentCls, antCls, controlSize, dotSize, marginFull, marginPart, colorFillContentHover} = token;
              return {
                  [componentCls]: Object.assign(Object.assign({}, resetComponent(token)), {
                      position: "relative",
                      height: controlSize,
                      margin: `${marginPart}px ${marginFull}px`,
                      padding: 0,
                      cursor: "pointer",
                      touchAction: "none",
                      "&-vertical": {
                          margin: `${marginFull}px ${marginPart}px`
                      },
                      [`${componentCls}-rail`]: {
                          position: "absolute",
                          backgroundColor: token.railBg,
                          borderRadius: token.borderRadiusXS,
                          transition: `background-color ${token.motionDurationMid}`
                      },
                      [`${componentCls}-track,${componentCls}-tracks`]: {
                          position: "absolute",
                          transition: `background-color ${token.motionDurationMid}`
                      },
                      [`${componentCls}-track`]: {
                          backgroundColor: token.trackBg,
                          borderRadius: token.borderRadiusXS
                      },
                      [`${componentCls}-track-draggable`]: {
                          boxSizing: "content-box",
                          backgroundClip: "content-box",
                          border: "solid rgba(0,0,0,0)"
                      },
                      "&:hover": {
                          [`${componentCls}-rail`]: {
                              backgroundColor: token.railHoverBg
                          },
                          [`${componentCls}-track`]: {
                              backgroundColor: token.trackHoverBg
                          },
                          [`${componentCls}-dot`]: {
                              borderColor: colorFillContentHover
                          },
                          [`${componentCls}-handle::after`]: {
                              boxShadow: `0 0 0 ${token.handleLineWidth}px ${token.colorPrimaryBorderHover}`
                          },
                          [`${componentCls}-dot-active`]: {
                              borderColor: token.dotActiveBorderColor
                          }
                      },
                      [`${componentCls}-handle`]: {
                          position: "absolute",
                          width: token.handleSize,
                          height: token.handleSize,
                          outline: "none",
                          [`${componentCls}-dragging`]: {
                              zIndex: 1
                          },
                          "&::before": {
                              content: '""',
                              position: "absolute",
                              insetInlineStart: -token.handleLineWidth,
                              insetBlockStart: -token.handleLineWidth,
                              width: token.handleSize + 2 * token.handleLineWidth,
                              height: token.handleSize + 2 * token.handleLineWidth,
                              backgroundColor: "transparent"
                          },
                          "&::after": {
                              content: '""',
                              position: "absolute",
                              insetBlockStart: 0,
                              insetInlineStart: 0,
                              width: token.handleSize,
                              height: token.handleSize,
                              backgroundColor: token.colorBgElevated,
                              boxShadow: `0 0 0 ${token.handleLineWidth}px ${token.handleColor}`,
                              borderRadius: "50%",
                              cursor: "pointer",
                              transition: `\n            inset-inline-start ${token.motionDurationMid},\n            inset-block-start ${token.motionDurationMid},\n            width ${token.motionDurationMid},\n            height ${token.motionDurationMid},\n            box-shadow ${token.motionDurationMid}\n          `
                          },
                          "&:hover, &:active, &:focus": {
                              "&::before": {
                                  insetInlineStart: -((token.handleSizeHover - token.handleSize) / 2 + token.handleLineWidthHover),
                                  insetBlockStart: -((token.handleSizeHover - token.handleSize) / 2 + token.handleLineWidthHover),
                                  width: token.handleSizeHover + 2 * token.handleLineWidthHover,
                                  height: token.handleSizeHover + 2 * token.handleLineWidthHover
                              },
                              "&::after": {
                                  boxShadow: `0 0 0 ${token.handleLineWidthHover}px ${token.handleActiveColor}`,
                                  width: token.handleSizeHover,
                                  height: token.handleSizeHover,
                                  insetInlineStart: (token.handleSize - token.handleSizeHover) / 2,
                                  insetBlockStart: (token.handleSize - token.handleSizeHover) / 2
                              }
                          }
                      },
                      [`${componentCls}-mark`]: {
                          position: "absolute",
                          fontSize: token.fontSize
                      },
                      [`${componentCls}-mark-text`]: {
                          position: "absolute",
                          display: "inline-block",
                          color: token.colorTextDescription,
                          textAlign: "center",
                          wordBreak: "keep-all",
                          cursor: "pointer",
                          userSelect: "none",
                          "&-active": {
                              color: token.colorText
                          }
                      },
                      [`${componentCls}-step`]: {
                          position: "absolute",
                          background: "transparent",
                          pointerEvents: "none"
                      },
                      [`${componentCls}-dot`]: {
                          position: "absolute",
                          width: dotSize,
                          height: dotSize,
                          backgroundColor: token.colorBgElevated,
                          border: `${token.handleLineWidth}px solid ${token.dotBorderColor}`,
                          borderRadius: "50%",
                          cursor: "pointer",
                          transition: `border-color ${token.motionDurationSlow}`,
                          pointerEvents: "auto",
                          "&-active": {
                              borderColor: token.dotActiveBorderColor
                          }
                      },
                      [`&${componentCls}-disabled`]: {
                          cursor: "not-allowed",
                          [`${componentCls}-rail`]: {
                              backgroundColor: `${token.railBg} !important`
                          },
                          [`${componentCls}-track`]: {
                              backgroundColor: `${token.trackBgDisabled} !important`
                          },
                          [`\n          ${componentCls}-dot\n        `]: {
                              backgroundColor: token.colorBgElevated,
                              borderColor: token.trackBgDisabled,
                              boxShadow: "none",
                              cursor: "not-allowed"
                          },
                          [`${componentCls}-handle::after`]: {
                              backgroundColor: token.colorBgElevated,
                              cursor: "not-allowed",
                              width: token.handleSize,
                              height: token.handleSize,
                              boxShadow: `0 0 0 ${token.handleLineWidth}px ${new TinyColor(token.colorTextDisabled).onBackground(token.colorBgContainer).toHexShortString()}`,
                              insetInlineStart: 0,
                              insetBlockStart: 0
                          },
                          [`\n          ${componentCls}-mark-text,\n          ${componentCls}-dot\n        `]: {
                              cursor: "not-allowed !important"
                          }
                      },
                      [`&-tooltip ${antCls}-tooltip-inner`]: {
                          minWidth: "unset"
                      }
                  })
              };
          }, genDirectionStyle = (token, horizontal) => {
              const {componentCls, railSize, handleSize, dotSize} = token, full = horizontal ? "width" : "height", part = horizontal ? "height" : "width", handlePos = horizontal ? "insetBlockStart" : "insetInlineStart", markInset = horizontal ? "top" : "insetInlineStart", handlePosSize = (3 * railSize - handleSize) / 2, draggableBorderSize = (handleSize - railSize) / 2, draggableBorder = horizontal ? {
                  borderWidth: `${draggableBorderSize}px 0`,
                  transform: `translateY(-${draggableBorderSize}px)`
              } : {
                  borderWidth: `0 ${draggableBorderSize}px`,
                  transform: `translateX(-${draggableBorderSize}px)`
              };
              return {
                  [horizontal ? "paddingBlock" : "paddingInline"]: railSize,
                  [part]: 3 * railSize,
                  [`${componentCls}-rail`]: {
                      [full]: "100%",
                      [part]: railSize
                  },
                  [`${componentCls}-track,${componentCls}-tracks`]: {
                      [part]: railSize
                  },
                  [`${componentCls}-track-draggable`]: Object.assign({}, draggableBorder),
                  [`${componentCls}-handle`]: {
                      [handlePos]: handlePosSize
                  },
                  [`${componentCls}-mark`]: {
                      insetInlineStart: 0,
                      top: 0,
                      [markInset]: 3 * railSize + (horizontal ? 0 : token.marginFull),
                      [full]: "100%"
                  },
                  [`${componentCls}-step`]: {
                      insetInlineStart: 0,
                      top: 0,
                      [markInset]: railSize,
                      [full]: "100%",
                      [part]: railSize
                  },
                  [`${componentCls}-dot`]: {
                      position: "absolute",
                      [handlePos]: (railSize - dotSize) / 2
                  }
              };
          }, genHorizontalStyle = token => {
              const {componentCls, marginPartWithMark} = token;
              return {
                  [`${componentCls}-horizontal`]: Object.assign(Object.assign({}, genDirectionStyle(token, !0)), {
                      [`&${componentCls}-with-marks`]: {
                          marginBottom: marginPartWithMark
                      }
                  })
              };
          }, genVerticalStyle = token => {
              const {componentCls} = token;
              return {
                  [`${componentCls}-vertical`]: Object.assign(Object.assign({}, genDirectionStyle(token, !1)), {
                      height: "100%"
                  })
              };
          }, slider_style = genComponentStyleHook("Slider", (token => {
              const sliderToken = statistic_merge(token, {
                  marginPart: (token.controlHeight - token.controlSize) / 2,
                  marginFull: token.controlSize / 2,
                  marginPartWithMark: token.controlHeightLG - token.controlSize
              });
              return [ genBaseStyle(sliderToken), genHorizontalStyle(sliderToken), genVerticalStyle(sliderToken) ];
          }), (token => {
              const controlSize = token.controlHeightLG / 4;
              return {
                  controlSize,
                  railSize: 4,
                  handleSize: controlSize,
                  handleSizeHover: token.controlHeightSM / 2,
                  dotSize: 8,
                  handleLineWidth: token.lineWidth + 1,
                  handleLineWidthHover: token.lineWidth + 3,
                  railBg: token.colorFillTertiary,
                  railHoverBg: token.colorFillSecondary,
                  trackBg: token.colorPrimaryBorder,
                  trackHoverBg: token.colorPrimaryBorderHover,
                  handleColor: token.colorPrimaryBorder,
                  handleActiveColor: token.colorPrimary,
                  dotBorderColor: token.colorBorderSecondary,
                  dotActiveBorderColor: token.colorPrimaryBorder,
                  trackBgDisabled: token.colorBgContainerDisabled
              };
          }));
          var slider_rest = function(s, e) {
              var t = {};
              for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
              if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
                  var i = 0;
                  for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
              }
              return t;
          };
          const defaultFormatter = val => "number" == typeof val ? val.toString() : "", slider_Slider = react.forwardRef(((props, ref) => {
              const {prefixCls: customizePrefixCls, range, className, rootClassName, style, disabled, tooltipPrefixCls: legacyTooltipPrefixCls, tipFormatter: legacyTipFormatter, tooltipVisible: legacyTooltipVisible, getTooltipPopupContainer: legacyGetTooltipPopupContainer, tooltipPlacement: legacyTooltipPlacement} = props, restProps = slider_rest(props, [ "prefixCls", "range", "className", "rootClassName", "style", "disabled", "tooltipPrefixCls", "tipFormatter", "tooltipVisible", "getTooltipPopupContainer", "tooltipPlacement" ]), {direction, slider, getPrefixCls, getPopupContainer} = react.useContext(context_ConfigContext), contextDisabled = react.useContext(config_provider_DisabledContext), mergedDisabled = null != disabled ? disabled : contextDisabled, [opens, setOpens] = react.useState({}), toggleTooltipOpen = (index, open) => {
                  setOpens((prev => Object.assign(Object.assign({}, prev), {
                      [index]: open
                  })));
              }, getTooltipPlacement = (placement, vertical) => placement || (vertical ? "rtl" === direction ? "left" : "right" : "top"), prefixCls = getPrefixCls("slider", customizePrefixCls), [wrapSSR, hashId] = slider_style(prefixCls), cls = classnames_default()(className, null == slider ? void 0 : slider.className, rootClassName, {
                  [`${prefixCls}-rtl`]: "rtl" === direction
              }, hashId);
              "rtl" !== direction || restProps.vertical || (restProps.reverse = !restProps.reverse);
              const [mergedRange, draggableTrack] = react.useMemo((() => range ? "object" == typeof range ? [ !0, range.draggableTrack ] : [ !0, !1 ] : [ !1 ]), [ range ]);
              const mergedStyle = Object.assign(Object.assign({}, null == slider ? void 0 : slider.style), style);
              return wrapSSR(react.createElement(rc_slider_es, Object.assign({}, restProps, {
                  step: restProps.step,
                  range: mergedRange,
                  draggableTrack,
                  className: cls,
                  style: mergedStyle,
                  disabled: mergedDisabled,
                  ref,
                  prefixCls,
                  handleRender: (node, info) => {
                      var _a;
                      const {index, dragging} = info, {tooltip = {}, vertical} = props, tooltipProps = Object.assign({}, tooltip), {open: tooltipOpen, placement: tooltipPlacement, getPopupContainer: getTooltipPopupContainer, prefixCls: customizeTooltipPrefixCls, formatter: tipFormatter} = tooltipProps;
                      let mergedTipFormatter;
                      mergedTipFormatter = tipFormatter || null === tipFormatter ? tipFormatter : legacyTipFormatter || null === legacyTipFormatter ? legacyTipFormatter : defaultFormatter;
                      const isTipFormatter = !!mergedTipFormatter && (opens[index] || dragging), open = null !== (_a = null != tooltipOpen ? tooltipOpen : legacyTooltipVisible) && void 0 !== _a ? _a : void 0 === tooltipOpen && isTipFormatter, passedProps = Object.assign(Object.assign({}, node.props), {
                          onMouseEnter: () => toggleTooltipOpen(index, !0),
                          onMouseLeave: () => toggleTooltipOpen(index, !1)
                      }), tooltipPrefixCls = getPrefixCls("tooltip", null != customizeTooltipPrefixCls ? customizeTooltipPrefixCls : legacyTooltipPrefixCls);
                      return react.createElement(slider_SliderTooltip, Object.assign({}, tooltipProps, {
                          prefixCls: tooltipPrefixCls,
                          title: mergedTipFormatter ? mergedTipFormatter(info.value) : "",
                          open,
                          placement: getTooltipPlacement(null != tooltipPlacement ? tooltipPlacement : legacyTooltipPlacement, vertical),
                          key: index,
                          overlayClassName: `${prefixCls}-tooltip`,
                          getPopupContainer: getTooltipPopupContainer || legacyGetTooltipPopupContainer || getPopupContainer
                      }), react.cloneElement(node, passedProps));
                  }
              })));
          }));
          const slider = slider_Slider;
          var lodash_throttle = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js");
          const uiConfigPopUp_style_module = {
              style: "zxR7lvJBLY7LngrphUKw",
              label: "B0uyQ2frjQFDqb1GAVz3"
          };
          const throttleScrollToBottom = __webpack_require__.n(lodash_throttle)()((function() {
              console.log("**** event scrollbottom"), window.postMessage({
                  type: "scrollToBottom"
              }, "*");
          }), 200), setOpacity = uiConfig.getState().setOpacity;
          const uiConfigPopUp_style = function({onBack}) {
              const {color, setColor} = useColor(), {fontSize, setFontSize} = useFontSize(), opacity = useOpacity(), {textShadow, setTextShadow} = useTextShadow();
              return (0, react.useEffect)((() => {
                  throttleScrollToBottom(), console.log("*** fontsize:", fontSize);
              }), [ fontSize ]), (0, jsx_runtime.jsxs)("div", {
                  className: dist_clsx(uiConfigPopUp_index_module_secondly, uiConfigPopUp_style_module.style),
                  style: {
                      width: "28em"
                  },
                  children: [ (0, jsx_runtime.jsxs)("header", {
                      className: uiConfigPopUp_index_module_header,
                      children: [ (0, jsx_runtime.jsx)("span", {
                          className: uiConfigPopUp_index_module_back,
                          onClick: e => onBack(e)
                      }), (0, jsx_runtime.jsx)("span", {
                          children: chrome.i18n.getMessage("style_setting")
                      }) ]
                  }), (0, jsx_runtime.jsx)("main", {
                      className: dist_clsx(uiConfigPopUp_index_module_content, uiConfigPopUp_style_module.content),
                      children: (0, jsx_runtime.jsxs)("div", {
                          className: uiConfigPopUp_index_module_menu,
                          children: [ (0, jsx_runtime.jsxs)("section", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_style_module.label,
                                  children: chrome.i18n.getMessage("font_color")
                              }), (0, jsx_runtime.jsx)("div", {
                                  children: (0, jsx_runtime.jsxs)(es_radio.Group, {
                                      value: color,
                                      onChange: e => setColor(e.target.value),
                                      children: [ (0, jsx_runtime.jsx)(es_radio, {
                                          value: "default",
                                          children: chrome.i18n.getMessage("white")
                                      }), (0, jsx_runtime.jsx)(es_radio, {
                                          value: "yellow",
                                          style: {
                                              color: "yellow"
                                          },
                                          children: chrome.i18n.getMessage("yellow")
                                      }), (0, jsx_runtime.jsx)(es_radio, {
                                          value: "green",
                                          style: {
                                              color: "#3f0"
                                          },
                                          children: chrome.i18n.getMessage("green")
                                      }) ]
                                  })
                              }) ]
                          }), (0, jsx_runtime.jsxs)("section", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_style_module.label,
                                  children: chrome.i18n.getMessage("font_size")
                              }), (0, jsx_runtime.jsx)("div", {
                                  children: (0, jsx_runtime.jsx)(slider, {
                                      value: fontSize,
                                      min: 12,
                                      max: 40,
                                      onChange: setFontSize,
                                      onAfterChange: value => setFontSize(value, !0)
                                  })
                              }) ]
                          }), (0, jsx_runtime.jsxs)("section", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_style_module.label,
                                  children: chrome.i18n.getMessage("background_opacity")
                              }), (0, jsx_runtime.jsx)("div", {
                                  children: (0, jsx_runtime.jsx)(slider, {
                                      value: opacity,
                                      min: 40,
                                      max: 100,
                                      step: 20,
                                      onChange: setOpacity,
                                      onAfterChange: value => setOpacity(value, !0),
                                      tooltip: {
                                          formatter: value => `${value}%`
                                      }
                                  })
                              }) ]
                          }), (0, jsx_runtime.jsxs)("section", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_style_module.label,
                                  children: chrome.i18n.getMessage("text_stroke")
                              }), (0, jsx_runtime.jsx)("div", {
                                  children: (0, jsx_runtime.jsxs)(es_radio.Group, {
                                      value: textShadow,
                                      onChange: e => setTextShadow(e.target.value),
                                      children: [ (0, jsx_runtime.jsx)(es_radio, {
                                          value: "none",
                                          children: chrome.i18n.getMessage("none")
                                      }), (0, jsx_runtime.jsx)(es_radio, {
                                          value: "black",
                                          children: chrome.i18n.getMessage("black")
                                      }), (0, jsx_runtime.jsx)(es_radio, {
                                          value: "white",
                                          children: chrome.i18n.getMessage("white")
                                      }) ]
                                  })
                              }) ]
                          }) ]
                      })
                  }) ]
              });
          }, setShowFloatingSwitch = value => {
              value ? chrome.runtime.sendMessage({
                  type: "show-floating-btn"
              }) : chrome.runtime.sendMessage({
                  type: "hide-floating-btn"
              });
          };
          const more = function({onBack}) {
              const showFloatingSwitch = useUserConfigStore((({config: {showFloatingSwitch}}) => showFloatingSwitch));
              return (0, jsx_runtime.jsxs)("div", {
                  className: uiConfigPopUp_index_module_secondly,
                  children: [ (0, jsx_runtime.jsxs)("header", {
                      className: uiConfigPopUp_index_module_header,
                      children: [ (0, jsx_runtime.jsx)("span", {
                          className: uiConfigPopUp_index_module_back,
                          onClick: e => onBack(e)
                      }), (0, jsx_runtime.jsx)("span", {
                          children: chrome.i18n.getMessage("more_setting")
                      }) ]
                  }), (0, jsx_runtime.jsx)("main", {
                      className: uiConfigPopUp_index_module_content,
                      children: (0, jsx_runtime.jsx)("div", {
                          className: uiConfigPopUp_index_module_menu,
                          children: (0, jsx_runtime.jsxs)("span", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_index_module_label,
                                  children: chrome.i18n.getMessage("PLUGIN__show_floating_switch")
                              }), (0, jsx_runtime.jsx)(es_switch, {
                                  checked: showFloatingSwitch,
                                  onChange: setShowFloatingSwitch
                              }) ]
                          })
                      })
                  }) ]
              });
          }, onFeedback = () => {
              const {logined} = user.getState();
              logined ? window.open(`${userUrl}/feedback?from=plugin&v=${config_version}`, "_blank", "width=800,height=600") : onLoginWithoutCheck();
          }, onHelp = () => {
              window.open("https://docs.google.com/document/d/1xnBXVc57JRuvMEcA0Bpv4Ky2cX-f5W-NxBdqAHhR5XU");
          }, onShowMoreProducts = () => {
              window.open("https://felo.me");
          };
          const about = function({onBack}) {
              return (0, jsx_runtime.jsxs)("div", {
                  className: uiConfigPopUp_index_module_secondly,
                  children: [ (0, jsx_runtime.jsxs)("header", {
                      className: uiConfigPopUp_index_module_header,
                      children: [ (0, jsx_runtime.jsx)("span", {
                          className: uiConfigPopUp_index_module_back,
                          onClick: e => onBack(e)
                      }), (0, jsx_runtime.jsx)("span", {
                          children: chrome.i18n.getMessage("about_felo")
                      }) ]
                  }), (0, jsx_runtime.jsx)("main", {
                      className: uiConfigPopUp_index_module_content,
                      children: (0, jsx_runtime.jsxs)("div", {
                          className: uiConfigPopUp_index_module_menu,
                          children: [ (0, jsx_runtime.jsx)("span", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: onFeedback,
                              children: chrome.i18n.getMessage("feedback")
                          }), (0, jsx_runtime.jsxs)("span", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_index_module_label,
                                  children: chrome.i18n.getMessage("app_version")
                              }), config_version ]
                          }), (0, jsx_runtime.jsx)("span", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: onHelp,
                              children: chrome.i18n.getMessage("help")
                          }), (0, jsx_runtime.jsx)("span", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: onShowMoreProducts,
                              children: chrome.i18n.getMessage("more_products")
                          }) ]
                      })
                  }) ]
              });
          };
          var _User;
          const setIsShowOriginTextInfo = value => {
              userConfig.getState().setBothSubtitles(value);
          }, onToggle = e => {
              e.clientY < window.innerHeight / 2 ? uiConfig.getState().toggleMenuVisible("bottom") : uiConfig.getState().toggleMenuVisible("top");
          };
          const uiConfigPopUp = function({children}) {
              const buttonRef = (0, react.useRef)(null), menuRef = (0, react.useRef)(null), menuVisible = useMenuVisible(), menuPosition = useUIConfigStore((({menuPosition}) => menuPosition)), [selectedOption, setSelectedOption] = (0, 
              react.useState)(), translateLang = useUserConfigStore((({config: {translateLang}}) => translateLang)), isShowOriginText = useBothSubtitles(), onBack = ev => {
                  ev.stopPropagation(), setSelectedOption(void 0);
              };
              return (0, react.useEffect)((() => {
                  const eventFn = ev => {
                      uiConfig.getState().menuVisible && (menuRef.current?.contains(ev.target) || buttonRef.current?.contains(ev.target) || (uiConfig.getState().toggleMenuVisible("bottom"), 
                      setSelectedOption(void 0)));
                  };
                  return document.body.addEventListener("click", eventFn), () => {
                      document.body.removeEventListener("click", eventFn);
                  };
              }), []), (0, jsx_runtime.jsxs)("div", {
                  children: [ (0, react.cloneElement)(children, {
                      ref: buttonRef,
                      onClick: onToggle
                  }), (0, jsx_runtime.jsxs)("div", {
                      ref: menuRef,
                      className: dist_clsx(uiConfigPopUp_index_module_popup, "top" === menuPosition && uiConfigPopUp_index_module_top),
                      hidden: !menuVisible,
                      children: [ menuVisible && !selectedOption && (_User || (_User = (0, jsx_runtime.jsx)(uiConfigPopUp_user, {}))), (0, 
                      jsx_runtime.jsxs)("div", {
                          className: uiConfigPopUp_index_module_menu,
                          hidden: !!selectedOption,
                          children: [ (0, jsx_runtime.jsxs)("div", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: () => setSelectedOption("language"),
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_index_module_label,
                                  children: chrome.i18n.getMessage("translation")
                              }), (0, jsx_runtime.jsx)("b", {
                                  children: languages.find((item => item.value === translateLang))?.label
                              }) ]
                          }), (0, jsx_runtime.jsxs)("div", {
                              className: uiConfigPopUp_index_module_item,
                              children: [ (0, jsx_runtime.jsx)("span", {
                                  className: uiConfigPopUp_index_module_label,
                                  children: chrome.i18n.getMessage("dual_subtitles")
                              }), (0, jsx_runtime.jsx)(es_switch, {
                                  checked: isShowOriginText,
                                  onChange: setIsShowOriginTextInfo
                              }) ]
                          }), (0, jsx_runtime.jsx)("div", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: () => setSelectedOption("style"),
                              children: chrome.i18n.getMessage("style_setting")
                          }), (0, jsx_runtime.jsx)("div", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: () => setSelectedOption("more"),
                              children: chrome.i18n.getMessage("more_setting")
                          }), (0, jsx_runtime.jsx)("div", {
                              className: dist_clsx(uiConfigPopUp_index_module_item, uiConfigPopUp_index_module_action),
                              onClick: () => setSelectedOption("about"),
                              children: chrome.i18n.getMessage("about_felo")
                          }) ]
                      }), "language" === selectedOption && (0, jsx_runtime.jsx)(uiConfigPopUp_language, {
                          value: translateLang,
                          onChange: value => {
                              setSelectedOption(void 0), (value => {
                                  userConfig.getState().setTranslateLang(value);
                              })(value);
                          },
                          onBack
                      }), "style" === selectedOption && (0, jsx_runtime.jsx)(uiConfigPopUp_style, {
                          onBack
                      }), "more" === selectedOption && (0, jsx_runtime.jsx)(more, {
                          onBack
                      }), "about" === selectedOption && (0, jsx_runtime.jsx)(about, {
                          onBack
                      }) ]
                  }) ]
              });
          };
          var main_div, _StopBox, _HistoryWithPadding, _div2, _SettingsWithPadding, _HiddenWithPadding, _Falert, _NoticeToast;
          const onOpenHistory = () => {
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_control: "OpenHistory"
              }), window.open(`${userUrl}/account/log`);
          }, onClose = () => {
              trackEvent({
                  event_type: "SubtitleClick",
                  trigger_type: "Manual",
                  trigger_control: "CloseSubtitle"
              }), window.postMessage({
                  type: "subtitle:close"
              }, "*");
          }, WindowContent = (_, ref) => {
              const opacity = useOpacity(), paused = usePaused(), menuVisible = useMenuVisible(), historyPopupVisible = useHistoryPopupVisible(), customContainerRef = (0, 
              react.useRef)(null), enterWrap = () => {
                  customContainerRef.current && customContainerRef.current.classList.remove("felo-wrapper-active");
              }, leaveWrap = () => {
                  if (!customContainerRef.current) return;
                  const {menuVisible, historyPopupVisible} = uiConfig.getState();
                  menuVisible || historyPopupVisible || customContainerRef.current.classList.add("felo-wrapper-active");
              };
              return (0, react.useImperativeHandle)(ref, (() => ({
                  enterWrap,
                  leaveWrap
              }))), (0, react.useEffect)((() => {
                  customContainerRef.current && customContainerRef.current.style.setProperty("--felo-panel-bg", opacity > 60 ? "#4e5058" : "#313338");
              }), [ opacity ]), (0, jsx_runtime.jsxs)("div", {
                  className: "felo-wrapper",
                  ref: customContainerRef,
                  children: [ (0, jsx_runtime.jsxs)("div", {
                      className: "felo-header",
                      style: {
                          backgroundColor: `rgb(0 0 0 / ${opacity + 5}%)`
                      },
                      children: [ main_div || (main_div = (0, jsx_runtime.jsx)("div", {
                          className: "felo-logo",
                          children: (0, jsx_runtime.jsx)(Felo, {})
                      })), _StopBox || (_StopBox = (0, jsx_runtime.jsx)(stopBox, {})), (0, jsx_runtime.jsxs)("div", {
                          className: "felo-toolbar",
                          children: [ (0, jsx_runtime.jsx)(historyNoticePopup, {
                              onClick: onOpenHistory,
                              children: (0, jsx_runtime.jsx)("div", {
                                  className: dist_clsx(historyPopupVisible && "active"),
                                  "data-tag": chrome.i18n.getMessage("history"),
                                  children: paused ? _HistoryWithPadding || (_HistoryWithPadding = (0, jsx_runtime.jsx)(HistoryWithPadding, {})) : _div2 || (_div2 = (0, 
                                  jsx_runtime.jsx)("div", {
                                      className: "toolbar-history"
                                  }))
                              })
                          }), (0, jsx_runtime.jsx)(uiConfigPopUp, {
                              children: (0, jsx_runtime.jsx)("div", {
                                  className: dist_clsx(menuVisible && "active"),
                                  "data-tag": chrome.i18n.getMessage("setting"),
                                  children: _SettingsWithPadding || (_SettingsWithPadding = (0, jsx_runtime.jsx)(SettingsWithPadding, {}))
                              })
                          }), (0, jsx_runtime.jsx)("div", {
                              "data-tag": chrome.i18n.getMessage("close"),
                              onClick: onClose,
                              children: _HiddenWithPadding || (_HiddenWithPadding = (0, jsx_runtime.jsx)(HiddenWithPadding, {}))
                          }) ]
                      }) ]
                  }), (0, jsx_runtime.jsxs)("div", {
                      className: "felo-content-box",
                      style: {
                          backgroundColor: `rgb(0 0 0 / ${opacity + 5}%)`
                      },
                      children: [ _Falert || (_Falert = (0, jsx_runtime.jsx)(Falert, {
                          children: (0, jsx_runtime.jsx)(subtitleList, {})
                      })), _NoticeToast || (_NoticeToast = (0, jsx_runtime.jsx)(noticeToast, {})) ]
                  }) ]
              });
          }, main = (0, react.forwardRef)(WindowContent), startAnimate = mode => new Promise((resolve => {
              const {position} = uiConfig.getState(), panel = document.querySelector(".f-d-panel"), btn = document.querySelector(".felo-floating .floating-btn");
              let fromTop, fromLeft, toTop, toLeft;
              panel || (console.log("no panel"), resolve());
              const btnPosition = btn?.getBoundingClientRect();
              let scaleAni;
              "open" === mode ? (fromTop = btnPosition?.y || 0, fromLeft = btnPosition?.x || document.body.clientWidth, 
              toTop = position?.y, toLeft = position?.x) : (fromTop = position?.y, fromLeft = position?.x, 
              toTop = btnPosition?.y || 0, toLeft = btnPosition?.x || document.body.clientWidth), 
              panel.style.transformOrigin = "top left", scaleAni = "open" === mode ? panel.animate([ {
                  opacity: 0,
                  transform: `translate(${fromLeft}px, ${fromTop}px) scale(0)`
              }, {
                  transform: `translate(${toLeft}px, ${toTop}px)`
              } ], {
                  duration: 300
              }) : panel.animate([ {
                  transform: `translate(${fromLeft}px, ${fromTop}px)`
              }, {
                  opacity: 0,
                  transform: `translate(${toLeft}px, ${toTop}px) scale(0)`
              } ], {
                  duration: 300
              });
              const onEnd = () => {
                  panel.style.transformOrigin = "", scaleAni.removeEventListener("finish", onEnd), 
                  resolve();
              };
              scaleAni.addEventListener("finish", onEnd);
          }));
          let asyncLock = "";
          const getLimitAndConnect = async stillConnect => {
              if (await limit.getState().getData()) {
                  const {roomId} = stores_info.getState();
                  roomId || await stores_info.getState().getRoomId(), await stores_mqtt.getState().init(stillConnect), 
                  limit.getState().startTimer();
                  const {visible, paused} = uiConfig.getState();
                  visible && !paused || (console.log("paul mqtt canceled because user visibled or paused", visible, paused), 
                  stores_mqtt.getState().destroy(), limit.getState().stopTimer(), uiConfig.getState().setPaused(!0));
              } else uiConfig.getState().setPaused(!0);
          };
          window.addEventListener("message", (async function({data}) {
              switch (data.type) {
                case "subtitle:microphone-enabled":
                  appConfig.setState({
                      microphoneEnabled: data.value
                  });
                  break;

                case "subtitle:video-muted":
                  if (data.value) {
                      const {hasExistSubtitles} = appConfig.getState();
                      hasExistSubtitles || (window.postMessage({
                          type: "subtitle:pause"
                      }), uiConfig.setState({
                          mutedVisible: data.value
                      }));
                  } else uiConfig.setState({
                      mutedVisible: data.value
                  });
                  break;

                case "subtitle:video-paused":
                  if (data.value) uiConfig.setState({
                      mutedVisible: data.value
                  }); else {
                      const {hasExistSubtitles} = appConfig.getState();
                      !hasExistSubtitles && data.isMuted || uiConfig.setState({
                          mutedVisible: data.value
                      });
                  }
                  break;

                case "subtitle:start":
                  {
                      console.log("pageEvent: subtitle:start", data, asyncLock);
                      const {setVisible, setPaused} = uiConfig.getState();
                      if ("start" === asyncLock) return;
                      data.automatic && trackEvent({
                          event_type: "SubtitleClick",
                          trigger_type: "Automatic",
                          trigger_control: "OpenSubtitle"
                      }), asyncLock = "start", appConfig.getState().setCanTranscribe(!0), setVisible(!0), 
                      setPaused(!1), stores_info.getState().bizId ? console.log("pageEvent: subtitle:start has bizid") : (stores_info.getState().setBizId(data.val), 
                      stores_info.getState().getPageInfo(), subtitle.getState().resetMessage()), limit.getState().reset();
                      try {
                          await getLimitAndConnect();
                      } catch (error) {
                          console.log("Connect error", error), uiConfig.getState().setPaused(!0);
                      }
                      asyncLock = "";
                      break;
                  }

                case "subtitle:end":
                  {
                      console.log("pageEvent: subtitle:end", data);
                      const {setCanTranscribe, setHasExistSubtitles} = appConfig.getState();
                      setCanTranscribe(!1), "youtube" === data.from && (setHasExistSubtitles(!1), uiConfig.getState().setVisible(!1), 
                      uiConfig.getState().getFloatingSwitchHighlight()), stores_mqtt.getState().destroy(), 
                      stores_info.getState().resetIds(), limit.getState().stopTimer(), uiConfig.getState().setPaused(!0);
                      break;
                  }

                case "subtitle:close":
                  console.log("pageEvent: subtitle:close"), appConfig.getState().setCanTranscribe(!1), 
                  stores_mqtt.getState().destroy(), limit.getState().stopTimer(), startAnimate("close").then((() => {
                      uiConfig.getState().setVisible(!1);
                  })), uiConfig.getState().setPaused(!0);
                  break;

                case "subtitle:reload":
                  stores_mqtt.getState().destroy(), limit.getState().stopTimer(), uiConfig.getState().visible ? (uiConfig.getState().setPaused(!1), 
                  getLimitAndConnect(data.stillConnect)) : uiConfig.getState().setPaused(!0);
                  break;

                case "subtitle:user-changed":
                  if (console.log("pageEvent: subtitle:user-changed", data.value), data.value) {
                      subtitle.getState().uploadMessages(), limit.getState().reset(), limit.getState().getData();
                      const {historyPopupVisible, setHistoryPopupVisible} = uiConfig.getState();
                      historyPopupVisible && setHistoryPopupVisible(!1);
                  } else stores_info.getState().resetRoomId(), subtitle.getState().resetMessage();
                  uiConfig.getState().paused || window.postMessage({
                      type: "subtitle:reload"
                  });
                  break;

                case "subtitle:transcribe-pause":
                  console.log("pageEvent: subtitle:transcribe-pause"), appConfig.getState().setCanTranscribe(!1);
                  break;

                case "subtitle:transcribe-continue":
                  console.log("pageEvent: subtitle:transcribe-continue"), appConfig.getState().setCanTranscribe(!0);
                  break;

                case "subtitle:pause":
                  console.log("pageEvent: subtitle:pause"), uiConfig.getState().setPaused(!0), subtitle.getState().fixLastMessage().then((() => {
                      stores_mqtt.getState().destroy(), limit.getState().stopTimer();
                  }));
                  break;

                case "subtitle:continue":
                  uiConfig.getState().setPaused(!1), stores_info.getState().roomId || await stores_info.getState().getRoomId(), 
                  await stores_mqtt.getState().init(), limit.getState().startTimer();
              }
          }));
          const lastRequestTime = {
              user: 0,
              limit: 0
          };
          var _App;
          chrome.runtime.onMessage.addListener((data => {
              if ("subtitle-start" === data.type) {
                  const {visible, noCapture} = uiConfig.getState();
                  if (console.log("** subtitle-start", visible, noCapture), noCapture && (uiConfig.setState({
                      noCapture: !1
                  }), visible)) return void window.postMessage({
                      type: "subtitle:reload"
                  });
                  trackEvent({
                      event_type: "SubtitleClick",
                      trigger_type: "Manual",
                      trigger_from: "ExtensionButton",
                      trigger_control: visible ? "CloseSubtitle" : "OpenSubtitle"
                  }), visible ? window.postMessage({
                      type: "subtitle:close"
                  }, "*") : window.postMessage({
                      type: "subtitle:start",
                      val: `capture-${Math.floor(1e3 * Math.random())}`
                  }, "*");
              }
              if ("subtitle-close" === data.type && window.postMessage({
                  type: "subtitle:close",
                  from: "others"
              }), "capture-error" === data.type && (uiConfig.setState({
                  noCapture: !0
              }), stores_mqtt.getState().destroy(), limit.getState().stopTimer(), uiConfig.getState().setPaused(!0)), 
              "remote-speech" === data.type) {
                  const {msg} = data, {translateLang} = userConfig.getState().config;
                  stores_mqtt.getState().sendSubtitle(msg.json, msg.sourceLang, translateLang, "", void 0, msg.resultId);
              }
              if ("active-tab" === data.type) {
                  const {visible, paused} = uiConfig.getState(), time = Date.now();
                  void 0 !== user.getState().logined && visible && paused && lastRequestTime.limit + 5e3 < time && (limit.getState().getData(), 
                  lastRequestTime.limit = time);
              }
              "show-floating-btn" === data.type && (console.log("paul", data.type), uiConfig.getState().getFloatingSwitchVisible(), 
              userConfig.getState().setShowFloatingSwitch(!0)), "hide-floating-btn" === data.type && (console.log("paul", data.type), 
              uiConfig.getState().setFloatingSwitchVisible(!1), userConfig.getState().setShowFloatingSwitch(!1));
          })), (() => {
              const body = document.body, container = document.createElement("div");
              container.className = "felo-floating", body.append(container);
              (0, client.s)(container).render(_FloatingBtn || (_FloatingBtn = (0, jsx_runtime.jsx)(FloatingBtn, {})));
          })(), uiConfig.getState().getPositionAndSize("translate");
          const App = () => {
              const visible = useVisible(), contentRef = (0, react.useRef)(null);
              return (0, react.useEffect)((() => {
                  visible && startAnimate("open");
              }), [ visible ]), (0, jsx_runtime.jsx)(antdConfigProvider, {
                  children: visible && (0, jsx_runtime.jsx)(dragPanel_translate, {
                      onMouseEnter: () => {
                          contentRef.current?.enterWrap();
                      },
                      onMouseLeave: () => {
                          contentRef.current?.leaveWrap();
                      },
                      children: (0, jsx_runtime.jsx)(TranslateProvider, {
                          children: (0, jsx_runtime.jsx)(main, {
                              ref: contentRef
                          })
                      })
                  })
              });
          };
          var selector;
          (selector = "#secondary.style-scope.ytd-watch-flexy", new Promise((resolve => {
              if (document.querySelector(selector)) return resolve(document.querySelector(selector));
              const observer = new MutationObserver((() => {
                  document.querySelector(selector) && (resolve(document.querySelector(selector)), 
                  observer.disconnect());
              }));
              observer.observe(document.body, {
                  childList: !0,
                  subtree: !0
              });
          }))).then((() => {
              const body = document.body, container = document.createElement("div");
              container.classList.add("felo-panel"), body.append(container);
              (0, client.s)(container).render(_App || (_App = (0, jsx_runtime.jsx)(App, {})));
          }));
      },
      "./node_modules/.pnpm/classnames@2.3.2/node_modules/classnames/index.js": (module, exports) => {
          var __WEBPACK_AMD_DEFINE_RESULT__;
          !function() {
              "use strict";
              var hasOwn = {}.hasOwnProperty;
              function classNames() {
                  for (var classes = [], i = 0; i < arguments.length; i++) {
                      var arg = arguments[i];
                      if (arg) {
                          var argType = typeof arg;
                          if ("string" === argType || "number" === argType) classes.push(arg); else if (Array.isArray(arg)) {
                              if (arg.length) {
                                  var inner = classNames.apply(null, arg);
                                  inner && classes.push(inner);
                              }
                          } else if ("object" === argType) {
                              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                                  classes.push(arg.toString());
                                  continue;
                              }
                              for (var key in arg) hasOwn.call(arg, key) && arg[key] && classes.push(key);
                          }
                      }
                  }
                  return classes.join(" ");
              }
              module.exports ? (classNames.default = classNames, module.exports = classNames) : void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                  return classNames;
              }.apply(exports, [])) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
          }();
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/a-callable.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), tryToString = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/try-to-string.js"), $TypeError = TypeError;
          module.exports = function(argument) {
              if (isCallable(argument)) return argument;
              throw $TypeError(tryToString(argument) + " is not a function");
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/a-possible-prototype.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), $String = String, $TypeError = TypeError;
          module.exports = function(argument) {
              if ("object" == typeof argument || isCallable(argument)) return argument;
              throw $TypeError("Can't set " + $String(argument) + " as a prototype");
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/an-object.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js"), $String = String, $TypeError = TypeError;
          module.exports = function(argument) {
              if (isObject(argument)) return argument;
              throw $TypeError($String(argument) + " is not an object");
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-basic-detection.js": module => {
          module.exports = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-view-core.js": (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var NAME, Constructor, Prototype, NATIVE_ARRAY_BUFFER = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-basic-detection.js"), DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), isObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js"), hasOwn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js"), classof = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof.js"), tryToString = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/try-to-string.js"), createNonEnumerableProperty = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/create-non-enumerable-property.js"), defineBuiltIn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/define-built-in.js"), defineProperty = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-define-property.js").f, isPrototypeOf = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-is-prototype-of.js"), getPrototypeOf = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-get-prototype-of.js"), setPrototypeOf = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-set-prototype-of.js"), wellKnownSymbol = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/well-known-symbol.js"), uid = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/uid.js"), InternalStateModule = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/internal-state.js"), enforceInternalState = InternalStateModule.enforce, getInternalState = InternalStateModule.get, Int8Array = global.Int8Array, Int8ArrayPrototype = Int8Array && Int8Array.prototype, Uint8ClampedArray = global.Uint8ClampedArray, Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype, TypedArray = Int8Array && getPrototypeOf(Int8Array), TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype), ObjectPrototype = Object.prototype, TypeError = global.TypeError, TO_STRING_TAG = wellKnownSymbol("toStringTag"), TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG"), NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && "Opera" !== classof(global.opera), TYPED_ARRAY_TAG_REQUIRED = !1, TypedArrayConstructorsList = {
              Int8Array: 1,
              Uint8Array: 1,
              Uint8ClampedArray: 1,
              Int16Array: 2,
              Uint16Array: 2,
              Int32Array: 4,
              Uint32Array: 4,
              Float32Array: 4,
              Float64Array: 8
          }, BigIntArrayConstructorsList = {
              BigInt64Array: 8,
              BigUint64Array: 8
          }, getTypedArrayConstructor = function(it) {
              var proto = getPrototypeOf(it);
              if (isObject(proto)) {
                  var state = getInternalState(proto);
                  return state && hasOwn(state, "TypedArrayConstructor") ? state.TypedArrayConstructor : getTypedArrayConstructor(proto);
              }
          }, isTypedArray = function(it) {
              if (!isObject(it)) return !1;
              var klass = classof(it);
              return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
          };
          for (NAME in TypedArrayConstructorsList) (Prototype = (Constructor = global[NAME]) && Constructor.prototype) ? enforceInternalState(Prototype).TypedArrayConstructor = Constructor : NATIVE_ARRAY_BUFFER_VIEWS = !1;
          for (NAME in BigIntArrayConstructorsList) (Prototype = (Constructor = global[NAME]) && Constructor.prototype) && (enforceInternalState(Prototype).TypedArrayConstructor = Constructor);
          if ((!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) && (TypedArray = function() {
              throw TypeError("Incorrect invocation");
          }, NATIVE_ARRAY_BUFFER_VIEWS)) for (NAME in TypedArrayConstructorsList) global[NAME] && setPrototypeOf(global[NAME], TypedArray);
          if ((!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) && (TypedArrayPrototype = TypedArray.prototype, 
          NATIVE_ARRAY_BUFFER_VIEWS)) for (NAME in TypedArrayConstructorsList) global[NAME] && setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
          if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype && setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype), 
          DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) for (NAME in TYPED_ARRAY_TAG_REQUIRED = !0, 
          defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
              get: function() {
                  return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
              }
          }), TypedArrayConstructorsList) global[NAME] && createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
          module.exports = {
              NATIVE_ARRAY_BUFFER_VIEWS,
              TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
              aTypedArray: function(it) {
                  if (isTypedArray(it)) return it;
                  throw TypeError("Target is not a typed array");
              },
              aTypedArrayConstructor: function(C) {
                  if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
                  throw TypeError(tryToString(C) + " is not a typed array constructor");
              },
              exportTypedArrayMethod: function(KEY, property, forced, options) {
                  if (DESCRIPTORS) {
                      if (forced) for (var ARRAY in TypedArrayConstructorsList) {
                          var TypedArrayConstructor = global[ARRAY];
                          if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
                              delete TypedArrayConstructor.prototype[KEY];
                          } catch (error) {
                              try {
                                  TypedArrayConstructor.prototype[KEY] = property;
                              } catch (error2) {}
                          }
                      }
                      TypedArrayPrototype[KEY] && !forced || defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);
                  }
              },
              exportTypedArrayStaticMethod: function(KEY, property, forced) {
                  var ARRAY, TypedArrayConstructor;
                  if (DESCRIPTORS) {
                      if (setPrototypeOf) {
                          if (forced) for (ARRAY in TypedArrayConstructorsList) if ((TypedArrayConstructor = global[ARRAY]) && hasOwn(TypedArrayConstructor, KEY)) try {
                              delete TypedArrayConstructor[KEY];
                          } catch (error) {}
                          if (TypedArray[KEY] && !forced) return;
                          try {
                              return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                          } catch (error) {}
                      }
                      for (ARRAY in TypedArrayConstructorsList) !(TypedArrayConstructor = global[ARRAY]) || TypedArrayConstructor[KEY] && !forced || defineBuiltIn(TypedArrayConstructor, KEY, property);
                  }
              },
              getTypedArrayConstructor,
              isView: function(it) {
                  if (!isObject(it)) return !1;
                  var klass = classof(it);
                  return "DataView" === klass || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
              },
              isTypedArray,
              TypedArray,
              TypedArrayPrototype
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-from-constructor-and-list.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var lengthOfArrayLike = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/length-of-array-like.js");
          module.exports = function(Constructor, list) {
              for (var index = 0, length = lengthOfArrayLike(list), result = new Constructor(length); length > index; ) result[index] = list[index++];
              return result;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-iteration-from-last.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var bind = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-bind-context.js"), IndexedObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/indexed-object.js"), toObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-object.js"), lengthOfArrayLike = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/length-of-array-like.js"), createMethod = function(TYPE) {
              var IS_FIND_LAST_INDEX = 1 == TYPE;
              return function($this, callbackfn, that) {
                  for (var value, O = toObject($this), self = IndexedObject(O), boundFunction = bind(callbackfn, that), index = lengthOfArrayLike(self); index-- > 0; ) if (boundFunction(value = self[index], index, O)) switch (TYPE) {
                    case 0:
                      return value;

                    case 1:
                      return index;
                  }
                  return IS_FIND_LAST_INDEX ? -1 : void 0;
              };
          };
          module.exports = {
              findLast: createMethod(0),
              findLastIndex: createMethod(1)
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-to-reversed.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var lengthOfArrayLike = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/length-of-array-like.js");
          module.exports = function(O, C) {
              for (var len = lengthOfArrayLike(O), A = new C(len), k = 0; k < len; k++) A[k] = O[len - k - 1];
              return A;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-with.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var lengthOfArrayLike = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/length-of-array-like.js"), toIntegerOrInfinity = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-integer-or-infinity.js"), $RangeError = RangeError;
          module.exports = function(O, C, index, value) {
              var len = lengthOfArrayLike(O), relativeIndex = toIntegerOrInfinity(index), actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
              if (actualIndex >= len || actualIndex < 0) throw $RangeError("Incorrect index");
              for (var A = new C(len), k = 0; k < len; k++) A[k] = k === actualIndex ? value : O[k];
              return A;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof-raw.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), toString = uncurryThis({}.toString), stringSlice = uncurryThis("".slice);
          module.exports = function(it) {
              return stringSlice(toString(it), 8, -1);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var TO_STRING_TAG_SUPPORT = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-string-tag-support.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), classofRaw = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof-raw.js"), TO_STRING_TAG = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/well-known-symbol.js")("toStringTag"), $Object = Object, CORRECT_ARGUMENTS = "Arguments" == classofRaw(function() {
              return arguments;
          }());
          module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
              var O, tag, result;
              return void 0 === it ? "Undefined" : null === it ? "Null" : "string" == typeof (tag = function(it, key) {
                  try {
                      return it[key];
                  } catch (error) {}
              }(O = $Object(it), TO_STRING_TAG)) ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : "Object" == (result = classofRaw(O)) && isCallable(O.callee) ? "Arguments" : result;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/correct-prototype-getter.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js");
          module.exports = !fails((function() {
              function F() {}
              return F.prototype.constructor = null, Object.getPrototypeOf(new F) !== F.prototype;
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/create-non-enumerable-property.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), definePropertyModule = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-define-property.js"), createPropertyDescriptor = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/create-property-descriptor.js");
          module.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
              return object[key] = value, object;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/create-property-descriptor.js": module => {
          module.exports = function(bitmap, value) {
              return {
                  enumerable: !(1 & bitmap),
                  configurable: !(2 & bitmap),
                  writable: !(4 & bitmap),
                  value
              };
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/define-built-in.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), definePropertyModule = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-define-property.js"), makeBuiltIn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/make-built-in.js"), defineGlobalProperty = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/define-global-property.js");
          module.exports = function(O, key, value, options) {
              options || (options = {});
              var simple = options.enumerable, name = void 0 !== options.name ? options.name : key;
              if (isCallable(value) && makeBuiltIn(value, name, options), options.global) simple ? O[key] = value : defineGlobalProperty(key, value); else {
                  try {
                      options.unsafe ? O[key] && (simple = !0) : delete O[key];
                  } catch (error) {}
                  simple ? O[key] = value : definePropertyModule.f(O, key, {
                      value,
                      enumerable: !1,
                      configurable: !options.nonConfigurable,
                      writable: !options.nonWritable
                  });
              }
              return O;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/define-global-property.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), defineProperty = Object.defineProperty;
          module.exports = function(key, value) {
              try {
                  defineProperty(global, key, {
                      value,
                      configurable: !0,
                      writable: !0
                  });
              } catch (error) {
                  global[key] = value;
              }
              return value;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js");
          module.exports = !fails((function() {
              return 7 != Object.defineProperty({}, 1, {
                  get: function() {
                      return 7;
                  }
              })[1];
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/document-all.js": module => {
          var documentAll = "object" == typeof document && document.all, IS_HTMLDDA = void 0 === documentAll && void 0 !== documentAll;
          module.exports = {
              all: documentAll,
              IS_HTMLDDA
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/document-create-element.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), isObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js"), document = global.document, EXISTS = isObject(document) && isObject(document.createElement);
          module.exports = function(it) {
              return EXISTS ? document.createElement(it) : {};
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/engine-user-agent.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var getBuiltIn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/get-built-in.js");
          module.exports = getBuiltIn("navigator", "userAgent") || "";
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/engine-v8-version.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var match, version, global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), userAgent = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/engine-user-agent.js"), process = global.process, Deno = global.Deno, versions = process && process.versions || Deno && Deno.version, v8 = versions && versions.v8;
          v8 && (version = (match = v8.split("."))[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1])), 
          !version && userAgent && (!(match = userAgent.match(/Edge\/(\d+)/)) || match[1] >= 74) && (match = userAgent.match(/Chrome\/(\d+)/)) && (version = +match[1]), 
          module.exports = version;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js": module => {
          module.exports = function(exec) {
              try {
                  return !!exec();
              } catch (error) {
                  return !0;
              }
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-bind-context.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this-clause.js"), aCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/a-callable.js"), NATIVE_BIND = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-bind-native.js"), bind = uncurryThis(uncurryThis.bind);
          module.exports = function(fn, that) {
              return aCallable(fn), void 0 === that ? fn : NATIVE_BIND ? bind(fn, that) : function() {
                  return fn.apply(that, arguments);
              };
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-bind-native.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js");
          module.exports = !fails((function() {
              var test = function() {}.bind();
              return "function" != typeof test || test.hasOwnProperty("prototype");
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-call.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var NATIVE_BIND = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-bind-native.js"), call = Function.prototype.call;
          module.exports = NATIVE_BIND ? call.bind(call) : function() {
              return call.apply(call, arguments);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-name.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), hasOwn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js"), FunctionPrototype = Function.prototype, getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor, EXISTS = hasOwn(FunctionPrototype, "name"), PROPER = EXISTS && "something" === function() {}.name, CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
          module.exports = {
              EXISTS,
              PROPER,
              CONFIGURABLE
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this-clause.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var classofRaw = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof-raw.js"), uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js");
          module.exports = function(fn) {
              if ("Function" === classofRaw(fn)) return uncurryThis(fn);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var NATIVE_BIND = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-bind-native.js"), FunctionPrototype = Function.prototype, call = FunctionPrototype.call, uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
          module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
              return function() {
                  return call.apply(fn, arguments);
              };
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/get-built-in.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js");
          module.exports = function(namespace, method) {
              return arguments.length < 2 ? (argument = global[namespace], isCallable(argument) ? argument : void 0) : global[namespace] && global[namespace][method];
              var argument;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/get-method.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var aCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/a-callable.js"), isNullOrUndefined = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-null-or-undefined.js");
          module.exports = function(V, P) {
              var func = V[P];
              return isNullOrUndefined(func) ? void 0 : aCallable(func);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var check = function(it) {
              return it && it.Math == Math && it;
          };
          module.exports = check("object" == typeof globalThis && globalThis) || check("object" == typeof window && window) || check("object" == typeof self && self) || check("object" == typeof __webpack_require__.g && __webpack_require__.g) || function() {
              return this;
          }() || Function("return this")();
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), toObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-object.js"), hasOwnProperty = uncurryThis({}.hasOwnProperty);
          module.exports = Object.hasOwn || function(it, key) {
              return hasOwnProperty(toObject(it), key);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/hidden-keys.js": module => {
          module.exports = {};
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/ie8-dom-define.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js"), createElement = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/document-create-element.js");
          module.exports = !DESCRIPTORS && !fails((function() {
              return 7 != Object.defineProperty(createElement("div"), "a", {
                  get: function() {
                      return 7;
                  }
              }).a;
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/indexed-object.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js"), classof = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof-raw.js"), $Object = Object, split = uncurryThis("".split);
          module.exports = fails((function() {
              return !$Object("z").propertyIsEnumerable(0);
          })) ? function(it) {
              return "String" == classof(it) ? split(it, "") : $Object(it);
          } : $Object;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/inspect-source.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), store = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-store.js"), functionToString = uncurryThis(Function.toString);
          isCallable(store.inspectSource) || (store.inspectSource = function(it) {
              return functionToString(it);
          }), module.exports = store.inspectSource;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/internal-state.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var set, get, has, NATIVE_WEAK_MAP = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/weak-map-basic-detection.js"), global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), isObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js"), createNonEnumerableProperty = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/create-non-enumerable-property.js"), hasOwn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js"), shared = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-store.js"), sharedKey = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-key.js"), hiddenKeys = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/hidden-keys.js"), TypeError = global.TypeError, WeakMap = global.WeakMap;
          if (NATIVE_WEAK_MAP || shared.state) {
              var store = shared.state || (shared.state = new WeakMap);
              store.get = store.get, store.has = store.has, store.set = store.set, set = function(it, metadata) {
                  if (store.has(it)) throw TypeError("Object already initialized");
                  return metadata.facade = it, store.set(it, metadata), metadata;
              }, get = function(it) {
                  return store.get(it) || {};
              }, has = function(it) {
                  return store.has(it);
              };
          } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = !0, set = function(it, metadata) {
                  if (hasOwn(it, STATE)) throw TypeError("Object already initialized");
                  return metadata.facade = it, createNonEnumerableProperty(it, STATE, metadata), metadata;
              }, get = function(it) {
                  return hasOwn(it, STATE) ? it[STATE] : {};
              }, has = function(it) {
                  return hasOwn(it, STATE);
              };
          }
          module.exports = {
              set,
              get,
              has,
              enforce: function(it) {
                  return has(it) ? get(it) : set(it, {});
              },
              getterFor: function(TYPE) {
                  return function(it) {
                      var state;
                      if (!isObject(it) || (state = get(it)).type !== TYPE) throw TypeError("Incompatible receiver, " + TYPE + " required");
                      return state;
                  };
              }
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-big-int-array.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var classof = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/classof.js"), slice = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js")("".slice);
          module.exports = function(it) {
              return "Big" === slice(classof(it), 0, 3);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var $documentAll = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/document-all.js"), documentAll = $documentAll.all;
          module.exports = $documentAll.IS_HTMLDDA ? function(argument) {
              return "function" == typeof argument || argument === documentAll;
          } : function(argument) {
              return "function" == typeof argument;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-null-or-undefined.js": module => {
          module.exports = function(it) {
              return null == it;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), $documentAll = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/document-all.js"), documentAll = $documentAll.all;
          module.exports = $documentAll.IS_HTMLDDA ? function(it) {
              return "object" == typeof it ? null !== it : isCallable(it) || it === documentAll;
          } : function(it) {
              return "object" == typeof it ? null !== it : isCallable(it);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-pure.js": module => {
          module.exports = !1;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-symbol.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var getBuiltIn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/get-built-in.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), isPrototypeOf = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-is-prototype-of.js"), USE_SYMBOL_AS_UID = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/use-symbol-as-uid.js"), $Object = Object;
          module.exports = USE_SYMBOL_AS_UID ? function(it) {
              return "symbol" == typeof it;
          } : function(it) {
              var $Symbol = getBuiltIn("Symbol");
              return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/length-of-array-like.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var toLength = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-length.js");
          module.exports = function(obj) {
              return toLength(obj.length);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/make-built-in.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), hasOwn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js"), DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), CONFIGURABLE_FUNCTION_NAME = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-name.js").CONFIGURABLE, inspectSource = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/inspect-source.js"), InternalStateModule = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/internal-state.js"), enforceInternalState = InternalStateModule.enforce, getInternalState = InternalStateModule.get, defineProperty = Object.defineProperty, CONFIGURABLE_LENGTH = DESCRIPTORS && !fails((function() {
              return 8 !== defineProperty((function() {}), "length", {
                  value: 8
              }).length;
          })), TEMPLATE = String(String).split("String"), makeBuiltIn = module.exports = function(value, name, options) {
              "Symbol(" === String(name).slice(0, 7) && (name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), 
              options && options.getter && (name = "get " + name), options && options.setter && (name = "set " + name), 
              (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) && (DESCRIPTORS ? defineProperty(value, "name", {
                  value: name,
                  configurable: !0
              }) : value.name = name), CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity && defineProperty(value, "length", {
                  value: options.arity
              });
              try {
                  options && hasOwn(options, "constructor") && options.constructor ? DESCRIPTORS && defineProperty(value, "prototype", {
                      writable: !1
                  }) : value.prototype && (value.prototype = void 0);
              } catch (error) {}
              var state = enforceInternalState(value);
              return hasOwn(state, "source") || (state.source = TEMPLATE.join("string" == typeof name ? name : "")), 
              value;
          };
          Function.prototype.toString = makeBuiltIn((function() {
              return isCallable(this) && getInternalState(this).source || inspectSource(this);
          }), "toString");
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/math-trunc.js": module => {
          var ceil = Math.ceil, floor = Math.floor;
          module.exports = Math.trunc || function(x) {
              var n = +x;
              return (n > 0 ? floor : ceil)(n);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-define-property.js": (__unused_webpack_module, exports, __webpack_require__) => {
          var DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), IE8_DOM_DEFINE = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/ie8-dom-define.js"), V8_PROTOTYPE_DEFINE_BUG = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/v8-prototype-define-bug.js"), anObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/an-object.js"), toPropertyKey = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-property-key.js"), $TypeError = TypeError, $defineProperty = Object.defineProperty, $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function(O, P, Attributes) {
              if (anObject(O), P = toPropertyKey(P), anObject(Attributes), "function" == typeof O && "prototype" === P && "value" in Attributes && "writable" in Attributes && !Attributes.writable) {
                  var current = $getOwnPropertyDescriptor(O, P);
                  current && current.writable && (O[P] = Attributes.value, Attributes = {
                      configurable: "configurable" in Attributes ? Attributes.configurable : current.configurable,
                      enumerable: "enumerable" in Attributes ? Attributes.enumerable : current.enumerable,
                      writable: !1
                  });
              }
              return $defineProperty(O, P, Attributes);
          } : $defineProperty : function(O, P, Attributes) {
              if (anObject(O), P = toPropertyKey(P), anObject(Attributes), IE8_DOM_DEFINE) try {
                  return $defineProperty(O, P, Attributes);
              } catch (error) {}
              if ("get" in Attributes || "set" in Attributes) throw $TypeError("Accessors not supported");
              return "value" in Attributes && (O[P] = Attributes.value), O;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-get-prototype-of.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var hasOwn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), toObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-object.js"), sharedKey = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-key.js"), CORRECT_PROTOTYPE_GETTER = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/correct-prototype-getter.js"), IE_PROTO = sharedKey("IE_PROTO"), $Object = Object, ObjectPrototype = $Object.prototype;
          module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
              var object = toObject(O);
              if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
              var constructor = object.constructor;
              return isCallable(constructor) && object instanceof constructor ? constructor.prototype : object instanceof $Object ? ObjectPrototype : null;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-is-prototype-of.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js");
          module.exports = uncurryThis({}.isPrototypeOf);
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/object-set-prototype-of.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), anObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/an-object.js"), aPossiblePrototype = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/a-possible-prototype.js");
          module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var setter, CORRECT_SETTER = !1, test = {};
              try {
                  (setter = uncurryThis(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(test, []), 
                  CORRECT_SETTER = test instanceof Array;
              } catch (error) {}
              return function(O, proto) {
                  return anObject(O), aPossiblePrototype(proto), CORRECT_SETTER ? setter(O, proto) : O.__proto__ = proto, 
                  O;
              };
          }() : void 0);
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/ordinary-to-primitive.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var call = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-call.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), isObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js"), $TypeError = TypeError;
          module.exports = function(input, pref) {
              var fn, val;
              if ("string" === pref && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
              if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
              if ("string" !== pref && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
              throw $TypeError("Can't convert object to primitive value");
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/require-object-coercible.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isNullOrUndefined = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-null-or-undefined.js"), $TypeError = TypeError;
          module.exports = function(it) {
              if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
              return it;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-key.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var shared = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared.js"), uid = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/uid.js"), keys = shared("keys");
          module.exports = function(key) {
              return keys[key] || (keys[key] = uid(key));
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-store.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), defineGlobalProperty = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/define-global-property.js"), store = global["__core-js_shared__"] || defineGlobalProperty("__core-js_shared__", {});
          module.exports = store;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var IS_PURE = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-pure.js"), store = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared-store.js");
          (module.exports = function(key, value) {
              return store[key] || (store[key] = void 0 !== value ? value : {});
          })("versions", []).push({
              version: "3.26.1",
              mode: IS_PURE ? "pure" : "global",
              copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
              license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",
              source: "https://github.com/zloirock/core-js"
          });
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/symbol-constructor-detection.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var V8_VERSION = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/engine-v8-version.js"), fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js");
          module.exports = !!Object.getOwnPropertySymbols && !fails((function() {
              var symbol = Symbol();
              return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-big-int.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var toPrimitive = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-primitive.js"), $TypeError = TypeError;
          module.exports = function(argument) {
              var prim = toPrimitive(argument, "number");
              if ("number" == typeof prim) throw $TypeError("Can't convert number to bigint");
              return BigInt(prim);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-integer-or-infinity.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var trunc = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/math-trunc.js");
          module.exports = function(argument) {
              var number = +argument;
              return number != number || 0 === number ? 0 : trunc(number);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-length.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var toIntegerOrInfinity = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-integer-or-infinity.js"), min = Math.min;
          module.exports = function(argument) {
              return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-object.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var requireObjectCoercible = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/require-object-coercible.js"), $Object = Object;
          module.exports = function(argument) {
              return $Object(requireObjectCoercible(argument));
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-primitive.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var call = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-call.js"), isObject = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-object.js"), isSymbol = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-symbol.js"), getMethod = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/get-method.js"), ordinaryToPrimitive = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/ordinary-to-primitive.js"), wellKnownSymbol = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/well-known-symbol.js"), $TypeError = TypeError, TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          module.exports = function(input, pref) {
              if (!isObject(input) || isSymbol(input)) return input;
              var result, exoticToPrim = getMethod(input, TO_PRIMITIVE);
              if (exoticToPrim) {
                  if (void 0 === pref && (pref = "default"), result = call(exoticToPrim, input, pref), 
                  !isObject(result) || isSymbol(result)) return result;
                  throw $TypeError("Can't convert object to primitive value");
              }
              return void 0 === pref && (pref = "number"), ordinaryToPrimitive(input, pref);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-property-key.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var toPrimitive = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-primitive.js"), isSymbol = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-symbol.js");
          module.exports = function(argument) {
              var key = toPrimitive(argument, "string");
              return isSymbol(key) ? key : key + "";
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-string-tag-support.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var test = {};
          test[__webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/well-known-symbol.js")("toStringTag")] = "z", 
          module.exports = "[object z]" === String(test);
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/try-to-string.js": module => {
          var $String = String;
          module.exports = function(argument) {
              try {
                  return $String(argument);
              } catch (error) {
                  return "Object";
              }
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/uid.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), id = 0, postfix = Math.random(), toString = uncurryThis(1..toString);
          module.exports = function(key) {
              return "Symbol(" + (void 0 === key ? "" : key) + ")_" + toString(++id + postfix, 36);
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/use-symbol-as-uid.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var NATIVE_SYMBOL = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/symbol-constructor-detection.js");
          module.exports = NATIVE_SYMBOL && !Symbol.sham && "symbol" == typeof Symbol.iterator;
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/v8-prototype-define-bug.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var DESCRIPTORS = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/descriptors.js"), fails = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/fails.js");
          module.exports = DESCRIPTORS && fails((function() {
              return 42 != Object.defineProperty((function() {}), "prototype", {
                  value: 42,
                  writable: !1
              }).prototype;
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/weak-map-basic-detection.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), isCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-callable.js"), WeakMap = global.WeakMap;
          module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/well-known-symbol.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var global = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/global.js"), shared = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/shared.js"), hasOwn = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/has-own-property.js"), uid = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/uid.js"), NATIVE_SYMBOL = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/symbol-constructor-detection.js"), USE_SYMBOL_AS_UID = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/use-symbol-as-uid.js"), WellKnownSymbolsStore = shared("wks"), Symbol = global.Symbol, symbolFor = Symbol && Symbol.for, createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
          module.exports = function(name) {
              if (!hasOwn(WellKnownSymbolsStore, name) || !NATIVE_SYMBOL && "string" != typeof WellKnownSymbolsStore[name]) {
                  var description = "Symbol." + name;
                  NATIVE_SYMBOL && hasOwn(Symbol, name) ? WellKnownSymbolsStore[name] = Symbol[name] : WellKnownSymbolsStore[name] = USE_SYMBOL_AS_UID && symbolFor ? symbolFor(description) : createWellKnownSymbol(description);
              }
              return WellKnownSymbolsStore[name];
          };
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/es.typed-array.find-last-index.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var ArrayBufferViewCore = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-view-core.js"), $findLastIndex = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-iteration-from-last.js").findLastIndex, aTypedArray = ArrayBufferViewCore.aTypedArray;
          (0, ArrayBufferViewCore.exportTypedArrayMethod)("findLastIndex", (function(predicate) {
              return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/es.typed-array.find-last.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var ArrayBufferViewCore = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-view-core.js"), $findLast = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-iteration-from-last.js").findLast, aTypedArray = ArrayBufferViewCore.aTypedArray;
          (0, ArrayBufferViewCore.exportTypedArrayMethod)("findLast", (function(predicate) {
              return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/esnext.typed-array.to-reversed.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var arrayToReversed = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-to-reversed.js"), ArrayBufferViewCore = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-view-core.js"), aTypedArray = ArrayBufferViewCore.aTypedArray, exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod, getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
          exportTypedArrayMethod("toReversed", (function() {
              return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/esnext.typed-array.to-sorted.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var ArrayBufferViewCore = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-view-core.js"), uncurryThis = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/function-uncurry-this.js"), aCallable = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/a-callable.js"), arrayFromConstructorAndList = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-from-constructor-and-list.js"), aTypedArray = ArrayBufferViewCore.aTypedArray, getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor, exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod, sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);
          exportTypedArrayMethod("toSorted", (function(compareFn) {
              void 0 !== compareFn && aCallable(compareFn);
              var O = aTypedArray(this), A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);
              return sort(A, compareFn);
          }));
      },
      "./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/modules/esnext.typed-array.with.js": (__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          var arrayWith = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-with.js"), ArrayBufferViewCore = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/array-buffer-view-core.js"), isBigIntArray = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/is-big-int-array.js"), toIntegerOrInfinity = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-integer-or-infinity.js"), toBigInt = __webpack_require__("./node_modules/.pnpm/core-js@3.26.1/node_modules/core-js/internals/to-big-int.js"), aTypedArray = ArrayBufferViewCore.aTypedArray, getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor, exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod, PROPER_ORDER = !!function() {
              try {
                  new Int8Array(1).with(2, {
                      valueOf: function() {
                          throw 8;
                      }
                  });
              } catch (error) {
                  return 8 === error;
              }
          }();
          exportTypedArrayMethod("with", {
              with: function(index, value) {
                  var O = aTypedArray(this), relativeIndex = toIntegerOrInfinity(index), actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
                  return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
              }
          }.with, !PROPER_ORDER);
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/dayjs.min.js": function(module) {
          module.exports = function() {
              "use strict";
              var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
                  name: "en",
                  weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                  months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                  ordinal: function(t) {
                      var e = [ "th", "st", "nd", "rd" ], n = t % 100;
                      return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
                  }
              }, m = function(t, e, n) {
                  var r = String(t);
                  return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
              }, v = {
                  s: m,
                  z: function(t) {
                      var e = -t.utcOffset(), n = Math.abs(e), r = Math.floor(n / 60), i = n % 60;
                      return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
                  },
                  m: function t(e, n) {
                      if (e.date() < n.date()) return -t(n, e);
                      var r = 12 * (n.year() - e.year()) + (n.month() - e.month()), i = e.clone().add(r, f), s = n - i < 0, u = e.clone().add(r + (s ? -1 : 1), f);
                      return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
                  },
                  a: function(t) {
                      return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
                  },
                  p: function(t) {
                      return {
                          M: f,
                          y: c,
                          w: o,
                          d: a,
                          D: d,
                          h: u,
                          m: s,
                          s: i,
                          ms: r,
                          Q: h
                      }[t] || String(t || "").toLowerCase().replace(/s$/, "");
                  },
                  u: function(t) {
                      return void 0 === t;
                  }
              }, g = "en", D = {};
              D[g] = M;
              var p = function(t) {
                  return t instanceof _;
              }, S = function t(e, n, r) {
                  var i;
                  if (!e) return g;
                  if ("string" == typeof e) {
                      var s = e.toLowerCase();
                      D[s] && (i = s), n && (D[s] = n, i = s);
                      var u = e.split("-");
                      if (!i && u.length > 1) return t(u[0]);
                  } else {
                      var a = e.name;
                      D[a] = e, i = a;
                  }
                  return !r && i && (g = i), i || !r && g;
              }, w = function(t, e) {
                  if (p(t)) return t.clone();
                  var n = "object" == typeof e ? e : {};
                  return n.date = t, n.args = arguments, new _(n);
              }, O = v;
              O.l = S, O.i = p, O.w = function(t, e) {
                  return w(t, {
                      locale: e.$L,
                      utc: e.$u,
                      x: e.$x,
                      $offset: e.$offset
                  });
              };
              var _ = function() {
                  function M(t) {
                      this.$L = S(t.locale, null, !0), this.parse(t);
                  }
                  var m = M.prototype;
                  return m.parse = function(t) {
                      this.$d = function(t) {
                          var e = t.date, n = t.utc;
                          if (null === e) return new Date(NaN);
                          if (O.u(e)) return new Date;
                          if (e instanceof Date) return new Date(e);
                          if ("string" == typeof e && !/Z$/i.test(e)) {
                              var r = e.match($);
                              if (r) {
                                  var i = r[2] - 1 || 0, s = (r[7] || "0").substring(0, 3);
                                  return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                              }
                          }
                          return new Date(e);
                      }(t), this.$x = t.x || {}, this.init();
                  }, m.init = function() {
                      var t = this.$d;
                      this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), 
                      this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
                  }, m.$utils = function() {
                      return O;
                  }, m.isValid = function() {
                      return !(this.$d.toString() === l);
                  }, m.isSame = function(t, e) {
                      var n = w(t);
                      return this.startOf(e) <= n && n <= this.endOf(e);
                  }, m.isAfter = function(t, e) {
                      return w(t) < this.startOf(e);
                  }, m.isBefore = function(t, e) {
                      return this.endOf(e) < w(t);
                  }, m.$g = function(t, e, n) {
                      return O.u(t) ? this[e] : this.set(n, t);
                  }, m.unix = function() {
                      return Math.floor(this.valueOf() / 1e3);
                  }, m.valueOf = function() {
                      return this.$d.getTime();
                  }, m.startOf = function(t, e) {
                      var n = this, r = !!O.u(e) || e, h = O.p(t), l = function(t, e) {
                          var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                          return r ? i : i.endOf(a);
                      }, $ = function(t, e) {
                          return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [ 0, 0, 0, 0 ] : [ 23, 59, 59, 999 ]).slice(e)), n);
                      }, y = this.$W, M = this.$M, m = this.$D, v = "set" + (this.$u ? "UTC" : "");
                      switch (h) {
                        case c:
                          return r ? l(1, 0) : l(31, 11);

                        case f:
                          return r ? l(1, M) : l(0, M + 1);

                        case o:
                          var g = this.$locale().weekStart || 0, D = (y < g ? y + 7 : y) - g;
                          return l(r ? m - D : m + (6 - D), M);

                        case a:
                        case d:
                          return $(v + "Hours", 0);

                        case u:
                          return $(v + "Minutes", 1);

                        case s:
                          return $(v + "Seconds", 2);

                        case i:
                          return $(v + "Milliseconds", 3);

                        default:
                          return this.clone();
                      }
                  }, m.endOf = function(t) {
                      return this.startOf(t, !1);
                  }, m.$set = function(t, e) {
                      var n, o = O.p(t), h = "set" + (this.$u ? "UTC" : ""), l = (n = {}, n[a] = h + "Date", 
                      n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", 
                      n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o], $ = o === a ? this.$D + (e - this.$W) : e;
                      if (o === f || o === c) {
                          var y = this.clone().set(d, 1);
                          y.$d[l]($), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
                      } else l && this.$d[l]($);
                      return this.init(), this;
                  }, m.set = function(t, e) {
                      return this.clone().$set(t, e);
                  }, m.get = function(t) {
                      return this[O.p(t)]();
                  }, m.add = function(r, h) {
                      var d, l = this;
                      r = Number(r);
                      var $ = O.p(h), y = function(t) {
                          var e = w(l);
                          return O.w(e.date(e.date() + Math.round(t * r)), l);
                      };
                      if ($ === f) return this.set(f, this.$M + r);
                      if ($ === c) return this.set(c, this.$y + r);
                      if ($ === a) return y(1);
                      if ($ === o) return y(7);
                      var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[$] || 1, m = this.$d.getTime() + r * M;
                      return O.w(m, this);
                  }, m.subtract = function(t, e) {
                      return this.add(-1 * t, e);
                  }, m.format = function(t) {
                      var e = this, n = this.$locale();
                      if (!this.isValid()) return n.invalidDate || l;
                      var r = t || "YYYY-MM-DDTHH:mm:ssZ", i = O.z(this), s = this.$H, u = this.$m, a = this.$M, o = n.weekdays, f = n.months, h = function(t, n, i, s) {
                          return t && (t[n] || t(e, r)) || i[n].slice(0, s);
                      }, c = function(t) {
                          return O.s(s % 12 || 12, t, "0");
                      }, d = n.meridiem || function(t, e, n) {
                          var r = t < 12 ? "AM" : "PM";
                          return n ? r.toLowerCase() : r;
                      }, $ = {
                          YY: String(this.$y).slice(-2),
                          YYYY: this.$y,
                          M: a + 1,
                          MM: O.s(a + 1, 2, "0"),
                          MMM: h(n.monthsShort, a, f, 3),
                          MMMM: h(f, a),
                          D: this.$D,
                          DD: O.s(this.$D, 2, "0"),
                          d: String(this.$W),
                          dd: h(n.weekdaysMin, this.$W, o, 2),
                          ddd: h(n.weekdaysShort, this.$W, o, 3),
                          dddd: o[this.$W],
                          H: String(s),
                          HH: O.s(s, 2, "0"),
                          h: c(1),
                          hh: c(2),
                          a: d(s, u, !0),
                          A: d(s, u, !1),
                          m: String(u),
                          mm: O.s(u, 2, "0"),
                          s: String(this.$s),
                          ss: O.s(this.$s, 2, "0"),
                          SSS: O.s(this.$ms, 3, "0"),
                          Z: i
                      };
                      return r.replace(y, (function(t, e) {
                          return e || $[t] || i.replace(":", "");
                      }));
                  }, m.utcOffset = function() {
                      return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
                  }, m.diff = function(r, d, l) {
                      var $, y = O.p(d), M = w(r), m = (M.utcOffset() - this.utcOffset()) * e, v = this - M, g = O.m(this, M);
                      return g = ($ = {}, $[c] = g / 12, $[f] = g, $[h] = g / 3, $[o] = (v - m) / 6048e5, 
                      $[a] = (v - m) / 864e5, $[u] = v / n, $[s] = v / e, $[i] = v / t, $)[y] || v, l ? g : O.a(g);
                  }, m.daysInMonth = function() {
                      return this.endOf(f).$D;
                  }, m.$locale = function() {
                      return D[this.$L];
                  }, m.locale = function(t, e) {
                      if (!t) return this.$L;
                      var n = this.clone(), r = S(t, e, !0);
                      return r && (n.$L = r), n;
                  }, m.clone = function() {
                      return O.w(this.$d, this);
                  }, m.toDate = function() {
                      return new Date(this.valueOf());
                  }, m.toJSON = function() {
                      return this.isValid() ? this.toISOString() : null;
                  }, m.toISOString = function() {
                      return this.$d.toISOString();
                  }, m.toString = function() {
                      return this.$d.toUTCString();
                  }, M;
              }(), T = _.prototype;
              return w.prototype = T, [ [ "$ms", r ], [ "$s", i ], [ "$m", s ], [ "$H", u ], [ "$W", a ], [ "$M", f ], [ "$y", c ], [ "$D", d ] ].forEach((function(t) {
                  T[t[1]] = function(e) {
                      return this.$g(e, t[0], t[1]);
                  };
              })), w.extend = function(t, e) {
                  return t.$i || (t(e, _, w), t.$i = !0), w;
              }, w.locale = S, w.isDayjs = p, w.unix = function(t) {
                  return w(1e3 * t);
              }, w.en = D[g], w.Ls = D, w.p = {}, w;
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/advancedFormat.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(e, t) {
                  var r = t.prototype, n = r.format;
                  r.format = function(e) {
                      var t = this, r = this.$locale();
                      if (!this.isValid()) return n.bind(this)(e);
                      var s = this.$utils(), a = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, (function(e) {
                          switch (e) {
                            case "Q":
                              return Math.ceil((t.$M + 1) / 3);

                            case "Do":
                              return r.ordinal(t.$D);

                            case "gggg":
                              return t.weekYear();

                            case "GGGG":
                              return t.isoWeekYear();

                            case "wo":
                              return r.ordinal(t.week(), "W");

                            case "w":
                            case "ww":
                              return s.s(t.week(), "w" === e ? 1 : 2, "0");

                            case "W":
                            case "WW":
                              return s.s(t.isoWeek(), "W" === e ? 1 : 2, "0");

                            case "k":
                            case "kk":
                              return s.s(String(0 === t.$H ? 24 : t.$H), "k" === e ? 1 : 2, "0");

                            case "X":
                              return Math.floor(t.$d.getTime() / 1e3);

                            case "x":
                              return t.$d.getTime();

                            case "z":
                              return "[" + t.offsetName() + "]";

                            case "zzz":
                              return "[" + t.offsetName("long") + "]";

                            default:
                              return e;
                          }
                      }));
                      return n.bind(this)(a);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/customParseFormat.js": function(module) {
          module.exports = function() {
              "use strict";
              var e = {
                  LTS: "h:mm:ss A",
                  LT: "h:mm A",
                  L: "MM/DD/YYYY",
                  LL: "MMMM D, YYYY",
                  LLL: "MMMM D, YYYY h:mm A",
                  LLLL: "dddd, MMMM D, YYYY h:mm A"
              }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e) {
                  return (e = +e) + (e > 68 ? 1900 : 2e3);
              }, a = function(e) {
                  return function(t) {
                      this[e] = +t;
                  };
              }, f = [ /[+-]\d\d:?(\d\d)?|Z/, function(e) {
                  (this.zone || (this.zone = {})).offset = function(e) {
                      if (!e) return 0;
                      if ("Z" === e) return 0;
                      var t = e.match(/([+-]|\d\d)/g), n = 60 * t[1] + (+t[2] || 0);
                      return 0 === n ? 0 : "+" === t[0] ? -n : n;
                  }(e);
              } ], h = function(e) {
                  var t = o[e];
                  return t && (t.indexOf ? t : t.s.concat(t.f));
              }, u = function(e, t) {
                  var n, r = o.meridiem;
                  if (r) {
                      for (var i = 1; i <= 24; i += 1) if (e.indexOf(r(i, 0, t)) > -1) {
                          n = i > 12;
                          break;
                      }
                  } else n = e === (t ? "pm" : "PM");
                  return n;
              }, d = {
                  A: [ i, function(e) {
                      this.afternoon = u(e, !1);
                  } ],
                  a: [ i, function(e) {
                      this.afternoon = u(e, !0);
                  } ],
                  S: [ /\d/, function(e) {
                      this.milliseconds = 100 * +e;
                  } ],
                  SS: [ n, function(e) {
                      this.milliseconds = 10 * +e;
                  } ],
                  SSS: [ /\d{3}/, function(e) {
                      this.milliseconds = +e;
                  } ],
                  s: [ r, a("seconds") ],
                  ss: [ r, a("seconds") ],
                  m: [ r, a("minutes") ],
                  mm: [ r, a("minutes") ],
                  H: [ r, a("hours") ],
                  h: [ r, a("hours") ],
                  HH: [ r, a("hours") ],
                  hh: [ r, a("hours") ],
                  D: [ r, a("day") ],
                  DD: [ n, a("day") ],
                  Do: [ i, function(e) {
                      var t = o.ordinal, n = e.match(/\d+/);
                      if (this.day = n[0], t) for (var r = 1; r <= 31; r += 1) t(r).replace(/\[|\]/g, "") === e && (this.day = r);
                  } ],
                  M: [ r, a("month") ],
                  MM: [ n, a("month") ],
                  MMM: [ i, function(e) {
                      var t = h("months"), n = (h("monthsShort") || t.map((function(e) {
                          return e.slice(0, 3);
                      }))).indexOf(e) + 1;
                      if (n < 1) throw new Error;
                      this.month = n % 12 || n;
                  } ],
                  MMMM: [ i, function(e) {
                      var t = h("months").indexOf(e) + 1;
                      if (t < 1) throw new Error;
                      this.month = t % 12 || t;
                  } ],
                  Y: [ /[+-]?\d+/, a("year") ],
                  YY: [ n, function(e) {
                      this.year = s(e);
                  } ],
                  YYYY: [ /\d{4}/, a("year") ],
                  Z: f,
                  ZZ: f
              };
              function c(n) {
                  var r, i;
                  r = n, i = o && o.formats;
                  for (var s = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t, n, r) {
                      var o = r && r.toUpperCase();
                      return n || i[r] || e[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e, t, n) {
                          return t || n.slice(1);
                      }));
                  }))).match(t), a = s.length, f = 0; f < a; f += 1) {
                      var h = s[f], u = d[h], c = u && u[0], l = u && u[1];
                      s[f] = l ? {
                          regex: c,
                          parser: l
                      } : h.replace(/^\[|\]$/g, "");
                  }
                  return function(e) {
                      for (var t = {}, n = 0, r = 0; n < a; n += 1) {
                          var i = s[n];
                          if ("string" == typeof i) r += i.length; else {
                              var o = i.regex, f = i.parser, h = e.slice(r), u = o.exec(h)[0];
                              f.call(t, u), e = e.replace(u, "");
                          }
                      }
                      return function(e) {
                          var t = e.afternoon;
                          if (void 0 !== t) {
                              var n = e.hours;
                              t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
                          }
                      }(t), t;
                  };
              }
              return function(e, t, n) {
                  n.p.customParseFormat = !0, e && e.parseTwoDigitYear && (s = e.parseTwoDigitYear);
                  var r = t.prototype, i = r.parse;
                  r.parse = function(e) {
                      var t = e.date, r = e.utc, s = e.args;
                      this.$u = r;
                      var a = s[1];
                      if ("string" == typeof a) {
                          var f = !0 === s[2], h = !0 === s[3], u = f || h, d = s[2];
                          h && (d = s[2]), o = this.$locale(), !f && d && (o = n.Ls[d]), this.$d = function(e, t, n) {
                              try {
                                  if ([ "x", "X" ].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
                                  var r = c(t)(e), i = r.year, o = r.month, s = r.day, a = r.hours, f = r.minutes, h = r.seconds, u = r.milliseconds, d = r.zone, l = new Date, m = s || (i || o ? 1 : l.getDate()), M = i || l.getFullYear(), Y = 0;
                                  i && !o || (Y = o > 0 ? o - 1 : l.getMonth());
                                  var p = a || 0, v = f || 0, D = h || 0, g = u || 0;
                                  return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
                              } catch (e) {
                                  return new Date("");
                              }
                          }(t, a, r), this.init(), d && !0 !== d && (this.$L = this.locale(d).$L), u && t != this.format(a) && (this.$d = new Date("")), 
                          o = {};
                      } else if (a instanceof Array) for (var l = a.length, m = 1; m <= l; m += 1) {
                          s[1] = a[m - 1];
                          var M = n.apply(this, s);
                          if (M.isValid()) {
                              this.$d = M.$d, this.$L = M.$L, this.init();
                              break;
                          }
                          m === l && (this.$d = new Date(""));
                      } else i.call(this, e);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/isMoment.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(e, n, t) {
                  t.isMoment = function(e) {
                      return t.isDayjs(e);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/isSameOrAfter.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(e, t) {
                  t.prototype.isSameOrAfter = function(e, t) {
                      return this.isSame(e, t) || this.isAfter(e, t);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/isSameOrBefore.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(e, i) {
                  i.prototype.isSameOrBefore = function(e, i) {
                      return this.isSame(e, i) || this.isBefore(e, i);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/localeData.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(n, e, t) {
                  var r = e.prototype, o = function(n) {
                      return n && (n.indexOf ? n : n.s);
                  }, u = function(n, e, t, r, u) {
                      var i = n.name ? n : n.$locale(), a = o(i[e]), s = o(i[t]), f = a || s.map((function(n) {
                          return n.slice(0, r);
                      }));
                      if (!u) return f;
                      var d = i.weekStart;
                      return f.map((function(n, e) {
                          return f[(e + (d || 0)) % 7];
                      }));
                  }, i = function() {
                      return t.Ls[t.locale()];
                  }, a = function(n, e) {
                      return n.formats[e] || function(n) {
                          return n.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(n, e, t) {
                              return e || t.slice(1);
                          }));
                      }(n.formats[e.toUpperCase()]);
                  }, s = function() {
                      var n = this;
                      return {
                          months: function(e) {
                              return e ? e.format("MMMM") : u(n, "months");
                          },
                          monthsShort: function(e) {
                              return e ? e.format("MMM") : u(n, "monthsShort", "months", 3);
                          },
                          firstDayOfWeek: function() {
                              return n.$locale().weekStart || 0;
                          },
                          weekdays: function(e) {
                              return e ? e.format("dddd") : u(n, "weekdays");
                          },
                          weekdaysMin: function(e) {
                              return e ? e.format("dd") : u(n, "weekdaysMin", "weekdays", 2);
                          },
                          weekdaysShort: function(e) {
                              return e ? e.format("ddd") : u(n, "weekdaysShort", "weekdays", 3);
                          },
                          longDateFormat: function(e) {
                              return a(n.$locale(), e);
                          },
                          meridiem: this.$locale().meridiem,
                          ordinal: this.$locale().ordinal
                      };
                  };
                  r.localeData = function() {
                      return s.bind(this)();
                  }, t.localeData = function() {
                      var n = i();
                      return {
                          firstDayOfWeek: function() {
                              return n.weekStart || 0;
                          },
                          weekdays: function() {
                              return t.weekdays();
                          },
                          weekdaysShort: function() {
                              return t.weekdaysShort();
                          },
                          weekdaysMin: function() {
                              return t.weekdaysMin();
                          },
                          months: function() {
                              return t.months();
                          },
                          monthsShort: function() {
                              return t.monthsShort();
                          },
                          longDateFormat: function(e) {
                              return a(n, e);
                          },
                          meridiem: n.meridiem,
                          ordinal: n.ordinal
                      };
                  }, t.months = function() {
                      return u(i(), "months");
                  }, t.monthsShort = function() {
                      return u(i(), "monthsShort", "months", 3);
                  }, t.weekdays = function(n) {
                      return u(i(), "weekdays", null, null, n);
                  }, t.weekdaysShort = function(n) {
                      return u(i(), "weekdaysShort", "weekdays", 3, n);
                  }, t.weekdaysMin = function(n) {
                      return u(i(), "weekdaysMin", "weekdays", 2, n);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/localizedFormat.js": function(module) {
          module.exports = function() {
              "use strict";
              var e = {
                  LTS: "h:mm:ss A",
                  LT: "h:mm A",
                  L: "MM/DD/YYYY",
                  LL: "MMMM D, YYYY",
                  LLL: "MMMM D, YYYY h:mm A",
                  LLLL: "dddd, MMMM D, YYYY h:mm A"
              };
              return function(t, o, n) {
                  var r = o.prototype, i = r.format;
                  n.en.formats = e, r.format = function(t) {
                      void 0 === t && (t = "YYYY-MM-DDTHH:mm:ssZ");
                      var o = this.$locale().formats, n = function(t, o) {
                          return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, (function(t, n, r) {
                              var i = r && r.toUpperCase();
                              return n || o[r] || e[r] || o[i].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, (function(e, t, o) {
                                  return t || o.slice(1);
                              }));
                          }));
                      }(t, void 0 === o ? {} : o);
                      return i.call(this, n);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/weekOfYear.js": function(module) {
          module.exports = function() {
              "use strict";
              var e = "week", t = "year";
              return function(i, n, r) {
                  var f = n.prototype;
                  f.week = function(i) {
                      if (void 0 === i && (i = null), null !== i) return this.add(7 * (i - this.week()), "day");
                      var n = this.$locale().yearStart || 1;
                      if (11 === this.month() && this.date() > 25) {
                          var f = r(this).startOf(t).add(1, t).date(n), s = r(this).endOf(e);
                          if (f.isBefore(s)) return 1;
                      }
                      var a = r(this).startOf(t).date(n).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, !0);
                      return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
                  }, f.weeks = function(e) {
                      return void 0 === e && (e = null), this.week(e);
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/weekYear.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(e, t) {
                  t.prototype.weekYear = function() {
                      var e = this.month(), t = this.week(), n = this.year();
                      return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n;
                  };
              };
          }();
      },
      "./node_modules/.pnpm/dayjs@1.11.6/node_modules/dayjs/plugin/weekday.js": function(module) {
          module.exports = function() {
              "use strict";
              return function(e, t) {
                  t.prototype.weekday = function(e) {
                      var t = this.$locale().weekStart || 0, i = this.$W, n = (i < t ? i + 7 : i) - t;
                      return this.$utils().u(e) ? n : this.subtract(n, "day").add(e, "day");
                  };
              };
          }();
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var Symbol = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js").Symbol;
          module.exports = Symbol;
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var Symbol = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"), getRawTag = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"), objectToString = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"), symToStringTag = Symbol ? Symbol.toStringTag : void 0;
          module.exports = function(value) {
              return null == value ? void 0 === value ? "[object Undefined]" : "[object Null]" : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var trimmedEndIndex = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"), reTrimStart = /^\s+/;
          module.exports = function(string) {
              return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var freeGlobal = "object" == typeof __webpack_require__.g && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
          module.exports = freeGlobal;
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var Symbol = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol ? Symbol.toStringTag : void 0;
          module.exports = function(value) {
              var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
              try {
                  value[symToStringTag] = void 0;
                  var unmasked = !0;
              } catch (e) {}
              var result = nativeObjectToString.call(value);
              return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), 
              result;
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js": module => {
          var nativeObjectToString = Object.prototype.toString;
          module.exports = function(value) {
              return nativeObjectToString.call(value);
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var freeGlobal = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"), freeSelf = "object" == typeof self && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
          module.exports = root;
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js": module => {
          var reWhitespace = /\s/;
          module.exports = function(string) {
              for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); ) ;
              return index;
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var isObject = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"), now = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js"), toNumber = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"), nativeMax = Math.max, nativeMin = Math.min;
          module.exports = function(func, wait, options) {
              var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
              if ("function" != typeof func) throw new TypeError("Expected a function");
              function invokeFunc(time) {
                  var args = lastArgs, thisArg = lastThis;
                  return lastArgs = lastThis = void 0, lastInvokeTime = time, result = func.apply(thisArg, args);
              }
              function shouldInvoke(time) {
                  var timeSinceLastCall = time - lastCallTime;
                  return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
              }
              function timerExpired() {
                  var time = now();
                  if (shouldInvoke(time)) return trailingEdge(time);
                  timerId = setTimeout(timerExpired, function(time) {
                      var timeWaiting = wait - (time - lastCallTime);
                      return maxing ? nativeMin(timeWaiting, maxWait - (time - lastInvokeTime)) : timeWaiting;
                  }(time));
              }
              function trailingEdge(time) {
                  return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, 
                  result);
              }
              function debounced() {
                  var time = now(), isInvoking = shouldInvoke(time);
                  if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                      if (void 0 === timerId) return function(time) {
                          return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result;
                      }(lastCallTime);
                      if (maxing) return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait), 
                      invokeFunc(lastCallTime);
                  }
                  return void 0 === timerId && (timerId = setTimeout(timerExpired, wait)), result;
              }
              return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, 
              maxWait = (maxing = "maxWait" in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, 
              trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function() {
                  void 0 !== timerId && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
              }, debounced.flush = function() {
                  return void 0 === timerId ? result : trailingEdge(now());
              }, debounced;
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js": module => {
          module.exports = function(value) {
              var type = typeof value;
              return null != value && ("object" == type || "function" == type);
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js": module => {
          module.exports = function(value) {
              return null != value && "object" == typeof value;
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var baseGetTag = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"), isObjectLike = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js");
          module.exports = function(value) {
              return "symbol" == typeof value || isObjectLike(value) && "[object Symbol]" == baseGetTag(value);
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/now.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var root = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js");
          module.exports = function() {
              return root.Date.now();
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/throttle.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var debounce = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/debounce.js"), isObject = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js");
          module.exports = function(func, wait, options) {
              var leading = !0, trailing = !0;
              if ("function" != typeof func) throw new TypeError("Expected a function");
              return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, 
              trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                  leading,
                  maxWait: wait,
                  trailing
              });
          };
      },
      "./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js": (module, __unused_webpack_exports, __webpack_require__) => {
          var baseTrim = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"), isObject = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"), isSymbol = __webpack_require__("./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"), reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
          module.exports = function(value) {
              if ("number" == typeof value) return value;
              if (isSymbol(value)) return NaN;
              if (isObject(value)) {
                  var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                  value = isObject(other) ? other + "" : other;
              }
              if ("string" != typeof value) return 0 === value ? value : +value;
              value = baseTrim(value);
              var isBinary = reIsBinary.test(value);
              return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NaN : +value;
          };
      },
      "./node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/cjs/react-is.production.min.js": (__unused_webpack_module, exports) => {
          "use strict";
          var u, b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen");
          function v(a) {
              if ("object" == typeof a && null !== a) {
                  var r = a.$$typeof;
                  switch (r) {
                    case b:
                      switch (a = a.type) {
                        case d:
                        case f:
                        case e:
                        case m:
                        case n:
                          return a;

                        default:
                          switch (a = a && a.$$typeof) {
                            case k:
                            case h:
                            case l:
                            case q:
                            case p:
                            case g:
                              return a;

                            default:
                              return r;
                          }
                      }

                    case c:
                      return r;
                  }
              }
          }
          u = Symbol.for("react.module.reference"), exports.isFragment = function(a) {
              return v(a) === d;
          }, exports.isMemo = function(a) {
              return v(a) === p;
          };
      },
      "./node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/index.js": (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          module.exports = __webpack_require__("./node_modules/.pnpm/react-is@18.2.0/node_modules/react-is/cjs/react-is.production.min.js");
      },
      "./node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/cjs/scheduler.production.min.js": (__unused_webpack_module, exports) => {
          "use strict";
          function f(a, b) {
              var c = a.length;
              a.push(b);
              a: for (;0 < c; ) {
                  var d = c - 1 >>> 1, e = a[d];
                  if (!(0 < g(e, b))) break a;
                  a[d] = b, a[c] = e, c = d;
              }
          }
          function h(a) {
              return 0 === a.length ? null : a[0];
          }
          function k(a) {
              if (0 === a.length) return null;
              var b = a[0], c = a.pop();
              if (c !== b) {
                  a[0] = c;
                  a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
                      var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
                      if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, 
                      a[m] = c, d = m); else {
                          if (!(n < e && 0 > g(x, c))) break a;
                          a[d] = x, a[n] = c, d = n;
                      }
                  }
              }
              return b;
          }
          function g(a, b) {
              var c = a.sortIndex - b.sortIndex;
              return 0 !== c ? c : a.id - b.id;
          }
          if ("object" == typeof performance && "function" == typeof performance.now) {
              var l = performance;
              exports.unstable_now = function() {
                  return l.now();
              };
          } else {
              var p = Date, q = p.now();
              exports.unstable_now = function() {
                  return p.now() - q;
              };
          }
          var r = [], t = [], u = 1, v = null, y = 3, z = !1, A = !1, B = !1, D = "function" == typeof setTimeout ? setTimeout : null, E = "function" == typeof clearTimeout ? clearTimeout : null, F = "undefined" != typeof setImmediate ? setImmediate : null;
          function G(a) {
              for (var b = h(t); null !== b; ) {
                  if (null === b.callback) k(t); else {
                      if (!(b.startTime <= a)) break;
                      k(t), b.sortIndex = b.expirationTime, f(r, b);
                  }
                  b = h(t);
              }
          }
          function H(a) {
              if (B = !1, G(a), !A) if (null !== h(r)) A = !0, I(J); else {
                  var b = h(t);
                  null !== b && K(H, b.startTime - a);
              }
          }
          function J(a, b) {
              A = !1, B && (B = !1, E(L), L = -1), z = !0;
              var c = y;
              try {
                  for (G(b), v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
                      var d = v.callback;
                      if ("function" == typeof d) {
                          v.callback = null, y = v.priorityLevel;
                          var e = d(v.expirationTime <= b);
                          b = exports.unstable_now(), "function" == typeof e ? v.callback = e : v === h(r) && k(r), 
                          G(b);
                      } else k(r);
                      v = h(r);
                  }
                  if (null !== v) var w = !0; else {
                      var m = h(t);
                      null !== m && K(H, m.startTime - b), w = !1;
                  }
                  return w;
              } finally {
                  v = null, y = c, z = !1;
              }
          }
          "undefined" != typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
          var S, N = !1, O = null, L = -1, P = 5, Q = -1;
          function M() {
              return !(exports.unstable_now() - Q < P);
          }
          function R() {
              if (null !== O) {
                  var a = exports.unstable_now();
                  Q = a;
                  var b = !0;
                  try {
                      b = O(!0, a);
                  } finally {
                      b ? S() : (N = !1, O = null);
                  }
              } else N = !1;
          }
          if ("function" == typeof F) S = function() {
              F(R);
          }; else if ("undefined" != typeof MessageChannel) {
              var T = new MessageChannel, U = T.port2;
              T.port1.onmessage = R, S = function() {
                  U.postMessage(null);
              };
          } else S = function() {
              D(R, 0);
          };
          function I(a) {
              O = a, N || (N = !0, S());
          }
          function K(a, b) {
              L = D((function() {
                  a(exports.unstable_now());
              }), b);
          }
          exports.unstable_IdlePriority = 5, exports.unstable_ImmediatePriority = 1, exports.unstable_LowPriority = 4, 
          exports.unstable_NormalPriority = 3, exports.unstable_Profiling = null, exports.unstable_UserBlockingPriority = 2, 
          exports.unstable_cancelCallback = function(a) {
              a.callback = null;
          }, exports.unstable_continueExecution = function() {
              A || z || (A = !0, I(J));
          }, exports.unstable_forceFrameRate = function(a) {
              0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
          }, exports.unstable_getCurrentPriorityLevel = function() {
              return y;
          }, exports.unstable_getFirstCallbackNode = function() {
              return h(r);
          }, exports.unstable_next = function(a) {
              switch (y) {
                case 1:
                case 2:
                case 3:
                  var b = 3;
                  break;

                default:
                  b = y;
              }
              var c = y;
              y = b;
              try {
                  return a();
              } finally {
                  y = c;
              }
          }, exports.unstable_pauseExecution = function() {}, exports.unstable_requestPaint = function() {}, 
          exports.unstable_runWithPriority = function(a, b) {
              switch (a) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  break;

                default:
                  a = 3;
              }
              var c = y;
              y = a;
              try {
                  return b();
              } finally {
                  y = c;
              }
          }, exports.unstable_scheduleCallback = function(a, b, c) {
              var d = exports.unstable_now();
              switch ("object" == typeof c && null !== c ? c = "number" == typeof (c = c.delay) && 0 < c ? d + c : d : c = d, 
              a) {
                case 1:
                  var e = -1;
                  break;

                case 2:
                  e = 250;
                  break;

                case 5:
                  e = 1073741823;
                  break;

                case 4:
                  e = 1e4;
                  break;

                default:
                  e = 5e3;
              }
              return a = {
                  id: u++,
                  callback: b,
                  priorityLevel: a,
                  startTime: c,
                  expirationTime: e = c + e,
                  sortIndex: -1
              }, c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), 
              L = -1) : B = !0, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = !0, 
              I(J))), a;
          }, exports.unstable_shouldYield = M, exports.unstable_wrapCallback = function(a) {
              var b = y;
              return function() {
                  var c = y;
                  y = b;
                  try {
                      return a.apply(this, arguments);
                  } finally {
                      y = c;
                  }
              };
          };
      },
      "./node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/index.js": (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          module.exports = __webpack_require__("./node_modules/.pnpm/scheduler@0.23.0/node_modules/scheduler/cjs/scheduler.production.min.js");
      },
      "./node_modules/.pnpm/tiny-uid@1.1.2/node_modules/tiny-uid/index.js": module => {
          const uid = (length = 7, hex = !1) => {
              return Array.from({
                  length
              }, (base = hex ? 16 : 36, "undefined" != typeof crypto && "function" == typeof crypto.getRandomValues ? () => {
                  const num = crypto.getRandomValues(new Uint8Array(1))[0];
                  return (num >= base ? num % base : num).toString(base);
              } : () => Math.floor(Math.random() * base).toString(base))).join("");
              var base;
          };
          module.exports = uid, module.exports.default = uid;
      },
      "./node_modules/.pnpm/ua-parser-js@1.0.36/node_modules/ua-parser-js/src/ua-parser.js": function(module, exports, __webpack_require__) {
          var __WEBPACK_AMD_DEFINE_RESULT__;
          !function(window, undefined) {
              "use strict";
              var MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", enumerize = function(arr) {
                  for (var enums = {}, i = 0; i < arr.length; i++) enums[arr[i].toUpperCase()] = arr[i];
                  return enums;
              }, has = function(str1, str2) {
                  return "string" == typeof str1 && -1 !== lowerize(str2).indexOf(lowerize(str1));
              }, lowerize = function(str) {
                  return str.toLowerCase();
              }, trim = function(str, len) {
                  if ("string" == typeof str) return str = str.replace(/^\s\s*/, ""), void 0 === len ? str : str.substring(0, 350);
              }, rgxMapper = function(ua, arrays) {
                  for (var j, k, p, q, matches, match, i = 0; i < arrays.length && !matches; ) {
                      var regex = arrays[i], props = arrays[i + 1];
                      for (j = k = 0; j < regex.length && !matches && regex[j]; ) if (matches = regex[j++].exec(ua)) for (p = 0; p < props.length; p++) match = matches[++k], 
                      "object" == typeof (q = props[p]) && q.length > 0 ? 2 === q.length ? "function" == typeof q[1] ? this[q[0]] = q[1].call(this, match) : this[q[0]] = q[1] : 3 === q.length ? "function" != typeof q[1] || q[1].exec && q[1].test ? this[q[0]] = match ? match.replace(q[1], q[2]) : undefined : this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined : 4 === q.length && (this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined) : this[q] = match || undefined;
                      i += 2;
                  }
              }, strMapper = function(str, map) {
                  for (var i in map) if ("object" == typeof map[i] && map[i].length > 0) {
                      for (var j = 0; j < map[i].length; j++) if (has(map[i][j], str)) return "?" === i ? undefined : i;
                  } else if (has(map[i], str)) return "?" === i ? undefined : i;
                  return str;
              }, windowsVersionMap = {
                  ME: "4.90",
                  "NT 3.11": "NT3.51",
                  "NT 4.0": "NT4.0",
                  2e3: "NT 5.0",
                  XP: [ "NT 5.1", "NT 5.2" ],
                  Vista: "NT 6.0",
                  7: "NT 6.1",
                  8: "NT 6.2",
                  8.1: "NT 6.3",
                  10: [ "NT 6.4", "NT 10.0" ],
                  RT: "ARM"
              }, regexes = {
                  browser: [ [ /\b(?:crmo|crios)\/([\w\.]+)/i ], [ VERSION, [ NAME, "Chrome" ] ], [ /edg(?:e|ios|a)?\/([\w\.]+)/i ], [ VERSION, [ NAME, "Edge" ] ], [ /(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i ], [ NAME, VERSION ], [ /opios[\/ ]+([\w\.]+)/i ], [ VERSION, [ NAME, "Opera Mini" ] ], [ /\bopr\/([\w\.]+)/i ], [ VERSION, [ NAME, "Opera" ] ], [ /(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i ], [ NAME, VERSION ], [ /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i ], [ VERSION, [ NAME, "UCBrowser" ] ], [ /microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i ], [ VERSION, [ NAME, "WeChat(Win) Desktop" ] ], [ /micromessenger\/([\w\.]+)/i ], [ VERSION, [ NAME, "WeChat" ] ], [ /konqueror\/([\w\.]+)/i ], [ VERSION, [ NAME, "Konqueror" ] ], [ /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i ], [ VERSION, [ NAME, "IE" ] ], [ /ya(?:search)?browser\/([\w\.]+)/i ], [ VERSION, [ NAME, "Yandex" ] ], [ /(avast|avg)\/([\w\.]+)/i ], [ [ NAME, /(.+)/, "$1 Secure Browser" ], VERSION ], [ /\bfocus\/([\w\.]+)/i ], [ VERSION, [ NAME, "Firefox Focus" ] ], [ /\bopt\/([\w\.]+)/i ], [ VERSION, [ NAME, "Opera Touch" ] ], [ /coc_coc\w+\/([\w\.]+)/i ], [ VERSION, [ NAME, "Coc Coc" ] ], [ /dolfin\/([\w\.]+)/i ], [ VERSION, [ NAME, "Dolphin" ] ], [ /coast\/([\w\.]+)/i ], [ VERSION, [ NAME, "Opera Coast" ] ], [ /miuibrowser\/([\w\.]+)/i ], [ VERSION, [ NAME, "MIUI Browser" ] ], [ /fxios\/([-\w\.]+)/i ], [ VERSION, [ NAME, "Firefox" ] ], [ /\bqihu|(qi?ho?o?|360)browser/i ], [ [ NAME, "360 Browser" ] ], [ /(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i ], [ [ NAME, /(.+)/, "$1 Browser" ], VERSION ], [ /(comodo_dragon)\/([\w\.]+)/i ], [ [ NAME, /_/g, " " ], VERSION ], [ /(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i ], [ NAME, VERSION ], [ /(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i ], [ NAME ], [ /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i ], [ [ NAME, "Facebook" ], VERSION ], [ /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i ], [ NAME, VERSION ], [ /\bgsa\/([\w\.]+) .*safari\//i ], [ VERSION, [ NAME, "GSA" ] ], [ /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i ], [ VERSION, [ NAME, "TikTok" ] ], [ /headlesschrome(?:\/([\w\.]+)| )/i ], [ VERSION, [ NAME, "Chrome Headless" ] ], [ / wv\).+(chrome)\/([\w\.]+)/i ], [ [ NAME, "Chrome WebView" ], VERSION ], [ /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i ], [ VERSION, [ NAME, "Android Browser" ] ], [ /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i ], [ NAME, VERSION ], [ /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i ], [ VERSION, [ NAME, "Mobile Safari" ] ], [ /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i ], [ VERSION, NAME ], [ /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i ], [ NAME, [ VERSION, strMapper, {
                      "1.0": "/8",
                      1.2: "/1",
                      1.3: "/3",
                      "2.0": "/412",
                      "2.0.2": "/416",
                      "2.0.3": "/417",
                      "2.0.4": "/419",
                      "?": "/"
                  } ] ], [ /(webkit|khtml)\/([\w\.]+)/i ], [ NAME, VERSION ], [ /(navigator|netscape\d?)\/([-\w\.]+)/i ], [ [ NAME, "Netscape" ], VERSION ], [ /mobile vr; rv:([\w\.]+)\).+firefox/i ], [ VERSION, [ NAME, "Firefox Reality" ] ], [ /ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i ], [ NAME, VERSION ], [ /(cobalt)\/([\w\.]+)/i ], [ NAME, [ VERSION, /master.|lts./, "" ] ] ],
                  cpu: [ [ /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i ], [ [ "architecture", "amd64" ] ], [ /(ia32(?=;))/i ], [ [ "architecture", lowerize ] ], [ /((?:i[346]|x)86)[;\)]/i ], [ [ "architecture", "ia32" ] ], [ /\b(aarch64|arm(v?8e?l?|_?64))\b/i ], [ [ "architecture", "arm64" ] ], [ /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i ], [ [ "architecture", "armhf" ] ], [ /windows (ce|mobile); ppc;/i ], [ [ "architecture", "arm" ] ], [ /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i ], [ [ "architecture", /ower/, "", lowerize ] ], [ /(sun4\w)[;\)]/i ], [ [ "architecture", "sparc" ] ], [ /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i ], [ [ "architecture", lowerize ] ] ],
                  device: [ [ /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i ], [ MODEL, [ VENDOR, "Samsung" ], [ TYPE, TABLET ] ], [ /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i ], [ MODEL, [ VENDOR, "Samsung" ], [ TYPE, MOBILE ] ], [ /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i ], [ MODEL, [ VENDOR, "Apple" ], [ TYPE, MOBILE ] ], [ /\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i ], [ MODEL, [ VENDOR, "Apple" ], [ TYPE, TABLET ] ], [ /(macintosh);/i ], [ MODEL, [ VENDOR, "Apple" ] ], [ /\b(sh-?[altvz]?\d\d[a-ekm]?)/i ], [ MODEL, [ VENDOR, "Sharp" ], [ TYPE, MOBILE ] ], [ /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i ], [ MODEL, [ VENDOR, "Huawei" ], [ TYPE, TABLET ] ], [ /(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i ], [ MODEL, [ VENDOR, "Huawei" ], [ TYPE, MOBILE ] ], [ /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i ], [ [ MODEL, /_/g, " " ], [ VENDOR, "Xiaomi" ], [ TYPE, MOBILE ] ], [ /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i ], [ [ MODEL, /_/g, " " ], [ VENDOR, "Xiaomi" ], [ TYPE, TABLET ] ], [ /; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i ], [ MODEL, [ VENDOR, "OPPO" ], [ TYPE, MOBILE ] ], [ /vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i ], [ MODEL, [ VENDOR, "Vivo" ], [ TYPE, MOBILE ] ], [ /\b(rmx[12]\d{3})(?: bui|;|\))/i ], [ MODEL, [ VENDOR, "Realme" ], [ TYPE, MOBILE ] ], [ /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i ], [ MODEL, [ VENDOR, "Motorola" ], [ TYPE, MOBILE ] ], [ /\b(mz60\d|xoom[2 ]{0,2}) build\//i ], [ MODEL, [ VENDOR, "Motorola" ], [ TYPE, TABLET ] ], [ /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i ], [ MODEL, [ VENDOR, "LG" ], [ TYPE, TABLET ] ], [ /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i ], [ MODEL, [ VENDOR, "LG" ], [ TYPE, MOBILE ] ], [ /(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i ], [ MODEL, [ VENDOR, "Lenovo" ], [ TYPE, TABLET ] ], [ /(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i ], [ [ MODEL, /_/g, " " ], [ VENDOR, "Nokia" ], [ TYPE, MOBILE ] ], [ /(pixel c)\b/i ], [ MODEL, [ VENDOR, "Google" ], [ TYPE, TABLET ] ], [ /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i ], [ MODEL, [ VENDOR, "Google" ], [ TYPE, MOBILE ] ], [ /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i ], [ MODEL, [ VENDOR, "Sony" ], [ TYPE, MOBILE ] ], [ /sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i ], [ [ MODEL, "Xperia Tablet" ], [ VENDOR, "Sony" ], [ TYPE, TABLET ] ], [ / (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i ], [ MODEL, [ VENDOR, "OnePlus" ], [ TYPE, MOBILE ] ], [ /(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i ], [ MODEL, [ VENDOR, "Amazon" ], [ TYPE, TABLET ] ], [ /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i ], [ [ MODEL, /(.+)/g, "Fire Phone $1" ], [ VENDOR, "Amazon" ], [ TYPE, MOBILE ] ], [ /(playbook);[-\w\),; ]+(rim)/i ], [ MODEL, VENDOR, [ TYPE, TABLET ] ], [ /\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i ], [ MODEL, [ VENDOR, "BlackBerry" ], [ TYPE, MOBILE ] ], [ /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i ], [ MODEL, [ VENDOR, "ASUS" ], [ TYPE, TABLET ] ], [ / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i ], [ MODEL, [ VENDOR, "ASUS" ], [ TYPE, MOBILE ] ], [ /(nexus 9)/i ], [ MODEL, [ VENDOR, "HTC" ], [ TYPE, TABLET ] ], [ /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i ], [ VENDOR, [ MODEL, /_/g, " " ], [ TYPE, MOBILE ] ], [ /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i ], [ MODEL, [ VENDOR, "Acer" ], [ TYPE, TABLET ] ], [ /droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i ], [ MODEL, [ VENDOR, "Meizu" ], [ TYPE, MOBILE ] ], [ /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i ], [ VENDOR, MODEL, [ TYPE, TABLET ] ], [ /(surface duo)/i ], [ MODEL, [ VENDOR, "Microsoft" ], [ TYPE, TABLET ] ], [ /droid [\d\.]+; (fp\du?)(?: b|\))/i ], [ MODEL, [ VENDOR, "Fairphone" ], [ TYPE, MOBILE ] ], [ /(u304aa)/i ], [ MODEL, [ VENDOR, "AT&T" ], [ TYPE, MOBILE ] ], [ /\bsie-(\w*)/i ], [ MODEL, [ VENDOR, "Siemens" ], [ TYPE, MOBILE ] ], [ /\b(rct\w+) b/i ], [ MODEL, [ VENDOR, "RCA" ], [ TYPE, TABLET ] ], [ /\b(venue[\d ]{2,7}) b/i ], [ MODEL, [ VENDOR, "Dell" ], [ TYPE, TABLET ] ], [ /\b(q(?:mv|ta)\w+) b/i ], [ MODEL, [ VENDOR, "Verizon" ], [ TYPE, TABLET ] ], [ /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i ], [ MODEL, [ VENDOR, "Barnes & Noble" ], [ TYPE, TABLET ] ], [ /\b(tm\d{3}\w+) b/i ], [ MODEL, [ VENDOR, "NuVision" ], [ TYPE, TABLET ] ], [ /\b(k88) b/i ], [ MODEL, [ VENDOR, "ZTE" ], [ TYPE, TABLET ] ], [ /\b(nx\d{3}j) b/i ], [ MODEL, [ VENDOR, "ZTE" ], [ TYPE, MOBILE ] ], [ /\b(gen\d{3}) b.+49h/i ], [ MODEL, [ VENDOR, "Swiss" ], [ TYPE, MOBILE ] ], [ /\b(zur\d{3}) b/i ], [ MODEL, [ VENDOR, "Swiss" ], [ TYPE, TABLET ] ], [ /\b((zeki)?tb.*\b) b/i ], [ MODEL, [ VENDOR, "Zeki" ], [ TYPE, TABLET ] ], [ /\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i ], [ [ VENDOR, "Dragon Touch" ], MODEL, [ TYPE, TABLET ] ], [ /\b(ns-?\w{0,9}) b/i ], [ MODEL, [ VENDOR, "Insignia" ], [ TYPE, TABLET ] ], [ /\b((nxa|next)-?\w{0,9}) b/i ], [ MODEL, [ VENDOR, "NextBook" ], [ TYPE, TABLET ] ], [ /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i ], [ [ VENDOR, "Voice" ], MODEL, [ TYPE, MOBILE ] ], [ /\b(lvtel\-)?(v1[12]) b/i ], [ [ VENDOR, "LvTel" ], MODEL, [ TYPE, MOBILE ] ], [ /\b(ph-1) /i ], [ MODEL, [ VENDOR, "Essential" ], [ TYPE, MOBILE ] ], [ /\b(v(100md|700na|7011|917g).*\b) b/i ], [ MODEL, [ VENDOR, "Envizen" ], [ TYPE, TABLET ] ], [ /\b(trio[-\w\. ]+) b/i ], [ MODEL, [ VENDOR, "MachSpeed" ], [ TYPE, TABLET ] ], [ /\btu_(1491) b/i ], [ MODEL, [ VENDOR, "Rotor" ], [ TYPE, TABLET ] ], [ /(shield[\w ]+) b/i ], [ MODEL, [ VENDOR, "Nvidia" ], [ TYPE, TABLET ] ], [ /(sprint) (\w+)/i ], [ VENDOR, MODEL, [ TYPE, MOBILE ] ], [ /(kin\.[onetw]{3})/i ], [ [ MODEL, /\./g, " " ], [ VENDOR, "Microsoft" ], [ TYPE, MOBILE ] ], [ /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i ], [ MODEL, [ VENDOR, "Zebra" ], [ TYPE, TABLET ] ], [ /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i ], [ MODEL, [ VENDOR, "Zebra" ], [ TYPE, MOBILE ] ], [ /smart-tv.+(samsung)/i ], [ VENDOR, [ TYPE, SMARTTV ] ], [ /hbbtv.+maple;(\d+)/i ], [ [ MODEL, /^/, "SmartTV" ], [ VENDOR, "Samsung" ], [ TYPE, SMARTTV ] ], [ /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i ], [ [ VENDOR, "LG" ], [ TYPE, SMARTTV ] ], [ /(apple) ?tv/i ], [ VENDOR, [ MODEL, "Apple TV" ], [ TYPE, SMARTTV ] ], [ /crkey/i ], [ [ MODEL, "Chromecast" ], [ VENDOR, "Google" ], [ TYPE, SMARTTV ] ], [ /droid.+aft(\w+)( bui|\))/i ], [ MODEL, [ VENDOR, "Amazon" ], [ TYPE, SMARTTV ] ], [ /\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i ], [ MODEL, [ VENDOR, "Sharp" ], [ TYPE, SMARTTV ] ], [ /(bravia[\w ]+)( bui|\))/i ], [ MODEL, [ VENDOR, "Sony" ], [ TYPE, SMARTTV ] ], [ /(mitv-\w{5}) bui/i ], [ MODEL, [ VENDOR, "Xiaomi" ], [ TYPE, SMARTTV ] ], [ /Hbbtv.*(technisat) (.*);/i ], [ VENDOR, MODEL, [ TYPE, SMARTTV ] ], [ /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i ], [ [ VENDOR, trim ], [ MODEL, trim ], [ TYPE, SMARTTV ] ], [ /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i ], [ [ TYPE, SMARTTV ] ], [ /(ouya)/i, /(nintendo) ([wids3utch]+)/i ], [ VENDOR, MODEL, [ TYPE, "console" ] ], [ /droid.+; (shield) bui/i ], [ MODEL, [ VENDOR, "Nvidia" ], [ TYPE, "console" ] ], [ /(playstation [345portablevi]+)/i ], [ MODEL, [ VENDOR, "Sony" ], [ TYPE, "console" ] ], [ /\b(xbox(?: one)?(?!; xbox))[\); ]/i ], [ MODEL, [ VENDOR, "Microsoft" ], [ TYPE, "console" ] ], [ /((pebble))app/i ], [ VENDOR, MODEL, [ TYPE, "wearable" ] ], [ /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i ], [ MODEL, [ VENDOR, "Apple" ], [ TYPE, "wearable" ] ], [ /droid.+; (glass) \d/i ], [ MODEL, [ VENDOR, "Google" ], [ TYPE, "wearable" ] ], [ /droid.+; (wt63?0{2,3})\)/i ], [ MODEL, [ VENDOR, "Zebra" ], [ TYPE, "wearable" ] ], [ /(quest( 2| pro)?)/i ], [ MODEL, [ VENDOR, "Facebook" ], [ TYPE, "wearable" ] ], [ /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i ], [ VENDOR, [ TYPE, "embedded" ] ], [ /(aeobc)\b/i ], [ MODEL, [ VENDOR, "Amazon" ], [ TYPE, "embedded" ] ], [ /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i ], [ MODEL, [ TYPE, MOBILE ] ], [ /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i ], [ MODEL, [ TYPE, TABLET ] ], [ /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i ], [ [ TYPE, TABLET ] ], [ /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i ], [ [ TYPE, MOBILE ] ], [ /(android[-\w\. ]{0,9});.+buil/i ], [ MODEL, [ VENDOR, "Generic" ] ] ],
                  engine: [ [ /windows.+ edge\/([\w\.]+)/i ], [ VERSION, [ NAME, "EdgeHTML" ] ], [ /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i ], [ VERSION, [ NAME, "Blink" ] ], [ /(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i ], [ NAME, VERSION ], [ /rv\:([\w\.]{1,9})\b.+(gecko)/i ], [ VERSION, NAME ] ],
                  os: [ [ /microsoft (windows) (vista|xp)/i ], [ NAME, VERSION ], [ /(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i ], [ NAME, [ VERSION, strMapper, windowsVersionMap ] ], [ /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i ], [ [ NAME, "Windows" ], [ VERSION, strMapper, windowsVersionMap ] ], [ /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i ], [ [ VERSION, /_/g, "." ], [ NAME, "iOS" ] ], [ /(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i ], [ [ NAME, "Mac OS" ], [ VERSION, /_/g, "." ] ], [ /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i ], [ VERSION, NAME ], [ /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i ], [ NAME, VERSION ], [ /\(bb(10);/i ], [ VERSION, [ NAME, "BlackBerry" ] ], [ /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i ], [ VERSION, [ NAME, "Symbian" ] ], [ /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i ], [ VERSION, [ NAME, "Firefox OS" ] ], [ /web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i ], [ VERSION, [ NAME, "webOS" ] ], [ /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i ], [ VERSION, [ NAME, "watchOS" ] ], [ /crkey\/([\d\.]+)/i ], [ VERSION, [ NAME, "Chromecast" ] ], [ /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i ], [ [ NAME, "Chromium OS" ], VERSION ], [ /panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i ], [ NAME, VERSION ], [ /(sunos) ?([\w\.\d]*)/i ], [ [ NAME, "Solaris" ], VERSION ], [ /((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i ], [ NAME, VERSION ] ]
              }, UAParser = function(ua, extensions) {
                  if ("object" == typeof ua && (extensions = ua, ua = undefined), !(this instanceof UAParser)) return new UAParser(ua, extensions).getResult();
                  var _navigator = void 0 !== window && window.navigator ? window.navigator : undefined, _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : ""), _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined, _rgxmap = extensions ? function(regexes, extensions) {
                      var mergedRegexes = {};
                      for (var i in regexes) extensions[i] && extensions[i].length % 2 == 0 ? mergedRegexes[i] = extensions[i].concat(regexes[i]) : mergedRegexes[i] = regexes[i];
                      return mergedRegexes;
                  }(regexes, extensions) : regexes, _isSelfNav = _navigator && _navigator.userAgent == _ua;
                  return this.getBrowser = function() {
                      var version, _browser = {};
                      return _browser[NAME] = undefined, _browser[VERSION] = undefined, rgxMapper.call(_browser, _ua, _rgxmap.browser), 
                      _browser.major = "string" == typeof (version = _browser[VERSION]) ? version.replace(/[^\d\.]/g, "").split(".")[0] : void 0, 
                      _isSelfNav && _navigator && _navigator.brave && "function" == typeof _navigator.brave.isBrave && (_browser[NAME] = "Brave"), 
                      _browser;
                  }, this.getCPU = function() {
                      var _cpu = {
                          architecture: undefined
                      };
                      return rgxMapper.call(_cpu, _ua, _rgxmap.cpu), _cpu;
                  }, this.getDevice = function() {
                      var _device = {};
                      return _device[VENDOR] = undefined, _device[MODEL] = undefined, _device[TYPE] = undefined, 
                      rgxMapper.call(_device, _ua, _rgxmap.device), _isSelfNav && !_device[TYPE] && _uach && _uach.mobile && (_device[TYPE] = MOBILE), 
                      _isSelfNav && "Macintosh" == _device[MODEL] && _navigator && void 0 !== _navigator.standalone && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2 && (_device[MODEL] = "iPad", 
                      _device[TYPE] = TABLET), _device;
                  }, this.getEngine = function() {
                      var _engine = {};
                      return _engine[NAME] = undefined, _engine[VERSION] = undefined, rgxMapper.call(_engine, _ua, _rgxmap.engine), 
                      _engine;
                  }, this.getOS = function() {
                      var _os = {};
                      return _os[NAME] = undefined, _os[VERSION] = undefined, rgxMapper.call(_os, _ua, _rgxmap.os), 
                      _isSelfNav && !_os[NAME] && _uach && "Unknown" != _uach.platform && (_os[NAME] = _uach.platform.replace(/chrome os/i, "Chromium OS").replace(/macos/i, "Mac OS")), 
                      _os;
                  }, this.getResult = function() {
                      return {
                          ua: this.getUA(),
                          browser: this.getBrowser(),
                          engine: this.getEngine(),
                          os: this.getOS(),
                          device: this.getDevice(),
                          cpu: this.getCPU()
                      };
                  }, this.getUA = function() {
                      return _ua;
                  }, this.setUA = function(ua) {
                      return _ua = "string" == typeof ua && ua.length > 350 ? trim(ua, 350) : ua, this;
                  }, this.setUA(_ua), this;
              };
              UAParser.VERSION = "1.0.36", UAParser.BROWSER = enumerize([ NAME, VERSION, "major" ]), 
              UAParser.CPU = enumerize([ "architecture" ]), UAParser.DEVICE = enumerize([ MODEL, VENDOR, TYPE, "console", MOBILE, SMARTTV, TABLET, "wearable", "embedded" ]), 
              UAParser.ENGINE = UAParser.OS = enumerize([ NAME, VERSION ]), void 0 !== exports ? (module.exports && (exports = module.exports = UAParser), 
              exports.UAParser = UAParser) : __webpack_require__.amdO ? undefined === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                  return UAParser;
              }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__) : void 0 !== window && (window.UAParser = UAParser);
              var $ = void 0 !== window && (window.jQuery || window.Zepto);
              if ($ && !$.ua) {
                  var parser = new UAParser;
                  $.ua = parser.getResult(), $.ua.get = function() {
                      return parser.getUA();
                  }, $.ua.set = function(ua) {
                      parser.setUA(ua);
                      var result = parser.getResult();
                      for (var prop in result) $.ua[prop] = result[prop];
                  };
              }
          }("object" == typeof window ? window : this);
      },
      "./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js": (__unused_webpack_module, exports, __webpack_require__) => {
          "use strict";
          var e = __webpack_require__("./node_modules/.pnpm/react@18.2.0/node_modules/react/index.js");
          var k = "function" == typeof Object.is ? Object.is : function(a, b) {
              return a === b && (0 !== a || 1 / a == 1 / b) || a != a && b != b;
          }, l = e.useState, m = e.useEffect, n = e.useLayoutEffect, p = e.useDebugValue;
          function r(a) {
              var b = a.getSnapshot;
              a = a.value;
              try {
                  var d = b();
                  return !k(a, d);
              } catch (f) {
                  return !0;
              }
          }
          var u = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function(a, b) {
              return b();
          } : function(a, b) {
              var d = b(), f = l({
                  inst: {
                      value: d,
                      getSnapshot: b
                  }
              }), c = f[0].inst, g = f[1];
              return n((function() {
                  c.value = d, c.getSnapshot = b, r(c) && g({
                      inst: c
                  });
              }), [ a, d, b ]), m((function() {
                  return r(c) && g({
                      inst: c
                  }), a((function() {
                      r(c) && g({
                          inst: c
                      });
                  }));
              }), [ a ]), p(d), d;
          };
          exports.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u;
      },
      "./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js": (__unused_webpack_module, exports, __webpack_require__) => {
          "use strict";
          var h = __webpack_require__("./node_modules/.pnpm/react@18.2.0/node_modules/react/index.js"), n = __webpack_require__("./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js");
          var q = "function" == typeof Object.is ? Object.is : function(a, b) {
              return a === b && (0 !== a || 1 / a == 1 / b) || a != a && b != b;
          }, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;
          exports.useSyncExternalStoreWithSelector = function(a, b, e, l, g) {
              var c = t(null);
              if (null === c.current) {
                  var f = {
                      hasValue: !1,
                      value: null
                  };
                  c.current = f;
              } else f = c.current;
              c = v((function() {
                  function a(a) {
                      if (!c) {
                          if (c = !0, d = a, a = l(a), void 0 !== g && f.hasValue) {
                              var b = f.value;
                              if (g(b, a)) return k = b;
                          }
                          return k = a;
                      }
                      if (b = k, q(d, a)) return b;
                      var e = l(a);
                      return void 0 !== g && g(b, e) ? b : (d = a, k = e);
                  }
                  var d, k, c = !1, m = void 0 === e ? null : e;
                  return [ function() {
                      return a(b());
                  }, null === m ? void 0 : function() {
                      return a(m());
                  } ];
              }), [ b, e, l, g ]);
              var d = r(a, c[0], c[1]);
              return u((function() {
                  f.hasValue = !0, f.value = d;
              }), [ d ]), w(d), d;
          };
      },
      "./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/index.js": (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          module.exports = __webpack_require__("./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.js");
      },
      "./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/shim/with-selector.js": (module, __unused_webpack_exports, __webpack_require__) => {
          "use strict";
          module.exports = __webpack_require__("./node_modules/.pnpm/use-sync-external-store@1.2.0_react@18.2.0/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.js");
      },
      "./node_modules/.pnpm/webextension-polyfill@0.9.0/node_modules/webextension-polyfill/dist/browser-polyfill.js": function(module, exports) {
          var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
          "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self && self, 
          __WEBPACK_AMD_DEFINE_ARRAY__ = [ module ], __WEBPACK_AMD_DEFINE_FACTORY__ = function(module) {
              "use strict";
              if ("object" != typeof globalThis || "object" != typeof chrome || !chrome || !chrome.runtime || !chrome.runtime.id) throw new Error("This script should only be loaded in a browser extension.");
              if (void 0 === globalThis.browser || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
                  const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.", SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)", wrapAPIs = extensionAPIs => {
                      const apiMetadata = {
                          alarms: {
                              clear: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              clearAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              get: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              getAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          bookmarks: {
                              create: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              get: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getChildren: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getRecent: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getSubTree: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getTree: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              move: {
                                  minArgs: 2,
                                  maxArgs: 2
                              },
                              remove: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeTree: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              search: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              update: {
                                  minArgs: 2,
                                  maxArgs: 2
                              }
                          },
                          browserAction: {
                              disable: {
                                  minArgs: 0,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              enable: {
                                  minArgs: 0,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              getBadgeBackgroundColor: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getBadgeText: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getPopup: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getTitle: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              openPopup: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              setBadgeBackgroundColor: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              setBadgeText: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              setIcon: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              setPopup: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              setTitle: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              }
                          },
                          browsingData: {
                              remove: {
                                  minArgs: 2,
                                  maxArgs: 2
                              },
                              removeCache: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeCookies: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeDownloads: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeFormData: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeHistory: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeLocalStorage: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removePasswords: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removePluginData: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              settings: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          commands: {
                              getAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          contextMenus: {
                              remove: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              update: {
                                  minArgs: 2,
                                  maxArgs: 2
                              }
                          },
                          cookies: {
                              get: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getAll: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getAllCookieStores: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              remove: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              set: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          devtools: {
                              inspectedWindow: {
                                  eval: {
                                      minArgs: 1,
                                      maxArgs: 2,
                                      singleCallbackArg: !1
                                  }
                              },
                              panels: {
                                  create: {
                                      minArgs: 3,
                                      maxArgs: 3,
                                      singleCallbackArg: !0
                                  },
                                  elements: {
                                      createSidebarPane: {
                                          minArgs: 1,
                                          maxArgs: 1
                                      }
                                  }
                              }
                          },
                          downloads: {
                              cancel: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              download: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              erase: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getFileIcon: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              open: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              pause: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeFile: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              resume: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              search: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              show: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              }
                          },
                          extension: {
                              isAllowedFileSchemeAccess: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              isAllowedIncognitoAccess: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          history: {
                              addUrl: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              deleteAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              deleteRange: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              deleteUrl: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getVisits: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              search: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          i18n: {
                              detectLanguage: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getAcceptLanguages: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          identity: {
                              launchWebAuthFlow: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          idle: {
                              queryState: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          management: {
                              get: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              getSelf: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              setEnabled: {
                                  minArgs: 2,
                                  maxArgs: 2
                              },
                              uninstallSelf: {
                                  minArgs: 0,
                                  maxArgs: 1
                              }
                          },
                          notifications: {
                              clear: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              create: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              getAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              getPermissionLevel: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              update: {
                                  minArgs: 2,
                                  maxArgs: 2
                              }
                          },
                          pageAction: {
                              getPopup: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getTitle: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              hide: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              setIcon: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              setPopup: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              setTitle: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              },
                              show: {
                                  minArgs: 1,
                                  maxArgs: 1,
                                  fallbackToNoCallback: !0
                              }
                          },
                          permissions: {
                              contains: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getAll: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              remove: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              request: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          runtime: {
                              getBackgroundPage: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              getPlatformInfo: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              openOptionsPage: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              requestUpdateCheck: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              sendMessage: {
                                  minArgs: 1,
                                  maxArgs: 3
                              },
                              sendNativeMessage: {
                                  minArgs: 2,
                                  maxArgs: 2
                              },
                              setUninstallURL: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          sessions: {
                              getDevices: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              getRecentlyClosed: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              restore: {
                                  minArgs: 0,
                                  maxArgs: 1
                              }
                          },
                          storage: {
                              local: {
                                  clear: {
                                      minArgs: 0,
                                      maxArgs: 0
                                  },
                                  get: {
                                      minArgs: 0,
                                      maxArgs: 1
                                  },
                                  getBytesInUse: {
                                      minArgs: 0,
                                      maxArgs: 1
                                  },
                                  remove: {
                                      minArgs: 1,
                                      maxArgs: 1
                                  },
                                  set: {
                                      minArgs: 1,
                                      maxArgs: 1
                                  }
                              },
                              managed: {
                                  get: {
                                      minArgs: 0,
                                      maxArgs: 1
                                  },
                                  getBytesInUse: {
                                      minArgs: 0,
                                      maxArgs: 1
                                  }
                              },
                              sync: {
                                  clear: {
                                      minArgs: 0,
                                      maxArgs: 0
                                  },
                                  get: {
                                      minArgs: 0,
                                      maxArgs: 1
                                  },
                                  getBytesInUse: {
                                      minArgs: 0,
                                      maxArgs: 1
                                  },
                                  remove: {
                                      minArgs: 1,
                                      maxArgs: 1
                                  },
                                  set: {
                                      minArgs: 1,
                                      maxArgs: 1
                                  }
                              }
                          },
                          tabs: {
                              captureVisibleTab: {
                                  minArgs: 0,
                                  maxArgs: 2
                              },
                              create: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              detectLanguage: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              discard: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              duplicate: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              executeScript: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              get: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getCurrent: {
                                  minArgs: 0,
                                  maxArgs: 0
                              },
                              getZoom: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              getZoomSettings: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              goBack: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              goForward: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              highlight: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              insertCSS: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              move: {
                                  minArgs: 2,
                                  maxArgs: 2
                              },
                              query: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              reload: {
                                  minArgs: 0,
                                  maxArgs: 2
                              },
                              remove: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              removeCSS: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              sendMessage: {
                                  minArgs: 2,
                                  maxArgs: 3
                              },
                              setZoom: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              setZoomSettings: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              update: {
                                  minArgs: 1,
                                  maxArgs: 2
                              }
                          },
                          topSites: {
                              get: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          webNavigation: {
                              getAllFrames: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              getFrame: {
                                  minArgs: 1,
                                  maxArgs: 1
                              }
                          },
                          webRequest: {
                              handlerBehaviorChanged: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          },
                          windows: {
                              create: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              get: {
                                  minArgs: 1,
                                  maxArgs: 2
                              },
                              getAll: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              getCurrent: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              getLastFocused: {
                                  minArgs: 0,
                                  maxArgs: 1
                              },
                              remove: {
                                  minArgs: 1,
                                  maxArgs: 1
                              },
                              update: {
                                  minArgs: 2,
                                  maxArgs: 2
                              }
                          }
                      };
                      if (0 === Object.keys(apiMetadata).length) throw new Error("api-metadata.json has not been included in browser-polyfill");
                      class DefaultWeakMap extends WeakMap {
                          constructor(createItem, items = void 0) {
                              super(items), this.createItem = createItem;
                          }
                          get(key) {
                              return this.has(key) || this.set(key, this.createItem(key)), super.get(key);
                          }
                      }
                      const isThenable = value => value && "object" == typeof value && "function" == typeof value.then, makeCallback = (promise, metadata) => (...callbackArgs) => {
                          extensionAPIs.runtime.lastError ? promise.reject(new Error(extensionAPIs.runtime.lastError.message)) : metadata.singleCallbackArg || callbackArgs.length <= 1 && !1 !== metadata.singleCallbackArg ? promise.resolve(callbackArgs[0]) : promise.resolve(callbackArgs);
                      }, pluralizeArguments = numArgs => 1 == numArgs ? "argument" : "arguments", wrapAsyncFunction = (name, metadata) => function(target, ...args) {
                          if (args.length < metadata.minArgs) throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                          if (args.length > metadata.maxArgs) throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                          return new Promise(((resolve, reject) => {
                              if (metadata.fallbackToNoCallback) try {
                                  target[name](...args, makeCallback({
                                      resolve,
                                      reject
                                  }, metadata));
                              } catch (cbError) {
                                  console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError), 
                                  target[name](...args), metadata.fallbackToNoCallback = !1, metadata.noCallback = !0, 
                                  resolve();
                              } else metadata.noCallback ? (target[name](...args), resolve()) : target[name](...args, makeCallback({
                                  resolve,
                                  reject
                              }, metadata));
                          }));
                      }, wrapMethod = (target, method, wrapper) => new Proxy(method, {
                          apply: (targetMethod, thisObj, args) => wrapper.call(thisObj, target, ...args)
                      });
                      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
                      const wrapObject = (target, wrappers = {}, metadata = {}) => {
                          let cache = Object.create(null), handlers = {
                              has: (proxyTarget, prop) => prop in target || prop in cache,
                              get(proxyTarget, prop, receiver) {
                                  if (prop in cache) return cache[prop];
                                  if (!(prop in target)) return;
                                  let value = target[prop];
                                  if ("function" == typeof value) if ("function" == typeof wrappers[prop]) value = wrapMethod(target, target[prop], wrappers[prop]); else if (hasOwnProperty(metadata, prop)) {
                                      let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                                      value = wrapMethod(target, target[prop], wrapper);
                                  } else value = value.bind(target); else if ("object" == typeof value && null !== value && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) value = wrapObject(value, wrappers[prop], metadata[prop]); else {
                                      if (!hasOwnProperty(metadata, "*")) return Object.defineProperty(cache, prop, {
                                          configurable: !0,
                                          enumerable: !0,
                                          get: () => target[prop],
                                          set(value) {
                                              target[prop] = value;
                                          }
                                      }), value;
                                      value = wrapObject(value, wrappers[prop], metadata["*"]);
                                  }
                                  return cache[prop] = value, value;
                              },
                              set: (proxyTarget, prop, value, receiver) => (prop in cache ? cache[prop] = value : target[prop] = value, 
                              !0),
                              defineProperty: (proxyTarget, prop, desc) => Reflect.defineProperty(cache, prop, desc),
                              deleteProperty: (proxyTarget, prop) => Reflect.deleteProperty(cache, prop)
                          }, proxyTarget = Object.create(target);
                          return new Proxy(proxyTarget, handlers);
                      }, wrapEvent = wrapperMap => ({
                          addListener(target, listener, ...args) {
                              target.addListener(wrapperMap.get(listener), ...args);
                          },
                          hasListener: (target, listener) => target.hasListener(wrapperMap.get(listener)),
                          removeListener(target, listener) {
                              target.removeListener(wrapperMap.get(listener));
                          }
                      }), onRequestFinishedWrappers = new DefaultWeakMap((listener => "function" != typeof listener ? listener : function(req) {
                          const wrappedReq = wrapObject(req, {}, {
                              getContent: {
                                  minArgs: 0,
                                  maxArgs: 0
                              }
                          });
                          listener(wrappedReq);
                      }));
                      let loggedSendResponseDeprecationWarning = !1;
                      const onMessageWrappers = new DefaultWeakMap((listener => "function" != typeof listener ? listener : function(message, sender, sendResponse) {
                          let wrappedSendResponse, result, didCallSendResponse = !1, sendResponsePromise = new Promise((resolve => {
                              wrappedSendResponse = function(response) {
                                  loggedSendResponseDeprecationWarning || (console.warn(SEND_RESPONSE_DEPRECATION_WARNING, (new Error).stack), 
                                  loggedSendResponseDeprecationWarning = !0), didCallSendResponse = !0, resolve(response);
                              };
                          }));
                          try {
                              result = listener(message, sender, wrappedSendResponse);
                          } catch (err) {
                              result = Promise.reject(err);
                          }
                          const isResultThenable = !0 !== result && isThenable(result);
                          if (!0 !== result && !isResultThenable && !didCallSendResponse) return !1;
                          const sendPromisedResult = promise => {
                              promise.then((msg => {
                                  sendResponse(msg);
                              }), (error => {
                                  let message;
                                  message = error && (error instanceof Error || "string" == typeof error.message) ? error.message : "An unexpected error occurred", 
                                  sendResponse({
                                      __mozWebExtensionPolyfillReject__: !0,
                                      message
                                  });
                              })).catch((err => {
                                  console.error("Failed to send onMessage rejected reply", err);
                              }));
                          };
                          return sendPromisedResult(isResultThenable ? result : sendResponsePromise), !0;
                      })), wrappedSendMessageCallback = ({reject, resolve}, reply) => {
                          extensionAPIs.runtime.lastError ? extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE ? resolve() : reject(new Error(extensionAPIs.runtime.lastError.message)) : reply && reply.__mozWebExtensionPolyfillReject__ ? reject(new Error(reply.message)) : resolve(reply);
                      }, wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
                          if (args.length < metadata.minArgs) throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                          if (args.length > metadata.maxArgs) throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                          return new Promise(((resolve, reject) => {
                              const wrappedCb = wrappedSendMessageCallback.bind(null, {
                                  resolve,
                                  reject
                              });
                              args.push(wrappedCb), apiNamespaceObj.sendMessage(...args);
                          }));
                      }, staticWrappers = {
                          devtools: {
                              network: {
                                  onRequestFinished: wrapEvent(onRequestFinishedWrappers)
                              }
                          },
                          runtime: {
                              onMessage: wrapEvent(onMessageWrappers),
                              onMessageExternal: wrapEvent(onMessageWrappers),
                              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                                  minArgs: 1,
                                  maxArgs: 3
                              })
                          },
                          tabs: {
                              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                                  minArgs: 2,
                                  maxArgs: 3
                              })
                          }
                      }, settingMetadata = {
                          clear: {
                              minArgs: 1,
                              maxArgs: 1
                          },
                          get: {
                              minArgs: 1,
                              maxArgs: 1
                          },
                          set: {
                              minArgs: 1,
                              maxArgs: 1
                          }
                      };
                      return apiMetadata.privacy = {
                          network: {
                              "*": settingMetadata
                          },
                          services: {
                              "*": settingMetadata
                          },
                          websites: {
                              "*": settingMetadata
                          }
                      }, wrapObject(extensionAPIs, staticWrappers, apiMetadata);
                  };
                  module.exports = wrapAPIs(chrome);
              } else module.exports = globalThis.browser;
          }, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof __WEBPACK_AMD_DEFINE_FACTORY__ ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
      },
      "?5a61": () => {},
      "?e474": () => {},
      "?bc42": () => {},
      "?ddf1": () => {},
      "?3d7d": () => {},
      "?7556": () => {},
      "?7ed4": () => {},
      "?03bb": () => {}
  }, __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
      var cachedModule = __webpack_module_cache__[moduleId];
      if (void 0 !== cachedModule) return cachedModule.exports;
      var module = __webpack_module_cache__[moduleId] = {
          exports: {}
      };
      return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
      module.exports;
  }
  __webpack_require__.m = __webpack_modules__, __webpack_require__.amdO = {}, deferred = [], 
  __webpack_require__.O = (result, chunkIds, fn, priority) => {
      if (!chunkIds) {
          var notFulfilled = 1 / 0;
          for (i = 0; i < deferred.length; i++) {
              for (var [chunkIds, fn, priority] = deferred[i], fulfilled = !0, j = 0; j < chunkIds.length; j++) (!1 & priority || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key => __webpack_require__.O[key](chunkIds[j]))) ? chunkIds.splice(j--, 1) : (fulfilled = !1, 
              priority < notFulfilled && (notFulfilled = priority));
              if (fulfilled) {
                  deferred.splice(i--, 1);
                  var r = fn();
                  void 0 !== r && (result = r);
              }
          }
          return result;
      }
      priority = priority || 0;
      for (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
      deferred[i] = [ chunkIds, fn, priority ];
  }, __webpack_require__.n = module => {
      var getter = module && module.__esModule ? () => module.default : () => module;
      return __webpack_require__.d(getter, {
          a: getter
      }), getter;
  }, getProto = Object.getPrototypeOf ? obj => Object.getPrototypeOf(obj) : obj => obj.__proto__, 
  __webpack_require__.t = function(value, mode) {
      if (1 & mode && (value = this(value)), 8 & mode) return value;
      if ("object" == typeof value && value) {
          if (4 & mode && value.__esModule) return value;
          if (16 & mode && "function" == typeof value.then) return value;
      }
      var ns = Object.create(null);
      __webpack_require__.r(ns);
      var def = {};
      leafPrototypes = leafPrototypes || [ null, getProto({}), getProto([]), getProto(getProto) ];
      for (var current = 2 & mode && value; "object" == typeof current && !~leafPrototypes.indexOf(current); current = getProto(current)) Object.getOwnPropertyNames(current).forEach((key => def[key] = () => value[key]));
      return def.default = () => value, __webpack_require__.d(ns, def), ns;
  }, __webpack_require__.d = (exports, definition) => {
      for (var key in definition) __webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key) && Object.defineProperty(exports, key, {
          enumerable: !0,
          get: definition[key]
      });
  }, __webpack_require__.g = function() {
      if ("object" == typeof globalThis) return globalThis;
      try {
          return this || new Function("return this")();
      } catch (e) {
          if ("object" == typeof window) return window;
      }
  }(), __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop), 
  __webpack_require__.r = exports => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
          value: "Module"
      }), Object.defineProperty(exports, "__esModule", {
          value: !0
      });
  }, (() => {
      var installedChunks = {
          translate: 0
      };
      __webpack_require__.O.j = chunkId => 0 === installedChunks[chunkId];
      var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
          var moduleId, chunkId, [chunkIds, moreModules, runtime] = data, i = 0;
          if (chunkIds.some((id => 0 !== installedChunks[id]))) {
              for (moduleId in moreModules) __webpack_require__.o(moreModules, moduleId) && (__webpack_require__.m[moduleId] = moreModules[moduleId]);
              if (runtime) var result = runtime(__webpack_require__);
          }
          for (parentChunkLoadingFunction && parentChunkLoadingFunction(data); i < chunkIds.length; i++) chunkId = chunkIds[i], 
          __webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId] && installedChunks[chunkId][0](), 
          installedChunks[chunkId] = 0;
          return __webpack_require__.O(result);
      }, chunkLoadingGlobal = globalThis.webpackChunkfelo_subtitle = globalThis.webpackChunkfelo_subtitle || [];
      chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0)), chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
  })(), __webpack_require__.O(void 0, [ "vendor" ], (() => __webpack_require__("./node_modules/.pnpm/antd-dayjs-webpack-plugin@1.0.6_dayjs@1.11.6/node_modules/antd-dayjs-webpack-plugin/src/init-dayjs-webpack-plugin-entry.js")));
  var __webpack_exports__ = __webpack_require__.O(void 0, [ "vendor" ], (() => __webpack_require__("./src/contents/translate/index.tsx")));
  __webpack_exports__ = __webpack_require__.O(__webpack_exports__);
})();